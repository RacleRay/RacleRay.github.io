

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.ico">
  <link rel="icon" href="/img/favicon.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#1aa3ff">
  <meta name="description" content="C++ 实践经验">
  <meta name="author" content="HeRui">
  <meta name="keywords" content="C++">
  <meta name="description" content="C++ 实践经验">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ Tips">
<meta property="og:url" content="https://racleray.github.io/posts/467a9cda.html">
<meta property="og:site_name" content="Racle&#96;s Story">
<meta property="og:description" content="C++ 实践经验">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-02-16T13:07:45.000Z">
<meta property="article:modified_time" content="2024-01-09T10:19:24.630Z">
<meta property="article:author" content="江左时雨">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary_large_image">
  
     <meta name="baidu-site-verification" content="code-tH44R5Z2fc" /> <meta name="msvalidate.01" content="4E3B92EC6A38584E946DBE40929107D9" /> <meta name="google-site-verification" content="c-8NXvOa-KKHK4OB0TyzjFeRUuIPFXEXM9h5hYePPpw" /> 
  
  <title>C++ Tips - Racle`s Story</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.4.0/styles/night-owl.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  
<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC&display=swap.css">
<link rel="stylesheet" href="/css/custom.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"racleray.github.io","root":"/","version":"1.8.11","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Racle`s Story" type="application/atom+xml"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>


<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="link link--kukuri" href="/", data-letters="Racle`s Story">
      Racle`s Story
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/talking/">
                <i class="iconfont icon-comment"></i>
                说说
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/46.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="C++ Tips">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2023-02-16 21:07" pubdate>
        2023年2月16日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      25k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      78 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">C++ Tips</h1>
            
            <div class="markdown-body">
              <h1><span id="c">C++</span></h1>
<h2><span id="new-features">New features</span></h2>
<p>C++11 引入了 {} 初始化表达式</p>
<p>C++11 引入了 range-based for-loop</p>
<p>C++14 的 lambda 允许用 auto 自动推断传入参数类型</p>
<p>C++17 CTAD / compile-time argument deduction / 编译期参数推断</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-built_in">vector</span> v = &#123;<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>&#125;; <span class="hljs-comment">// 编译期参数推断</span><br><br>    <span class="hljs-keyword">int</span> sum;<br>    for_each(v.begin(),v.end(),[&amp;](<span class="hljs-keyword">auto</span> vi)&#123;<br>        sum += vi;<br>    &#125;);<br><br>    <span class="hljs-built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="hljs-built_in">endl</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>C++20 引入区间（ranges），g++ 编译时指定 -std=gnu20</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;numeric&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ranges&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span> v = &#123;<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-2</span>&#125;;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;&amp;vi: v<br>         | <span class="hljs-built_in">std</span>::views::filter([] (<span class="hljs-keyword">auto</span> &amp;&amp;x) &#123; <span class="hljs-keyword">return</span> x &gt;= <span class="hljs-number">0</span>; &#125;)<br>         | <span class="hljs-built_in">std</span>::views::transform([] (<span class="hljs-keyword">auto</span> &amp;&amp;x) &#123; <span class="hljs-keyword">return</span> sqrtf(x); &#125;)<br>         ) &#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; vi &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>C++20 引入模块（module）</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">import</span> &lt;<span class="hljs-built_in">vector</span>&gt;;<br><span class="hljs-keyword">import</span> &lt;iostream&gt;;<br><span class="hljs-keyword">import</span> &lt;numeric&gt;;<br><span class="hljs-keyword">import</span> &lt;ranges&gt;;<br><span class="hljs-keyword">import</span> &lt;cmath&gt;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span> v = &#123;<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-2</span>&#125;;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;&amp;vi: v<br>         | <span class="hljs-built_in">std</span>::views::filter([] (<span class="hljs-keyword">auto</span> &amp;&amp;x) &#123; <span class="hljs-keyword">return</span> x &gt;= <span class="hljs-number">0</span>; &#125;)<br>         | <span class="hljs-built_in">std</span>::views::transform([] (<span class="hljs-keyword">auto</span> &amp;&amp;x) &#123; <span class="hljs-keyword">return</span> sqrtf(x); &#125;)<br>         ) &#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; vi &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>C++20 允许函数参数为自动推断（auto）</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">import</span> &lt;<span class="hljs-built_in">vector</span>&gt;;<br><span class="hljs-keyword">import</span> &lt;iostream&gt;;<br><span class="hljs-keyword">import</span> &lt;numeric&gt;;<br><span class="hljs-keyword">import</span> &lt;ranges&gt;;<br><span class="hljs-keyword">import</span> &lt;cmath&gt;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">myfunc</span><span class="hljs-params">(<span class="hljs-keyword">auto</span> &amp;&amp;v)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;&amp;vi: v<br>         | <span class="hljs-built_in">std</span>::views::filter([] (<span class="hljs-keyword">auto</span> &amp;&amp;x) &#123; <span class="hljs-keyword">return</span> x &gt;= <span class="hljs-number">0</span>; &#125;)<br>         | <span class="hljs-built_in">std</span>::views::transform([] (<span class="hljs-keyword">auto</span> &amp;&amp;x) &#123; <span class="hljs-keyword">return</span> sqrtf(x); &#125;)<br>         ) &#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; vi &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span> v = &#123;<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-2</span>&#125;;<br>    myfunc(v);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>C++23
引入协程（coroutine）和生成器（generator），注意需要切换到最新的编译器</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">import</span> &lt;<span class="hljs-built_in">vector</span>&gt;;<br><span class="hljs-keyword">import</span> &lt;iostream&gt;;<br><span class="hljs-keyword">import</span> &lt;numeric&gt;;<br><span class="hljs-keyword">import</span> &lt;ranges&gt;;<br><span class="hljs-keyword">import</span> &lt;cmath&gt;;<br><span class="hljs-keyword">import</span> &lt;generator&gt;;<br><br><span class="hljs-function"><span class="hljs-built_in">std</span>::generator&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">myfunc</span><span class="hljs-params">(<span class="hljs-keyword">auto</span> &amp;&amp;v)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;&amp;vi: v<br>         | <span class="hljs-built_in">std</span>::views::filter([] (<span class="hljs-keyword">auto</span> &amp;&amp;x) &#123; <span class="hljs-keyword">return</span> x &gt;= <span class="hljs-number">0</span>; &#125;)<br>         | <span class="hljs-built_in">std</span>::views::transform([] (<span class="hljs-keyword">auto</span> &amp;&amp;x) &#123; <span class="hljs-keyword">return</span> sqrtf(x); &#125;)<br>         ) &#123;<br>        <span class="hljs-keyword">co_yield</span> vi;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span> v = &#123;<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-2</span>&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;&amp;vi: myfunc(v)) &#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; vi &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>C++20 标准库加入 format 支持</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">import</span> &lt;<span class="hljs-built_in">vector</span>&gt;;<br><span class="hljs-keyword">import</span> &lt;iostream&gt;;<br><span class="hljs-keyword">import</span> &lt;numeric&gt;;<br><span class="hljs-keyword">import</span> &lt;ranges&gt;;<br><span class="hljs-keyword">import</span> &lt;cmath&gt;;<br><span class="hljs-keyword">import</span> &lt;generator&gt;;<br><span class="hljs-keyword">import</span> &lt;format&gt;;<br><br><span class="hljs-function"><span class="hljs-built_in">std</span>::generator&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">myfunc</span><span class="hljs-params">(<span class="hljs-keyword">auto</span> &amp;&amp;v)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;&amp;vi: v<br>         | <span class="hljs-built_in">std</span>::views::filter([] (<span class="hljs-keyword">auto</span> &amp;&amp;x) &#123; <span class="hljs-keyword">return</span> x &gt;= <span class="hljs-number">0</span>; &#125;)<br>         | <span class="hljs-built_in">std</span>::views::transform([] (<span class="hljs-keyword">auto</span> &amp;&amp;x) &#123; <span class="hljs-keyword">return</span> sqrtf(x); &#125;)<br>         ) &#123;<br>        <span class="hljs-keyword">co_yield</span> vi;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span> v = &#123;<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-2</span>&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;&amp;vi: myfunc(v)) &#123;<br>        <span class="hljs-built_in">std</span>::format_to(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>, <span class="hljs-string">"number is &#123;&#125;\n"</span>, vi);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h2><span id="c思想封装">C++思想：封装</span></h2>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//size_t nv = 4;</span><br>    <span class="hljs-comment">//int *v = (int *)malloc(nv * sizeof(int));</span><br>    <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span></span>;<br><br>    v[<span class="hljs-number">0</span>] = <span class="hljs-number">4</span>;<br>    v[<span class="hljs-number">1</span>] = <span class="hljs-number">3</span>;<br>    v[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br>    v[<span class="hljs-number">3</span>] = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; nv; i++) &#123;<br>        sum += v[i];<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, sum);<br><br>    <span class="hljs-built_in">free</span>(v);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>比如要表达一个数组，需要：起始地址指针v，数组大小nv。</p>
<p>因此 C++ 的 vector 将他俩打包起来，避免程序员犯错。</p>
<h3><span id="封装不变性">封装：不变性</span></h3>
<p>当需要修改一个成员时，其他也成员需要被修改，否则出错</p>
<p>这种情况出现时，就意味着你需要把成员变量的读写封装为<strong>成员函数</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//size_t nv = 2;</span><br>    <span class="hljs-comment">//int *v = (int *)malloc(nv * sizeof(int));</span><br>    <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>;<br><br>    v[<span class="hljs-number">0</span>] = <span class="hljs-number">4</span>;<br>    v[<span class="hljs-number">1</span>] = <span class="hljs-number">3</span>;<br><br>    <span class="hljs-comment">//nv = 4;</span><br>    <span class="hljs-comment">//v = (int *)realloc(v, nv * sizeof(int));</span><br>    v.resize(<span class="hljs-number">4</span>);<br><br>    v[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br>    v[<span class="hljs-number">3</span>] = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; nv; i++) &#123;<br>        sum += v[i];<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, sum);<br><br>    <span class="hljs-built_in">free</span>(v);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><strong>仅当出现“修改一个成员时，其他也成员要被修改，否则出错”的现象时，才需要getter/setter
封装。</strong></p>
<p>各个成员之间相互正交，比如数学矢量类
Vec3，就没必要去搞封装，只会让程序员变得痛苦，同时还有一定性能损失。特别是当
getter/setter 函数分离了声明和定义，实现在另一个文件时。</p>
<h2><span id="c思想raiiresourceacquisition-is-initialization">C++思想：RAII（Resource
Acquisition Is Initialization）</span></h2>
<p>资源获取视为初始化，反之，资源释放视为销毁</p>
<p>与 Java，Python 等垃圾回收语言不同，C++
的解构函数是显式的，离开作用域自动销毁，毫不含糊（有好处也有坏处，对高性能计算而言利大于弊）</p>
<h3><span id="异常安全exception-safe">异常安全（exception-safe）</span></h3>
<p>C++ 标准保证当异常发生时，会调用已创建对象的解构函数。</p>
<p>因此 C++ 中没有（也不需要） finally 语句。</p>
<p>如果对<strong>时序</strong>有要求或对<strong>性能</strong>有要求就不能依靠
GC。比如 mutex 忘记 unlock 造成<strong>死锁</strong>等等……</p>
<h3><span id="自定义构造函数">自定义构造函数</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Pig</span> &#123;</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> m_name;<br>    <span class="hljs-keyword">int</span> m_weight;<br><br>    Pig()<br>    &#123;<br>        m_name = <span class="hljs-string">"佩奇"</span>;<br>        m_weight = <span class="hljs-number">80</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Pig pig;<br><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"name: "</span> &lt;&lt; pig.m_name &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"weight: "</span> &lt;&lt; pig.m_weight &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>为什么需要初始化表达式？</p>
<ol type="1">
<li><p>假如类成员为 const 和引用</p></li>
<li><p>假如类成员没有无参构造函数</p></li>
<li><p>避免重复初始化，更高效</p></li>
</ol>
<h4><span id="构造函数单个参数避免陷阱">构造函数：单个参数（避免陷阱）</span></h4>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Pig</span> &#123;</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> m_name;<br>    <span class="hljs-keyword">int</span> m_weight;<br><br>    Pig(<span class="hljs-keyword">int</span> weight)<br>        : m_name(<span class="hljs-string">"一只重达"</span> + <span class="hljs-built_in">std</span>::to_string(weight) + <span class="hljs-string">"kg的猪"</span>)<br>        , m_weight(weight)<br>    &#123;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Pig pig = <span class="hljs-number">80</span>;  <span class="hljs-comment">// 编译通过</span><br>    <span class="hljs-comment">//Pig pig(80);</span><br><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"name: "</span> &lt;&lt; pig.m_name &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"weight: "</span> &lt;&lt; pig.m_weight &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Pig</span> &#123;</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> m_name;<br>    <span class="hljs-keyword">int</span> m_weight;<br><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Pig</span><span class="hljs-params">(<span class="hljs-keyword">int</span> weight)</span></span><br><span class="hljs-function">        : <span class="hljs-title">m_name</span><span class="hljs-params">(<span class="hljs-string">"一只重达"</span> + <span class="hljs-built_in">std</span>::to_string(weight) + <span class="hljs-string">"kg的猪"</span>)</span></span><br>        , m_weight(weight)<br>    &#123;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Pig pig = 80;  // 编译错误</span><br>    <span class="hljs-function">Pig <span class="hljs-title">pig</span><span class="hljs-params">(<span class="hljs-number">80</span>)</span></span>;      <span class="hljs-comment">// 编译通过</span><br><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"name: "</span> &lt;&lt; pig.m_name &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"weight: "</span> &lt;&lt; pig.m_weight &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>避免 80 被隐式转换为 pig 类，使用 explicit 禁止隐式类型转换。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Pig</span> &#123;</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> m_name;<br>    <span class="hljs-keyword">int</span> m_weight;<br><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Pig</span><span class="hljs-params">(<span class="hljs-keyword">int</span> weight)</span></span><br><span class="hljs-function">        : <span class="hljs-title">m_name</span><span class="hljs-params">(<span class="hljs-string">"一只重达"</span> + <span class="hljs-built_in">std</span>::to_string(weight) + <span class="hljs-string">"kg的猪"</span>)</span></span><br>        , m_weight(weight)<br>    &#123;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(Pig pig)</span> </span>&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"name: "</span> &lt;&lt; pig.m_name &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"weight: "</span> &lt;&lt; pig.m_weight &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// show(80);    // 编译错误</span><br>    show(Pig(<span class="hljs-number">80</span>));  <span class="hljs-comment">// 编译通过</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>比如 std::vector 的构造函数 vector(size_t n) 也是 explicit 的</p>
<h4><span id="使用-和-调用构造函数有什么区别">使用 {} 和 ()
调用构造函数，有什么区别？</span></h4>
<ol type="1">
<li><p>int(3.14f) 不会出错，但是 int{3.14f} 会出错，因为 {}
是非强制转换。</p></li>
<li><p>Pig(“佩奇”, 3.14f) 不会出错，但是 Pig{“佩奇”, 3.14f}
会出错，原因同上，更安全。</p></li>
<li><p>可读性：Pig(1, 2) 则 Pig 有可能是个函数，Pig{1, 2}
看起来更明确。</p></li>
</ol>
<p>在 C++ 中：</p>
<ul>
<li>使用 static_cast&lt;int&gt;(3.14f) 而不是 int(3.14f)</li>
<li>使用 reinterpret_cast&lt;void <em>&gt;(0xb8000) 而不是 (void
</em>)0xb8000</li>
</ul>
<p>更加明确用的哪一种类型转换（cast），从而避免一些像是
static_cast<int>(ptr) 的错误。</int></p>
<h4><span id="编译器默认生成的构造函数无参数">编译器默认生成的构造函数：无参数</span></h4>
<p>默认生成的构造函数，这些类型<strong>不会被初始化为</strong>
<strong>0</strong>：</p>
<p>1.int, float, double 等基础类型</p>
<p>2.void <em>, Object </em> 等指针类型</p>
<p>3.完全由这些类型组成的类</p>
<p>这些类型被称为 <strong>POD</strong>（plain-old-data）.</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Pig</span> &#123;</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> m_name;<br>    <span class="hljs-keyword">int</span> m_weight;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(Pig pig)</span> </span>&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"name: "</span> &lt;&lt; pig.m_name &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"weight: "</span> &lt;&lt; pig.m_weight &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Pig pig;<br><br>    show(pig);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">name:</span> <br><span class="hljs-attr">weight:</span> <span class="hljs-number">-265808448</span><br></code></pre></div></td></tr></table></figure>
<p>可以手动指定初始化 weight 为0。</p>
<p>通过 {}
语法指定的初始化值，会在<strong>编译器自动生成的构造函数</strong>里执行。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Pig</span> &#123;</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> m_name;<br>    <span class="hljs-keyword">int</span> m_weight&#123;<span class="hljs-number">0</span>&#125;;<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">name:</span> <br><span class="hljs-attr">weight:</span> <span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure>
<p>通过 {}
语法指定的初始化值，不仅会在<strong>编译器自动生成的构造函数</strong>里执行，也会在<strong>用户自定义构造函数</strong>里执行。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Pig</span> &#123;</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> m_name;<br>    <span class="hljs-keyword">int</span> m_weight&#123;<span class="hljs-number">0</span>&#125;;<br><br>    Pig(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> name) : m_name(name)<br>    &#123;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(Pig pig)</span> </span>&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"name: "</span> &lt;&lt; pig.m_name &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"weight: "</span> &lt;&lt; pig.m_weight &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Pig <span class="hljs-title">pig</span><span class="hljs-params">(<span class="hljs-string">"佩奇"</span>)</span></span>;<br><br>    show(pig);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">name:</span> <span class="hljs-string">佩奇</span><br><span class="hljs-attr">weight:</span> <span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure>
<p>类成员的 {} 中还可以有多个参数，甚至能用 =，当然 explicit
限制的构造函数除外。</p>
<p>除了不能用 () 之外，和函数局部变量的定义方式基本等价。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Demo</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Demo</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> a, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> b)</span> </span>&#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Demo("</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">','</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">')'</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Pig</span> &#123;</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> m_name&#123;<span class="hljs-string">"佩奇"</span>&#125;;<br>    <span class="hljs-keyword">int</span> m_weight = <span class="hljs-number">80</span>;<br>    Demo m_demo&#123;<span class="hljs-string">"Hello"</span>, <span class="hljs-string">"world"</span>&#125;;        <span class="hljs-comment">// 编译通过</span><br>    <span class="hljs-comment">// Demo m_demo = &#123;"Hello", "world"&#125;;  // 编译出错</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(Pig pig)</span> </span>&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"name: "</span> &lt;&lt; pig.m_name &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"weight: "</span> &lt;&lt; pig.m_weight &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Pig pig;<br><br>    show(pig);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>另外：</p>
<figure class="highlight abnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs abnf">int x&#123;&#125;<span class="hljs-comment">;</span><br>void *p&#123;&#125;<span class="hljs-comment">;</span><br></code></pre></div></td></tr></table></figure>
<p>与</p>
<figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> x&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-built_in">void</span> *p&#123;<span class="hljs-literal">null</span>ptr&#125;;<br></code></pre></div></td></tr></table></figure>
<p>等价，都会<strong>零初始化</strong>。</p>
<blockquote>
<p>std::cout &lt;&lt; int{}; 会打印出 0</p>
</blockquote>
<p>当一个类（和他的基类）没有定义任何构造函数，这时编译器会自动生成一个<strong>参数个数和成员一样的构造函数</strong>。</p>
<p>他会将 {}
内的内容，<strong>会按顺序赋值给对象的每一个成员</strong>。目的是为了<strong>方便程序员</strong>不必手写冗长的构造函数一个个赋值给成员。</p>
<p>且初始化列表的构造函数只支持通过 {} 或 = {} 来构造，不支持通过 ()
构造 （为了向下兼容 C++98）</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Pig</span> &#123;</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> m_name;<br>    <span class="hljs-keyword">int</span> m_weight;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(Pig pig)</span> </span>&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"name: "</span> &lt;&lt; pig.m_name &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"weight: "</span> &lt;&lt; pig.m_weight &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Pig pig1 = &#123;<span class="hljs-string">"佩奇"</span>, <span class="hljs-number">80</span>&#125;;   <span class="hljs-comment">// 编译通过</span><br>    Pig pig2&#123;<span class="hljs-string">"佩奇"</span>, <span class="hljs-number">80</span>&#125;;      <span class="hljs-comment">// 编译通过</span><br>    <span class="hljs-comment">// Pig pig3("佩奇", 80);   // 编译错误！</span><br><br>    show(pig1);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>所以可以使用默认构造函数类，<strong>解决函数多返回值</strong>（妙用）。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-keyword">bool</span> hit;<br>    Vec3 pos;<br>    Vec3 normal;<br>    <span class="hljs-keyword">float</span> depth;<br>&#125; intersect(Ray r) &#123;<br>    ...<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-literal">true</span>, r.origin, r.direction, <span class="hljs-number">233.0f</span>&#125;;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Ray r;<br>    <span class="hljs-keyword">auto</span> hit = intersect(r);<br>    <span class="hljs-keyword">if</span> (hit.hit) &#123;<br>        r.origin = hit.pos;<br>        r.direction = hit.normal;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>和 std::tuple 相比，最大的好处是每个属性都有名字，不容易搞错。</p>
<p>函数的参数，如果是很复杂的类型，你不想把<strong>类型名重复写一遍</strong>，也可以利用
{} 初始化列表来简化</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::tuple&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">float</span>, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; arg, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; arr)</span> </span>&#123;<br>    ...<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    func(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">3.14f</span>, <span class="hljs-string">"佩奇"</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>&#125;);<br>    <span class="hljs-comment">// 等价于：</span><br>    func(<span class="hljs-built_in">std</span>::tuple&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">float</span>, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">3.14f</span>, <span class="hljs-string">"佩奇"</span>),<br>         <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>&#125;));<br>    <span class="hljs-comment">// （C++17起）等价于：</span><br>    func(<span class="hljs-built_in">std</span>::tuple(<span class="hljs-number">1</span>, <span class="hljs-number">3.14f</span>, <span class="hljs-string">"佩奇"</span>), <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>&#125;));<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>一旦我们定义了自己的构造函数，编译器就<strong>不会再生成默认的无参构造函数</strong>。</p>
<p>有自定义构造函数时仍想用默认构造函数：= default</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Pig</span> &#123;</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> m_name;<br>    <span class="hljs-keyword">int</span> m_weight&#123;<span class="hljs-number">0</span>&#125;;<br><br>    Pig() = <span class="hljs-keyword">default</span>;<br><br>    Pig(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> name, <span class="hljs-keyword">int</span> weight)<br>        : m_name(name), m_weight(weight)<br>    &#123;&#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<h3><span id="拷贝构造函数">拷贝构造函数</span></h3>
<p>编译器默认会生成拷贝构造函数：Pig(Pig const &amp;)</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Pig</span> &#123;</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> m_name;<br>    <span class="hljs-keyword">int</span> m_weight&#123;<span class="hljs-number">0</span>&#125;;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(Pig pig)</span> </span>&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"name: "</span> &lt;&lt; pig.m_name &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"weight: "</span> &lt;&lt; pig.m_weight &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Pig pig&#123;<span class="hljs-string">"佩奇"</span>, <span class="hljs-number">80</span>&#125;;<br><br>    show(pig);<br><br>    Pig pig2 = pig;    <span class="hljs-comment">// 调用 Pig(Pig const &amp;)</span><br>    <span class="hljs-comment">// Pig pig2(pig);  // 与上一种方式等价</span><br><br>    show(pig);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3><span id="拷贝赋值函数">拷贝赋值函数</span></h3>
<p>编译器默认还会生成这样一个重载’=’这个运算符的函数：</p>
<p>Pig &amp;operator=(Pig const &amp;other);</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">Pig pig = pig2; <span class="hljs-comment">// 拷贝构造</span><br><br>Pig pig;       <span class="hljs-comment">// 无参构造</span><br>pig = pig2;    <span class="hljs-comment">// 拷贝赋值</span><br></code></pre></div></td></tr></table></figure>
<p>追求性能时推荐用<strong>拷贝构造</strong>，因为可以避免一次无参构造，拷贝赋值是出于需要临时修改对象的灵活性需要。</p>
<h4><span id="如何避免不经意的隐式拷贝">如何避免不经意的隐式拷贝</span></h4>
<p>将拷贝构造函数声明为 explicit 的，这样隐式的拷贝就会出错。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Pig</span> &#123;</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> m_name;<br>    <span class="hljs-keyword">int</span> m_weight&#123;<span class="hljs-number">0</span>&#125;;<br><br>    Pig(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> name, <span class="hljs-keyword">int</span> weight)<br>        : m_name(name), m_weight(weight)<br>    &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Pig</span><span class="hljs-params">(Pig <span class="hljs-keyword">const</span> &amp;other)</span> </span>= <span class="hljs-keyword">default</span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(Pig pig)</span> </span>&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"name: "</span> &lt;&lt; pig.m_name &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"weight: "</span> &lt;&lt; pig.m_weight &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Pig pig&#123;<span class="hljs-string">"佩奇"</span>, <span class="hljs-number">80</span>&#125;;<br><br>    <span class="hljs-comment">// show(pig);  // 编译错误</span><br>    show(Pig&#123;pig&#125;);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3><span id="自动生成的特殊函数">自动生成的特殊函数</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">C</span> &#123;</span><br>    C();                       <span class="hljs-comment">// 默认构造函数</span><br><br>    C(C <span class="hljs-keyword">const</span> &amp;c);             <span class="hljs-comment">// 拷贝构造函数</span><br>    C(C &amp;&amp;c);                  <span class="hljs-comment">// 移动构造函数（C++11 引入）</span><br>    C &amp;<span class="hljs-keyword">operator</span>=(C <span class="hljs-keyword">const</span> &amp;c);  <span class="hljs-comment">// 拷贝赋值函数</span><br>    C &amp;<span class="hljs-keyword">operator</span>=(C &amp;&amp;c);       <span class="hljs-comment">// 移动赋值函数（C++11 引入）</span><br><br>    ~C();                      <span class="hljs-comment">// 解构函数</span><br>&#125;;<br></code></pre></div></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Pig</span> &#123;</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> m_name;<br>    <span class="hljs-keyword">int</span> m_weight&#123;<span class="hljs-number">0</span>&#125;;<br><br>    Pig(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> name, <span class="hljs-keyword">int</span> weight)<br>        : m_name(name), m_weight(weight)<br>    &#123;&#125;<br><br>    Pig()<br>    &#123;&#125;<br><br>    Pig(Pig <span class="hljs-keyword">const</span> &amp;other)<br>        : m_name(other.m_name)<br>        , m_weight(other.m_weight)<br>    &#123;&#125;<br><br>    Pig &amp;<span class="hljs-keyword">operator</span>=(Pig <span class="hljs-keyword">const</span> &amp;other) &#123;<br>        m_name = other.m_name;<br>        m_weight = other.m_weight;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    Pig(Pig &amp;&amp;other)<br>        : m_name(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(other.m_name))<br>        , m_weight(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(other.m_weight))<br>    &#123;&#125;<br><br>    Pig &amp;<span class="hljs-keyword">operator</span>=(Pig &amp;&amp;other) &#123;<br>        m_name = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(other.m_name);<br>        m_weight = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(other.m_weight);<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    ~Pig() &#123;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(Pig pig)</span> </span>&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"name: "</span> &lt;&lt; pig.m_name &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"weight: "</span> &lt;&lt; pig.m_weight &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Pig pig;<br><br>    show(pig);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>如果其中一个成员（比如m_name）<strong>不支持拷贝构造函数</strong>，那么
Pig 类的拷贝构造函数将不会被编译器自动生成。</p>
<h3><span id="设计规则-经验">设计规则 经验</span></h3>
<ol type="1">
<li>如果一个类定义了<strong>析构</strong>函数，那么您必须同时<strong>定义或删除</strong>
<strong>拷贝构造</strong>函数和<strong>拷贝赋值</strong>函数，否则出错。</li>
<li>如果一个类<strong>定义或删除</strong>了<strong>拷贝构造</strong>函数，那么您必须同时<strong>定义或删除</strong>
<strong>拷贝赋值</strong>函数，否则出错，删除可导致低效。</li>
<li>如果一个类定义了<strong>移动构造</strong>函数，那么您必须同时<strong>定义或删除</strong>
<strong>移动赋值函数</strong>，否则出错，删除可导致低效。</li>
<li>如果一个类定义了<strong>拷贝构造</strong>函数或<strong>拷贝赋值</strong>函数，那么您必须最好同时<strong>定义</strong>
<strong>移动构造</strong>函数<strong>或
移动赋值</strong>函数，否则低效。</li>
</ol>
<p>例如：</p>
<p>在 = 时，默认是会拷贝的。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Vector</span> &#123;</span><br>    <span class="hljs-keyword">size_t</span> m_size;<br>    <span class="hljs-keyword">int</span> *m_data;<br><br>    Vector(<span class="hljs-keyword">size_t</span> n) &#123;<br>        m_size = n;<br>        m_data = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(n * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));<br>    &#125;<br><br>    ~Vector() &#123;<br>        <span class="hljs-built_in">free</span>(m_data);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> m_size;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">resize</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> <span class="hljs-built_in">size</span>)</span> </span>&#123;<br>        m_size = <span class="hljs-built_in">size</span>;<br>        m_data = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">realloc</span>(m_data, m_size);<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> &amp;<span class="hljs-keyword">operator</span>[](<span class="hljs-keyword">size_t</span> index) &#123;<br>        <span class="hljs-keyword">return</span> m_data[index];<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Vector <span class="hljs-title">v1</span><span class="hljs-params">(<span class="hljs-number">32</span>)</span></span>;<br><br>    Vector v2 = v1;<br>    <span class="hljs-comment">// Vector v2(v1);  // 与上一种等价</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-comment">// 自动释放 v1, v2</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-built_in">free</span>(): <span class="hljs-keyword">double</span> <span class="hljs-built_in">free</span> detected in tcache <span class="hljs-number">2</span><br></code></pre></div></td></tr></table></figure>
<p>当前 Vector 的实现造成一个很大的问题：其 m_data
指针是按地址值<strong>浅拷贝</strong>的，而不深拷贝其指向的数组！</p>
<p>在退出 main 函数作用域的时候，v1.m_data 会被释放两次！更危险的则是 v1
被解构而 v2 仍在被使用的情况。</p>
<p>这就是为什么“如果一个类定义了解构函数，那么您必须同时定义或删除拷贝构造函数和拷贝赋值函数，否则出错。”</p>
<p>最简单的办法是，直接禁止用户拷贝这个类的对象，在 C++11 中可以用 =
delete
表示这个函数被删除，让编译器不要自动生成一个默认的（会导致指针浅拷贝的）拷贝构造函数了。</p>
<p>这样就可以在编译期提前发现错误</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Vector</span> &#123;</span><br>    <span class="hljs-keyword">size_t</span> m_size;<br>    <span class="hljs-keyword">int</span> *m_data;<br><br>    Vector(<span class="hljs-keyword">size_t</span> n) &#123;<br>        m_size = n;<br>        m_data = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(n * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));<br>    &#125;<br><br>    ~Vector() &#123;<br>        <span class="hljs-built_in">free</span>(m_data);<br>    &#125;<br><br>    Vector(Vector <span class="hljs-keyword">const</span> &amp;other) = <span class="hljs-keyword">delete</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> m_size;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">resize</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> <span class="hljs-built_in">size</span>)</span> </span>&#123;<br>        m_size = <span class="hljs-built_in">size</span>;<br>        m_data = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">realloc</span>(m_data, m_size);<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> &amp;<span class="hljs-keyword">operator</span>[](<span class="hljs-keyword">size_t</span> index) &#123;<br>        <span class="hljs-keyword">return</span> m_data[index];<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>如果需要允许用户拷贝你的 Vector
类对象，保证任何单个操作前后，对象都是处于<strong>正确的状态</strong>，从而避免程序读到<strong>错误数据</strong>（如空悬指针）的情况。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Vector</span> &#123;</span><br>    <span class="hljs-keyword">size_t</span> m_size;<br>    <span class="hljs-keyword">int</span> *m_data;<br><br>    Vector(<span class="hljs-keyword">size_t</span> n) &#123;<br>        m_size = n;<br>        m_data = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(n * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));<br>    &#125;<br><br>    ~Vector() &#123;<br>        <span class="hljs-built_in">free</span>(m_data);<br>    &#125;<br><br>    Vector(Vector <span class="hljs-keyword">const</span> &amp;other) &#123;<br>        m_size = other.m_size;<br>        m_data = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(m_size * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));<br>        <span class="hljs-built_in">memcpy</span>(m_data, other.m_data, m_size * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> m_size;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">resize</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> <span class="hljs-built_in">size</span>)</span> </span>&#123;<br>        m_size = <span class="hljs-built_in">size</span>;<br>        m_data = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">realloc</span>(m_data, m_size);<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> &amp;<span class="hljs-keyword">operator</span>[](<span class="hljs-keyword">size_t</span> index) &#123;<br>        <span class="hljs-keyword">return</span> m_data[index];<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<h3><span id="区分拷贝构造和拷贝赋值">区分拷贝构造和拷贝赋值</span></h3>
<p>区分两种拷贝可以<strong>提高性能</strong>。</p>
<p>int x = 1; // 拷贝构造函数 x = 2; // 拷贝赋值函数</p>
<p><strong>拷贝赋值函数 ≈ 解构函数 + 拷贝构造函数</strong>。</p>
<p>拷贝构造：直接未初始化的内存上构造 2 拷贝赋值：先销毁现有的
1，再重新构造 2</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">...<br>Vector(Vector <span class="hljs-keyword">const</span> &amp;other) &#123;<br>       m_size = other.m_size;<br>       m_data = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(m_size * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));<br>       <span class="hljs-built_in">memcpy</span>(m_data, other.m_data, m_size * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));<br>   &#125;<br><br>   Vector &amp;<span class="hljs-keyword">operator</span>=(Vector <span class="hljs-keyword">const</span> &amp;other) &#123;<br>       <span class="hljs-keyword">this</span>-&gt;~Vector();             <span class="hljs-comment">// 先销毁现有的</span><br>       <span class="hljs-keyword">new</span> (<span class="hljs-keyword">this</span>) Vector(other);    <span class="hljs-comment">// 再重新构造（placement new）</span><br>       <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;                <span class="hljs-comment">// 支持连等号：v1 = v2 = v3</span><br>   &#125;<br>...<br></code></pre></div></td></tr></table></figure>
<p>更高效的写法</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">Vector &amp;<span class="hljs-keyword">operator</span>=(Vector <span class="hljs-keyword">const</span> &amp;other) &#123;<br>       m_size = other.m_size;<br>       m_data = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">realloc</span>(m_data, m_size * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));<br>       <span class="hljs-built_in">memcpy</span>(m_data, other.m_data, m_size * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));<br>       <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>   &#125;<br></code></pre></div></td></tr></table></figure>
<p>内存的销毁重新分配可以通过realloc，从而就地利用当前现有的m_data，避免重新分配。</p>
<h3><span id="拷贝和移动"><strong>拷贝和移动</strong></span></h3>
<p>时间复杂度：移动是 O(1)，拷贝是 O(n)。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test_copy</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">v1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">v2</span><span class="hljs-params">(<span class="hljs-number">200</span>)</span></span>;<br><br>    v1 = v2;                  <span class="hljs-comment">// 拷贝赋值 O(n)</span><br><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"after copy:"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"v1 length "</span> &lt;&lt; v1.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;  <span class="hljs-comment">// 200</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"v2 length "</span> &lt;&lt; v2.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;  <span class="hljs-comment">// 200</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test_move</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">v1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">v2</span><span class="hljs-params">(<span class="hljs-number">200</span>)</span></span>;<br><br>    v1 = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(v2);      <span class="hljs-comment">// 移动赋值 O(1)</span><br><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"after move:"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"v1 length "</span> &lt;&lt; v1.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;  <span class="hljs-comment">// 200</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"v2 length "</span> &lt;&lt; v2.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;  <span class="hljs-comment">// 0</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test_swap</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">v1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">v2</span><span class="hljs-params">(<span class="hljs-number">200</span>)</span></span>;<br><br>    <span class="hljs-built_in">std</span>::swap(v1, v2);      <span class="hljs-comment">// 交换两者 O(1)</span><br><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"after swap:"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"v1 length "</span> &lt;&lt; v1.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;  <span class="hljs-comment">// 200</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"v2 length "</span> &lt;&lt; v2.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;  <span class="hljs-comment">// 10</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    test_copy();<br>    test_move();<br>    test_swap();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>swap 可能是这样实现的：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><br><span class="hljs-class"><span class="hljs-title">void</span> <span class="hljs-title">swap</span>(<span class="hljs-title">T</span>&amp; <span class="hljs-title">t1</span>, <span class="hljs-title">T</span>&amp; <span class="hljs-title">t2</span>) &#123;</span><br>    T tmp = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(t2);<br>    t2 = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(t1);<br>    t1 = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(tmp);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>swap 在高性能计算中可以用来实现双缓存（ping-pong buffer）。</p>
<h4><span id="哪些情况会触发移动"><strong>哪些情况会触发“移动”</strong></span></h4>
<p>这些情况下编译器会调用移动：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">return</span> v2;          <span class="hljs-comment">// v2 作返回值</span><br>v1 = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">200</span>);  <span class="hljs-comment">// 就地构造的 v2</span><br>v1 = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(v2);      <span class="hljs-comment">// 显式地移动</span><br></code></pre></div></td></tr></table></figure>
<p>这些情况下编译器会调用拷贝：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::as_const(v2)     <span class="hljs-comment">// 显式地拷贝</span><br>v1 = v2         <span class="hljs-comment">// 默认拷贝</span><br></code></pre></div></td></tr></table></figure>
<p>注意，下面两个语句没有任何作用：</p>
<p>这两个函数只是负责转换类型，实际产生移动/拷贝效果的是在类的构造/赋值函数里。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(v2)   <span class="hljs-comment">// 不会清空 v2，需要清空可以用 v2 = &#123;&#125; 或 v2.clear()</span><br><span class="hljs-built_in">std</span>::as_const(v2)  <span class="hljs-comment">// 不会拷贝 v2，需要拷贝可以用 &#123; auto _ = v2; &#125;</span><br></code></pre></div></td></tr></table></figure>
<h3><span id="移动构造函数"><strong>移动构造函数</strong></span></h3>
<p>默认移动构造和移动赋值，编译器会自动这样做：</p>
<p>移动构造≈拷贝构造+他解构+他默认构造
移动赋值≈拷贝赋值+他解构+他默认构造</p>
<p>虽然低效，但至少可以保证不出错。</p>
<p>若自定义了移动构造，则： 移动赋值≈解构（当前自身的资源）+
移动构造</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">Vector(Vector &amp;&amp;other) &#123;<br>    m_size = other.m_size;<br>    other.m_size = <span class="hljs-number">0</span>;<br>    m_data = other.m_data;<br>    other.m_data = <span class="hljs-literal">nullptr</span>;<br>&#125;<br><br>Vector &amp;<span class="hljs-keyword">operator</span>=(Vector &amp;&amp;other) &#123;<br>    <span class="hljs-keyword">this</span>-&gt;~Vector();<br>    <span class="hljs-keyword">new</span> (<span class="hljs-keyword">this</span>) Vector(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(other));<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>如果有移动赋值函数，可以删除拷贝赋值函数。那么，当用户调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">v2 = v1;<br></code></pre></div></td></tr></table></figure>
<p>时，因为拷贝赋值被删除，编译器会尝试：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">v2 = List(v1)<br></code></pre></div></td></tr></table></figure>
<p>从而先调用拷贝构造函数（拷贝v1），然后因为 List(v1)
相当于<strong>就地构造</strong>的对象，从而<strong>变成了移动语义</strong>，从而进一步调用移动赋值函数。</p>
<h2><span id="智能指针">智能指针</span></h2>
<h3><span id="unique_ptr"><strong>unique_ptr</strong></span></h3>
<p>C++11 引入了 unique_ptr 容器，他的解构函数中会调用 delete p</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">C</span> &#123;</span><br>    C() &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"分配内存!\n"</span>);<br>    &#125;<br><br>    ~C() &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"释放内存!\n"</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    C *p = <span class="hljs-keyword">new</span> C;<br><br>    <span class="hljs-keyword">if</span> (rand() != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"出了点小状况……\n"</span>);<br>        <span class="hljs-comment">// delete p;   // 程序员粗心忘记释放指针</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">delete</span> p;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>unique_ptr 则把下面连个操作封装成一个操作</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">delete</span> p;<br>p = <span class="hljs-literal">nullptr</span>;<br></code></pre></div></td></tr></table></figure>
<p>只需要：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">p = <span class="hljs-literal">nullptr</span>;      <span class="hljs-comment">// 等价于：p.reset()</span><br></code></pre></div></td></tr></table></figure>
<p>= nullptr 时，就释放了 unique_ptr 。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;C&gt; p = <span class="hljs-built_in">std</span>::make_unique&lt;C&gt;();<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> + <span class="hljs-number">1</span> == <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"出了点小状况……\n"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">// 自动释放 p</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">// 自动释放 p</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4><span id="禁止拷贝"><strong>禁止拷贝</strong></span></h4>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;C&gt; p = <span class="hljs-built_in">std</span>::make_unique&lt;C&gt;();<br>    func(p);  <span class="hljs-comment">// 出错</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>因为 unique_ptr 删除了拷贝构造函数。如果要拷贝，有以下方法：</p>
<p>第一种是获取原始指针，你的 func()
实际上并不需要“夺走”资源的占有权（ownership）。</p>
<p>func() 只是调用了 p
的某个成员函数而已，<strong>并没有接过掌管对象生命周期的大权</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">C</span> &#123;</span><br>    C() &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"分配内存!\n"</span>);<br>    &#125;<br><br>    ~C() &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"释放内存!\n"</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">do_something</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"成员函数!\n"</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(C *p)</span> </span>&#123;<br>    p-&gt;do_something();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;C&gt; p = <span class="hljs-built_in">std</span>::make_unique&lt;C&gt;();<br>    func(p.<span class="hljs-built_in">get</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>第二种是移动，你的 func()
需要“夺走”资源的<strong>占有权</strong>。</p>
<p>func 把指针放到一个全局的列表里，p 的生命周期将会变得和 objlist
一样长。因此需要接过掌管对象生命周期的大权。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">C</span> &#123;</span><br>    C() &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"分配内存!\n"</span>);<br>    &#125;<br><br>    ~C() &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"释放内存!\n"</span>);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">do_something</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"我的数字是 %d!\n"</span>, m_number);<br>    &#125;<br>&#125;;<br><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;C&gt;&gt; objlist;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;C&gt; p)</span> </span>&#123;<br>    objlist.push_back(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(p));  <span class="hljs-comment">// 进一步移动到 objlist</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;C&gt; p = <span class="hljs-built_in">std</span>::make_unique&lt;C&gt;();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"移交前：%p\n"</span>, p.<span class="hljs-built_in">get</span>());  <span class="hljs-comment">// 不为 null</span><br>    func(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(p));    <span class="hljs-comment">// 通过移动构造函数，转移指针控制权</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"移交后：%p\n"</span>, p.<span class="hljs-built_in">get</span>());  <span class="hljs-comment">// null，因为移动会清除原对象</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<figure class="highlight erlang-repl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs erlang-repl">分配内存!<br>移交前：<span class="hljs-number">0</span>x55ec91b162b0<br>移交后：(nil)<br>释放内存!<br></code></pre></div></td></tr></table></figure>
<p>如果，<strong>移交控制权后仍希望访问到</strong> <strong>p</strong>
<strong>指向的对象</strong>。最简单的办法是，在移交控制权给 func
前，提前通过 p.get() 获取原始指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;C&gt; p = <span class="hljs-built_in">std</span>::make_unique&lt;C&gt;();<br>    func(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(p));<br><br>    p-&gt;do_something();  <span class="hljs-comment">// 出错，p 已经为空了！</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;C&gt; p = <span class="hljs-built_in">std</span>::make_unique&lt;C&gt;();<br><br>    C *raw_p = p.<span class="hljs-built_in">get</span>();<br>    func(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(p));<br><br>    raw_p-&gt;do_something();  <span class="hljs-comment">// 正常执行，raw_p 保留了转移前的指针</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>不过你得保证 raw_p 的存在时间不超过 p
的生命周期，否则会出现危险的空悬指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;C&gt; p = <span class="hljs-built_in">std</span>::make_unique&lt;C&gt;();<br><br>    C *raw_p = p.<span class="hljs-built_in">get</span>();<br>    func(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(p));<br><br>    raw_p-&gt;do_something();  <span class="hljs-comment">// 正常执行，raw_p 保留了转移前的指针</span><br><br>    objlist.<span class="hljs-built_in">clear</span>();        <span class="hljs-comment">// 刚刚 p 移交给 func 的生命周期结束了！</span><br><br>    raw_p-&gt;do_something();  <span class="hljs-comment">// 错误！raw_p 指向的对象已经被释放！</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<figure class="highlight erlang-repl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs erlang-repl">分配内存!<br>我的数字是 <span class="hljs-number">42</span>!<br>释放内存!<br>我的数字是 -<span class="hljs-number">803182608</span>!<br></code></pre></div></td></tr></table></figure>
<h3><span id="shared_ptr"><strong>shared_ptr</strong></span></h3>
<p>牺牲效率换来自由度的 shared_ptr
则允许拷贝，他解决<strong>重复释放</strong>的方式是通过<strong>引用计数</strong>。</p>
<p>当一个 shared_ptr 初始化时，将计数器设为1。 当一个 shared_ptr
被拷贝时，计数器加1。 当一个 shared_ptr
被解构时，计数器减1。减到0时，则自动销毁他指向的对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">C</span> &#123;</span><br>    <span class="hljs-keyword">int</span> m_number;<br><br>    C() &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"分配内存!\n"</span>);<br>        m_number = <span class="hljs-number">42</span>;<br>    &#125;<br><br>    ~C() &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"释放内存!\n"</span>);<br>        m_number = <span class="hljs-number">-2333333</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">do_something</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"我的数字是 %d!\n"</span>, m_number);<br>    &#125;<br>&#125;;<br><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;C&gt;&gt; objlist;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;C&gt; p)</span> </span>&#123;<br>    objlist.push_back(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(p));  <span class="hljs-comment">// 这里用移动可以更高效，但不必须</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;C&gt; p = <span class="hljs-built_in">std</span>::make_shared&lt;C&gt;(); <span class="hljs-comment">// 引用计数初始化为1</span><br><br>    func(p);  <span class="hljs-comment">// shared_ptr 允许拷贝！和当前指针共享所有权，引用计数加1</span><br>    func(p);  <span class="hljs-comment">// 多次也没问题~ 多个 shared_ptr 会共享所有权，引用计数加1</span><br><br>    p-&gt;do_something();  <span class="hljs-comment">// 正常执行，p 指向的地址本来就没有改变</span><br><br>    objlist.<span class="hljs-built_in">clear</span>();    <span class="hljs-comment">// 刚刚 p 移交给 func 的生命周期结束了！引用计数减2</span><br><br>    p-&gt;do_something();  <span class="hljs-comment">// 正常执行，因为引用计数还剩1，不会被释放</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">// 到这里最后一个引用 p 也被释放，p 指向的对象才终于释放</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>只要还有存在哪怕一个指针指向该对象，就不会被解构。</p>
<p>可以使用 p.use_count() 来获取当前指针的引用计数。</p>
<blockquote>
<p>注意 <em>p.func()</em> 是 shared_ptr 类型本身的成员函数，而
<em>p-&gt;func()</em> 是 p 指向对象（也就是
C）的成员函数，不要混淆。</p>
</blockquote>
<h3><span id="weak_ptr"><strong>weak_ptr</strong></span></h3>
<p>弱引用的拷贝与解构不影响其引用计数器。</p>
<p>可以通过 <em>lock()</em> 随时产生一个新的 shared_ptr 作为强引用。但不
lock 的时候不影响计数。</p>
<p>如果失效（计数器归零）则 expired() 会返回 false，且 lock() 也会返回
nullptr。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;C&gt; p = <span class="hljs-built_in">std</span>::make_shared&lt;C&gt;(); <span class="hljs-comment">// 引用计数初始化为1</span><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"use count = %ld\n"</span>, p.use_count());   <span class="hljs-comment">// 1</span><br><br>    <span class="hljs-built_in">std</span>::weak_ptr&lt;C&gt; weak_p = p;        <span class="hljs-comment">// 创建一个不影响计数器的弱引用</span><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"use count = %ld\n"</span>, p.use_count());   <span class="hljs-comment">// 1</span><br><br>    func(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(p));  <span class="hljs-comment">// 控制权转移，p 变为 null，引用计数加不变</span><br><br>    <span class="hljs-keyword">if</span> (weak_p.expired())<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"错误：弱引用已失效！"</span>);<br>    <span class="hljs-keyword">else</span><br>        weak_p.lock()-&gt;do_something();  <span class="hljs-comment">// 正常执行，p 的生命周期仍被 objlist 延续着</span><br><br>    objlist.<span class="hljs-built_in">clear</span>();    <span class="hljs-comment">// 刚刚 p 移交给 func 的生命周期结束了！引用计数减1，变成0了</span><br><br>    <span class="hljs-keyword">if</span> (weak_p.expired())              <span class="hljs-comment">// 因为 shared_ptr 指向的对象已释放，弱引用会失效</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"错误：弱引用已失效！"</span>);<br>    <span class="hljs-keyword">else</span><br>        weak_p.lock()-&gt;do_something();  <span class="hljs-comment">// 不会执行</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">// 到这里最后一个弱引用 weak_p 也被释放，他指向的“管理块”被释放</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<figure class="highlight fortran"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs fortran">分配内存<span class="hljs-comment">!</span><br><span class="hljs-keyword">use</span> <span class="hljs-built_in">count</span> = <span class="hljs-number">1</span><br><span class="hljs-keyword">use</span> <span class="hljs-built_in">count</span> = <span class="hljs-number">1</span><br>我的数字是 <span class="hljs-number">42</span><span class="hljs-comment">!</span><br>释放内存<span class="hljs-comment">!</span><br>错误：弱引用已失效！<br></code></pre></div></td></tr></table></figure>
<h3><span id="智能指针作为类的成员变量"><strong>智能指针作为类的成员变量</strong></span></h3>
<p>判断要用哪一种智能指针：</p>
<ol type="1">
<li>unique_ptr：当该指针所指对象仅仅属于我时。比如：父窗口中指向子窗口的指针。</li>
<li>原始指针：当该对象不属于我，但他释放前我必然被释放时。有一定风险。对象使用指针。比如：子窗口中指向父窗口的指针。</li>
<li>shared_ptr：当该对象由多个对象共享时，或虽然该对象仅仅属于我，但有使用
weak_ptr 的需要，对象使用shared_ptr。</li>
<li>weak_ptr：当该对象不属于我，且他释放后我仍可能不被释放时，对象使用weak_ptr。比如：指向窗口中上一次被点击的元素。</li>
<li>初学者可以多用 shared_ptr 和 weak_ptr 的组合，更安全。</li>
</ol>
<p>shared_ptr 需要维护一个 atomic
的引用计数器，<strong>效率低</strong>，需要额外的一块管理内存，访问实际对象需要二级指针，而且
deleter 使用了类型擦除技术。</p>
<p>全部用
shared_ptr，可能出现<strong>循环引用</strong>之类的问题，导致内存泄露，依然需要使用不影响计数的原始指针或者
weak_ptr 来避免。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">C</span> &#123;</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;C&gt; m_child;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;C&gt; m_parent;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> parent = <span class="hljs-built_in">std</span>::make_shared&lt;C&gt;();<br>    <span class="hljs-keyword">auto</span> child = <span class="hljs-built_in">std</span>::make_shared&lt;C&gt;();<br><br>    <span class="hljs-comment">// 建立相互引用：</span><br>    parent-&gt;m_child = child;<br>    child-&gt;m_parent = parent;<br><br>    parent = <span class="hljs-literal">nullptr</span>;  <span class="hljs-comment">// parent 不会被释放！因为 child 还指向他！</span><br>    child = <span class="hljs-literal">nullptr</span>;   <span class="hljs-comment">// child 也不会被释放！因为 parent 还指向他！</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>如何解决？只需要把其中逻辑上“不具有所属权”的那一个改成 weak_ptr
即可：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">C</span> &#123;</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;C&gt; m_child;<br>    <span class="hljs-built_in">std</span>::weak_ptr&lt;C&gt; m_parent;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> parent = <span class="hljs-built_in">std</span>::make_shared&lt;C&gt;();<br>    <span class="hljs-keyword">auto</span> child = <span class="hljs-built_in">std</span>::make_shared&lt;C&gt;();<br><br>    <span class="hljs-comment">// 建立相互引用：</span><br>    parent-&gt;m_child = child;<br>    child-&gt;m_parent = parent;<br><br>    parent = <span class="hljs-literal">nullptr</span>;  <span class="hljs-comment">// parent 会被释放。因为 child 指向他的是 **弱引用**</span><br>    child = <span class="hljs-literal">nullptr</span>;   <span class="hljs-comment">// child 会被释放。因为指向 child 的 parent 已经释放了</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>改成 weak_ptr， 没有 parent 的所有权。</p>
<p>也可以把 m_parent 变成原始指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">C</span> &#123;</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;C&gt; m_child;<br>    C *m_parent;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> parent = <span class="hljs-built_in">std</span>::make_shared&lt;C&gt;();<br>    <span class="hljs-keyword">auto</span> child = <span class="hljs-built_in">std</span>::make_shared&lt;C&gt;();<br><br>    <span class="hljs-comment">// 建立相互引用：</span><br>    parent-&gt;m_child = child;<br>    child-&gt;m_parent = parent.<span class="hljs-built_in">get</span>();<br><br>    parent = <span class="hljs-literal">nullptr</span>;  <span class="hljs-comment">// parent 会被释放。因为 child 指向他的是原始指针</span><br>    child = <span class="hljs-literal">nullptr</span>;   <span class="hljs-comment">// child 会被释放。因为指向 child 的 parent 已经释放了</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>假定他释放前我必然被释放，完全可以把 m_child
变成一个标志这“完全所有权”的 unique_ptr。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">C</span> &#123;</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;C&gt; m_child;<br>    C *m_parent;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> parent = <span class="hljs-built_in">std</span>::make_unique&lt;C&gt;();<br>    <span class="hljs-keyword">auto</span> child = <span class="hljs-built_in">std</span>::make_unique&lt;C&gt;();<br><br>    <span class="hljs-comment">// 建立相互引用：</span><br>    child-&gt;m_parent = parent.<span class="hljs-built_in">get</span>();<br>    parent-&gt;m_child = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(child);  <span class="hljs-comment">// 移交 child 的所属权给 parent</span><br><br>    parent = <span class="hljs-literal">nullptr</span>;  <span class="hljs-comment">// parent 会被释放。因为 child 指向他的是原始指针</span><br>    <span class="hljs-comment">// 此时 child 也已经被释放了，因为 child 完全隶属于 parent</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3><span id="安全类型">安全类型</span></h3>
<p>以下类型是安全的：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> id;                            <span class="hljs-comment">// 基础类型</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; arr;              <span class="hljs-comment">// STL 容器</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Object&gt; child;     <span class="hljs-comment">// 智能指针</span><br>Object *parent;                    <span class="hljs-comment">// 原始指针，如果是从智能指针里 .get() 出来的</span><br></code></pre></div></td></tr></table></figure>
<p>以下对象是不安全的：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">char</span> *ptr;        <span class="hljs-comment">// 原始指针，如果是通过 malloc/free 或 new/delete 分配的</span><br>GLint tex;        <span class="hljs-comment">// 是基础类型 int，但是对应着某种资源</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;Object *&gt; objs;       <span class="hljs-comment">// STL 容器，但存了不安全的对象</span><br></code></pre></div></td></tr></table></figure>
<p><strong>有不安全类型成员的</strong>对象的类的设计需要考虑之前的设计原则问题。</p>
<p>如果你的类所有成员，都是<strong>安全</strong>的类型，那么五大构造/析构函数都无需声明（或声明为
= default），你的类自动就是<strong>安全</strong>的。</p>
<p>最好的判断方式是：如果你不需要<strong>自定义的解构函数</strong>，那么这个类就不需要担心。</p>
<p>因为如果用到了自定义解构函数，往往意味着你的类成员中，包含有<strong>不安全</strong>的类型。</p>
<p>这样的类型一般无外乎两种情况：</p>
<ol type="1">
<li><p>你的类<strong>管理着资源</strong>。</p></li>
<li><p>你的类<strong>是数据结构</strong>。</p></li>
</ol>
<h4><span id="管理着资源的类"><strong>管理着资源的类</strong></span></h4>
<p>这个类管理着某种资源，资源往往不能被“复制”。比如一个 OpenGL
的着色器，或是一个 Qt 的窗口。</p>
<p>一般<strong>删除拷贝函数，然后统一用智能指针管理</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Shader</span> &#123;</span><br>  GLuint sha;<br>  GLuint target&#123;GL_ARRAY_BUFFER&#125;;<br><br>  Shader(GLuint type) &#123; CHECK_GL(sha = g1CreateShader(type)); &#125;<br>  ~Shader() &#123; CHECK_GL(g1DeIeteShader(sha)); &#125;<br><br>  Shader(Shader <span class="hljs-keyword">const</span> &amp;) = <span class="hljs-keyword">delete</span>;<br>  Shader &amp;<span class="hljs-keyword">operator</span>=(Shader <span class="hljs-keyword">const</span> &amp;) = <span class="hljs-keyword">delete</span>;<br><br>&#125;;<br></code></pre></div></td></tr></table></figure>
<h4><span id="数据结构类"><strong>数据结构类</strong></span></h4>
<p>如果可以，自己定义拷贝和移动函数。</p>
<h3><span id="函数参数类型优化"><strong>函数参数类型优化</strong></span></h3>
<p>如果是基础类型（比如 int，float）则<strong>按值</strong>传递： float
squareRoot(float val);</p>
<p>如果是原始指针（比如 int <em>，Object
</em>）则<strong>按值</strong>传递： void doSomethingWith(Object
*ptr);</p>
<p>如果是数据容器类型（比如
vector，string）则按<strong>常引用</strong>传递： int
sumArray(std::vector<int> const &amp;arr);</int></p>
<p>如果数据容器不大（比如 tuple&lt;int,
int&gt;），则其实可以<strong>按值</strong>传递： glm::vec3
calculateGravityAt(glm::vec3 pos);</p>
<p>如果是智能指针（比如
shared_ptr），且需要生命周期控制权，则<strong>按值</strong>传递： void
addObject(std::shared_ptr<object> obj);</object></p>
<p>如果是智能指针，但不需要生命周期，则通过 <strong>.get()
获取原始指针</strong>后，<strong>按值</strong>传递： void
modifyObject(Object *obj);</p>
<h3><span id="其他语言对比">其他语言对比</span></h3>
<p>Java 和 Python
的业务需求大多是在和<strong>资源</strong>打交道，从而基本都是刚刚说的要删除拷贝函数的那一类。</p>
<p>Java 和 Python
干脆简化：一切非基础类型的对象都是<strong>浅拷贝</strong>，引用计数由<strong>垃圾回收</strong>机制自动管理。</p>
<p>以<strong>系统级编程、算法数据结构、高性能计算</strong>为主要业务的
C++，才发展出了这些思想，并将拷贝/移动/指针/可变性/多线程等概念作为<strong>语言基本元素</strong>存在。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Notes/">Notes</a>
                    
                      <a class="hover-with-bg" href="/categories/Notes/C/">C++</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/C/">C++</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/posts/dd44df07.html">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Linux内核链表设计</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/posts/4df195e7.html">
                        <span class="hidden-mobile">C语言程序内存安全检查</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      var light = 'github-light';
      var dark = 'github-dark';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'RacleRay/comments');
      s.setAttribute('issue-term', 'title');
      
      s.setAttribute('label', 'utterances');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://github.com/RacleRay" class="hint--bottom hint--rounded" aria-label="GitHub" target="_blank"> <i class="iconfont icon-github-fill" aria-hidden="true"></i> </a>
<a href="mailto:969232057@qq.com" class="hint--bottom hint--rounded" aria-label="Email" target="_blank"> <i class="iconfont icon-mail" aria-hidden="true"></i> </a>
<a href="tencent://AddContact/?fromId=50&amp;fromSubId=1&amp;subcmd=all&amp;uin=969232057" class="hint--bottom hint--rounded" aria-label="QQ" target="_blank"> <i class="iconfont icon-qq-fill" aria-hidden="true"></i> </a>
<a class="qr-trigger" target="_self"> <i class="iconfont icon-wechat-fill" aria-hidden="true"></i> <img class="qr-img" src="/img/wexin.jpg" srcset="/img/loading.gif" lazyload alt="qrcode"> </a>
<a href="/atom.xml" class="hint--bottom hint--rounded" aria-label="Email" target="_blank"> <i class="iconfont icon-rss" aria-hidden="true"></i> </a>
<div></div> <a> POWERED BY </a> <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.staticfile.org/jquery/3.5.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.staticfile.org/tocbot/4.12.0/tocbot.min.js" ></script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>



  <script  src="/js/local-search.js" ></script>






  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>
