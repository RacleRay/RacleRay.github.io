

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.ico">
  <link rel="icon" href="/img/favicon.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#1aa3ff">
  <meta name="description" content="Effective Modern Cpp 读书笔记">
  <meta name="author" content="HeRui">
  <meta name="keywords" content="C++">
  <meta name="description" content="Effective Modern Cpp 读书笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="Effective Modern Cpp">
<meta property="og:url" content="https://racleray.github.io/posts/b3d88a54.html">
<meta property="og:site_name" content="Racle&#96;s Story">
<meta property="og:description" content="Effective Modern Cpp 读书笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://racleray.github.io/posts/images/Effective-Modern-Cpp/image-20230918083719236.png">
<meta property="og:image" content="https://racleray.github.io/posts/images/Effective-Modern-Cpp/item20_fig1.png">
<meta property="og:image" content="https://racleray.github.io/posts/images/Effective-Modern-Cpp/item20_fig2.png">
<meta property="article:published_time" content="2022-04-12T13:00:52.000Z">
<meta property="article:modified_time" content="2024-01-09T10:23:43.747Z">
<meta property="article:author" content="江左时雨">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://racleray.github.io/posts/images/Effective-Modern-Cpp/image-20230918083719236.png">
  
     <meta name="baidu-site-verification" content="code-tH44R5Z2fc" /> <meta name="msvalidate.01" content="4E3B92EC6A38584E946DBE40929107D9" /> <meta name="google-site-verification" content="c-8NXvOa-KKHK4OB0TyzjFeRUuIPFXEXM9h5hYePPpw" /> 
  
  <title>Effective Modern Cpp - Racle`s Story</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.4.0/styles/night-owl.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  
<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC&display=swap.css">
<link rel="stylesheet" href="/css/custom.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"racleray.github.io","root":"/","version":"1.8.11","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Racle`s Story" type="application/atom+xml"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>


<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="link link--kukuri" href="/", data-letters="Racle`s Story">
      Racle`s Story
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/talking/">
                <i class="iconfont icon-comment"></i>
                说说
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/46.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Effective Modern Cpp">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-04-12 21:00" pubdate>
        2022年4月12日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      109k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      339 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Effective Modern Cpp</h1>
            
            <div class="markdown-body">
              <p>为什么<code>const</code>成员函数应当线程安全？怎样使用<code>std::unique_ptr</code>实现Pimpl惯用法？为何要避免<em>lambda</em>表达式用默认捕获模式？<code>std::atomic</code>与<code>volatile</code>的区别是什么？</p>
<h2><span id="基础简介">基础简介</span></h2>
<p>C++中的许多东西都可被声明和定义。<strong>声明</strong>（<em>declarations</em>）引入名字和类型，并不给出比如存放在哪或者怎样实现等的细节：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> x;                       <span class="hljs-comment">//对象声明</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span>;</span>                       <span class="hljs-comment">//类声明</span><br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Widget&amp; w)</span></span>;         <span class="hljs-comment">//函数声明</span><br><br><span class="hljs-keyword">enum</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Color</span>;</span>                   <span class="hljs-comment">//限域enum声明</span><br></code></pre></div></td></tr></table></figure>
<p><strong>定义</strong>（<em>definitions</em>）提供存储位置或者实现细节：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> x;                              <span class="hljs-comment">//对象定义</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> &#123;</span>                      <span class="hljs-comment">//类定义</span><br>    …<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Widget&amp; w)</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-keyword">return</span> w.size() &lt; <span class="hljs-number">10</span>; &#125;           <span class="hljs-comment">//函数定义</span><br><br><span class="hljs-keyword">enum</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Color</span></span><br><span class="hljs-class">&#123;</span> Yellow, Red, Blue &#125;;              <span class="hljs-comment">//限域enum定义</span><br></code></pre></div></td></tr></table></figure>
<p>定义也有资格称为声明。</p>
<p>定义一个函数的<strong>签名</strong>（<em>signature</em>）为它声明的一部分，这个声明指定了形参类型和返回类型。函数名和形参名不是签名的一部分。在上面的例子中，<code>func</code>的签名是<code>bool(const Widget&amp;)</code>。函数声明中除了形参类型和返回类型之外的元素（比如<code>noexcept</code>或者<code>constexpr</code>，如果存在的话）都被排除在外。</p>
<p>另外
<code>std::auto_ptr</code>在C++11中被废弃，因为<code>std::unique_ptr</code>可以做同样的工作，而且只会做的更好。</p>
<p>如果一个操作的结果有<strong>未定义的行为</strong>（<em>undefined
behavior</em>）。这意味着运行时表现是不可预测的。比如，在<code>std::vector</code>范围外使用方括号（“<code>[]</code>”），解引用未初始化的迭代器，或者数据竞争（即有两个或以上线程，至少一个是writer，同时访问相同的内存位置）。</p>
<p>还有，智能指针通常重载指针解引用运算符（<code>operator-&gt;</code>和<code>operator*</code>），但
<code>std::weak_ptr</code>是个例外。</p>
<h1><span id="1-类型推导">1 类型推导</span></h1>
<p>C++11修改了一些类型推导规则并增加了两套规则，一套用于<code>auto</code>，一套用于<code>decltype</code>。C++14扩展了<code>auto</code>和<code>decltype</code>可能使用的范围。</p>
<h2><span id="条款1理解模板类型推导">条款1：理解模板类型推导</span></h2>
<p>C++最重要最吸引人的特性<code>auto</code>是建立在模板类型推导的基础上的。</p>
<p>考虑像这样一个函数模板：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(ParamType param)</span></span>;<br></code></pre></div></td></tr></table></figure>
<p>更具体一点是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T&amp; param)</span></span>;         <span class="hljs-comment">//ParamType是const T&amp;</span><br></code></pre></div></td></tr></table></figure>
<p>编译器对 f
函数的参数进行两个类型推导：一个是针对<code>T</code>的，另一个是针对<code>ParamType</code>的。这两个类型通常是不同的，因为<code>ParamType</code>包含一些修饰，比如<code>const</code>和引用修饰符。</p>
<p>然后这样进行调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<br>f(x);                           <span class="hljs-comment">//用一个int类型的变量调用f</span><br></code></pre></div></td></tr></table></figure>
<p><code>T</code>被推导为<code>int</code>，<code>ParamType</code>却被推导为<code>const int&amp;</code>。</p>
<p><code>T</code>的类型推导不仅取决于<code>expr</code>的类型，也取决于<code>ParamType</code>的类型。有三种情况：</p>
<ul>
<li><code>ParamType</code>是一个指针或引用，但不是通用引用（参见
Item24，它不同于左值引用和右值引用）</li>
<li><code>ParamType</code>是一个通用引用</li>
<li><code>ParamType</code>既不是指针也不是引用</li>
</ul>
<h3><span id="paramtype是一个指针或引用但不是通用引用"><code>ParamType</code>是一个指针或引用，但不是通用引用</span></h3>
<p><code>f(expr)</code> 的类型推导会这样进行：</p>
<ol type="1">
<li>如果<code>expr</code>的类型是一个引用，忽略引用部分</li>
<li>然后<code>expr</code>的类型与<code>ParamType</code>进行模式匹配来决定<code>T</code></li>
</ol>
<p>如果这是我们的模板，</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T&amp; param)</span></span>;               <span class="hljs-comment">//param是一个引用</span><br></code></pre></div></td></tr></table></figure>
<p>我们声明这些变量，</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> x=<span class="hljs-number">27</span>;                       <span class="hljs-comment">//x是int</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> cx=x;                 <span class="hljs-comment">//cx是const int</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; rx=x;                <span class="hljs-comment">//rx是指向作为const int的x的引用</span><br></code></pre></div></td></tr></table></figure>
<p>在不同的调用中，对<code>param</code>和<code>T</code>推导的类型会是这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">f(x);                           <span class="hljs-comment">//T是int，param的类型是int&amp;</span><br>f(cx);                          <span class="hljs-comment">//T是const int，param的类型是const int&amp;</span><br>f(rx);                          <span class="hljs-comment">//T是const int，param的类型是const int&amp;</span><br></code></pre></div></td></tr></table></figure>
<p>即使<code>rx</code>的类型是一个引用，<code>T</code>也会被推导为一个非引用
，这是因为<code>rx</code>的引用性（reference-ness）在类型推导中会被忽略。</p>
<p>当<code>param</code>是reference-to-<code>const</code>，<code>const</code>不再被推导为<code>T</code>的一部分：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T&amp; param)</span></span>;         <span class="hljs-comment">//param现在是reference-to-const</span><br><br><span class="hljs-keyword">int</span> x = <span class="hljs-number">27</span>;                     <span class="hljs-comment">//如之前一样</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> cx = x;               <span class="hljs-comment">//如之前一样</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; rx = x;              <span class="hljs-comment">//如之前一样</span><br><br>f(x);                           <span class="hljs-comment">//T是int，param的类型是const int&amp;</span><br>f(cx);                          <span class="hljs-comment">//T是int，param的类型是const int&amp;</span><br>f(rx);                          <span class="hljs-comment">//T是int，param的类型是const int&amp;</span><br></code></pre></div></td></tr></table></figure>
<p>同之前一样，<code>rx</code>的reference-ness在类型推导中被忽略了。</p>
<p>如果<code>param</code>是一个指针（或者指向<code>const</code>的指针）而不是引用，情况本质上也一样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T* param)</span></span>;               <span class="hljs-comment">//param现在是指针</span><br><br><span class="hljs-keyword">int</span> x = <span class="hljs-number">27</span>;                     <span class="hljs-comment">//同之前一样</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *px = &amp;x;             <span class="hljs-comment">//px是指向作为const int的x的指针</span><br><br>f(&amp;x);                          <span class="hljs-comment">//T是int，param的类型是int*</span><br>f(px);                          <span class="hljs-comment">//T是const int，param的类型是const int*</span><br></code></pre></div></td></tr></table></figure>
<h3><span id="paramtype是一个通用引用"><code>ParamType</code>是一个通用引用</span></h3>
<p>形参被声明为像右值引用一样（也就是，在函数模板中假设有一个类型形参<code>T</code>，那么通用引用声明形式就是<code>T&amp;&amp;</code>)。</p>
<ul>
<li><p>如果<code>expr</code>是左值，<code>T</code>和<code>ParamType</code>都会被推导为左值引用。</p>
<blockquote>
<ul>
<li><p>这是模板类型推导中唯一一种<code>T</code>被推导为引用的情况。</p></li>
<li><p>虽然<code>ParamType</code>被声明为右值引用类型，但是最后推导的结果是左值引用。</p></li>
</ul>
</blockquote></li>
<li><p>如果<code>expr</code>是右值，就使用正常的（也就是上一节中的）推导规则</p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T&amp;&amp; param)</span></span>;              <span class="hljs-comment">//param现在是一个通用引用类型</span><br>		<br><span class="hljs-keyword">int</span> x=<span class="hljs-number">27</span>;                      <br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> cx=x;             <br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp; rx=cx;      <br><br>f(x);                           <span class="hljs-comment">//x是左值，所以T是int&amp;，</span><br>                                <span class="hljs-comment">//param类型也是int&amp;</span><br><br>f(cx);                          <span class="hljs-comment">//cx是左值，所以T是const int&amp;，</span><br>                                <span class="hljs-comment">//param类型也是const int&amp;</span><br><br>f(rx);                          <span class="hljs-comment">//rx是左值，所以T是const int&amp;，</span><br>                                <span class="hljs-comment">//param类型也是const int&amp;</span><br><br>f(<span class="hljs-number">27</span>);                          <span class="hljs-comment">//27是右值，所以T是int，</span><br>                                <span class="hljs-comment">//param类型就是int&amp;&amp;</span><br></code></pre></div></td></tr></table></figure>
<p>通用引用的类型推导规则是不同于普通的左值或者右值引用的。尤其是，当通用引用被使用时，类型推导会区分左值实参和右值实参，但是对非通用引用时不会区分。</p>
<h3><span id="paramtype既不是指针也不是引用"><code>ParamType</code>既不是指针也不是引用</span></h3>
<p>当<code>ParamType</code>既不是指针也不是引用时，我们通过传值（pass-by-value）的方式处理：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T param)</span></span>;                <span class="hljs-comment">//以传值的方式处理param</span><br></code></pre></div></td></tr></table></figure>
<p>这意味着无论传递什么<code>param</code>都会成为它的一份拷贝——一个完整的新对象。事实上<code>param</code>成为一个新对象这一行为会影响<code>T</code>如何从<code>expr</code>中推导出结果。</p>
<ol type="1">
<li>如果<code>expr</code>的类型是一个引用，忽略这个引用部分</li>
<li>如果忽略<code>expr</code>的引用性（reference-ness）之后，<code>expr</code>是一个<code>const</code>，那就再忽略<code>const</code>。如果它是<code>volatile</code>，也忽略<code>volatile</code>（<code>volatile</code>对象不常见，它通常用于驱动程序的开发中）</li>
</ol>
<p>因此：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> x=<span class="hljs-number">27</span>;                       <span class="hljs-comment">//如之前一样</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> cx=x;                 <span class="hljs-comment">//如之前一样</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp; rx=cx;              <span class="hljs-comment">//如之前一样</span><br><br>f(x);                           <span class="hljs-comment">//T和param的类型都是int</span><br>f(cx);                          <span class="hljs-comment">//T和param的类型都是int</span><br>f(rx);                          <span class="hljs-comment">//T和param的类型都是int</span><br></code></pre></div></td></tr></table></figure>
<p>即使<code>cx</code>和<code>rx</code>表示<code>const</code>值，<code>param</code>也不是<code>const</code>。这是有意义的。<code>param</code>是一个完全独立于<code>cx</code>和<code>rx</code>的对象——是<code>cx</code>或<code>rx</code>的一个拷贝。</p>
<p>认识到只有在传值给形参时才会忽略<code>const</code>（和<code>volatile</code>）这一点很重要。对于reference-to-<code>const</code>和pointer-to-<code>const</code>形参来说，<code>expr</code>的常量性<code>const</code>ness在推导时会被保留。</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T param)</span></span>;                <span class="hljs-comment">//仍然以传值的方式处理param</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* <span class="hljs-keyword">const</span> ptr =         <span class="hljs-comment">//ptr是一个常量指针，指向常量对象 </span><br>    <span class="hljs-string">"Fun with pointers"</span>;<br><br>f(ptr);                         <span class="hljs-comment">//传递const char * const类型的实参</span><br></code></pre></div></td></tr></table></figure>
<p>当<code>ptr</code>作为实参传给<code>f</code>，组成这个指针的每一比特都被拷贝进<code>param</code>。<code>ptr</code>自身的值会被传给形参。</p>
<p>在类型推导中，这个指针指向的数据的常量性<code>const</code>ness将会被保留，但是当拷贝<code>ptr</code>来创造一个新指针<code>param</code>时，<code>ptr</code>自身的常量性<code>const</code>ness将会被忽略。</p>
<h4><span id="数组实参">数组实参</span></h4>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> name[] = <span class="hljs-string">"J. P. Briggs"</span>;     <span class="hljs-comment">//name的类型是const char[13]</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * ptrToName = name;          <span class="hljs-comment">//数组退化为指针</span><br></code></pre></div></td></tr></table></figure>
<p>在这里<code>const char*</code>指针<code>ptrToName</code>会由<code>name</code>初始化，而<code>name</code>的类型为<code>const char[13]</code>，这两种类型（<code>const char*</code>和<code>const char[13]</code>）是不一样的，但是由于数组退化为指针的规则，编译器允许这样的代码。</p>
<p>但要是一个数组传值给一个模板会怎样？会发生什么？</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T param)</span></span>;                        <span class="hljs-comment">//传值形参的模板</span><br><br>f(name);                                <span class="hljs-comment">//T和param会推导成什么类型?</span><br></code></pre></div></td></tr></table></figure>
<p>数组与指针形参这样的等价是C语言的产物，C++又是建立在C语言的基础上，它让人产生了一种数组和指针是等价的的错觉。</p>
<p>因为数组形参会视作指针形参，所以传值给模板的一个数组类型会被推导为一个指针类型。这意味着在模板函数<code>f</code>的调用中，它的类型形参<code>T</code>会被推导为<code>const char*</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">f(name);                        <span class="hljs-comment">//name是一个数组，但是T被推导为const char*</span><br></code></pre></div></td></tr></table></figure>
<p>但是在C++中，虽然函数不能声明形参为真正的数组，但是<strong>可以</strong>接受指向数组的<strong>引用</strong>！所以我们修改<code>f</code>为传引用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T&amp; param)</span></span>;                       <span class="hljs-comment">//传引用形参的模板</span><br></code></pre></div></td></tr></table></figure>
<p>我们这样进行调用，</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">f(name);                                <span class="hljs-comment">//传数组给f</span><br></code></pre></div></td></tr></table></figure>
<p><code>T</code>被推导为了真正的数组！这个类型包括了数组的大小，在这个例子中<code>T</code>被推导为<code>const char[13]</code>，<code>f</code>的形参（对这个数组的引用）的类型则为<code>const char (&amp;)[13]</code>。</p>
<p>可声明指向数组的引用的能力，使得我们可以创建一个模板函数来推导出数组的大小：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//在编译期间返回一个数组大小的常量值，这里的数组形参没有名字</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> N&gt;                    <br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> <span class="hljs-title">arraySize</span><span class="hljs-params">(T (&amp;)[N])</span> <span class="hljs-keyword">noexcept</span> </span>&#123;                                                  <br>    <span class="hljs-keyword">return</span> N;                                     <br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>将一个函数声明为<code>constexpr</code>使得结果在编译期间可用。这使得我们可以用一个花括号声明一个数组，然后第二个数组可以使用第一个数组的大小作为它的大小，就像这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> keyVals[] = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">35</span> &#125;;             <span class="hljs-comment">//keyVals有七个元素</span><br><br><span class="hljs-keyword">int</span> mappedVals[arraySize(keyVals)];                     <span class="hljs-comment">//mappedVals也有七个</span><br></code></pre></div></td></tr></table></figure>
<p>当然作为一个现代C++程序员，你自然应该想到使用<code>std::array</code>而不是内置的数组：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">array</span>&lt;<span class="hljs-keyword">int</span>, arraySize(keyVals)&gt; mappedVals;         <span class="hljs-comment">//mappedVals的大小为7</span><br></code></pre></div></td></tr></table></figure>
<p>至于<code>arraySize</code>被声明为<code>noexcept</code>，会使得编译器生成更好的代码。</p>
<h4><span id="函数实参">函数实参</span></h4>
<p>在C++中不只是数组会退化为指针，函数类型也会退化为一个函数指针。对于数组类型推导的全部讨论都可以应用到函数类型推导和退化为函数指针上来。结果是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">someFunc</span><span class="hljs-params">(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span>)</span></span>;         <span class="hljs-comment">//someFunc是一个函数，</span><br>                                    <span class="hljs-comment">//类型是void(int, double)</span><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f1</span><span class="hljs-params">(T param)</span></span>;                   <span class="hljs-comment">//传值给f1</span><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f2</span><span class="hljs-params">(T &amp; param)</span></span>;                 <span class="hljs-comment">//传引用给f2</span><br><br>f1(someFunc);                       <span class="hljs-comment">//param被推导为指向函数的指针，</span><br>                                    <span class="hljs-comment">//类型是void(*)(int, double)</span><br>f2(someFunc);                       <span class="hljs-comment">//param被推导为指向函数的引用，</span><br>                                    <span class="hljs-comment">//类型是void(&amp;)(int, double)</span><br></code></pre></div></td></tr></table></figure>
<p>这个实际上没有什么不同，只是函数退化为指针。</p>
<h3><span id="结论">结论</span></h3>
<ul>
<li>在模板类型推导时，有引用的实参会被视为无引用，引用会被忽略</li>
<li>对于<strong>通用引用</strong>的推导，左值实参会被特殊对待</li>
<li>对于<strong>传值类型</strong>推导，<code>const</code>和/或<code>volatile</code>实参会被认为是non-<code>const</code>的和non-<code>volatile</code>的</li>
<li>在模板类型推导时，数组名或者函数名实参会退化为指针，除非它们被用于初始化引用模板参数类型。</li>
</ul>
<h2><span id="2-理解-auto-类型推导">2 理解 <code>auto</code> 类型推导</span></h2>
<p>模板类型推导使用下面这个函数模板</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(ParmaType param)</span></span>;<br><br>f(expr);                        <span class="hljs-comment">//使用一些表达式调用f</span><br></code></pre></div></td></tr></table></figure>
<p>在<code>f</code>的调用中，编译器使用<code>expr</code>推导<code>T</code>和<code>ParamType</code>的类型。</p>
<p>当一个变量使用<code>auto</code>进行声明时，<code>auto</code>扮演了模板中<code>T</code>的角色，变量的类型说明符扮演了<code>ParamType</code>的角色。</p>
<p>考虑这个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> x = <span class="hljs-number">27</span>;<br></code></pre></div></td></tr></table></figure>
<p>这里<code>x</code>的类型说明符是<code>auto</code>自己，另一方面，在这个声明中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> cx = x;<br></code></pre></div></td></tr></table></figure>
<p>类型说明符是<code>const auto</code>。另一个：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp; rx=cx;<br></code></pre></div></td></tr></table></figure>
<p>类型说明符是<code>const auto&amp;</code>。</p>
<p>在这里例子中要推导<code>x</code>，<code>rx</code>和<code>cx</code>的类型，编译器的行为看起来就像是认为这里每个声明都有一个模板，然后使用合适的初始化表达式进行调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;            <span class="hljs-comment">//概念化的模板用来推导x的类型</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func_for_x</span><span class="hljs-params">(T param)</span></span>;<br><br>func_for_x(<span class="hljs-number">27</span>);                 <span class="hljs-comment">//概念化调用：</span><br>                                <span class="hljs-comment">//param的推导类型是x的类型</span><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;            <span class="hljs-comment">//概念化的模板用来推导cx的类型</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func_for_cx</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T param)</span></span>;<br><br>func_for_cx(x);                 <span class="hljs-comment">//概念化调用：</span><br>                                <span class="hljs-comment">//param的推导类型是cx的类型</span><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;            <span class="hljs-comment">//概念化的模板用来推导rx的类型</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func_for_rx</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T &amp; param)</span></span>;<br><br>func_for_rx(x);                 <span class="hljs-comment">//概念化调用：</span><br>                                <span class="hljs-comment">//param的推导类型是rx的类型</span><br></code></pre></div></td></tr></table></figure>
<p>在使用<code>auto</code>作为类型说明符的变量声明中，类型说明符代替了<code>ParamType</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> x = <span class="hljs-number">27</span>;                    <span class="hljs-comment">//类型说明符既不是指针也不是引用</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> cx = x;              <span class="hljs-comment">//类型说明符既不是指针也不是引用</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp; rx=cx;             <span class="hljs-comment">//类型说明符是一个指针或引用但不是通用引用</span><br></code></pre></div></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span>&amp;&amp; uref1 = x;               <span class="hljs-comment">//x是int左值，</span><br>                                <span class="hljs-comment">//所以uref1类型为int&amp;</span><br><span class="hljs-keyword">auto</span>&amp;&amp; uref2 = cx;              <span class="hljs-comment">//cx是const int左值，</span><br>                                <span class="hljs-comment">//所以uref2类型为const int&amp;</span><br><span class="hljs-keyword">auto</span>&amp;&amp; uref3 = <span class="hljs-number">27</span>;              <span class="hljs-comment">//27是int右值，</span><br>                                <span class="hljs-comment">//所以uref3类型为int&amp;&amp;</span><br></code></pre></div></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> name[] =             <span class="hljs-comment">//name的类型是const char[13]</span><br> <span class="hljs-string">"R. N. Briggs"</span>;<br><br><span class="hljs-keyword">auto</span> arr1 = name;               <span class="hljs-comment">//arr1的类型是const char*</span><br><span class="hljs-keyword">auto</span>&amp; arr2 = name;              <span class="hljs-comment">//arr2的类型是const char (&amp;)[13]</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">someFunc</span><span class="hljs-params">(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span>)</span></span>;     <span class="hljs-comment">//someFunc是一个函数，</span><br>                                <span class="hljs-comment">//类型为void(int, double)</span><br><br><span class="hljs-keyword">auto</span> func1 = someFunc;          <span class="hljs-comment">//func1的类型是void (*)(int, double)</span><br><span class="hljs-keyword">auto</span>&amp; func2 = someFunc;         <span class="hljs-comment">//func2的类型是void (&amp;)(int, double)</span><br></code></pre></div></td></tr></table></figure>
<p><code>auto</code>类型推导和模板类型推导几乎一样的工作。</p>
<p>如果你想声明一个带有初始值27的<code>int</code>，C++98提供两种语法选择：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> x1 = <span class="hljs-number">27</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x2</span><span class="hljs-params">(<span class="hljs-number">27</span>)</span></span>;<br></code></pre></div></td></tr></table></figure>
<p>C++11由于也添加了用于支持统一初始化（<strong>uniform
initialization</strong>）的语法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> x3 = &#123; <span class="hljs-number">27</span> &#125;;<br><span class="hljs-keyword">int</span> x4&#123; <span class="hljs-number">27</span> &#125;;<br></code></pre></div></td></tr></table></figure>
<p>总之，这四种不同的语法只会产生一个相同的结果：变量类型为<code>int</code>值为27。</p>
<p>使用 <code>auto</code> 进行的类型推导，其结果却不一样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> x1 = <span class="hljs-number">27</span>;                   <span class="hljs-comment">//类型是int，值是27</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">x2</span><span class="hljs-params">(<span class="hljs-number">27</span>)</span></span>;                    <span class="hljs-comment">//同上</span><br><span class="hljs-keyword">auto</span> x3 = &#123; <span class="hljs-number">27</span> &#125;;               <span class="hljs-comment">//类型是std::initializer_list&lt;int&gt;，</span><br>                                <span class="hljs-comment">//值是&#123; 27 &#125;</span><br><span class="hljs-keyword">auto</span> x4&#123; <span class="hljs-number">27</span> &#125;;                  <span class="hljs-comment">//同上</span><br></code></pre></div></td></tr></table></figure>
<p>这就造成了<code>auto</code>类型推导不同于模板类型推导的特殊情况。当用<code>auto</code>声明的变量使用花括号进行初始化，<code>auto</code>类型推导推出的类型则为<code>std::initializer_list</code>。如果这样的一个类型不能被成功推导（比如花括号里面包含的是不同类型的变量），编译器会拒绝这样的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> x5 = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3.0</span> &#125;;        <span class="hljs-comment">//错误！无法推导std::initializer_list&lt;T&gt;中的T</span><br></code></pre></div></td></tr></table></figure>
<p>对于花括号的处理是<code>auto</code>类型推导和模板类型推导唯一不同的地方。</p>
<p>然而如果在模板中指定<code>T</code>是<code>std::initializer_list&lt;T&gt;</code>而留下未知<code>T</code>，模板类型推导就能正常工作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">initializer_list</span>&lt;T&gt; initList)</span></span>;<br><br>f(&#123; <span class="hljs-number">11</span>, <span class="hljs-number">23</span>, <span class="hljs-number">9</span> &#125;);               <span class="hljs-comment">//T被推导为int，initList的类型为</span><br>                                <span class="hljs-comment">//std::initializer_list&lt;int&gt;</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>在C++11编程中一个典型的错误就是偶然使用了<code>std::initializer_list&lt;T&gt;</code>类型的变量。</p>
</blockquote>
<p>但是对于C++14故事还在继续，C++14允许<code>auto</code>用于函数返回值并会被推导。</p>
<p>而且C++14的<em>lambda</em>函数也允许在形参声明中使用<code>auto</code>。但是在这些情况下<code>auto</code>实际上使用<strong>模板类型推导</strong>的那一套规则在工作，而不是<code>auto</code>类型推导，所以说下面这样的代码不会通过编译：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">createInitList</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;;         <span class="hljs-comment">//错误！不能推导&#123; 1, 2, 3 &#125;的类型</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>同样在C++14的 lambda 函数中这样使用auto也不能通过编译：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v;<br><br><span class="hljs-keyword">auto</span> resetV = <br>    [&amp;v](<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; newValue)&#123; v = newValue; &#125;;        <span class="hljs-comment">//C++14</span><br><br>resetV(&#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;);            <span class="hljs-comment">//错误！不能推导&#123; 1, 2, 3 &#125;的类型</span><br></code></pre></div></td></tr></table></figure>
<h3><span id="结论">结论</span></h3>
<ul>
<li><code>auto</code>类型推导通常和模板类型推导相同，但是<code>auto</code>类型推导假定花括号初始化代表<code>std::initializer_list</code>，而模板类型推导不这样做</li>
<li>在C++14中<code>auto</code>允许出现在函数返回值或者<em>lambda</em>函数形参中，但是它的工作机制是模板类型推导那一套方案，而不是<code>auto</code>类型推导</li>
</ul>
<h2><span id="3-decltype">3 decltype</span></h2>
<p><code>decltype</code>，给它一个名字或者表达式<code>decltype</code>就会告诉你这个名字或者表达式的类型。通常，它会精确的告诉你你想要的结果。</p>
<p><code>decltype</code>只是简单的返回名字或者表达式的类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;                <span class="hljs-comment">//decltype(i)是const int</span><br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Widget&amp; w)</span></span>;        <span class="hljs-comment">//decltype(w)是const Widget&amp;</span><br>                                <span class="hljs-comment">//decltype(f)是bool(const Widget&amp;)</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span>&#123;</span><br>    <span class="hljs-keyword">int</span> x,y;                    <span class="hljs-comment">//decltype(Point::x)是int</span><br>&#125;;                              <span class="hljs-comment">//decltype(Point::y)是int</span><br><br>Widget w;                       <span class="hljs-comment">//decltype(w)是Widget</span><br><br><span class="hljs-keyword">if</span> (f(w))…                      <span class="hljs-comment">//decltype(f(w))是bool</span><br></code></pre></div></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;            <span class="hljs-comment">//std::vector的简化版本</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">vector</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    …<br>    T&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> index);<br>    …<br>&#125;;<br><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v;                  <span class="hljs-comment">//decltype(v)是vector&lt;int&gt;</span><br>…<br><span class="hljs-keyword">if</span> (v[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>)…                 <span class="hljs-comment">//decltype(v[0])是int&amp;</span><br></code></pre></div></td></tr></table></figure>
<p>在C++11中，<code>decltype</code>最主要的用途就是用于声明函数模板，而这个函数返回类型依赖于形参类型。</p>
<p>对一个<code>T</code>类型的容器使用<code>operator[]</code>
通常会返回一个<code>T&amp;</code>对象，比如<code>std::deque</code>就是这样。</p>
<p>但是<code>std::vector</code>有一个例外，对于<code>std::vector&lt;bool&gt;</code>，<code>operator[]</code>不会返回<code>bool&amp;</code>，它会返回一个全新的对象（MSVC的STL实现中返回的是<code>std::_Vb_reference&lt;std::_Wrap_alloc&lt;std::allocator&lt;unsigned int&gt;&gt;&gt;</code>对象）。</p>
<h3><span id="decltype获取返回值类型的示例">decltype
获取返回值类型的示例</span></h3>
<p>使用<code>decltype</code>计算返回类型的一个例子是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Container, <span class="hljs-keyword">typename</span> Index&gt;    <span class="hljs-comment">//可以工作，</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">authAndAccess</span><span class="hljs-params">(Container&amp; c, Index i)</span>       <span class="hljs-comment">//但是需要改良</span></span><br>    -&gt;decltype(c[i])<br>&#123;<br>    authenticateUser();<br>    <span class="hljs-keyword">return</span> c[i];<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>函数名称前面的<code>auto</code>不会做任何的类型推导工作。相反的，他只是暗示使用了C++11的<strong>尾置返回类型</strong>语法，即在函数形参列表后面使用一个”<code>-&gt;</code>“符号指出函数的返回类型，尾置返回类型的好处是我们可以在函数返回类型中使用函数形参相关的信息。在<code>authAndAccess</code>函数中，我们使用<code>c</code>和<code>i</code>指定返回类型。</p>
<p>在C++14标准下我们可以忽略尾置返回类型，只留下一个<code>auto</code>。使用这种声明形式，auto标示这里会发生类型推导。更准确的说，编译器将会从函数实现中推导出函数的返回类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Container, <span class="hljs-keyword">typename</span> Index&gt;    <span class="hljs-comment">//C++14版本，</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">authAndAccess</span><span class="hljs-params">(Container&amp; c, Index i)</span>       <span class="hljs-comment">//不那么正确</span></span><br><span class="hljs-function"></span>&#123;<br>    authenticateUser();<br>    <span class="hljs-keyword">return</span> c[i];                                <span class="hljs-comment">//从c[i]中推导返回类型</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3><span id="从返回对象进行修改">从返回对象进行修改</span></h3>
<p>上述代码出现的一个问题是：</p>
<p><code>operator[]</code>对于大多数<code>T</code>类型的容器会返回一个<code>T&amp;</code>，但是
条款1
解释了在模板类型推导期间，表达式的引用性（reference-ness）会被忽略。基于这样的规则，考虑它会对下面用户的代码有哪些影响：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">deque</span>&lt;<span class="hljs-keyword">int</span>&gt; d;<br>…<br>authAndAccess(d, <span class="hljs-number">5</span>) = <span class="hljs-number">10</span>;               <span class="hljs-comment">//认证用户，返回d[5]，</span><br>                                        <span class="hljs-comment">//然后把10赋值给它</span><br>                                        <span class="hljs-comment">//无法通过编译器！</span><br></code></pre></div></td></tr></table></figure>
<p>在这里<code>d[5]</code>本该返回一个<code>int&amp;</code>，但是模板类型推导会剥去引用的部分，因此产生了<code>int</code>返回类型。函数返回的那个<code>int</code>是一个右值，上面的代码尝试把10赋值给右值<code>int</code>，C++11禁止这样做，所以代码无法编译。</p>
<p>要想让<code>authAndAccess</code>像我们期待的那样工作，我们需要使用<code>decltype</code>类型推导来推导它的返回值，即指定<code>authAndAccess</code>应该返回一个和<code>c[i]</code>表达式类型一样的类型。</p>
<p>因此我们可以这样写<code>authAndAccess</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Container, <span class="hljs-keyword">typename</span> Index&gt;    <span class="hljs-comment">//C++14版本，</span><br><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>)                                  <span class="hljs-comment">//可以工作，</span><br>authAndAccess(Container&amp; c, Index i)            <span class="hljs-comment">//但是还需要</span><br>&#123;                                               <span class="hljs-comment">//改良</span><br>    authenticateUser();<br>    <span class="hljs-keyword">return</span> c[i];<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>现在<code>authAndAccess</code>将会真正的返回<code>c[i]</code>的类型。现在事情解决了，一般情况下<code>c[i]</code>返回<code>T&amp;</code>，<code>authAndAccess</code>也会返回<code>T&amp;</code>，特殊情况下<code>c[i]</code>返回一个对象，<code>authAndAccess</code>也会返回一个对象。</p>
<blockquote>
<p><code>decltype(auto)</code>的使用不仅仅局限于函数返回类型，当你想对初始化表达式使用<code>decltype</code>推导的规则，你也可以使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">Widget w;<br><br><span class="hljs-keyword">const</span> Widget&amp; cw = w;<br><br><span class="hljs-keyword">auto</span> myWidget1 = cw;                    <span class="hljs-comment">//auto类型推导</span><br>                                     <span class="hljs-comment">//myWidget1的类型为Widget</span><br><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) myWidget2 = cw;          <span class="hljs-comment">//decltype类型推导</span><br>                                     <span class="hljs-comment">//myWidget2的类型是const Widget&amp;</span><br></code></pre></div></td></tr></table></figure>
</blockquote>
<h3><span id="形参传递问题">形参传递问题</span></h3>
<p><code>authAndAccess</code>声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Container, <span class="hljs-keyword">typename</span> Index&gt;<br><span class="hljs-function"><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">authAndAccess</span><span class="hljs-params">(Container&amp; c, Index i)</span></span>;<br></code></pre></div></td></tr></table></figure>
<p>容器通过传引用的方式传递非常量左值引用（lvalue-reference-to-non-const），因为返回一个引用允许用户可以修改容器。</p>
<p>但是这意味着在不能给这个函数传递右值容器，右值不能被绑定到左值引用上，除非这个左值引用是一个const（lvalue-references-to-const）。</p>
<p>一个右值容器，是一个临时对象，通常会在<code>authAndAccess</code>调用结束被销毁，这意味着<code>authAndAccess</code>返回的引用将会成为一个悬置的（dangle）引用。</p>
<p>为了使<code>authAndAccess</code>的引用可以绑定左值和右值，可以使用通用引用。所以我们这样声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Containter, <span class="hljs-keyword">typename</span> Index&gt;   <span class="hljs-comment">//现在c是通用引用</span><br><span class="hljs-function"><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">authAndAccess</span><span class="hljs-params">(Container&amp;&amp; c, Index i)</span></span>;<br></code></pre></div></td></tr></table></figure>
<p>这行代码中还有一个问题：</p>
<p>在这个模板中，我们不知道我们操纵的容器的类型是什么，也就是说不知道它使用的索引对象（index
objects）的类型。</p>
<p>对一个未知类型的对象使用传值通常会造成不必要的拷贝，对程序的性能有极大的影响，还会造成对象切片行为。</p>
<p>但是只针对 STL
容器（比如<code>std::string</code>，<code>std::vector</code>和<code>std::deque</code>的<code>operator[]</code>），这样处理是合理的。</p>
<p>为了保持参数本身的左右值属性，还需要进行
<code>std::forward</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Container, <span class="hljs-keyword">typename</span> Index&gt;    <span class="hljs-comment">//最终的C++14版本</span><br><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>)<br>authAndAccess(Container&amp;&amp; c, Index i)<br>&#123;<br>    authenticateUser();<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::forward&lt;Container&gt;(c)[i];<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>C++11版本：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Container, <span class="hljs-keyword">typename</span> Index&gt;    <span class="hljs-comment">//最终的C++11版本</span><br><span class="hljs-keyword">auto</span><br>authAndAccess(Container&amp;&amp; c, Index i)<br>-&gt;<span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">std</span>::forward&lt;Container&gt;(c)[i])<br>&#123;<br>    authenticateUser();<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::forward&lt;Container&gt;(c)[i];<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>将<code>decltype</code>应用于变量名会产生该变量名的声明类型。虽然变量名都是左值表达式，但这不会影响<code>decltype</code>的行为。但是对于一些表达式，其类型推导结果，可能出现&amp;引用类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">f1</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<br>    …<br>    <span class="hljs-keyword">return</span> x;                            <span class="hljs-comment">//decltype(x）是int，所以f1返回int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">f2</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> (x);                          <span class="hljs-comment">//decltype((x))是int&amp;，所以f2返回int&amp;</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>对于名字来说，<code>x</code>是一个左值，C++11定义了表达式<code>(x)</code>也是一个左值。<code>decltype((x))</code>是<code>int&amp;</code>。用小括号覆盖一个名字可以改变<code>decltype</code>对于名字产生的结果。</p>
<p>因此，当使用<code>decltype(auto)</code>的时候一定要加倍的小心，在表达式中看起来无足轻重的细节将会影响到<code>decltype(auto)</code>的推导结果。</p>
<h3><span id="结论">结论</span></h3>
<ul>
<li><code>decltype</code>产生变量或者表达式的类型</li>
<li>对于<code>T</code>类型的不是单纯的变量名的左值表达式，<code>decltype</code>总是产出<code>T</code>的引用即<code>T&amp;</code></li>
<li>C++14支持<code>decltype(auto)</code>，推导出类型，但是它使用<code>decltype</code>的规则进行推导，而不是
<code>auto</code></li>
</ul>
<h2><span id="4-查看类型推导结果">4 查看类型推导结果</span></h2>
<p>三种方案：</p>
<ul>
<li>IDE编辑器获得类型推导的结果</li>
<li>在编译期间获得结果</li>
<li>在运行时获得结果</li>
</ul>
<h3><span id="ide">IDE</span></h3>
<p>IDE之所以能提供这些信息是因为一个C++编译器（或者至少是前端中的一个部分）运行于IDE中。如果这个编译器对你的代码不能做出有意义的分析或者推导，它就不会显示推导的结果。</p>
<h3><span id="编译">编译</span></h3>
<p>可以首先声明一个类模板但<strong>不定义</strong>。就像这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;                <span class="hljs-comment">//只对TD进行声明</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TD</span>;</span>                           <span class="hljs-comment">//TD == "Type Displayer"</span><br></code></pre></div></td></tr></table></figure>
<p>尝试实例化这个类模板就会引出一个错误消息，因为这里没有用来实例化的类模板定义。为了查看<code>x</code>和<code>y</code>的类型，只需要使用它们的类型去实例化<code>TD</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">TD&lt;<span class="hljs-keyword">decltype</span>(x)&gt; xType;              <span class="hljs-comment">//引出包含x和y</span><br>TD&lt;<span class="hljs-keyword">decltype</span>(y)&gt; yType;              <span class="hljs-comment">//的类型的错误消息</span><br></code></pre></div></td></tr></table></figure>
<p>出现 undefined template TD&lt;xxx&gt;。</p>
<h3><span id="运行时">运行时</span></h3>
<p>使用<code>printf</code>的方法使类型信息只有在运行时才会显示出来（尽管不建议使用<code>printf</code>）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">typeid</span>(x).name() &lt;&lt; <span class="hljs-string">'\n'</span>;  <span class="hljs-comment">//显示x和y的类型</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">typeid</span>(y).name() &lt;&lt; <span class="hljs-string">'\n'</span>;<br></code></pre></div></td></tr></table></figure>
<p>这种方法对一个对象如<code>x</code>或<code>y</code>调用<code>typeid</code>产生一个<code>std::type_info</code>的对象，然后<code>std::type_info</code>里面的成员函数<code>name()</code>来产生一个C风格的字符串（即一个<code>const char*</code>）表示变量的名字。</p>
<p>调用<code>std::type_info::name</code>不保证返回任何有意义的东西，但是库的实现者尝试尽量使它们返回的结果有用。</p>
<p>举个例子，GNU和Clang环境下<code>x</code>的类型会显示为"<code>i</code>"，<code>y</code>会显示为"<code>PKi</code>"。"<code>i</code>"表示"<code>int</code>"，""<code>PK</code>"表示"pointer
to <del><code>konst</code></del>
<code>const</code>"（指向常量的指针）。</p>
<p>如果传递的是一个引用，那么引用部分（reference-ness）将被忽略，如果忽略后还具有<code>const</code>或者<code>volatile</code>，那么常量性<code>const</code>ness或者易变性<code>volatile</code>ness也会被忽略。</p>
<p><code>std::type_info::name</code>的结果并不总是可信的，因为<code>std::type_info::name</code>规范批准像传值形参一样来对待这些类型。Boost
TypeIndex库（<strong>Boost.TypeIndex</strong>）是更好的选择。</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;boost/type_index.hpp&gt;</span></span><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T&amp; param)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>;<br>    <span class="hljs-keyword">using</span> boost::typeindex::type_id_with_cvr;<br><br>    <span class="hljs-comment">//显示T</span><br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"T =     "</span><br>         &lt;&lt; type_id_with_cvr&lt;T&gt;().pretty_name()<br>         &lt;&lt; <span class="hljs-string">'\n'</span>;<br>    <br>    <span class="hljs-comment">//显示param类型</span><br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"param = "</span><br>         &lt;&lt; type_id_with_cvr&lt;<span class="hljs-keyword">decltype</span>(param)&gt;().pretty_name()<br>         &lt;&lt; <span class="hljs-string">'\n'</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><code>boost::typeindex::type_id_with_cvr</code>获取一个类型实参（我们想获得相应信息的那个类型），它不消除实参的<code>const</code>，<code>volatile</code>和引用修饰符（因此模板名中有“<code>with_cvr</code>”）。结果是一个<code>boost::typeindex::type_index</code>对象，它的<code>pretty_name</code>成员函数输出一个<code>std::string</code>，包含我们能看懂的类型表示。
基于这个<code>f</code>的实现版本，再次考虑那个使用<code>typeid</code>时获取<code>param</code>类型信息出错的调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">std</span>::vetor&lt;Widget&gt; <span class="hljs-title">createVec</span><span class="hljs-params">()</span></span>;         <span class="hljs-comment">//工厂函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> vw = createVec();            <span class="hljs-comment">//使用工厂函数返回值初始化vw</span><br><span class="hljs-keyword">if</span> (!vw.empty())&#123;<br>    f(&amp;vw[<span class="hljs-number">0</span>]);                          <span class="hljs-comment">//调用f</span><br>    …<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>在GNU和Clang的编译器环境下，使用Boost.TypeIndex版本的<code>f</code>最后会产生下面的（准确的）输出：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">T =     Widget <span class="hljs-keyword">const</span> *<br>param = Widget <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span>&amp;<br></code></pre></div></td></tr></table></figure>
<p>在Microsoft的编译器环境下，结果也是极其相似：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">T =     class Widget <span class="hljs-keyword">const</span> *<br>param = class Widget <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span> &amp;<br></code></pre></div></td></tr></table></figure>
<h3><span id="结论">结论</span></h3>
<ul>
<li>类型推断可以使用IDE，使用编译器报错，使用Boost.TypeIndex库</li>
<li>这些工具可能既不准确也无帮助，所以理解C++类型推导规则才是最重要的</li>
</ul>
<h2><span id="5优先考虑auto而非显式类型声明">5
优先考虑<code>auto</code>而非显式类型声明</span></h2>
<p>从程序员的角度来说，如果按照符合规定的流程走，那<code>auto</code>类型推导的一些结果是错误的。当这些情况发生时，引导<code>auto</code>产生正确的结果是很重要的。</p>
<p><code>auto</code>变量从初始化表达式中推导出类型，所以我们必须初始化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> x1;                         <span class="hljs-comment">//潜在的未初始化的变量</span><br>	<br><span class="hljs-keyword">auto</span> x2;                        <span class="hljs-comment">//错误！必须要初始化</span><br><br><span class="hljs-keyword">auto</span> x3 = <span class="hljs-number">0</span>;                    <span class="hljs-comment">//没问题，x已经定义了</span><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> It&gt;           <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dwim</span><span class="hljs-params">(It b,It e)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (b != e) &#123;<br>        <span class="hljs-keyword">auto</span> currValue = *b;<br>        …<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">auto</span> derefUPLess = <br>    [](<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;Widget&gt; &amp;p1,       <span class="hljs-comment">//用于std::unique_ptr</span><br>       <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;Widget&gt; &amp;p2)       <span class="hljs-comment">//指向的Widget类型的</span><br>    &#123; <span class="hljs-keyword">return</span> *p1 &lt; *p2; &#125;;                      <span class="hljs-comment">//比较函数</span><br></code></pre></div></td></tr></table></figure>
<p>如果使用C++14，将会变得更酷，因为<em>lambda</em>表达式中的形参也可以使用<code>auto</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> derefLess =                                <span class="hljs-comment">//C++14版本</span><br>    [](<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; p1,                          <span class="hljs-comment">//被任何像指针一样的东西</span><br>       <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; p2)                          <span class="hljs-comment">//指向的值的比较函数</span><br>    &#123; <span class="hljs-keyword">return</span> *p1 &lt; *p2; &#125;;<br><br><span class="hljs-comment">// 也即</span><br><span class="hljs-built_in">std</span>::function&lt;<span class="hljs-keyword">bool</span>(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;Widget&gt; &amp;,<br>                   <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;Widget&gt; &amp;)&gt;<br>derefUPLess = [](<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;Widget&gt; &amp;p1,<br>                 <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;Widget&gt; &amp;p2)<br>                &#123; <span class="hljs-keyword">return</span> *p1 &lt; *p2; &#125;;<br></code></pre></div></td></tr></table></figure>
<p>实例化<code>std::function</code>并声明一个对象这个对象将会有固定的大小。这个大小可能不足以存储一个闭包，这个时候<code>std::function</code>的构造函数将会在堆上面分配内存来存储，这就造成了使用<code>std::function</code>比<code>auto</code>声明变量会消耗更多的内存。</p>
<p>通过<code>std::function</code>调用一个闭包几乎无疑比<code>auto</code>声明的对象调用要慢。换句话说，<code>std::function</code>方法比<code>auto</code>方法要更耗空间且更慢，还可能有<em>out-of-memory</em>异常。并且正如上面的例子，比起写<code>std::function</code>实例化的类型来，使用<code>auto</code>要方便得多。</p>
<p>考虑以下问题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v;<br>…<br><span class="hljs-keyword">unsigned</span> sz = v.size();<br></code></pre></div></td></tr></table></figure>
<p><code>v.size()</code>的标准返回类型是<code>std::vector&lt;int&gt;::size_type</code>，但是只有少数开发者意识到这点。<code>std::vector&lt;int&gt;::size_type</code>实际上被指定为无符号整型。上述的代码，会造成一些有趣的结果。</p>
<p>举个例子，在Windows
32-bit上<code>std::vector&lt;int&gt;::size_type</code>和<code>unsigned</code>是一样的大小，但是在Windows
64-bit上<code>std::vector&lt;int&gt;::size_type</code>是64位，<code>unsigned</code>是32位。这意味着这段代码在Windows
32-bit上正常工作，但是当把应用程序移植到Windows
64-bit上时就可能会出现一些问题。</p>
<p>所以使用<code>auto</code>可以确保你不需要浪费时间：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> sz =v.size();                      <span class="hljs-comment">//sz的类型是std::vector&lt;int&gt;::size_type</span><br></code></pre></div></td></tr></table></figure>
<p>考虑下面的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt; m;<br>…<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::pair&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt;&amp; p : m)<br>&#123;<br>    …                                   <span class="hljs-comment">//用p做一些事</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>看起来好像很合情合理的表达，但是这里有一个问题：</p>
<p><code>std::unordered_map</code>的<em>key</em>是<code>const</code>的，所以<em>hash
table</em>中的<code>std::pair</code>的类型不是<code>std::pair&lt;std::string, int&gt;</code>，而是<code>std::pair&lt;const std::string, int&gt;</code>。</p>
<p>编译器会努力的找到一种方法把<code>std::pair&lt;const std::string, int&gt;</code>（即<em>hash
table</em>中的东西）转换为<code>std::pair&lt;std::string, int&gt;</code>（<code>p</code>的声明类型）。它会成功的，因为它会通过拷贝<code>m</code>中的对象创建一个临时对象，是<code>m</code>中元素的类型。然后把<code>p</code>的引用绑定到这个临时对象上。在每个循环迭代结束时，临时对象将会销毁。</p>
<p>所以不只是让<code>p</code>指向<code>m</code>中各个元素的引用而已。</p>
<p>使用<code>auto</code>可以避免这些很难被意识到的类型不匹配的错误：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; p : m) &#123;<br>    …                                   <span class="hljs-comment">//如之前一样</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>这样无疑更具效率，且更容易书写。而且，这个代码有一个非常吸引人的特性，如果你获取<code>p</code>的地址，你确实会得到一个指向<code>m</code>中元素的指针。在没有<code>auto</code>的版本中<code>p</code>会指向一个临时变量，这个临时变量在每次迭代完成时会被销毁。</p>
<p>讲究！</p>
<p>有时候，显式的指定类型可能会导致你不想看到的类型转换。如果你使用<code>auto</code>声明目标变量你就不必担心这个问题。</p>
<p>然而<code>auto</code>也不是完美的。每个<code>auto</code>变量都从初始化表达式中推导类型，有一些表达式的类型和我们期望的大相径庭，比如在
<code>理解auto类型推导</code> 小结的内容。</p>
<p>另外，一个适当的变量名称就能体现大量的抽象类型信息，所以不用考虑 auto
带来的信息不可见性。</p>
<h3><span id="结论">结论</span></h3>
<ul>
<li><code>auto</code>变量必须初始化，通常它可以避免一些移植性和效率性的问题，也使得重构更方便，还能让你少打几个字。</li>
<li>注意 <code>auto</code> 可能出现一些类型推导不一致的问题。</li>
</ul>
<h2><span id="6-auto遇上代理类型使用显式类型初始化">6 <code>auto</code>
遇上代理类型，使用显式类型初始化</span></h2>
<p>假如我有一个函数，参数为<code>Widget</code>，返回一个<code>std::vector&lt;bool&gt;</code>，这里的<code>bool</code>表示<code>Widget</code>是否提供一个独有的特性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">features</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Widget&amp; w)</span></span>;<br></code></pre></div></td></tr></table></figure>
<p>更进一步假设第5个<em>bit</em>表示<code>Widget</code>是否具有高优先级，我们可以写这样的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">Widget w;<br>…<br><span class="hljs-keyword">bool</span> highPriority = features(w)[<span class="hljs-number">5</span>];     <span class="hljs-comment">//w高优先级吗？</span><br>…<br>processWidget(w, highPriority);         <span class="hljs-comment">//根据它的优先级处理w</span><br></code></pre></div></td></tr></table></figure>
<p>这个代码没有任何问题。它会正常工作，但是如果我们使用<code>auto</code>代替<code>highPriority</code>的显式指定类型做一些看起来很无害的改变：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> highPriority = features(w)[<span class="hljs-number">5</span>];     <span class="hljs-comment">//w高优先级吗？</span><br></code></pre></div></td></tr></table></figure>
<p>情况变了。所有代码仍然可编译，但是行为不再可预测：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">processWidget(w,highPriority);          <span class="hljs-comment">//未定义行为！</span><br></code></pre></div></td></tr></table></figure>
<p>因为 features(w)[5] 调用
<code>operator[]</code>不会返回容器中元素的引用，取而代之它返回一个<code>std::vector&lt;bool&gt;::reference</code>的对象。</p>
<p>调用<code>features</code>将返回一个<code>std::vector&lt;bool&gt;</code>临时对象，这个对象没有名字，为了方便我们的讨论，我这里叫他<code>temp</code>。<code>operator[]</code>在<code>temp</code>上调用，它返回的<code>std::vector&lt;bool&gt;::reference</code>包含一个指向存着这些
<em>bits</em>
的指针（<code>temp</code>管理这些<em>bits</em>）。<code>highPriority</code>是这个<code>std::vector&lt;bool&gt;::reference</code>的拷贝，所以<code>highPriority</code>也包含一个指针，指向<code>temp</code>中的管理
bits
。在这个语句结束的时候<code>temp</code>将会被销毁，因为它是一个临时变量。因此<code>highPriority</code>包含一个悬挂（<em>dangling</em>）指针，如果用于<code>processWidget</code>调用中将会造成未定义行为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">processWidget(w, highPriority);         <span class="hljs-comment">//未定义行为！</span><br>                                        <span class="hljs-comment">//highPriority包含一个悬置指针！</span><br></code></pre></div></td></tr></table></figure>
<h3><span id="代理类问题">代理类问题</span></h3>
<p><code>std::vector&lt;bool&gt;::reference</code>是一个代理类（<em>proxy
class</em>）的例子：所谓代理类就是以模仿和增强一些类型的行为为目的而存在的类。</p>
<p>C++标准模板库中的智能指针也是用代理类实现了对原始指针的资源管理行为。</p>
<p>一些代理类被设计于用以对客户可见。比如<code>std::shared_ptr</code>和<code>std::unique_ptr</code>。其他的代理类则或多或少不可见，比如<code>std::vector&lt;bool&gt;::reference</code>就是不可见代理类的一个例子，还有<code>std::bitset::reference</code>
等。</p>
<p>一些C++库也是用了表达式模板（<em>expression
templates</em>）的黑科技。这些库通常被用于提高数值运算的效率。给出一个矩阵类<code>Matrix</code>和矩阵对象<code>m1</code>，<code>m2</code>，<code>m3</code>，<code>m4</code>，举个例子，这个表达式</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">Matrix sum = m1 + m2 + m3 + m4;<br></code></pre></div></td></tr></table></figure>
<p>可以使计算更加高效，只需要使让<code>operator+</code>返回一个代理类代理结果
<code>Sum&lt;Matrix, Matrix&gt;</code> 而不是返回结果本身。</p>
<p>作为一个通则，不可见的代理类通常不适用于<code>auto</code>。这样类型的对象的生命期通常不会活过一条语句，所以创建那样的对象是危险的。</p>
<h3><span id="显式类型初始化器theexplicitly-typed-initialized-idiom">显式类型初始化器（<em>the
explicitly typed initialized idiom</em>)</span></h3>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> highPriority = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">bool</span>&gt;(features(w)[<span class="hljs-number">5</span>]);<br></code></pre></div></td></tr></table></figure>
<p>这里，<code>features(w)[5]</code>还是返回一个<code>std::vector&lt;bool&gt;::reference</code>对象，但是这个转型使得表达式类型为<code>bool</code>，然后<code>auto</code>才被用于推导<code>highPriority</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> sum = <span class="hljs-keyword">static_cast</span>&lt;Matrix&gt;(m1 + m2 + m3 + m4);<br><span class="hljs-keyword">auto</span> ep = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">float</span>&gt;(calcEpsilon());  <span class="hljs-comment">// 转换精度</span><br></code></pre></div></td></tr></table></figure>
<h3><span id="结论">结论</span></h3>
<ul>
<li>不可见的代理类可能会使<code>auto</code>从表达式中推导出“错误的”类型</li>
<li>显式类型初始化器强制<code>auto</code>推导出你想要的结果</li>
</ul>
<h2><span id="7区分和创建对象">7
区分<code>()</code>和<code>{}</code>创建对象</span></h2>
<p>C++11使用统一初始化（<em>uniform initialization</em>）</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v&#123; <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span> &#125;;  <span class="hljs-comment">//v初始内容为1,3,5</span><br></code></pre></div></td></tr></table></figure>
<p>C++11允许"="初始化不加花括号也拥有这种能力，括号初始化也能被用于为非静态数据成员指定默认初始值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span>&#123;</span><br>    …<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> x&#123; <span class="hljs-number">0</span> &#125;;                 <span class="hljs-comment">//没问题，x初始值为0</span><br>    <span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span>;                  <span class="hljs-comment">//也可以</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">z</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;                   <span class="hljs-comment">//错误！</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>另一方面，不可拷贝的对象（例如<code>std::atomic</code>）可以使用花括号初始化或者圆括号初始化，但是不能使用"="初始化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-built_in">std</span>::atomic&lt;<span class="hljs-keyword">int</span>&gt; ai1&#123; <span class="hljs-number">0</span> &#125;;      <span class="hljs-comment">//没问题</span><br><span class="hljs-function"><span class="hljs-built_in">std</span>::atomic&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ai2</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;        <span class="hljs-comment">//没问题</span><br><span class="hljs-built_in">std</span>::atomic&lt;<span class="hljs-keyword">int</span>&gt; ai3 = <span class="hljs-number">0</span>;       <span class="hljs-comment">//错误！</span><br></code></pre></div></td></tr></table></figure>
<h3><span id="内置类型间的隐式变窄转换narrowing-conversion">内置类型间的隐式变窄转换
(narrowing conversion)</span></h3>
<p>括号表达式还有一个少见的特性，即它不允许内置类型间隐式的变窄转换（<em>narrowing
conversion</em>）。如果一个使用了括号初始化的表达式的值，不能保证由被初始化的对象的类型来表示，代码就不会通过编译：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">double</span> x, y, z;<br><br><span class="hljs-keyword">int</span> sum1&#123; x + y + z &#125;;          <span class="hljs-comment">//错误！double的和可能不能表示为int</span><br></code></pre></div></td></tr></table></figure>
<p>使用圆括号和"="的初始化不检查是否转换为变窄转换，因为由于历史遗留问题它们必须要兼容老旧代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum2</span><span class="hljs-params">(x + y +z)</span></span>;             <span class="hljs-comment">//可以（表达式的值被截为int）</span><br><br><span class="hljs-keyword">int</span> sum3 = x + y + z;           <span class="hljs-comment">//同上</span><br></code></pre></div></td></tr></table></figure>
<h3><span id="被误认为是声明">被误认为是声明</span></h3>
<p>C++规定任何<em>可以被解析</em>为一个声明的东西<em>必须被解析</em>为声明。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">Widget <span class="hljs-title">w1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;                  <span class="hljs-comment">//使用实参10调用Widget的一个构造函数</span><br></code></pre></div></td></tr></table></figure>
<p>但是如果你尝试使用相似的语法调用<code>Widget</code>无参构造函数，它就会变成函数声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">Widget <span class="hljs-title">w2</span><span class="hljs-params">()</span></span>;                    <span class="hljs-comment">//最令人头疼的解析！声明一个函数w2，返回Widget</span><br></code></pre></div></td></tr></table></figure>
<p>由于函数声明中形参列表不能带花括号，所以使用花括号初始化表明你想调用默认构造函数构造对象就没有问题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">Widget w3&#123;&#125;;                    <span class="hljs-comment">//调用没有参数的构造函数构造对象</span><br></code></pre></div></td></tr></table></figure>
<h3><span id="initializer_list关联问题">initializer_list关联问题</span></h3>
<p>在构造函数调用中，只要不包含<code>std::initializer_list</code>形参，那么花括号初始化和圆括号初始化都会产生一样的结果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> &#123;</span> <br><span class="hljs-keyword">public</span>:  <br>    Widget(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">bool</span> b);      <span class="hljs-comment">//构造函数未声明</span><br>    Widget(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">double</span> d);    <span class="hljs-comment">//std::initializer_list这个形参 </span><br>    …<br>&#125;;<br><span class="hljs-function">Widget <span class="hljs-title">w1</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-literal">true</span>)</span></span>;            <span class="hljs-comment">//调用第一个构造函数</span><br>Widget w2&#123;<span class="hljs-number">10</span>, <span class="hljs-literal">true</span>&#125;;            <span class="hljs-comment">//也调用第一个构造函数</span><br><span class="hljs-function">Widget <span class="hljs-title">w3</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">5.0</span>)</span></span>;             <span class="hljs-comment">//调用第二个构造函数</span><br>Widget w4&#123;<span class="hljs-number">10</span>, <span class="hljs-number">5.0</span>&#125;;             <span class="hljs-comment">//也调用第二个构造函数</span><br></code></pre></div></td></tr></table></figure>
<p>然而，如果有一个或者多个构造函数的声明包含一个<code>std::initializer_list</code>形参，那么使用括号初始化语法的调用更倾向于选择带<code>std::initializer_list</code>的那个构造函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> &#123;</span> <br><span class="hljs-keyword">public</span>:  <br>    Widget(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">bool</span> b);      <span class="hljs-comment">//同上</span><br>    Widget(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">double</span> d);    <span class="hljs-comment">//同上</span><br>    Widget(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">initializer_list</span>&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">double</span>&gt; il);      <span class="hljs-comment">//新添加的</span><br>    …<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p><code>w2</code>和<code>w4</code>将会使用新添加的构造函数，即使另一个非<code>std::initializer_list</code>构造函数和实参更匹配：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">Widget <span class="hljs-title">w1</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-literal">true</span>)</span></span>;    <span class="hljs-comment">//使用圆括号初始化，同之前一样</span><br>                        <span class="hljs-comment">//调用第一个构造函数</span><br><br>Widget w2&#123;<span class="hljs-number">10</span>, <span class="hljs-literal">true</span>&#125;;    <span class="hljs-comment">//使用花括号初始化，但是现在</span><br>                        <span class="hljs-comment">//调用带std::initializer_list的构造函数</span><br>                        <span class="hljs-comment">//(10 和 true 转化为long double)</span><br><br><span class="hljs-function">Widget <span class="hljs-title">w3</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">5.0</span>)</span></span>;     <span class="hljs-comment">//使用圆括号初始化，同之前一样</span><br>                        <span class="hljs-comment">//调用第二个构造函数 </span><br><br>Widget w4&#123;<span class="hljs-number">10</span>, <span class="hljs-number">5.0</span>&#125;;     <span class="hljs-comment">//使用花括号初始化，但是现在</span><br>                        <span class="hljs-comment">//调用带std::initializer_list的构造函数</span><br>                        <span class="hljs-comment">//(10 和 5.0 转化为long double)</span><br></code></pre></div></td></tr></table></figure>
<p>编译器一遇到括号初始化就选择带<code>std::initializer_list</code>的构造函数的决心是如此强烈，以至于就算带<code>std::initializer_list</code>的构造函数不能被调用，它也会硬选。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> &#123;</span> <br><span class="hljs-keyword">public</span>: <br>    Widget(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">bool</span> b);                      <span class="hljs-comment">//同之前一样</span><br>    Widget(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">double</span> d);                    <span class="hljs-comment">//同之前一样</span><br>    Widget(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">initializer_list</span>&lt;<span class="hljs-keyword">bool</span>&gt; il);     <span class="hljs-comment">//现在元素类型为bool</span><br>    …                                           <span class="hljs-comment">//没有隐式转换函数</span><br>&#125;;<br><br>Widget w&#123;<span class="hljs-number">10</span>, <span class="hljs-number">5.0</span>&#125;;              <span class="hljs-comment">//错误！要求变窄转换</span><br></code></pre></div></td></tr></table></figure>
<p>这里，编译器会直接忽略前面两个构造函数（其中第二个构造函数是所有实参类型的最佳匹配），然后尝试调用<code>std::initializer_list&lt;bool&gt;</code>构造函数。调用这个函数将会把<code>int(10)</code>和<code>double(5.0)</code>转换为<code>bool</code>，由于会产生变窄转换（<code>bool</code>不能准确表示其中任何一个值），括号初始化拒绝变窄转换，所以这个调用无效，代码无法通过编译。</p>
<p>只有当没办法把括号初始化中实参的类型转化为<code>std::initializer_list</code>时，编译器才会回到正常的函数决议流程中。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> &#123;</span> <br><span class="hljs-keyword">public</span>:  <br>    Widget(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">bool</span> b);                              <span class="hljs-comment">//同之前一样</span><br>    Widget(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">double</span> d);                            <span class="hljs-comment">//同之前一样</span><br>    <span class="hljs-comment">//现在std::initializer_list元素类型为std::string</span><br>    Widget(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">initializer_list</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; il);<br>    …                                                   <span class="hljs-comment">//没有隐式转换函数</span><br>&#125;;<br><br><span class="hljs-function">Widget <span class="hljs-title">w1</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-literal">true</span>)</span></span>;     <span class="hljs-comment">// 使用圆括号初始化，调用第一个构造函数</span><br>Widget w2&#123;<span class="hljs-number">10</span>, <span class="hljs-literal">true</span>&#125;;     <span class="hljs-comment">// 使用花括号初始化，现在调用第一个构造函数</span><br><span class="hljs-function">Widget <span class="hljs-title">w3</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">5.0</span>)</span></span>;      <span class="hljs-comment">// 使用圆括号初始化，调用第二个构造函数</span><br>Widget w4&#123;<span class="hljs-number">10</span>, <span class="hljs-number">5.0</span>&#125;;      <span class="hljs-comment">// 使用花括号初始化，现在调用第二个构造函数</span><br></code></pre></div></td></tr></table></figure>
<p>空的花括号意味着没有实参，不是一个空的<code>std::initializer_list</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> &#123;</span> <br><span class="hljs-keyword">public</span>:  <br>    Widget();                                   <span class="hljs-comment">//默认构造函数</span><br>    Widget(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">initializer_list</span>&lt;<span class="hljs-keyword">int</span>&gt; il);      <span class="hljs-comment">//std::initializer_list构造函数</span><br><br>    …                                           <span class="hljs-comment">//没有隐式转换函数</span><br>&#125;;<br><br>Widget w1;                      <span class="hljs-comment">//调用默认构造函数</span><br>Widget w2&#123;&#125;;                    <span class="hljs-comment">//也调用默认构造函数</span><br><span class="hljs-function">Widget <span class="hljs-title">w3</span><span class="hljs-params">()</span></span>;                    <span class="hljs-comment">//最令人头疼的解析！声明一个函数</span><br></code></pre></div></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">Widget <span class="hljs-title">w4</span><span class="hljs-params">(&#123;&#125;)</span></span>;                  <span class="hljs-comment">//使用空花括号列表调用std::initializer_list构造函数</span><br>Widget w5&#123;&#123;&#125;&#125;;                  <span class="hljs-comment">//同上</span><br></code></pre></div></td></tr></table></figure>
<p>作为一个类库使用者，你必须认真的在花括号和圆括号之间选择一个来创建对象。大多数开发者都使用其中一种作为默认情况，只有当他们不能使用这种的时候才会考虑另一种。</p>
<h3><span id="结论">结论</span></h3>
<ul>
<li>花括号初始化是最广泛使用的初始化语法，它防止变窄转换，并且对于C++最令人头疼的解析（括号解析为函数）有天生的免疫性</li>
<li>在构造函数重载决议中，编译器会尽最大努力将括号初始化与<code>std::initializer_list</code>参数匹配，即便其他构造函数看起来是更好的选择</li>
<li>对于数值类型的<code>std::vector</code>来说使用花括号初始化和圆括号初始化会造成巨大的不同</li>
<li>在模板类选择使用圆括号初始化或使用花括号初始化创建对象是需要仔细考虑</li>
</ul>
<h2><span id="8-优先-nullptr">8 优先 <code>nullptr</code></span></h2>
<p>在C++98中，对指针类型和整型进行重载意味着可能导致奇怪的事情。如果给下面的重载函数传递<code>0</code>或<code>NULL</code>，它们绝不会调用指针版本的重载函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>;        <span class="hljs-comment">//三个f的重载函数</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">bool</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">void</span>*)</span></span>;<br><br>f(<span class="hljs-number">0</span>);               <span class="hljs-comment">//调用f(int)而不是f(void*)</span><br><br>f(<span class="hljs-literal">NULL</span>);            <span class="hljs-comment">//可能不会被编译，一般来说调用f(int)，</span><br>                    <span class="hljs-comment">//绝对不会调用f(void*)</span><br></code></pre></div></td></tr></table></figure>
<p>而<code>f(NULL)</code>的不确定行为是由<code>NULL</code>的实现不同造成的。如果<code>NULL</code>被定义为<code>0L</code>（指的是<code>0</code>为<code>long</code>类型），这个调用就具有二义性，因为从<code>long</code>到<code>int</code>的转换或从<code>long</code>到<code>bool</code>的转换或<code>0L</code>到<code>void*</code>的转换都同样好。</p>
<p><code>nullptr</code>的优点是它不是整型。它也不是一个指针类型，但是你可以把它认为是<strong>所有</strong>类型的指针。<code>nullptr</code>的真正类型是<code>std::nullptr_t</code>，在一个完美的循环定义以后，<code>std::nullptr_t</code>又被定义为<code>nullptr</code>。<code>std::nullptr_t</code>可以隐式转换为指向任何内置类型的指针。</p>
<p>使用<code>nullptr</code>调用<code>f</code>将会调用<code>void*</code>版本的重载函数，因为<code>nullptr</code>不能被视作任何整型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">f(<span class="hljs-literal">nullptr</span>);         <span class="hljs-comment">//调用重载函数f的f(void*)版本</span><br></code></pre></div></td></tr></table></figure>
<p>看下面的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> result = findRecord( <span class="hljs-comment">/* arguments */</span> );<br><span class="hljs-keyword">if</span> (result == <span class="hljs-number">0</span>) &#123;<br>    …<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>如果你不知道<code>findRecord</code>返回了什么，那么你就不太清楚到底<code>result</code>是一个指针类型还是一个整型。但是换一种假设如果你看到这样的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> result = findRecord( <span class="hljs-comment">/* arguments */</span> );<br><br><span class="hljs-keyword">if</span> (result == <span class="hljs-literal">nullptr</span>) &#123;  <br>    …<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>这就没有任何歧义：<code>result</code>的结果一定是指针类型。</p>
<p>再考虑下面例子：</p>
<p>假如你有一些函数只能被合适的已锁互斥量调用。每个函数都有一个不同类型的指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span>    <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt; spw)</span></span>;     <span class="hljs-comment">//只能被合适的</span><br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">f2</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;Widget&gt; upw)</span></span>;     <span class="hljs-comment">//已锁互斥量</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span>   <span class="hljs-title">f3</span><span class="hljs-params">(Widget* pw)</span></span>;                      <span class="hljs-comment">//调用</span><br></code></pre></div></td></tr></table></figure>
<p>如果这样传递空指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-built_in">std</span>::mutex f1m, f2m, f3m;       <span class="hljs-comment">//用于f1，f2，f3函数的互斥量</span><br><br><span class="hljs-keyword">using</span> MuxGuard = <span class="hljs-built_in">std</span>::lock_guard&lt;<span class="hljs-built_in">std</span>::mutex&gt;;<br>…<br><br>&#123;  <br>    <span class="hljs-function">MuxGuard <span class="hljs-title">g</span><span class="hljs-params">(f1m)</span></span>;            <span class="hljs-comment">//为f1m上锁</span><br>    <span class="hljs-keyword">auto</span> result = f1(<span class="hljs-number">0</span>);        <span class="hljs-comment">//向f1传递0作为空指针</span><br>&#125;                               <span class="hljs-comment">//解锁 </span><br>…<br>&#123;  <br>    <span class="hljs-function">MuxGuard <span class="hljs-title">g</span><span class="hljs-params">(f2m)</span></span>;            <span class="hljs-comment">//为f2m上锁</span><br>    <span class="hljs-keyword">auto</span> result = f2(<span class="hljs-literal">NULL</span>);     <span class="hljs-comment">//向f2传递NULL作为空指针</span><br>&#125;                               <span class="hljs-comment">//解锁 </span><br>…<br>&#123;<br>    <span class="hljs-function">MuxGuard <span class="hljs-title">g</span><span class="hljs-params">(f3m)</span></span>;            <span class="hljs-comment">//为f3m上锁</span><br>    <span class="hljs-keyword">auto</span> result = f3(<span class="hljs-literal">nullptr</span>);  <span class="hljs-comment">//向f3传递nullptr作为空指针</span><br>&#125;                               <span class="hljs-comment">//解锁</span><br></code></pre></div></td></tr></table></figure>
<p>令人遗憾前两个调用没有使用<code>nullptr</code>，但是代码可以正常运行。</p>
<p>模板化这个调用流程：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> FuncType,<br>         <span class="hljs-keyword">typename</span> MuxType,<br>         <span class="hljs-keyword">typename</span> PtrType&gt;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">lockAndCall</span><span class="hljs-params">(FuncType func,                 </span></span><br><span class="hljs-function"><span class="hljs-params">                 MuxType&amp; mutex,                 </span></span><br>                 PtrType ptr) -&gt; decltype(func(ptr))<br>&#123;<br>    <span class="hljs-function">MuxGuard <span class="hljs-title">g</span><span class="hljs-params">(mutex)</span></span>;  <br>    <span class="hljs-keyword">return</span> func(ptr); <br>&#125;<br></code></pre></div></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> FuncType,<br>         <span class="hljs-keyword">typename</span> MuxType,<br>         <span class="hljs-keyword">typename</span> PtrType&gt;<br><span class="hljs-function"><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">lockAndCall</span><span class="hljs-params">(FuncType func,       <span class="hljs-comment">//C++14</span></span></span><br><span class="hljs-function"><span class="hljs-params">                           MuxType&amp; mutex,</span></span><br><span class="hljs-function"><span class="hljs-params">                           PtrType ptr)</span></span><br><span class="hljs-function"></span>&#123; <br>    <span class="hljs-function">MuxGuard <span class="hljs-title">g</span><span class="hljs-params">(mutex)</span></span>;  <br>    <span class="hljs-keyword">return</span> func(ptr); <br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>可以写这样的代码调用<code>lockAndCall</code>模板：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> result1 = lockAndCall(f1, f1m, <span class="hljs-number">0</span>);         <span class="hljs-comment">//错误！</span><br>...<br><span class="hljs-keyword">auto</span> result2 = lockAndCall(f2, f2m, <span class="hljs-literal">NULL</span>);      <span class="hljs-comment">//错误！</span><br>...<br><span class="hljs-keyword">auto</span> result3 = lockAndCall(f3, f3m, <span class="hljs-literal">nullptr</span>);   <span class="hljs-comment">//没问题</span><br></code></pre></div></td></tr></table></figure>
<p>代码虽然可以这样写，但是就像注释中说的，前两个情况不能通过编译。</p>
<p>当<code>0</code>被传递给<code>lockAndCall</code>模板，模板类型推导会尝试去推导实参类型，<code>0</code>的类型总是<code>int</code>。</p>
<p>这意味着<code>lockAndCall</code>中<code>func</code>会被<code>int</code>类型的实参调用，这与<code>f1</code>期待的<code>std::shared_ptr&lt;Widget&gt;</code>形参不符。把<code>int</code>类型看做<code>std::shared_ptr&lt;Widget&gt;</code>类型给<code>f1</code>自然是一个类型错误。在模板<code>lockAndCall</code>中使用<code>0</code>之所以失败是因为在模板中，传给的是<code>int</code>但实际上函数期待的是一个<code>std::shared_ptr&lt;Widget&gt;</code>。</p>
<p>当<code>nullptr</code>传给<code>lockAndCall</code>时，<code>ptr</code>被推导为<code>std::nullptr_t</code>。当<code>ptr</code>被传递给<code>f3</code>的时候，隐式转换使<code>std::nullptr_t</code>转换为<code>Widget*</code>，因为<code>std::nullptr_t</code>可以隐式转换为任何指针类型。</p>
<h3><span id="结论">结论</span></h3>
<ul>
<li>优先考虑 <code>nullptr</code></li>
<li>避免重载指针和整型</li>
</ul>
<h2><span id="9-优先-alias-而不是typedef">9 优先 <code>alias</code> 而不是
<code>typedef</code></span></h2>
<p><code>typedef</code>即可：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt;&gt;<br>    UPtrMapSS;<br></code></pre></div></td></tr></table></figure>
<p>但<code>typedef</code>是C++98的东西。</p>
<p>C++11也提供了一个别名声明（<em>alias declaration</em>）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> UPtrMapSS =<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt;&gt;;<br></code></pre></div></td></tr></table></figure>
<p>由于这里给出的<code>typedef</code>和别名声明做的都是完全一样的事情。</p>
<p>使用别名模板，会容易很多：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;                            <span class="hljs-comment">//MyAllocList&lt;T&gt;是</span><br><span class="hljs-keyword">using</span> MyAllocList = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">list</span>&lt;T, MyAlloc&lt;T&gt;&gt;;   <span class="hljs-comment">//std::list&lt;T, MyAlloc&lt;T&gt;&gt;</span><br>                                                <span class="hljs-comment">//的同义词</span><br><br>MyAllocList&lt;Widget&gt; lw;                         <span class="hljs-comment">//用户代码</span><br></code></pre></div></td></tr></table></figure>
<p>使用<code>typedef</code>，你就只能从头开始：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;                            <span class="hljs-comment">//MyAllocList&lt;T&gt;是</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MyAllocList</span> &#123;</span>                            <span class="hljs-comment">//std::list&lt;T, MyAlloc&lt;T&gt;&gt;</span><br>    <span class="hljs-keyword">typedef</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">list</span>&lt;T, MyAlloc&lt;T&gt;&gt; type;      <span class="hljs-comment">//的同义词  </span><br>&#125;;<br><br>MyAllocList&lt;Widget&gt;::type lw;                   <span class="hljs-comment">//用户代码</span><br></code></pre></div></td></tr></table></figure>
<p>如果你想使用在一个模板内使用<code>typedef</code>声明一个链表对象，而这个对象又使用了模板形参，你就不得不在<code>typedef</code>前面加上<code>typename</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> &#123;</span>                              <span class="hljs-comment">//Widget&lt;T&gt;含有一个</span><br><span class="hljs-keyword">private</span>:                                    <span class="hljs-comment">//MyAllocLIst&lt;T&gt;对象</span><br>    <span class="hljs-keyword">typename</span> MyAllocList&lt;T&gt;::type <span class="hljs-built_in">list</span>;     <span class="hljs-comment">//作为数据成员</span><br>    …<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>这里<code>MyAllocList&lt;T&gt;::type</code>使用了一个类型，这个类型依赖于模板参数<code>T</code>。</p>
<p>如果使用别名声明定义一个<code>MyAllocList</code>，就不需要使用<code>typename</code>（同时省略麻烦的“<code>::type</code>”后缀）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <br><span class="hljs-keyword">using</span> MyAllocList = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">list</span>&lt;T, MyAlloc&lt;T&gt;&gt;;   <span class="hljs-comment">//同之前一样</span><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    MyAllocList&lt;T&gt; <span class="hljs-built_in">list</span>;                        <span class="hljs-comment">//没有“typename”</span><br>    …                                           <span class="hljs-comment">//没有“::type”</span><br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>C++11在<em>type
traits</em>（类型特性）中给了你一系列工具去实现类型转换，如果要使用这些模板请包含头文件<code>&lt;type_traits&gt;</code>。里面有许许多多<em>type
traits</em>，也不全是类型转换的工具，也包含一些可预测接口的工具。给一个你想施加转换的类型<code>T</code>，结果类型就是<code>std::</code>transformation<code>&lt;T&gt;::type</code>，比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-built_in">std</span>::remove_const&lt;T&gt;::type          <span class="hljs-comment">//从const T中产出T</span><br><span class="hljs-built_in">std</span>::remove_reference&lt;T&gt;::type      <span class="hljs-comment">//从T&amp;和T&amp;&amp;中产出T</span><br><span class="hljs-built_in">std</span>::add_lvalue_reference&lt;T&gt;::type  <span class="hljs-comment">//从T中产出T&amp;</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>注释仅仅简单的总结了类型转换做了什么，所以不要太随便的使用。在你的项目使用它们之前，你最好看看它们的详细说明书。</p>
</blockquote>
<p>这些别名声明有一个通用形式：对于C++11的类型转换<code>std::</code>transformation<code>&lt;T&gt;::type</code>在C++14中变成了<code>std::</code>transformation<code>_t</code>。举个例子或许更容易理解：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-built_in">std</span>::remove_const&lt;T&gt;::type          <span class="hljs-comment">//C++11: const T → T </span><br><span class="hljs-built_in">std</span>::<span class="hljs-keyword">remove_const_t</span>&lt;T&gt;              <span class="hljs-comment">//C++14 等价形式</span><br><br><span class="hljs-built_in">std</span>::remove_reference&lt;T&gt;::type      <span class="hljs-comment">//C++11: T&amp;/T&amp;&amp; → T </span><br><span class="hljs-built_in">std</span>::<span class="hljs-keyword">remove_reference_t</span>&lt;T&gt;          <span class="hljs-comment">//C++14 等价形式</span><br><br><span class="hljs-built_in">std</span>::add_lvalue_reference&lt;T&gt;::type  <span class="hljs-comment">//C++11: T → T&amp; </span><br><span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_lvalue_reference_t</span>&lt;T&gt;      <span class="hljs-comment">//C++14 等价形式</span><br></code></pre></div></td></tr></table></figure>
<p>C++11的的形式在C++14中也有效。其简单实现形式是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt; </span><br><span class="hljs-class"><span class="hljs-title">using</span> <span class="hljs-title">remove_const_t</span> = <span class="hljs-title">typename</span> <span class="hljs-title">remove_const</span>&lt;T&gt;:</span>:type;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt; </span><br><span class="hljs-class"><span class="hljs-title">using</span> <span class="hljs-title">remove_reference_t</span> = <span class="hljs-title">typename</span> <span class="hljs-title">remove_reference</span>&lt;T&gt;:</span>:type;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt; </span><br><span class="hljs-class"><span class="hljs-title">using</span> <span class="hljs-title">add_lvalue_reference_t</span> =</span><br><span class="hljs-class">  <span class="hljs-title">typename</span> <span class="hljs-title">add_lvalue_reference</span>&lt;T&gt;:</span>:type;<br></code></pre></div></td></tr></table></figure>
<h3><span id="结论">结论</span></h3>
<ul>
<li><code>typedef</code>不支持模板化，但是别名声明支持。</li>
<li>别名模板避免了使用“<code>::type</code>”后缀，而且在模板中使用<code>typedef</code>还需要在前面加上<code>typename</code></li>
<li>C++14提供了C++11所有<em>type traits</em>转换的别名声明版本</li>
</ul>
<h2><span id="10-限域enum">10 限域`enum</span></h2>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">enum</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Color</span> &#123;</span> black, white, red &#125;; <span class="hljs-comment">//black, white, red</span><br>                                        <span class="hljs-comment">//限制在Color域内</span><br><span class="hljs-keyword">auto</span> white = <span class="hljs-literal">false</span>;                     <span class="hljs-comment">//没问题，域内没有其他“white”</span><br><br>Color c = white;                        <span class="hljs-comment">//错误，域中没有枚举名叫white</span><br><br>Color c = Color::white;                 <span class="hljs-comment">//没问题</span><br><span class="hljs-keyword">auto</span> c = Color::white;                  <span class="hljs-comment">//也没问题（也符合Item5的建议）</span><br></code></pre></div></td></tr></table></figure>
<p>因为限域<code>enum</code>是通过“<code>enum class</code>”声明，所以它们有时候也被称为枚举类(<em><code>enum</code>
classes</em>)。</p>
<p>使用限域<code>enum</code>来减少命名空间污染，这是一个足够合理使用它而不是它的同胞未限域<code>enum</code>的理由。</p>
<p>其实限域<code>enum</code>还有第二个吸引人的优点：在它的作用域中，枚举名是强类型。未限域<code>enum</code>中的枚举名会隐式转换为整型（现在，也可以转换为浮点类型）。因此下面这种歪曲语义的做法也是完全有效的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">enum</span> Color &#123; black, white, red &#125;;       <span class="hljs-comment">//未限域enum</span><br><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span>&gt;                <span class="hljs-comment">//func返回x的质因子</span><br>  primeFactors(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> x);<br><br>Color c = red;<br>…<br><br><span class="hljs-keyword">if</span> (c &lt; <span class="hljs-number">14.5</span>) &#123;                         <span class="hljs-comment">// Color与double比较 (!)</span><br>    <span class="hljs-keyword">auto</span> factors =                      <span class="hljs-comment">// 计算一个Color的质因子(!)</span><br>      primeFactors(c);<br>    …<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>在<code>enum</code>后面写一个<code>class</code>就可以将非限域<code>enum</code>转换为限域<code>enum</code>，接下来就是完全不同的故事展开了。现在不存在任何隐式转换可以将限域<code>enum</code>中的枚举名转化为任何其他类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">enum</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Color</span> &#123;</span> black, white, red &#125;; <span class="hljs-comment">//Color现在是限域enum</span><br><br>Color c = Color::red;                   <span class="hljs-comment">//和之前一样，只是</span><br>...                                     <span class="hljs-comment">//多了一个域修饰符</span><br><br><span class="hljs-keyword">if</span> (c &lt; <span class="hljs-number">14.5</span>) &#123;                         <span class="hljs-comment">//错误！不能比较</span><br>                                        <span class="hljs-comment">//Color和double</span><br>    <span class="hljs-keyword">auto</span> factors =                      <span class="hljs-comment">//错误！不能向参数为std::size_t</span><br>      primeFactors(c);                  <span class="hljs-comment">//的函数传递Color参数</span><br>    …<br>&#125;<br><br><span class="hljs-comment">// 除非 static_cast&lt;double&gt;(c)</span><br></code></pre></div></td></tr></table></figure>
<p>在C++中所有的<code>enum</code>都有一个由编译器决定的整型的底层类型。对于非限域<code>enum</code>比如<code>Color</code>，</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">enum</span> Color &#123; black, white, red &#125;;<br></code></pre></div></td></tr></table></figure>
<p>编译器可能选择<code>char</code>作为底层类型，因为这里只需要表示三个值。然而，有些<code>enum</code>中的枚举值范围可能会大些，比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">enum</span> Status &#123; good = <span class="hljs-number">0</span>,<br>              failed = <span class="hljs-number">1</span>,<br>              incomplete = <span class="hljs-number">100</span>,<br>              corrupt = <span class="hljs-number">200</span>,<br>              indeterminate = <span class="hljs-number">0xFFFFFFFF</span><br>            &#125;;<br></code></pre></div></td></tr></table></figure>
<p>这里值的范围从<code>0</code>到<code>0xFFFFFFFF</code>。除了在不寻常的机器上（比如一个<code>char</code>至少有32bits的那种），编译器都会选择一个比<code>char</code>大的整型类型来表示<code>Status</code>。</p>
<p>为了高效使用内存，编译器通常在确保能包含所有枚举值的前提下为<code>enum</code>选择一个最小的底层类型。</p>
<p>为此，C++98只支持<code>enum</code>定义（所有枚举名全部列出来）；<code>enum</code>声明是不被允许的。编译器才能在使用之前为每一个<code>enum</code>选择一个底层类型。</p>
<p>不能前置声明<code>enum</code>也是有缺点的。最大的缺点莫过于它可能增加编译依赖。系统中某个枚举类型的头文件包含在多个文件中。如果引入一个新状态值，那么可能整个系统都得重新编译。</p>
<p>C++11中的前置声明<code>enum</code>s可以解决这个问题。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">enum</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Status</span>;</span>                  <span class="hljs-comment">//前置声明</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">continueProcessing</span><span class="hljs-params">(Status s)</span></span>;  <span class="hljs-comment">//使用前置声明enum</span><br></code></pre></div></td></tr></table></figure>
<p>即使<code>Status</code>的定义发生改变，包含这些声明的头文件也不需要重新编译。</p>
<p>默认情况下，限域枚举的底层类型是<code>int</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">enum</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Status</span>;</span>                  <span class="hljs-comment">//底层类型是int</span><br></code></pre></div></td></tr></table></figure>
<p>如果默认的<code>int</code>不适用，你可以重写它：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">enum</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Status</span>:</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>;   <span class="hljs-comment">//Status的底层类型</span><br>                                    <span class="hljs-comment">//是std::uint32_t</span><br>                                    <span class="hljs-comment">//（需要包含 &lt;cstdint&gt;）</span><br></code></pre></div></td></tr></table></figure>
<p>不管怎样，编译器都知道限域<code>enum</code>中的枚举名占用多少字节。</p>
<p>要为非限域<code>enum</code>指定底层类型，你可以同上，结果就可以前向声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">enum</span> Color: <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>;   <span class="hljs-comment">//非限域enum前向声明</span><br>                            <span class="hljs-comment">//底层类型为</span><br>                            <span class="hljs-comment">//std::uint8_t</span><br></code></pre></div></td></tr></table></figure>
<p>底层类型说明也可以放到<code>enum</code>定义处：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">enum</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Status</span>:</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span> &#123; good = <span class="hljs-number">0</span>,<br>                                   failed = <span class="hljs-number">1</span>,<br>                                   incomplete = <span class="hljs-number">100</span>,<br>                                   corrupt = <span class="hljs-number">200</span>,<br>                                   audited = <span class="hljs-number">500</span>,<br>                                   indeterminate = <span class="hljs-number">0xFFFFFFFF</span><br>                                 &#125;;<br></code></pre></div></td></tr></table></figure>
<p>假设我们有一个<em>tuple</em>保存了用户的名字，email地址，声望值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> UserInfo =                <span class="hljs-comment">//类型别名，参见Item9</span><br>    <span class="hljs-built_in">std</span>::tuple&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>,     <span class="hljs-comment">//名字</span><br>               <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>,     <span class="hljs-comment">//email地址</span><br>               <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span>&gt; ;   <span class="hljs-comment">//声望</span><br></code></pre></div></td></tr></table></figure>
<p>虽然注释说明了tuple各个字段对应的意思，但当你在另一文件遇到下面的代码那之前的注释就不是那么有用了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">UserInfo uInfo;                 <span class="hljs-comment">//tuple对象</span><br>…<br><span class="hljs-keyword">auto</span> val = <span class="hljs-built_in">std</span>::get&lt;<span class="hljs-number">1</span>&gt;(uInfo);	<span class="hljs-comment">//获取第一个字段</span><br></code></pre></div></td></tr></table></figure>
<p>在 get 时，显示写明1随代表的字段。</p>
<p>用非限域<code>enum</code>将名字和字段编号关联起来以避免上述需求：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">enum</span> UserInfoFields &#123; uiName, uiEmail, uiReputation &#125;;<br><br>UserInfo uInfo;                         <span class="hljs-comment">//同之前一样</span><br>…<br><span class="hljs-keyword">auto</span> val = <span class="hljs-built_in">std</span>::get&lt;uiEmail&gt;(uInfo);    <span class="hljs-comment">//啊，获取用户email字段的值</span><br></code></pre></div></td></tr></table></figure>
<p>之所以它能正常工作是因为<code>UserInfoFields</code>中的枚举名隐式转换成<code>std::size_t</code>。</p>
<p>对应的限域<code>enum</code>版本就很啰嗦了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">enum</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserInfoFields</span> &#123;</span> uiName, uiEmail, uiReputation &#125;;<br><br>UserInfo uInfo;                         <span class="hljs-comment">//同之前一样</span><br>…<br><span class="hljs-keyword">auto</span> val =<br>    <span class="hljs-built_in">std</span>::get&lt;<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span>&gt;(UserInfoFields::uiEmail)&gt;<br>        (uInfo);<br></code></pre></div></td></tr></table></figure>
<p>为避免这种冗长的表示，我们可以写一个函数传入枚举名并返回对应的<code>std::size_t</code>值，但这有一点技巧性。</p>
<p>将枚举名变换为<code>std::size_t</code>值的函数必须<strong>在编译期</strong>产生这个结果。</p>
<p>它该是一个<code>constexpr</code>函数模板，因为它应该能用于任何<code>enum</code>。</p>
<p>底层类型可以通过<code>std::underlying_type</code>这个<em>type
trait</em>获得。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> E&gt;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">typename</span> <span class="hljs-built_in">std</span>::underlying_type&lt;E&gt;::type<br>    toUType(E enumerator) <span class="hljs-keyword">noexcept</span><br>&#123;<br>    <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">typename</span><br>                    <span class="hljs-built_in">std</span>::underlying_type&lt;E&gt;::type&gt;(enumerator);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>在C++14中，<code>toUType</code>还可以进一步用<code>std::underlying_type_t</code>代替<code>typename std::underlying_type&lt;E&gt;::type</code>打磨：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> E&gt;                <span class="hljs-comment">//C++14</span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">underlying_type_t</span>&lt;E&gt;<br>    toUType(E enumerator) <span class="hljs-keyword">noexcept</span><br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">underlying_type_t</span>&lt;E&gt;&gt;(enumerator);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>还可以再用C++14 <code>auto</code>打磨一下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> E&gt;                <span class="hljs-comment">//C++14</span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span><br>    toUType(E enumerator) <span class="hljs-keyword">noexcept</span><br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">underlying_type_t</span>&lt;E&gt;&gt;(enumerator);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>不管它怎么写，<code>toUType</code>现在允许这样访问tuple的字段了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> val = <span class="hljs-built_in">std</span>::get&lt;toUType(UserInfoFields::uiEmail)&gt;(uInfo);<br></code></pre></div></td></tr></table></figure>
<h3><span id="结论">结论</span></h3>
<ul>
<li>限域<code>enum</code>的枚举名仅在<code>enum</code>内可见。要转换为其它类型只能使用<em>cast</em>。</li>
<li>非限域/限域<code>enum</code>都支持底层类型说明语法，限域<code>enum</code>底层类型默认是<code>int</code>。非限域<code>enum</code>没有默认底层类型。</li>
<li>限域<code>enum</code>总是可以前置声明。非限域<code>enum</code>仅当指定它们的底层类型时才能前置。</li>
</ul>
<h2><span id="11-使用-delete而不是私有化其声明">11 使用 delete
而不是私有化其声明</span></h2>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">charT</span>, <span class="hljs-title">class</span> <span class="hljs-title">traits</span> = <span class="hljs-title">char_traits</span>&lt;charT&gt; &gt;</span><br><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">basic_ios</span> :</span> <span class="hljs-keyword">public</span> ios_base &#123;<br><span class="hljs-keyword">public</span>:<br>    …<br><br>    basic_ios(<span class="hljs-keyword">const</span> basic_ios&amp; ) = <span class="hljs-keyword">delete</span>;<br>    basic_ios&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> basic_ios&amp;) = <span class="hljs-keyword">delete</span>;<br>    …<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p><em>deleted</em>函数不能以任何方式被调用，即使你在成员函数或者友元函数里面调用<em>deleted</em>函数也<strong>不能通过编译</strong>。这是较之C++98行为的一个改进，C++98中不正确的使用这些函数在链接时才被诊断出来。</p>
<p>通常，<em>deleted</em>函数被声明为<code>public</code>而不是<code>private</code>。这也是有原因的。当客户端代码试图调用成员函数，C++会在检查<em>deleted</em>状态前检查它的访问性。当客户端代码调用一个私有的<em>deleted</em>函数，一些编译器只会给出该函数是<code>private</code>的错误。</p>
<p><em>deleted</em>函数还有一个重要的优势是<strong>任何</strong>函数都可以标记为<em>deleted</em>，而只有成员函数可被标记为<code>private</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isLucky</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span></span>;       <span class="hljs-comment">//原始版本</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isLucky</span><span class="hljs-params">(<span class="hljs-keyword">char</span>)</span> </span>= <span class="hljs-keyword">delete</span>;    <span class="hljs-comment">//拒绝char</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isLucky</span><span class="hljs-params">(<span class="hljs-keyword">bool</span>)</span> </span>= <span class="hljs-keyword">delete</span>;    <span class="hljs-comment">//拒绝bool</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isLucky</span><span class="hljs-params">(<span class="hljs-keyword">double</span>)</span> </span>= <span class="hljs-keyword">delete</span>;  <span class="hljs-comment">//拒绝float和double</span><br></code></pre></div></td></tr></table></figure>
<p>另一个<em>deleted</em>函数用武之地（<code>private</code>成员函数做不到的地方）是禁止一些模板的实例化。假如你要求一个模板仅支持原生指针:</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">processPointer</span><span class="hljs-params">(T* ptr)</span></span>;<br><br><span class="hljs-keyword">template</span>&lt;&gt;<br><span class="hljs-keyword">void</span> processPointer&lt;<span class="hljs-keyword">void</span>&gt;(<span class="hljs-keyword">void</span>*) = <span class="hljs-keyword">delete</span>;<br><br><span class="hljs-keyword">template</span>&lt;&gt;<br><span class="hljs-keyword">void</span> processPointer&lt;<span class="hljs-keyword">char</span>&gt;(<span class="hljs-keyword">char</span>*) = <span class="hljs-keyword">delete</span>;<br><br><span class="hljs-keyword">template</span>&lt;&gt;<br><span class="hljs-keyword">void</span> processPointer&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>&gt;(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>*) = <span class="hljs-keyword">delete</span>;<br><br><span class="hljs-keyword">template</span>&lt;&gt;<br><span class="hljs-keyword">void</span> processPointer&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>&gt;(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*) = <span class="hljs-keyword">delete</span>;<br></code></pre></div></td></tr></table></figure>
<p>如果你想做得更彻底一些，你还要删除<code>const volatile void*</code>和<code>const volatile char*</code>重载版本，另外还需要一并删除其他标准字符类型的重载版本：<code>std::wchar_t</code>，<code>std::char16_t</code>和<code>std::char32_t</code>。</p>
<p>类模板在命名空间作用域中，删除特定实例化（private 是做不到的）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    …<br>    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">processPointer</span><span class="hljs-params">(T* ptr)</span></span><br><span class="hljs-function">    </span>&#123; … &#125;<br>    …<br><br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;&gt;                                          <span class="hljs-comment">//还是public，</span><br><span class="hljs-keyword">void</span> Widget::processPointer&lt;<span class="hljs-keyword">void</span>&gt;(<span class="hljs-keyword">void</span>*) = <span class="hljs-keyword">delete</span>;  <span class="hljs-comment">//但是已经被删除了</span><br></code></pre></div></td></tr></table></figure>
<h3><span id="结论">结论</span></h3>
<ul>
<li>使用<em>delete</em>函数更好</li>
<li>任何函数都能 delete，包括非成员函数和模板实例</li>
</ul>
<h2><span id="12使用override声明重写函数">12
使用<code>override</code>声明重写函数</span></h2>
<p>派生类的虚函数<strong>重写</strong>基类同名函数，很可能一不小心就错了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doWork</span><span class="hljs-params">()</span></span>;          <span class="hljs-comment">//基类虚函数</span><br>    …<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span>:</span> <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doWork</span><span class="hljs-params">()</span></span>;          <span class="hljs-comment">//重写Base::doWork</span><br>    …                               <span class="hljs-comment">//（这里“virtual”是可以省略的）</span><br>&#125;; <br><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;Base&gt; upb =         <span class="hljs-comment">//创建基类指针指向派生类对象</span><br>    <span class="hljs-built_in">std</span>::make_unique&lt;Derived&gt;();    <span class="hljs-comment">//关于std::make_unique</span><br>…                                   <span class="hljs-comment">//请参见Item21</span><br><br>    <br>upb-&gt;doWork();                      <span class="hljs-comment">//通过基类指针调用doWork，</span><br>                                    <span class="hljs-comment">//实际上是派生类的doWork</span><br>                                    <span class="hljs-comment">//函数被调用</span><br></code></pre></div></td></tr></table></figure>
<p>要想重写一个函数，必须满足下列要求：</p>
<ul>
<li>基类函数必须是<code>virtual</code></li>
<li>基类和派生类函数名必须完全一样（除非是析构函数)</li>
<li>基类和派生类函数形参类型必须完全一样</li>
<li>基类和派生类函数常量性<code>const</code>ness必须完全一样</li>
<li>基类和派生类函数的返回值和异常说明（<em>exception
specifications</em>）必须兼容</li>
</ul>
<p>除了这些C++98就存在的约束外，C++11又添加了一个：</p>
<ul>
<li>函数的引用限定符（<em>reference
qualifiers</em>）必须完全一样。它可以限定成员函数只能用于左值或者右值：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    …<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doWork</span><span class="hljs-params">()</span> &amp;</span>;    <span class="hljs-comment">//只有*this为左值的时候才能被调用</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doWork</span><span class="hljs-params">()</span> &amp;&amp;</span>;   <span class="hljs-comment">//只有*this为右值的时候才能被调用</span><br>&#125;; <br>…<br><span class="hljs-function">Widget <span class="hljs-title">makeWidget</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">//工厂函数（返回右值）</span><br>Widget w;               <span class="hljs-comment">//普通对象（左值）</span><br>…<br>w.doWork();             <span class="hljs-comment">//调用被左值引用限定修饰的Widget::doWork版本</span><br>                        <span class="hljs-comment">//（即Widget::doWork &amp;）</span><br>makeWidget().doWork();  <span class="hljs-comment">//调用被右值引用限定修饰的Widget::doWork版本</span><br>                        <span class="hljs-comment">//（即Widget::doWork &amp;&amp;）</span><br></code></pre></div></td></tr></table></figure>
<p>对于下面的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mf1</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mf2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mf3</span><span class="hljs-params">()</span> &amp;</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mf4</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>C++11提供一个方法让你可以显式地指定一个派生类函数是基类版本的重写：将它声明为<code>override</code>。还是上面那个例子，我们可以这样做：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span>:</span> <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mf1</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mf2</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> x)</span> <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mf3</span><span class="hljs-params">()</span> &amp;&amp; <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mf4</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">override</span></span>;<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>代码不能编译，当然了，因为这样写的时候，编译器会显示所有与重写有关的问题。这也是你想要的，以及为什么要在所有重写函数后面加上<code>override</code>。</p>
<p>没有<code>override</code>，你只能寄希望于完善的单元测试。</p>
<p>C++11引入了两个上下文关键字（<em>contextual
keywords</em>），<code>override</code>和<code>final</code>（向虚函数添加<code>final</code>可以防止派生类重写。<code>final</code>也能用于类，这时这个类不能用作基类）。</p>
<h3><span id="函数引用限定符">函数引用限定符</span></h3>
<p>reference
qualifiers。如果我们想写一个函数只接受左值实参，我们声明一个non-<code>const</code>左值引用形参：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">(Widget&amp; w)</span></span>;    <span class="hljs-comment">//只接受左值Widget对象</span><br></code></pre></div></td></tr></table></figure>
<p>如果我们想写一个函数只接受右值实参，我们声明一个右值引用形参：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">(Widget&amp;&amp; w)</span></span>;   <span class="hljs-comment">//只接受右值Widget对象</span><br></code></pre></div></td></tr></table></figure>
<p>成员函数的引用限定可以很容易的区分一个成员函数被哪个对象（即<code>*this</code>）调用。它和在成员函数声明尾部添加一个<code>const</code>很相似，暗示了调用这个成员函数的对象（即<code>*this</code>）是<code>const</code>的。</p>
<p>考虑下面一个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> DataType = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt;;  <br>    …<br>    <span class="hljs-function">DataType&amp; <span class="hljs-title">data</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> values; &#125;<br>    …<br><span class="hljs-keyword">private</span>:<br>    DataType values;<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>客户端代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">Widget w;<br>…<br><span class="hljs-keyword">auto</span> vals1 = w.data();  <span class="hljs-comment">//拷贝w.values到vals1</span><br></code></pre></div></td></tr></table></figure>
<p><code>Widget::data</code>函数的返回值是一个左值引用（准确的说是<code>std::vector&lt;double&gt;&amp;</code>）,
因为左值引用是左值，所以<code>vals1</code>是从左值初始化的。因此<code>vals1</code>由<code>w.values</code>拷贝构造而得。</p>
<p>现在假设我们有一个创建<code>Widget</code>s的工厂函数，</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">Widget <span class="hljs-title">makeWidget</span><span class="hljs-params">()</span></span>;<br></code></pre></div></td></tr></table></figure>
<p>我们想用<code>makeWidget</code>返回的<code>Widget</code>里的<code>std::vector</code>初始化一个变量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> vals2 = makeWidget().data();   <span class="hljs-comment">//拷贝Widget里面的值到vals2</span><br></code></pre></div></td></tr></table></figure>
<p><code>Widget</code>是<code>makeWidget</code>返回的临时对象（即右值），所以将其中的<code>std::vector</code>进行拷贝纯属浪费。最好是移动，但是因为<code>data</code>返回左值引用，C++的规则要求编译器不得不生成一个拷贝。</p>
<p>指明当<code>data</code>被右值<code>Widget</code>对象调用的时候结果也应该是一个右值。现在就可以使用<strong>引用限定</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> DataType = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt;;<br>    …<br>    <span class="hljs-function">DataType&amp; <span class="hljs-title">data</span><span class="hljs-params">()</span> &amp;              <span class="hljs-comment">//对于左值Widgets,</span></span><br><span class="hljs-function">    </span>&#123; <span class="hljs-keyword">return</span> values; &#125;              <span class="hljs-comment">//返回左值</span><br>    <br>    <span class="hljs-function">DataType <span class="hljs-title">data</span><span class="hljs-params">()</span> &amp;&amp;              <span class="hljs-comment">//对于右值Widgets,</span></span><br><span class="hljs-function">    </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(values); &#125;   <span class="hljs-comment">//返回右值</span><br>    …<br><br><span class="hljs-keyword">private</span>:<br>    DataType values;<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p><code>data</code>重载的返回类型是不同的，左值引用重载版本返回一个左值引用（即一个左值），右值引用重载返回一个临时对象（即一个右值）。这意味着现在客户端的行为和我们的期望相符了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> vals1 = w.data();              <span class="hljs-comment">//调用左值重载版本的Widget::data，</span><br>                                    <span class="hljs-comment">//拷贝构造vals1</span><br><span class="hljs-keyword">auto</span> vals2 = makeWidget().data();   <span class="hljs-comment">//调用右值重载版本的Widget::data, </span><br>                                    <span class="hljs-comment">//移动构造vals2</span><br></code></pre></div></td></tr></table></figure>
<h3><span id="结论">结论</span></h3>
<ul>
<li>为重写函数加上<code>override</code></li>
<li>成员函数引用限定，区别对待左值对象和右值对象（即<code>*this</code>)</li>
</ul>
<h2><span id="13-优先考虑const_iterator-而不是-iterator">13 优先考虑
<code>const_iterator</code> 而不是 <code>iterator</code></span></h2>
<p>STL
<code>const_iterator</code>等价于指向常量的指针（pointer-to-<code>const</code>）。它们都指向不能被修改的值。标准实践是能加上<code>const</code>就加上。</p>
<p>只是需要注意，C++11 和 C++98 对 <code>const_iterator</code>
的支持不一样。</p>
<p>没办法简简单单的从non-<code>const</code>容器中获取<code>const_iterator</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator IterT;               <span class="hljs-comment">//typedef</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;::const_iterator ConstIterT;<br><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; values;<br>…<br>ConstIterT ci =<br>    <span class="hljs-built_in">std</span>::find(<span class="hljs-keyword">static_cast</span>&lt;ConstIterT&gt;(values.begin()),  <span class="hljs-comment">//cast</span><br>              <span class="hljs-keyword">static_cast</span>&lt;ConstIterT&gt;(values.end()),    <span class="hljs-comment">//cast</span><br>              <span class="hljs-number">1983</span>);<br><br>values.insert(<span class="hljs-keyword">static_cast</span>&lt;IterT&gt;(ci), <span class="hljs-number">1998</span>);    <span class="hljs-comment">//可能无法通过编译，</span><br>                                                <span class="hljs-comment">//原因见下</span><br></code></pre></div></td></tr></table></figure>
<p>因为向 <code>insert</code>
传入<code>const_iterator</code>不能通过编译，所以我们将<code>const_iterator</code>
转换为<code>iterator</code>的。</p>
<p>上面的代码仍然可能无法编译，因为没有一个可移植的从<code>const_iterator</code>到<code>iterator</code>的方法，即使使用<code>static_cast</code>也不行。</p>
<p>所有的这些都在C++11中改变了，现在<code>const_iterator</code>既容易获取又容易使用。容器的成员函数<code>cbegin</code>和<code>cend</code>产出<code>const_iterator</code>，甚至对于non-<code>const</code>容器也可用，那些之前使用<em>iterator</em>指示位置（如<code>insert</code>和<code>erase</code>）的STL成员函数也可以使用<code>const_iterator</code>了。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; values;                                <span class="hljs-comment">//和之前一样</span><br>…<br><span class="hljs-keyword">auto</span> it =                                               <span class="hljs-comment">//使用cbegin</span><br>	<span class="hljs-built_in">std</span>::<span class="hljs-built_in">find</span>(values.cbegin(), values.cend(), <span class="hljs-number">1983</span>);    <span class="hljs-comment">//和cend</span><br>values.insert(it, <span class="hljs-number">1998</span>);<br></code></pre></div></td></tr></table></figure>
<p>C++11 的一个缺陷是，对于 非成员函数，没有类似的 cbegin，cend
函数支持。C++14补上了这一空白。</p>
<p>非成员函数也叫 自由函数<em>free
function</em>，即一个函数，只要不是成员函数就可被称作<em>free
function</em>。</p>
<p>举个例子，我们可以泛化下面的<code>findAndInsert</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> C, <span class="hljs-keyword">typename</span> V&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">findAndInsert</span><span class="hljs-params">(C&amp; container,            <span class="hljs-comment">//在容器中查找第一次</span></span></span><br><span class="hljs-function"><span class="hljs-params">                   <span class="hljs-keyword">const</span> V&amp; targetVal,      <span class="hljs-comment">//出现targetVal的位置，</span></span></span><br><span class="hljs-function"><span class="hljs-params">                   <span class="hljs-keyword">const</span> V&amp; insertVal)</span>      <span class="hljs-comment">//然后在那插入insertVal</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::cbegin;<br>    <span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::cend;<br><br>    <span class="hljs-keyword">auto</span> it = <span class="hljs-built_in">std</span>::find(cbegin(container),  <span class="hljs-comment">//非成员函数cbegin</span><br>                        cend(container),    <span class="hljs-comment">//非成员函数cend</span><br>                        targetVal);<br>    container.insert(it, insertVal);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>它可以在C++14工作良好，但是很遗憾，C++11不在良好之列。</p>
<p>如果你使用C++11，并且想写一个最大程度通用的代码，而你使用的STL没有提供缺失的非成员函数<code>cbegin</code>，你可以简单的写下你自己的实现。比如，下面就是非成员函数<code>cbegin</code>的实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span>&gt;</span><br><span class="hljs-class"><span class="hljs-title">auto</span> <span class="hljs-title">cbegin</span>(<span class="hljs-title">const</span> <span class="hljs-title">C</span>&amp; <span class="hljs-title">container</span>)-&gt;<span class="hljs-title">decltype</span>(<span class="hljs-title">std</span>:</span>:begin(container)) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::begin(container);   <span class="hljs-comment">//解释见下</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3><span id="结论">结论</span></h3>
<ul>
<li>优先考虑<code>const_iterator</code>而非<code>iterator</code></li>
<li>在最大程度通用的代码中，优先考虑非成员函数版本的<code>begin</code>，<code>end</code>，<code>rbegin</code>等，而非同名成员函数</li>
</ul>
<h2><span id="14如果函数不抛出异常请使用noexcept">14
如果函数不抛出异常请使用<code>noexcept</code></span></h2>
<p>调用者可以查看函数是否声明为<code>noexcept</code>，这个可以影响到调用代码的异常安全性（<em>exception
safety</em>）和效率。就其本身而言，函数是否为<code>noexcept</code>和成员函数是否<code>const</code>一样重要。当你知道这个函数不会抛异常而没加上<code>noexcept</code>，那这个接口说明就有点差劲了。</p>
<p><code>noexcept</code> 允许编译器生成更好的目标代码。</p>
<p>两种表达方式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span>;   <span class="hljs-comment">//C++98风格，没有来自f的异常</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> <span class="hljs-keyword">noexcept</span></span>;  <span class="hljs-comment">//C++11风格，没有来自f的异常</span><br></code></pre></div></td></tr></table></figure>
<p>如果在运行时，<code>f</code>出现一个异常，那么就和<code>f</code>的异常说明冲突了。在C++98的异常说明中，调用栈（the
<em>call
stack</em>）会展开至<code>f</code>的调用者，在一些与这地方不相关的动作后，程序被终止。C++11异常说明的运行时行为有些不同：调用栈只是<strong>可能</strong>在程序终止前展开。</p>
<p>展开调用栈和<strong>可能</strong>展开调用栈两者对于代码生成（code
generation）有非常大的影响。在一个<code>noexcept</code>函数中，当异常可能传播到函数外时，优化器不需要保证运行时栈（the
runtime
stack）处于可展开状态；也不需要保证当异常离开<code>noexcept</code>函数时，<code>noexcept</code>函数中的对象按照构造的反序析构。而标注
“<code>throw()</code>”
异常声明的函数缺少这样的优化灵活性，没加异常声明的函数也一样。可以总结一下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">RetType <span class="hljs-title">function</span><span class="hljs-params">(params)</span> <span class="hljs-keyword">noexcept</span></span>;  <span class="hljs-comment">//极尽所能优化</span><br><span class="hljs-function">RetType <span class="hljs-title">function</span><span class="hljs-params">(params)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span>;   <span class="hljs-comment">//较少优化</span><br><span class="hljs-function">RetType <span class="hljs-title">function</span><span class="hljs-params">(params)</span></span>;           <span class="hljs-comment">//较少优化</span><br></code></pre></div></td></tr></table></figure>
<p>这是一个充分的理由使得你当知道它不抛异常时加上<code>noexcept</code>。</p>
<p>另外对于一些容器数据结构的构造，如果可以就移动，如果必要则复制。对于这个函数只有在知晓移动不抛异常的情况下用C++11的移动操作替换C++98的复制操作才是安全的。</p>
<p>但是如何知道一个函数中的移动操作是否产生异常？答案很明显：它检查这个操作是否被声明为<code>noexcept</code>。</p>
<p>像是 <code>std::vector::push_back</code>
之类的函数调用<code>std::move_if_noexcept</code>，这是个<code>std::move</code>的变体，根据其中类型的移动构造函数是否为<code>noexcept</code>的.
<code>std::move_if_noexcept</code>查阅<code>std::is_nothrow_move_constructible</code>这个<em>type
trait</em>.</p>
<p><code>swap</code>函数是<code>noexcept</code>的另一个绝佳用地。<code>swap</code>是STL算法实现的一个关键组件，它也常用于拷贝运算符重载中。它的广泛使用意味着对其施加不抛异常的优化是非常有价值的。有趣的是，标准库的<code>swap</code>是否<code>noexcept</code>有时依赖于用户定义的<code>swap</code>是否<code>noexcept</code>。比如，数组和<code>std::pair</code>的<code>swap</code>声明如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>, <span class="hljs-title">size_t</span> <span class="hljs-title">N</span>&gt;</span><br><span class="hljs-class"><span class="hljs-title">void</span> <span class="hljs-title">swap</span>(<span class="hljs-title">T</span> (&amp;<span class="hljs-title">a</span>)[<span class="hljs-title">N</span>],</span><br><span class="hljs-class">          <span class="hljs-title">T</span> (&amp;<span class="hljs-title">b</span>)[<span class="hljs-title">N</span>]) <span class="hljs-title">noexcept</span>(<span class="hljs-title">noexcept</span>(<span class="hljs-title">swap</span>(*<span class="hljs-title">a</span>, *<span class="hljs-title">b</span>)));</span>  <span class="hljs-comment">//见下文</span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T1</span>, <span class="hljs-title">class</span> <span class="hljs-title">T2</span>&gt;</span><br><span class="hljs-class"><span class="hljs-title">struct</span> <span class="hljs-title">pair</span> &#123;</span><br>    …<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(pair&amp; p)</span> <span class="hljs-title">noexcept</span><span class="hljs-params">(<span class="hljs-keyword">noexcept</span>(swap(first, p.first)) &amp;&amp;</span></span><br><span class="hljs-function"><span class="hljs-params">                                <span class="hljs-keyword">noexcept</span>(swap(second, p.second)))</span></span>;<br>    …<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>这些函数视情况<code>noexcept</code>：它们是否<code>noexcept</code>依赖于<code>noexcept</code>声明中的表达式是否<code>noexcept</code>。</p>
<p>一些函数很自然的不应该抛异常，尤其是移动操作和<code>swap</code>。使其<code>noexcept</code>有重大意义，只要可能就应该将它们实现为<code>noexcept</code>。</p>
<p>对于一些函数，使其成为<code>noexcept</code>是很重要的，它们应当默认如是。在C++98，允许内存释放（memory
deallocation）函数（即<code>operator delete</code>和<code>operator delete[]</code>）和析构函数抛出异常是糟糕的代码设计，C++11将这种作风升级为语言规则。</p>
<p>默认情况下，内存释放函数和析构函数——不管是用户定义的还是编译器生成的——都是隐式<code>noexcept</code>。因此它们不需要声明<code>noexcept</code>。</p>
<p>析构函数非隐式<code>noexcept</code>的情况仅当类的数据成员（包括继承的成员还有继承成员内的数据成员）明确声明它的析构函数可能抛出异常（如声明“<code>noexcept(false)</code>”）。</p>
<p>如果一个对象的析构函数可能被标准库使用（比如在容器内或者被传给一个算法），析构函数又可能抛异常，那么程序的行为是未定义的。</p>
<p>有时候, 一些库函数, C++98的函数, 即使是决不抛出异常的, 也没有标识为
<code>noexcept</code>.
因为从C标准库移动到了<code>std</code>命名空间，也可能缺少异常规范，<code>std::strlen</code>就是一个例子，它没有声明<code>noexcept</code>.
另外C++98异常规范和C++11不同.</p>
<h3><span id="结论">结论</span></h3>
<ul>
<li><code>noexcept</code>是函数接口的一部分，这意味着调用者可能会依赖它</li>
<li><code>noexcept</code>函数较之于non-<code>noexcept</code>函数更容易优化</li>
<li><code>noexcept</code>对于移动语义，<code>swap</code>，内存释放函数和析构函数非常有用</li>
<li>大多数函数是异常中立的（可能抛也可能不抛异常）而不是<code>noexcept</code></li>
</ul>
<h2><span id="15-尽量使用-constexpr">15 尽量使用 <code>constexpr</code></span></h2>
<p>从概念上来说，<code>constexpr</code>表明一个值不仅仅是常量，还是编译期可知的。这个表述并不全面，因为当<code>constexpr</code>被用于函数的时候，事情就有一些细微差别了。</p>
<p>但是，并不能保证<code>constexpr</code>函数的结果是<code>const</code>，也不能保证它们的返回值是在编译期可知的。</p>
<p>和<code>const</code>一样，<code>constexpr</code>是编译期可知的。技术上来讲，它们的值在翻译期（translation）决议，所谓翻译（translation）不仅仅包含是编译（compilation）也包含链接（linking）。</p>
<p>编译期可知的值“享有特权”，它们可能被存放到只读存储空间中。对于那些嵌入式系统的开发者，这个特性是相当重要的。更广泛的应用是
“其值编译期可知” 的常量整数会出现在需要
“整型常量表达式（<strong>integral constant
expression</strong>）的上下文中：包括数组大小，整数模板参数（包括<code>std::array</code>对象的长度），枚举名的值，对齐修饰符（<a href="https://en.cppreference.com/w/cpp/language/alignas" target="_blank" rel="noopener"><code>alignas(val)</code></a>），等等。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> sz;                             <span class="hljs-comment">//non-constexpr变量</span><br>…<br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> arraySize1 = sz;     <span class="hljs-comment">//错误！sz的值在</span><br>                                    <span class="hljs-comment">//编译期不可知</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">array</span>&lt;<span class="hljs-keyword">int</span>, sz&gt; data1;          <span class="hljs-comment">//错误！一样的问题</span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> arraySize2 = <span class="hljs-number">10</span>;     <span class="hljs-comment">//没问题，10是</span><br>                                    <span class="hljs-comment">//编译期可知常量</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">array</span>&lt;<span class="hljs-keyword">int</span>, arraySize2&gt; data2;  <span class="hljs-comment">//没问题, arraySize2是constexpr</span><br></code></pre></div></td></tr></table></figure>
<p>注意<code>const</code>不提供<code>constexpr</code>所能保证之事，因为<code>const</code>对象不需要在编译期初始化它的值。</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> sz;                            <br>…<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> arraySize = sz;         <span class="hljs-comment">//没问题，arraySize是sz的const复制</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">array</span>&lt;<span class="hljs-keyword">int</span>, arraySize&gt; data;   <span class="hljs-comment">//错误，arraySize值在编译期不可知</span><br></code></pre></div></td></tr></table></figure></p>
<p>简而言之，所有<code>constexpr</code>对象都是<code>const</code>，但不是所有<code>const</code>对象都是<code>constexpr</code>。如果你想编译器保证一个变量有一个值，这个值可以放到那些需要编译期常量（compile-time
constants）的上下文的地方，你需要的工具是<code>constexpr</code>而不是<code>const</code>。</p>
<p>注意，I/O语句一般不被允许出现在<code>constexpr</code>函数里。</p>
<h3><span id="constexpr-限制">constexpr 限制</span></h3>
<p>因为<code>constexpr</code>函数必须能在编译期值调用的时候返回编译期结果，就必须对它的实现施加一些限制。这些限制在C++11和C++14标准间有所出入。</p>
<p>C++11中，<code>constexpr</code>函数的代码不超过一行语句：一个<code>return</code>。听起来很受限，但实际上有两个技巧可以扩展<code>constexpr</code>函数的表达能力。第一，使用三元运算符“<code>?:</code>”来代替<code>if</code>-<code>else</code>语句，第二，使用递归代替循环。因此<code>pow</code>可以像这样实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> base, <span class="hljs-keyword">int</span> <span class="hljs-built_in">exp</span>)</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">exp</span> == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : base * <span class="hljs-built_in">pow</span>(base, <span class="hljs-built_in">exp</span> - <span class="hljs-number">1</span>));<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>在C++11中，有两个限制使得<code>Point</code>的成员函数<code>setX</code>和<code>setY</code>不能声明为<code>constexpr</code>。第一，它们修改它们操作的对象的状态，
并且在C++11中，<code>constexpr</code>成员函数是隐式的<code>const</code>。第二，它们有<code>void</code>返回类型，<code>void</code>类型不是C++11中的字面值类型。这两个限制在C++14中放开了，所以C++14中<code>Point</code>的<em>setter</em>（赋值器）也能声明为<code>constexpr</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    …<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setX</span><span class="hljs-params">(<span class="hljs-keyword">double</span> newX)</span> <span class="hljs-keyword">noexcept</span> </span>&#123; x = newX; &#125; <span class="hljs-comment">//C++14</span><br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setY</span><span class="hljs-params">(<span class="hljs-keyword">double</span> newY)</span> <span class="hljs-keyword">noexcept</span> </span>&#123; y = newY; &#125; <span class="hljs-comment">//C++14</span><br>    …<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>现在也能写这样的函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//返回p相对于原点的镜像</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> Point <span class="hljs-title">reflection</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Point&amp; p)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123;<br>    Point result;                   <span class="hljs-comment">//创建non-const Point</span><br>    result.setX(-p.xValue());       <span class="hljs-comment">//设定它的x和y值</span><br>    result.setY(-p.yValue());<br>    <span class="hljs-keyword">return</span> result;                  <span class="hljs-comment">//返回它的副本</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3><span id="c14-constexpr">C++14 constexpr</span></h3>
<p>在C++14中，<code>constexpr</code>函数的限制变得非常宽松了，所以下面的函数实现成为了可能：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> base, <span class="hljs-keyword">int</span> <span class="hljs-built_in">exp</span>)</span> <span class="hljs-keyword">noexcept</span>   <span class="hljs-comment">//C++14</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> result = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">exp</span>; ++i) result *= base;<br>    <br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><code>constexpr</code>函数限制为只能获取和返回<strong>字面值类型</strong>，这基本上意味着那些有了值的类型能在编译期决定。在C++11中，除了<code>void</code>外的所有内置类型，以及一些用户定义类型都可以是字面值类型，因为构造函数和其他成员函数可能是<code>constexpr</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">Point</span><span class="hljs-params">(<span class="hljs-keyword">double</span> xVal = <span class="hljs-number">0</span>, <span class="hljs-keyword">double</span> yVal = <span class="hljs-number">0</span>)</span> <span class="hljs-keyword">noexcept</span></span><br>    : x(xVal), y(yVal)<br>    &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">double</span> <span class="hljs-title">xValue</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span> </span>&#123; <span class="hljs-keyword">return</span> x; &#125; <br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">double</span> <span class="hljs-title">yValue</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span> </span>&#123; <span class="hljs-keyword">return</span> y; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setX</span><span class="hljs-params">(<span class="hljs-keyword">double</span> newX)</span> <span class="hljs-keyword">noexcept</span> </span>&#123; x = newX; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setY</span><span class="hljs-params">(<span class="hljs-keyword">double</span> newY)</span> <span class="hljs-keyword">noexcept</span> </span>&#123; y = newY; &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">double</span> x, y;<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p><code>Point</code>的构造函数可被声明为<code>constexpr</code>，因为如果传入的参数在编译期可知，<code>Point</code>的数据成员也能在编译器可知。因此这样初始化的<code>Point</code>就能为<code>constexpr</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> Point <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">9.4</span>, <span class="hljs-number">27.7</span>)</span></span>;  <span class="hljs-comment">//没问题，constexpr构造函数</span><br>                                <span class="hljs-comment">//会在编译期“运行”</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> Point <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">28.8</span>, <span class="hljs-number">5.3</span>)</span></span>;  <span class="hljs-comment">//也没问题</span><br></code></pre></div></td></tr></table></figure>
<p>类似的，<code>xValue</code>和<code>yValue</code>的<em>getter</em>（取值器）函数也能是<code>constexpr</code>，因为如果对一个编译期已知的<code>Point</code>对象（如一个<code>constexpr</code>
<code>Point</code>对象）调用<em>getter</em>，数据成员<code>x</code>和<code>y</code>的值也能在编译期知道。这使得我们可以写一个<code>constexpr</code>函数，里面调用<code>Point</code>的<em>getter</em>并初始化<code>constexpr</code>的对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">constexpr</span><br><span class="hljs-function">Point <span class="hljs-title">midpoint</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Point&amp; p1, <span class="hljs-keyword">const</span> Point&amp; p2)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> &#123; (p1.xValue() + p2.xValue()) / <span class="hljs-number">2</span>,   <span class="hljs-comment">//调用constexpr</span><br>             (p1.yValue() + p2.yValue()) / <span class="hljs-number">2</span> &#125;; <span class="hljs-comment">//成员函数</span><br>&#125;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> mid = midpoint(p1, p2);      <span class="hljs-comment">//使用constexpr函数的结果</span><br>                                            <span class="hljs-comment">//初始化constexpr对象</span><br></code></pre></div></td></tr></table></figure>
<p><code>mid</code>对象通过调用构造函数，<em>getter</em>和非成员函数来进行初始化过程就能在只读内存中被创建出来。</p>
<p><code>constexpr</code>对象和<code>constexpr</code>函数可以使用的范围比non-<code>constexpr</code>对象和函数大得多。使用<code>constexpr</code>关键字可以最大化你的对象和函数可以使用的场景。</p>
<p>还有个重要的需要注意的是<code>constexpr</code>是对象和函数接口的一部分。加上<code>constexpr</code>相当于宣称“我能被用在C++要求常量表达式的地方”。</p>
<h3><span id="结论">结论</span></h3>
<ul>
<li><code>constexpr</code>对象是<code>const</code>，它被在编译期可知的值初始化</li>
<li>当传递编译期可知的值时，<code>constexpr</code>函数可以产出编译期可知的结果</li>
<li><code>constexpr</code>对象和函数可以使用的范围比non-<code>constexpr</code>对象和函数要大</li>
<li><code>constexpr</code>是对象和函数接口的一部分</li>
</ul>
<h2><span id="16-让-const成员函数线程安全">16 让 <code>const</code>
成员函数线程安全</span></h2>
<p>考虑下面的例子，计算多项式的根，多项式的根在多项式确定时，根一般是确定的，声明为
<code>const</code> 。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Polynomial</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> RootsType = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt;;<br>    <br>    <span class="hljs-function">RootsType <span class="hljs-title">roots</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!rootsAreValid) &#123;               <span class="hljs-comment">//如果缓存不可用</span><br>            …                               <span class="hljs-comment">//计算根</span><br>                                            <span class="hljs-comment">//用rootVals存储它们</span><br>            rootsAreValid = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> rootVals;<br>    &#125;<br>    <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">mutable</span> <span class="hljs-keyword">bool</span> rootsAreValid&#123; <span class="hljs-literal">false</span> &#125;;    <span class="hljs-comment">//初始化器（initializer）的</span><br>    <span class="hljs-keyword">mutable</span> RootsType rootVals&#123;&#125;;           <br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p><code>roots</code>是<code>const</code>成员函数，那就表示着它是一个读操作。在没有同步的情况下，让多个线程执行读操作是安全的。</p>
<p>但是，在<code>roots</code>中，这些线程中的一个或两个可能尝试修改成员变量<code>rootsAreValid</code>和<code>rootVals</code>。这就意味着在没有同步的情况下，这些代码会有不同的线程读写相同的内存，这就是数据竞争（<em>data
race</em>）的定义。这段代码的行为是未定义的。</p>
<p>问题就是<code>roots</code>被声明为<code>const</code>，但不是线程安全的。</p>
<p>解决这个问题最普遍简单的方法就是——使用<code>mutex</code>（互斥量）：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Polynomial</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> RootsType = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt;;<br>    <br>    <span class="hljs-function">RootsType <span class="hljs-title">roots</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-function"><span class="hljs-built_in">std</span>::lock_guard&lt;<span class="hljs-built_in">std</span>::mutex&gt; <span class="hljs-title">g</span><span class="hljs-params">(m)</span></span>;       <span class="hljs-comment">//锁定互斥量</span><br>        <br>        <span class="hljs-keyword">if</span> (!rootsAreValid) &#123;                   <span class="hljs-comment">//如果缓存无效</span><br>            …                                   <span class="hljs-comment">//计算/存储根值</span><br>            rootsAreValid = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> rootsVals;<br>    &#125;                                           <span class="hljs-comment">//解锁互斥量</span><br>    <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">mutable</span> <span class="hljs-built_in">std</span>::mutex m;<br>    <span class="hljs-keyword">mutable</span> <span class="hljs-keyword">bool</span> rootsAreValid &#123; <span class="hljs-literal">false</span> &#125;;<br>    <span class="hljs-keyword">mutable</span> RootsType rootsVals &#123;&#125;;<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p><code>std::mutex</code>
既不可移动，也不可复制。因而包含他们的类也同时是不可移动和不可复制的</p>
</blockquote>
<p>在某些情况下，互斥量的副作用显会得过大。例如，如果你所做的只是计算成员函数被调用了多少次，使用<code>std::atomic</code>
修饰的计数器通常会是一个开销更小的方法（当然是否更小，取决于你使用的硬件和标准库对互斥量的实现）。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> &#123;</span>                                   <span class="hljs-comment">//2D点</span><br><span class="hljs-keyword">public</span>:<br>    …<br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">distanceFromOrigin</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>  <span class="hljs-comment">//noexcept的使用</span></span><br><span class="hljs-function">    </span>&#123;                                           <br>        ++callCount;                            <span class="hljs-comment">//atomic的递增</span><br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">sqrt</span>((x * x) + (y * y));<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">mutable</span> <span class="hljs-built_in">std</span>::atomic&lt;<span class="hljs-keyword">unsigned</span>&gt; callCount&#123; <span class="hljs-number">0</span> &#125;;<br>    <span class="hljs-keyword">double</span> x, y;<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>与 <code>std::mutex</code> 类似的，实际上 <code>std::atomic</code>
既不可移动，也不可复制。因而包含他们的类也同时是不可移动和不可复制的</p>
</blockquote>
<p>但是只使用 <code>std::atomic</code> 存在以下问题：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    …<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">magicValue</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (cacheValid) <span class="hljs-keyword">return</span> cachedValue;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">auto</span> val1 = expensiveComputation1();<br>            <span class="hljs-keyword">auto</span> val2 = expensiveComputation2();<br>            cachedValue = val1 + val2;              <span class="hljs-comment">//第一步</span><br>            cacheValid = <span class="hljs-literal">true</span>;                      <span class="hljs-comment">//第二步</span><br>            <span class="hljs-keyword">return</span> cachedValid;<br>        &#125;<br>    &#125;<br>    <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">mutable</span> <span class="hljs-built_in">std</span>::atomic&lt;<span class="hljs-keyword">bool</span>&gt; cacheValid&#123; <span class="hljs-literal">false</span> &#125;;<br>    <span class="hljs-keyword">mutable</span> <span class="hljs-built_in">std</span>::atomic&lt;<span class="hljs-keyword">int</span>&gt; cachedValue;<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>仍然可能出现重复计算。考虑：</p>
<ul>
<li>一个线程调用<code>Widget::magicValue</code>，将<code>cacheValid</code>视为<code>false</code>，执行这两个昂贵的计算，并将它们的和分配给<code>cachedValue</code>。</li>
<li>此时，第二个线程调用<code>Widget::magicValue</code>，也将<code>cacheValid</code>视为<code>false</code>，因此执行刚才完成的第一个线程相同的计算。（这里的“第二个线程”实际上可能是其他<strong>几个</strong>线程。）</li>
</ul>
<p>这种行为与使用缓存的目的背道而驰。将<code>cachedValue</code>和<code>CacheValid</code>的赋值顺序交换可以解决这个问题，但结果会更糟。</p>
<p>假设<code>cacheValid</code>是false，那么：</p>
<ul>
<li>一个线程调用<code>Widget::magicValue</code>，刚执行完将<code>cacheValid</code>设置<code>true</code>的语句。</li>
<li>在这时，第二个线程调用<code>Widget::magicValue</code>，检查<code>cacheValid</code>。看到它是<code>true</code>，就返回<code>cacheValue</code>，即使第一个线程还没有给它赋值。因此返回的值是不正确的。</li>
</ul>
<p>对于需要同步的是单个的变量或者内存位置，使用<code>std::atomic</code>就足够了。不过，一旦你需要对两个以上的变量或内存位置作为一个单元来操作的话，就应该使用互斥量。</p>
<h3><span id="结论">结论</span></h3>
<ul>
<li>确保<code>const</code>成员函数线程安全（先得明白什么是线程不安全），除非你<strong>确定</strong>它们永远不会在并发上下文（<em>concurrent
context</em>）中使用。</li>
<li>使用<code>std::atomic</code>变量可能比互斥量提供更好的性能，但是它只适合操作单个变量或内存位置。</li>
</ul>
<h2><span id="17-理解特殊成员函数的生成">17 理解特殊成员函数的生成</span></h2>
<p>C++98有四个：默认构造函数，析构函数，拷贝构造函数，拷贝赋值运算符。默认构造函数仅在类完全没有构造函数的时候才生成。</p>
<p>C++11特殊成员函数俱乐部迎来了两位新会员：移动构造函数和移动赋值运算符。它们的签名是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    …<br>    Widget(Widget&amp;&amp; rhs);               <span class="hljs-comment">//移动构造函数</span><br>    Widget&amp; <span class="hljs-keyword">operator</span>=(Widget&amp;&amp; rhs);    <span class="hljs-comment">//移动赋值运算符</span><br>    …<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>移动操作仅在需要的时候生成，如果生成了，就会对类的non-static数据成员执行逐成员的移动。</p>
<p>逐成员移动的核心是对对象使用<code>std::move</code>，然后函数决议时会选择执行移动还是拷贝操作。记住如果支持移动就会逐成员移动类成员和基类成员，如果不支持移动就执行拷贝操作就好了。</p>
<h3><span id="拷贝构造与移动构造生成方式">拷贝构造与移动构造生成方式</span></h3>
<p>如果你声明一个拷贝构造函数，但是没有声明拷贝赋值运算符，如果写的代码用到了拷贝赋值，编译器会帮助你生成拷贝赋值运算符。同样的，如果你声明拷贝赋值运算符但是没有拷贝构造函数，代码用到拷贝构造函数时编译器就会生成它。</p>
<p>两个移动操作不是相互独立的。如果你声明了其中一个，编译器就不再生成另一个。如果你给类声明了，比如，一个移动构造函数，就表明对于移动操作应怎样实现，与编译器应生成的默认逐成员移动有些区别。如果逐成员移动构造有些问题，那么逐成员移动赋值同样也可能有问题。所以声明移动构造函数阻止移动赋值运算符的生成，声明移动赋值运算符同样阻止编译器生成移动构造函数。</p>
<p>如果一个类显式声明了拷贝操作，编译器就不会生成移动操作。这种限制的解释是如果声明拷贝操作（构造或者赋值）就暗示着平常拷贝对象的方法（逐成员拷贝）不适用于该类，编译器会明白如果逐成员拷贝对拷贝操作来说不合适，逐成员移动也可能对移动操作来说不合适。</p>
<h3><span id="rule-of-three">Rule of Three</span></h3>
<p>如果你声明了拷贝构造函数，拷贝赋值运算符，或者析构函数三者之一，你应该也声明其余两个。</p>
<p>如果一个类显式声明了拷贝操作，编译器就不会生成移动操作。所以，C++11不会为那些有用户定义的析构函数的类生成移动操作。</p>
<p>仅当下面条件成立时才会生成移动操作（当需要时）：</p>
<ul>
<li>类中没有拷贝操作</li>
<li>类中没有移动操作</li>
<li>类中没有用户定义的析构</li>
</ul>
<p>假设编译器生成的函数行为是正确的（即逐成员拷贝类non-static数据是你期望的行为），你的工作很简单，C++11的<code>= default</code>就可以表达你想做的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> &#123;</span><br>    <span class="hljs-keyword">public</span>:<br>    … <br>    ~Widget();                              <span class="hljs-comment">//用户声明的析构函数</span><br>    …                                       <span class="hljs-comment">//默认拷贝构造函数</span><br>    Widget(<span class="hljs-keyword">const</span> Widget&amp;) = <span class="hljs-keyword">default</span>;        <span class="hljs-comment">//的行为还可以</span><br><br>    Widget&amp;                                 <span class="hljs-comment">//默认拷贝赋值运算符</span><br>        <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Widget&amp;) = <span class="hljs-keyword">default</span>; <span class="hljs-comment">//的行为还可以</span><br>    … <br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>就算编译器乐于为你的类生成拷贝和移动操作，生成的函数也如你所愿，你也应该手动声明它们然后加上<code>= default</code>。这看起来比较多余，但是它让你的意图更明确，也能帮助你避免一些微妙的bug。</p>
<p>声明析构有潜在的副作用：它阻止了移动操作的生成。然而，拷贝操作的生成是不受影响的。所以手动声明为
<code>=default</code> 是有意义的。</p>
<h3><span id="c11-处理规则">C++11 处理规则</span></h3>
<ul>
<li><strong>默认构造函数</strong>：和C++98规则相同。仅当类不存在用户声明的构造函数时才自动生成。</li>
<li><strong>析构函数</strong>：基本上和C++98相同；稍微不同的是现在析构默认<code>noexcept</code>（参见<a href="../3.MovingToModernCpp/item14.md">Item14</a>）。和C++98一样，仅当基类析构为虚函数时该类析构才为虚函数。</li>
<li><strong>拷贝构造函数</strong>：和C++98运行时行为一样：逐成员拷贝non-static数据。仅当类没有用户定义的拷贝构造时才生成。如果类声明了移动操作它就是<em>delete</em>的。但是，当用户声明了拷贝赋值或者析构，该函数自动生成已被废弃。</li>
<li><strong>拷贝赋值运算符</strong>：和C++98运行时行为一样：逐成员拷贝赋值non-static数据。仅当类没有用户定义的拷贝赋值时才生成。如果类声明了移动操作它就是<em>delete</em>的。但是，当用户声明了拷贝构造或者析构，该函数自动生成已被废弃。</li>
<li><strong>移动构造函数</strong>和<strong>移动赋值运算符</strong>：都对非static数据执行逐成员移动。仅当类没有用户定义的拷贝操作，移动操作或析构时才自动生成。</li>
</ul>
<h3><span id="结论">结论</span></h3>
<ul>
<li>特殊成员函数是编译器可能自动生成的函数：默认构造函数，析构函数，拷贝操作，移动操作。</li>
<li>移动操作仅当类没有显式声明移动操作，拷贝操作，析构函数时才自动生成。</li>
<li>拷贝构造函数仅当类没有显式声明拷贝构造函数时才自动生成，并且如果用户声明了移动操作，拷贝构造就是<em>delete</em>。</li>
<li>拷贝赋值运算符仅当类没有显式声明拷贝赋值运算符时才自动生成，并且如果用户声明了移动操作，拷贝赋值运算符就是<em>delete</em>。当用户声明了析构函数，拷贝操作的自动生成已被废弃。</li>
<li>成员函数模板不抑制特殊成员函数的生成。</li>
</ul>
<h2><span id="18-对独占资源使用stdunique_ptr">18 对独占资源使用
<code>std::unique_ptr</code></span></h2>
<p>默认情况下，<code>std::unique_ptr</code>大小等同于原始指针，而且对于大多数操作（包括取消引用），他们执行的指令完全相同。这意味着你甚至可以在内存和时间都比较紧张的情况下使用它。如果原始指针够小够快，那么<code>std::unique_ptr</code>一样可以。</p>
<p><code>std::unique_ptr</code>体现了专有所有权（<em>exclusive
ownership</em>）语义。</p>
<p>一个non-null
<code>std::unique_ptr</code>始终拥有其指向的内容。移动一个<code>std::unique_ptr</code>将所有权从源指针转移到目的指针。（源指针被设为null）</p>
<p>拷贝一个<code>std::unique_ptr</code>是不允许的，因为如果你能拷贝一个<code>std::unique_ptr</code>，你会得到指向相同内容的两个<code>std::unique_ptr</code>，每个都认为自己拥有（并且应当最后销毁）资源，销毁时就会出现重复销毁。</p>
<p>因此，<code>std::unique_ptr</code>是一种只可移动类型（<em>move-only
type</em>）。当析构时，一个non-null
<code>std::unique_ptr</code>销毁它指向的资源。默认情况下，资源析构通过对<code>std::unique_ptr</code>里原始指针调用<code>delete</code>来实现。</p>
<p><code>Investment</code>继承关系的工厂函数可以这样声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Ts&gt;            <span class="hljs-comment">//返回指向对象的std::unique_ptr，</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;Investment&gt;         <span class="hljs-comment">//对象使用给定实参创建</span><br>makeInvestment(Ts&amp;&amp;... params);<br></code></pre></div></td></tr></table></figure>
<p>调用者应该在单独的作用域中使用返回的<code>std::unique_ptr</code>智能指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">&#123;<br>    …<br>    <span class="hljs-keyword">auto</span> pInvestment =                  <span class="hljs-comment">//pInvestment是</span><br>        makeInvestment( arguments );    <span class="hljs-comment">//std::unique_ptr&lt;Investment&gt;类型</span><br>    …<br>&#125;                                       <span class="hljs-comment">//销毁 *pInvestment</span><br></code></pre></div></td></tr></table></figure>
<p><code>std::unique_ptr</code>将保证指向内容的析构函数被调用，销毁对应资源。</p>
<p>这个规则也有些例外。大多数情况发生于不正常的程序终止。</p>
<p>如果一个异常传播到线程的基本函数，比如程序初始线程的<code>main</code>函数外，或者违反<code>noexcept</code>说明，局部变量可能不会被销毁；如果<code>std::abort</code>或者退出函数（如<code>std::_Exit</code>，<code>std::exit</code>，或<code>std::quick_exit</code>）被调用，局部变量一定没被销毁。</p>
<h3><span id="自定义删除器">自定义删除器</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> delInvmt = [](Investment* pInvestment)         <span class="hljs-comment">//自定义删除器</span><br>                &#123;                                   <span class="hljs-comment">//（lambda表达式）</span><br>                    makeLogEntry(pInvestment);<br>                    <span class="hljs-keyword">delete</span> pInvestment; <br>                &#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Ts&gt;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;Investment, <span class="hljs-keyword">decltype</span>(delInvmt)&gt;     <span class="hljs-comment">//更改后的返回类型</span><br>makeInvestment(Ts&amp;&amp;... params)<br>&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;Investment, <span class="hljs-keyword">decltype</span>(delInvmt)&gt; <span class="hljs-comment">//应返回的指针</span><br>        pInv(<span class="hljs-literal">nullptr</span>, delInvmt);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-comment">/*一个Stock对象应被创建*/</span>)<br>    &#123;<br>        pInv.reset(<span class="hljs-keyword">new</span> Stock(<span class="hljs-built_in">std</span>::forward&lt;Ts&gt;(params)...));<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( <span class="hljs-comment">/*一个Bond对象应被创建*/</span> )   <br>    &#123;     <br>        pInv.reset(<span class="hljs-keyword">new</span> Bond(<span class="hljs-built_in">std</span>::forward&lt;Ts&gt;(params)...));   <br>    &#125;   <br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( <span class="hljs-comment">/*一个RealEstate对象应被创建*/</span> )   <br>    &#123;     <br>        pInv.reset(<span class="hljs-keyword">new</span> RealEstate(<span class="hljs-built_in">std</span>::forward&lt;Ts&gt;(params)...));   <br>    &#125;   <br>    <span class="hljs-keyword">return</span> pInv;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>上述代码中：</p>
<ul>
<li><code>delInvmt</code>是从<code>makeInvestment</code>返回的对象的自定义的删除器。</li>
<li>删除器类型必须作为第二个类型实参传给<code>std::unique_ptr</code>。</li>
<li>尝试将原始指针（比如<code>new</code>创建）赋值给<code>std::unique_ptr</code>通不过编译，因为是一种从原始指针到智能指针的隐式转换。这种隐式转换会出问题，所以C++11的智能指针禁止这个行为。这就是通过<code>reset</code>来让<code>pInv</code>接管通过<code>new</code>创建的对象的所有权的原因。</li>
<li>使用<code>new</code>时，我们使用<code>std::forward</code>把传给<code>makeInvestment</code>的实参完美转发出去。</li>
<li>自定义删除器的一个形参，类型是<code>Investment*</code>，不管在<code>makeInvestment</code>内部创建的对象的真实类型（如<code>Stock</code>，<code>Bond</code>，或<code>RealEstate</code>）是什么，它最终在<em>lambda</em>表达式中，作为<code>Investment*</code>对象被删除。这意味着我们通过基类指针删除派生类实例，为此，基类<code>Investment</code>必须有虚析构函数。</li>
</ul>
<p>C++14中，存在返回类型推导，写法更为简单：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Ts&gt;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">makeInvestment</span><span class="hljs-params">(Ts&amp;&amp;... params)</span>                 <span class="hljs-comment">//C++14</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> delInvmt = [](Investment* pInvestment)     <span class="hljs-comment">//现在在</span><br>                    &#123;                               <span class="hljs-comment">//makeInvestment里</span><br>                        makeLogEntry(pInvestment);<br>                        <span class="hljs-keyword">delete</span> pInvestment; <br>                    &#125;;<br><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;Investment, <span class="hljs-keyword">decltype</span>(delInvmt)&gt; <span class="hljs-comment">//同之前一样</span><br>        pInv(<span class="hljs-literal">nullptr</span>, delInvmt);<br>    <span class="hljs-keyword">if</span> ( … )                                        <span class="hljs-comment">//同之前一样</span><br>    &#123;<br>        pInv.reset(<span class="hljs-keyword">new</span> Stock(<span class="hljs-built_in">std</span>::forward&lt;Ts&gt;(params)...));<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( … )                                   <span class="hljs-comment">//同之前一样</span><br>    &#123;     <br>        pInv.reset(<span class="hljs-keyword">new</span> Bond(<span class="hljs-built_in">std</span>::forward&lt;Ts&gt;(params)...));   <br>    &#125;   <br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( … )                                   <span class="hljs-comment">//同之前一样</span><br>    &#123;     <br>        pInv.reset(<span class="hljs-keyword">new</span> RealEstate(<span class="hljs-built_in">std</span>::forward&lt;Ts&gt;(params)...));   <br>    &#125;   <br>    <span class="hljs-keyword">return</span> pInv;                                    <span class="hljs-comment">//同之前一样</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>当使用默认删除器时（如<code>delete</code>），你可以合理假设<code>std::unique_ptr</code>对象和原始指针大小相同。</p>
<p>但是当自定义删除器时，情况可能不再如此。函数指针形式的删除器，通常会使<code>std::unique_ptr</code>的从一个字（<em>word</em>）大小增加到两个。这可能导致
<code>std::unique_ptr</code>对象变得过大。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">delInvmt2</span><span class="hljs-params">(Investment* pInvestment)</span>             <span class="hljs-comment">//函数形式的</span></span><br><span class="hljs-function"></span>&#123;                                                   <span class="hljs-comment">//自定义删除器</span><br>    makeLogEntry(pInvestment);<br>    <span class="hljs-keyword">delete</span> pInvestment;<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Ts&gt;                            <span class="hljs-comment">//返回类型大小是</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;Investment, <span class="hljs-keyword">void</span> (*)(Investment*)&gt;  <span class="hljs-comment">//Investment*的指针</span><br>makeInvestment(Ts&amp;&amp;... params);                     <span class="hljs-comment">//加至少一个函数指针的大小</span><br></code></pre></div></td></tr></table></figure>
<p>对于函数对象形式的删除器来说，变化的大小取决于函数对象中存储的状态多少，无状态函数（stateless
function）对象（比如不捕获变量的<em>lambda</em>表达式）对大小没有影响，这意味当自定义删除器可以实现为函数或者<em>lambda</em>时，尽量使用<em>lambda</em>。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> delInvmt1 = [](Investment* pInvestment)        <span class="hljs-comment">//无状态lambda的</span><br>                 &#123;                                  <span class="hljs-comment">//自定义删除器</span><br>                     makeLogEntry(pInvestment);<br>                     <span class="hljs-keyword">delete</span> pInvestment; <br>                 &#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Ts&gt;                            <span class="hljs-comment">//返回类型大小是</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;Investment, <span class="hljs-keyword">decltype</span>(delInvmt1)&gt;    <span class="hljs-comment">//Investment*的大小</span><br>makeInvestment(Ts&amp;&amp;... args);<br></code></pre></div></td></tr></table></figure>
<h3><span id="向-stdshared_ptr的自动转化">向 <code>std::shared_ptr</code>
的自动转化</span></h3>
<p><code>std::unique_ptr</code>是C++11中表示专有所有权的方法，但是其最吸引人的功能之一是它可以轻松高效的转换为<code>std::shared_ptr</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Investment&gt; sp =            <span class="hljs-comment">//将std::unique_ptr</span><br>    makeInvestment(arguments);              <span class="hljs-comment">//转为std::shared_ptr</span><br></code></pre></div></td></tr></table></figure>
<p>这就是<code>std::unique_ptr</code>非常适合用作工厂函数返回类型的原因的关键部分。
工厂函数无法知道调用者是否要对它们返回的对象使用专有所有权语义，或者共享所有权（即<code>std::shared_ptr</code>）是否更合适。</p>
<h3><span id="结论">结论</span></h3>
<ul>
<li><code>std::unique_ptr</code>是轻量级、快速的、只可移动（<em>move-only</em>）的管理专有所有权语义资源的智能指针</li>
<li>默认情况，资源销毁通过<code>delete</code>实现，但是支持自定义删除器。有状态的删除器（捕获变量的<em>lambda</em>表达式）和函数指针（带参数）会增加<code>std::unique_ptr</code>对象的大小。所以是一般使用无状态的
<code>lambda</code> 表达式</li>
<li>将<code>std::unique_ptr</code>转化为<code>std::shared_ptr</code>非常简单</li>
</ul>
<h2><span id="19对于共享资源使用stdshared_ptr">19
对于共享资源使用<code>std::shared_ptr</code></span></h2>
<p><code>std::shared_ptr</code>通过引用计数（<em>reference
count</em>）来确保它是否是最后一个指向某种资源的指针，引用计数关联资源并跟踪有多少<code>std::shared_ptr</code>指向该资源。如果<code>std::shared_ptr</code>在计数值递减后发现引用计数值为零，没有其他<code>std::shared_ptr</code>指向该资源，它就会销毁资源。</p>
<p>引用计数暗示着性能问题：</p>
<ul>
<li><strong><code>std::shared_ptr</code>大小是原始指针的两倍</strong>，因为它内部包含一个指向资源的原始指针，还包含一个指向资源的引用计数值的原始指针。</li>
<li><strong>引用计数的内存几乎使用动态分配</strong>。
<code>std::make_shared</code>创建<code>std::shared_ptr</code>可以避免引用计数的动态分配，但是还存在一些<code>std::make_shared</code>不能使用的场景，这时候引用计数就会动态分配。</li>
<li><strong>递增递减引用计数必须是原子性的</strong>，因为多个reader、writer可能在不同的线程。比如，指向某种资源的<code>std::shared_ptr</code>可能在一个线程执行析构（于是递减指向的对象的引用计数），在另一个不同的线程，<code>std::shared_ptr</code>指向相同的对象，但是执行的却是拷贝操作（因此递增了同一个引用计数）。原子操作通常比非原子操作要慢，所以即使引用计数通常只有一个<em>word</em>大小，你也应该假定读写它们是存在开销的。</li>
</ul>
<p>移动<code>std::shared_ptr</code>会比拷贝它要快：拷贝要求递增引用计数值，移动不需要。移动赋值运算符同理，所以移动构造比拷贝构造快，移动赋值运算符也比拷贝赋值运算符快。</p>
<h3><span id="与-stdunique_ptr的区别">与 <code>std::unique_ptr</code>
的区别</span></h3>
<p><code>std::shared_ptr</code>使用<code>delete</code>作为资源的默认销毁机制，但是它也支持自定义的删除器。这种支持有别于<code>std::unique_ptr</code>。对于<code>std::unique_ptr</code>来说，删除器类型是智能指针类型的一部分。对于<code>std::shared_ptr</code>则不是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs CPP"><span class="hljs-keyword">auto</span> loggingDel = [](Widget *pw)        <span class="hljs-comment">//自定义删除器</span><br>                  &#123;                    <br>                      makeLogEntry(pw);<br>                      <span class="hljs-keyword">delete</span> pw;<br>                  &#125;;<br><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;                        <span class="hljs-comment">//删除器类型是</span><br>    Widget, <span class="hljs-keyword">decltype</span>(loggingDel)        <span class="hljs-comment">//指针类型的一部分</span><br>    &gt; upw(<span class="hljs-keyword">new</span> Widget, loggingDel);<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt;                 <span class="hljs-comment">//删除器类型不是</span><br>    spw(<span class="hljs-keyword">new</span> Widget, loggingDel);        <span class="hljs-comment">//指针类型的一部分</span><br></code></pre></div></td></tr></table></figure>
<p><code>std::shared_ptr</code>的设计更为灵活。考虑有两个<code>std::shared_ptr&lt;Widget&gt;</code>，每个自带不同的删除器（比如通过<em>lambda</em>表达式自定义删除器）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs CPP"><span class="hljs-keyword">auto</span> customDeleter1 = [](Widget *pw) &#123; … &#125;;     <span class="hljs-comment">//自定义删除器，</span><br><span class="hljs-keyword">auto</span> customDeleter2 = [](Widget *pw) &#123; … &#125;;     <span class="hljs-comment">//每种类型不同</span><br><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt; <span class="hljs-title">pw1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Widget, customDeleter1)</span></span>;<br><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt; <span class="hljs-title">pw2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Widget, customDeleter2)</span></span>;<br></code></pre></div></td></tr></table></figure>
<p>因为 <code>pw1</code> 和 <code>pw2</code>
有相同的类型，所以它们都可以放到存放那个类型的对象的容器中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs CPP"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt;&gt; vpw&#123; pw1, pw2 &#125;;<br></code></pre></div></td></tr></table></figure>
<p>它们也能相互赋值，也可以传入一个形参为<code>std::shared_ptr&lt;Widget&gt;</code>的函数。但是自定义删除器类型不同的<code>std::unique_ptr</code>就不行，因为<code>std::unique_ptr</code>把删除器视作类型的一部分。</p>
<p>另一个不同于<code>std::unique_ptr</code>的地方是，指定自定义删除器不会改变<code>std::shared_ptr</code>对象的大小。不管删除器是什么，一个<code>std::shared_ptr</code>对象都是两个指针大小。这是个好消息，但是它应该让你隐隐约约不安。自定义删除器可以是函数对象，函数对象可以包含任意多的数据。它意味着函数对象是任意大的。</p>
<p>引用计数是另一个更大的数据结构的一部分，那个数据结构通常叫做<strong>控制块</strong>（<em>control
block</em>）。每个<code>std::shared_ptr</code>管理的对象都有个相应的控制块。控制块除了包含引用计数值外还有一个自定义删除器的拷贝，当然前提是存在自定义删除器。如果用户还指定了自定义分配器，控制块也会包含一个分配器的拷贝。控制块可能还包含一些额外的数据，一个次级引用计数<em>weak
count</em>。</p>
<p><img src="images/Effective-Modern-Cpp/image-20230918083719236.png" srcset="/img/loading.gif" lazyload alt="image-20230918083719236" style="zoom:67%;"></p>
<p>对于一个创建指向对象的<code>std::shared_ptr</code>的函数来说不可能知道是否有其他<code>std::shared_ptr</code>早已指向那个对象，所以控制块的创建会遵循下面几条规则：</p>
<ul>
<li><strong><code>std::make_shared</code>总是创建一个控制块</strong>。它创建一个要指向的新对象，所以可以肯定<code>std::make_shared</code>调用时对象不存在其他控制块。</li>
<li><strong>当从独占指针（即<code>std::unique_ptr</code>或者<code>std::auto_ptr</code>）上构造出<code>std::shared_ptr</code>时会创建控制块</strong>。独占指针没有使用控制块，所以指针指向的对象没有关联控制块。（作为构造的一部分，<code>std::shared_ptr</code>侵占独占指针所指向的对象的独占权，所以独占指针被设置为null）</li>
<li><strong>当从原始指针上构造出<code>std::shared_ptr</code>时会创建控制块</strong>。如果你想从一个早已存在控制块的对象上创建<code>std::shared_ptr</code>，你将假定传递一个<code>std::shared_ptr</code>或者<code>std::weak_ptr</code>。作为构造函数实参，而不是原始指针。用<code>std::shared_ptr</code>或者<code>std::weak_ptr</code>作为构造函数实参创建<code>std::shared_ptr</code>不会创建新控制块，因为它可以依赖传递来的智能指针指向控制块。</li>
</ul>
<p>从原始指针上构造超过一个<code>std::shared_ptr</code>会造成未定义行为，因为指向的对象有多个控制块关联。多个控制块意味着多个引用计数值，多个引用计数值意味着对象将会被销毁多次（每个引用计数一次）。那意味着像下面的代码是有问题的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> pw = <span class="hljs-keyword">new</span> Widget;                           <span class="hljs-comment">//pw是原始指针</span><br>…<br><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt; <span class="hljs-title">spw1</span><span class="hljs-params">(pw, loggingDel)</span></span>;   <span class="hljs-comment">//为*pw创建控制块</span><br>…<br><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt; <span class="hljs-title">spw2</span><span class="hljs-params">(pw, loggingDel)</span></span>;   <span class="hljs-comment">//为*pw创建第二个控制块</span><br></code></pre></div></td></tr></table></figure>
<p>使用智能指针而不是原始指针。</p>
<p>使用 <code>std::shared_ptr</code>
的建议是：第一，避免传给<code>std::shared_ptr</code>构造函数原始指针。通常替代方案是使用<code>std::make_shared</code>，不过用<code>std::make_shared</code>就没办法使用自定义删除器。第二，如果你必须传给<code>std::shared_ptr</code>构造函数原始指针，直接传<code>new</code>出来的结果，不要传指针变量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt; <span class="hljs-title">spw1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Widget,    <span class="hljs-comment">//直接使用new的结果</span></span></span><br><span class="hljs-function"><span class="hljs-params">                             loggingDel)</span></span>;<br></code></pre></div></td></tr></table></figure>
<p>创建<code>spw2</code>也会很自然的用<code>spw1</code>作为初始化参数（即用<code>std::shared_ptr</code>拷贝构造函数），那就没什么问题了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs CPP"><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt; <span class="hljs-title">spw2</span><span class="hljs-params">(spw1)</span></span>;         <span class="hljs-comment">//spw2使用spw1一样的控制块</span><br></code></pre></div></td></tr></table></figure>
<h3><span id="this指针避免创建多余的控制块">this
指针：避免创建多余的控制块</span></h3>
<p><code>std::enable_shared_from_this</code>。如果你想创建一个用<code>std::shared_ptr</code>管理的类，这个类能够用<code>this</code>指针安全地创建一个<code>std::shared_ptr</code>，<code>std::enable_shared_from_this</code>就可作为基类的模板类。<code>Widget</code>将会继承自<code>std::enable_shared_from_this</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span>:</span> <span class="hljs-keyword">public</span> <span class="hljs-built_in">std</span>::enable_shared_from_this&lt;Widget&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>    …<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span></span>;<br>    …<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>这个标准名字就是奇异递归模板模式（<em>The Curiously Recurring
Template Pattern</em>（<em>CRTP</em>））。</p>
<p><code>std::enable_shared_from_this</code>
定义了一个成员函数，成员函数会创建指向当前对象的<code>std::shared_ptr</code>
却不创建多余控制块。这个成员函数就是<code>shared_from_this</code>，无论在哪当你想在成员函数中使用<code>std::shared_ptr</code>指向<code>this</code>所指对象时都请使用它。这里有个<code>Widget::process</code>的安全实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Widget::process</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//和之前一样，处理Widget</span><br>    …<br>    <span class="hljs-comment">//把指向当前对象的std::shared_ptr加入processedWidgets</span><br>    processedWidgets.emplace_back(shared_from_this());<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>从内部来说，<code>shared_from_this</code>查找当前对象控制块，然后创建一个新的<code>std::shared_ptr</code>关联这个控制块。设计的依据是当前对象已经存在一个关联的控制块。</p>
<p>要想符合设计依据的情况，必须已经存在一个指向当前对象的<code>std::shared_ptr</code>（比如调用<code>shared_from_this</code>的成员函数外面已经存在一个<code>std::shared_ptr</code>）。如果没有<code>std::shared_ptr</code>指向当前对象（即当前对象没有关联控制块），行为是未定义的，<code>shared_from_this</code>通常抛出一个异常。</p>
<p>要想防止客户端在存在一个指向对象的<code>std::shared_ptr</code>前先调用含有<code>shared_from_this</code>的成员函数，继承自<code>std::enable_shared_from_this</code>的类通常将它们的构造函数声明为<code>private</code>，并且让客户端通过返回<code>std::shared_ptr</code>的工厂函数创建对象。以<code>Widget</code>为例，代码可以是这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span>:</span> <span class="hljs-keyword">public</span> <span class="hljs-built_in">std</span>::enable_shared_from_this&lt;Widget&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//完美转发参数给private构造函数的工厂函数</span><br>    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Ts&gt;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt; <span class="hljs-title">create</span><span class="hljs-params">(Ts&amp;&amp;... params)</span></span>;<br>    …<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span></span>;     <span class="hljs-comment">//和前面一样</span><br>    …<br><span class="hljs-keyword">private</span>:<br>    …                   <span class="hljs-comment">//构造函数</span><br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>确保需要先调用 create，才能调用 process。</p>
<h3><span id="shared_ptr-开销">shared_ptr 开销</span></h3>
<p>控制块通常只占几个<em>word</em>大小，自定义删除器和分配器可能会让它变大一点。通常控制块的实现比你想的更复杂一些。它使用继承，甚至里面还有一个虚函数（用来确保指向的对象被正确销毁）。这意味着使用<code>std::shared_ptr</code>
，会带来使用虚函数带来的成本。</p>
<p>使用默认删除器和默认分配器，使用<code>std::make_shared</code>创建<code>std::shared_ptr</code>，产生的控制块只需三个word大小。它的分配基本上是无开销的。</p>
<p>对<code>std::shared_ptr</code>解引用的开销不会比原始指针高。执行需要原子引用计数修改的操作需要承担一两个原子操作开销，这些操作通常都会一一映射到机器指令上，所以即使对比非原子指令来说，原子指令开销较大，但是它们仍然只是单个指令上的。对于每个被<code>std::shared_ptr</code>指向的对象来说，控制块中的虚函数机制产生的开销通常只需要承受一次，即对象销毁的时候。</p>
<p>如果独占资源可行或者<strong>可能</strong>可行，用<code>std::unique_ptr</code>是一个更好的选择。它的性能表现更接近于原始指针，并且从<code>std::unique_ptr</code>升级到<code>std::shared_ptr</code>也很容易，因为<code>std::shared_ptr</code>可以从<code>std::unique_ptr</code>上创建。</p>
<p>从 <code>std::shared_ptr</code>转换到 <code>std::unique_ptr</code>
是不行的
。当你的资源由<code>std::shared_ptr</code>管理，现在又想修改资源生命周期管理方式是没有办法的。即使引用计数为一，你也不能重新修改资源所有权，改用<code>std::unique_ptr</code>管理它。资源和指向它的<code>std::shared_ptr</code>的签订的所有权协议是“除非死亡否则永不分开”。不能分离，不能废除，没有特许。</p>
<p><code>std::shared_ptr</code>不能处理的另一个东西是数组。和<code>std::unique_ptr</code>不同的是，<code>std::shared_ptr</code>的API设计之初就是针对单个对象的，没有办法<code>std::shared_ptr&lt;T[]&gt;</code>。</p>
<p><code>std::shared_ptr</code>没有提供<code>operator[]</code>，所以数组索引操作需要借助怪异的指针算术。另一方面，<code>std::shared_ptr</code>支持转换为指向基类的指针，这对于单个对象来说有效，但是当用于数组类型时这是容易出问题。（出于这个原因，<code>std::unique_ptr&lt;T[]&gt;</code>
API禁止这种转换。）</p>
<p>更重要的是，C++11已经提供了很多内置数组的候选方案（比如<code>std::array</code>，<code>std::vector</code>，<code>std::string</code>）。所以，声明一个指向数组的智能指针几乎总是糟糕的设计。</p>
<h3><span id="结论">结论</span></h3>
<ul>
<li><code>std::shared_ptr</code>为有共享所有权的任意资源提供一种自动垃圾回收的便捷方式。</li>
<li>较之于<code>std::unique_ptr</code>，<code>std::shared_ptr</code>对象通常大两倍，控制块会产生开销，需要原子性的引用计数修改操作。</li>
<li><code>std::shared_ptr</code>
默认资源销毁是通过<code>delete</code>，但是也支持自定义删除器。但是删除器的类型不是
<code>std::shared_ptr</code> 的类型的一部分。</li>
<li>避免从原始指针变量上创建<code>std::shared_ptr</code>。</li>
</ul>
<h2><span id="20当stdshared_ptr可能悬空时使用stdweak_ptr">20
当<code>std::shared_ptr</code>可能悬空时使用<code>std::weak_ptr</code></span></h2>
<p>一个真正的智能指针应该跟踪所指对象，在悬空时知晓，悬空（<em>dangle</em>）就是指针指向的对象不再存在。这就是对<code>std::weak_ptr</code>最精确的描述。</p>
<p><code>std::weak_ptr</code>不能解引用，也不能测试是否为空值。因为<code>std::weak_ptr</code>不是一个独立的智能指针。它是<code>std::shared_ptr</code>的增强。</p>
<p><code>std::weak_ptr</code>通常从<code>std::shared_ptr</code>上创建。当从<code>std::shared_ptr</code>上创建<code>std::weak_ptr</code>时两者指向相同的对象，但是<code>std::weak_ptr</code>不会影响所指对象的引用计数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> spw =                      <span class="hljs-comment">//spw创建之后，指向的Widget的</span><br>    <span class="hljs-built_in">std</span>::make_shared&lt;Widget&gt;(); <span class="hljs-comment">//引用计数（ref count，RC）为1。</span><br>                               <br>…<br><span class="hljs-function"><span class="hljs-built_in">std</span>::weak_ptr&lt;Widget&gt; <span class="hljs-title">wpw</span><span class="hljs-params">(spw)</span></span>; <span class="hljs-comment">//wpw指向与spw所指相同的Widget。RC仍为1</span><br>…<br>spw = <span class="hljs-literal">nullptr</span>;                  <span class="hljs-comment">//RC变为0，Widget被销毁。</span><br>                                <span class="hljs-comment">//wpw现在悬空</span><br></code></pre></div></td></tr></table></figure>
<p>悬空的<code>std::weak_ptr</code>被称作已经<strong>expired</strong>（过期）。你可以用它直接做测试：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs CPP"><span class="hljs-keyword">if</span> (wpw.expired()) …            <span class="hljs-comment">//如果wpw没有指向对象…</span><br></code></pre></div></td></tr></table></figure>
<p>但是通常你期望的是检查<code>std::weak_ptr</code>是否已经过期，如果没有过期则访问其指向的对象。不过，将检查是否过期和解引用分开会引入竞态条件：在调用<code>expired</code>和解引用操作之间，另一个线程可能对指向这对象的<code>std::shared_ptr</code>重新赋值或者析构，并由此造成对象已析构。这种情况下，你的解引用将会产生未定义行为。</p>
<p>你需要的是一个原子操作检查<code>std::weak_ptr</code>是否已经过期，如果没有过期就访问所指对象。这可以通过从<code>std::weak_ptr</code>创建<code>std::shared_ptr</code>来实现，具体有两种形式可以从<code>std::weak_ptr</code>上创建<code>std::shared_ptr</code>，具体用哪种取决于<code>std::weak_ptr</code>过期时你希望<code>std::shared_ptr</code>表现出什么行为。</p>
<p>一种形式是<code>std::weak_ptr::lock</code>，它返回一个<code>std::shared_ptr</code>，如果<code>std::weak_ptr</code>过期这个<code>std::shared_ptr</code>为空：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt; spw1 = wpw.lock();  <span class="hljs-comment">//如果wpw过期，spw1就为空</span><br> 											<br><span class="hljs-keyword">auto</span> spw2 = wpw.lock();                     <span class="hljs-comment">//同上，但是使用auto</span><br></code></pre></div></td></tr></table></figure>
<p>另一种形式是以<code>std::weak_ptr</code>为实参构造<code>std::shared_ptr</code>。这种情况中，如果<code>std::weak_ptr</code>过期，会抛出一个异常：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt; <span class="hljs-title">spw3</span><span class="hljs-params">(wpw)</span></span>;          <span class="hljs-comment">//如果wpw过期，抛出std::bad_weak_ptr异常</span><br></code></pre></div></td></tr></table></figure>
<h3><span id="一个例子">一个例子</span></h3>
<p>考虑一个工厂函数，它基于一个唯一ID从只读对象上产出智能指针。根据条款18的描述，工厂函数会返回一个该对象类型的<code>std::unique_ptr</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-keyword">const</span> Widget&gt; <span class="hljs-title">loadWidget</span><span class="hljs-params">(WidgetID id)</span></span>;<br></code></pre></div></td></tr></table></figure>
<p>如果调用<code>loadWidget</code>是一个昂贵的操作（比如它操作文件或者数据库I/O）并且重复使用ID很常见，一个合理的优化是再写一个函数除了完成<code>loadWidget</code>做的事情之外再缓存它的结果。另一个合理的优化可以是当<code>Widget</code>不再使用的时候销毁它的缓存。</p>
<p>对于可缓存的工厂函数，返回<code>std::unique_ptr</code>不是好的选择。调用者应该接收缓存对象的智能指针，调用者也应该确定这些对象的生命周期，但是缓存本身也需要一个指针指向它所缓存的对象。缓存对象的指针需要知道它是否已经悬空，因为当工厂客户端使用完工厂产生的对象后，对象将被销毁，关联的缓存条目会悬空。所以缓存应该使用<code>std::weak_ptr</code>，这可以知道是否已经悬空。这意味着工厂函数返回值类型应该是<code>std::shared_ptr</code>，因为只有当对象的生命周期由<code>std::shared_ptr</code>管理时，<code>std::weak_ptr</code>才能检测到悬空。</p>
<p>一个简版的实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">const</span> Widget&gt; <span class="hljs-title">fastLoadWidget</span><span class="hljs-params">(WidgetID id)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unordered_map</span>&lt;WidgetID,<br>                              <span class="hljs-built_in">std</span>::weak_ptr&lt;<span class="hljs-keyword">const</span> Widget&gt;&gt; cache;<br>                                        <span class="hljs-comment">//std::weak_ptr&lt;const Widget&gt;</span><br>    <span class="hljs-keyword">auto</span> objPtr = cache[id].lock();     <span class="hljs-comment">//objPtr是去缓存对象的</span><br>                                        <span class="hljs-comment">//std::shared_ptr（或</span><br>                                        <span class="hljs-comment">//当对象不在缓存中时为null）</span><br><br>    <span class="hljs-keyword">if</span> (!objPtr) &#123;                      <span class="hljs-comment">//如果不在缓存中</span><br>        objPtr = loadWidget(id);        <span class="hljs-comment">//加载它</span><br>        cache[id] = objPtr;             <span class="hljs-comment">//缓存它</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> objPtr;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p><code>fastLoadWidget</code>的实现仍有以下问题：缓存可能会累积过期的<code>std::weak_ptr</code>，这些指针对应了不再使用的<code>Widget</code>（也已经被销毁了）。</p>
</blockquote>
<h3><span id="另一个例子">另一个例子</span></h3>
<p>考虑第二个用例：观察者设计模式（Observer design pattern）。</p>
<p>此模式的主要组件是subjects（状态可能会更改的对象）和observers（状态发生更改时要通知的对象）。在大多数实现中，每个subject都包含一个数据成员，该成员持有指向其observers的指针。这使subjects很容易发布状态更改通知。</p>
<p>subjects对控制observers的生命周期（即它们什么时候被销毁）没有兴趣，但是subjects对确保另一件事具有极大的兴趣，那事就是一个observer被销毁时，不再尝试访问它。一个合理的设计是每个subject持有一个<code>std::weak_ptr</code>s容器指向observers，因此可以在使用前检查是否已经悬空。</p>
<h3><span id="最后一个例子">最后一个例子</span></h3>
<p>考虑一个持有三个对象<code>A</code>、<code>B</code>、<code>C</code>的数据结构，<code>A</code>和<code>C</code>共享<code>B</code>的所有权，因此持有<code>std::shared_ptr</code>：</p>
<figure>
<img src="images/Effective-Modern-Cpp/item20_fig1.png" srcset="/img/loading.gif" lazyload alt="item20_fig1">
<figcaption aria-hidden="true">item20_fig1</figcaption>
</figure>
<p>假定从B指向A的指针也很有用。应该使用哪种指针？</p>
<figure>
<img src="images/Effective-Modern-Cpp/item20_fig2.png" srcset="/img/loading.gif" lazyload alt="item20_fig2">
<figcaption aria-hidden="true">item20_fig2</figcaption>
</figure>
<p>有三种选择：</p>
<ul>
<li><strong>原始指针</strong>。使用这种方法，如果<code>A</code>被销毁，但是<code>C</code>继续指向<code>B</code>，<code>B</code>就会有一个指向<code>A</code>的悬空指针。而且<code>B</code>不知道指针已经悬空，所以<code>B</code>可能会继续访问，就会导致未定义行为。</li>
<li><strong><code>std::shared_ptr</code></strong>。这种设计，<code>A</code>和<code>B</code>都互相持有对方的<code>std::shared_ptr</code>，导致的<code>std::shared_ptr</code>环状结构（<code>A</code>指向<code>B</code>，<code>B</code>指向<code>A</code>）阻止<code>A</code>和<code>B</code>的销毁。甚至<code>A</code>和<code>B</code>无法从其他数据结构访问了（比如，<code>C</code>不再指向<code>B</code>），每个的引用计数都还是1。如果发生了这种情况，<code>A</code>和<code>B</code>都被泄漏：程序无法访问它们，但是资源并没有被回收。</li>
<li><strong><code>std::weak_ptr</code></strong>。这避免了上述两个问题。如果<code>A</code>被销毁，<code>B</code>指向它的指针悬空，但是<code>B</code>可以检测到这件事。尤其是，尽管<code>A</code>和<code>B</code>互相指向对方，<code>B</code>的指针不会影响<code>A</code>的引用计数，因此在没有<code>std::shared_ptr</code>指向<code>A</code>时不会导致<code>A</code>无法被销毁。</li>
</ul>
<blockquote>
<p>但是，需要注意使用<code>std::weak_ptr</code>打破<code>std::shared_ptr</code>循环并不常见。在严格分层的数据结构比如树中，子节点只被父节点持有。当父节点被销毁时，子节点就被销毁。从父到子的链接关系可以使用<code>std::unique_ptr</code>很好的表征。从子到父的反向连接可以使用原始指针安全实现，因为子节点的生命周期肯定短于父节点。因此没有子节点解引用一个悬空的父节点指针这样的风险。</p>
</blockquote>
<p>从效率角度来看，<code>std::weak_ptr</code>与<code>std::shared_ptr</code>基本相同。两者的大小是相同的，使用相同的控制块。构造、析构、赋值操作涉及引用计数的原子操作。</p>
<blockquote>
<p>虽然，<code>std::weak_ptr</code>不参与对象的<strong>共享所有权</strong>，因此不影响<strong>指向对象的引用计数</strong>。实际上在控制块中还是有第二个引用计数，<code>std::weak_ptr</code>操作的是第二个引用计数。</p>
</blockquote>
<h3><span id="结论">结论</span></h3>
<ul>
<li>用<code>std::weak_ptr</code>替代可能会悬空的<code>std::shared_ptr</code>。</li>
<li><code>std::weak_ptr</code>的潜在使用场景包括：缓存、观察者列表、打破<code>std::shared_ptr</code>环状结构。</li>
</ul>
<h2><span id="21优先考虑使用stdmake_unique和stdmake_shared而非直接使用new">21
优先考虑使用<code>std::make_unique</code>和<code>std::make_shared</code>，而非直接使用<code>new</code></span></h2>
<p><code>std::make_shared</code>是C++11标准的一部分，但是，<code>std::make_unique</code>是从C++14开始加入标准库。</p>
<p>一个基础版本的<code>std::make_unique</code>是很容易自己写出的，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Ts&gt;<br><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;T&gt; <span class="hljs-title">make_unique</span><span class="hljs-params">(Ts&amp;&amp;... params)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;T&gt;(<span class="hljs-keyword">new</span> T(<span class="hljs-built_in">std</span>::forward&lt;Ts&gt;(params)...));<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>这种形式的函数不支持数组和自定义析构（见条款18）</p>
<blockquote>
<p><code>std::make_unique</code>和<code>std::make_shared</code>是三个<strong>make函数</strong>
中的两个：接收任意的多参数集合，完美转发到构造函数去动态分配一个对象，然后返回这个指向这个对象的指针。</p>
<p>第三个<code>make</code>函数是<code>std::allocate_shared</code>。它行为和<code>std::make_shared</code>一样，只不过第一个参数是用来动态分配内存的<em>allocator</em>对象。</p>
</blockquote>
<h3><span id="使用-stdmake_unique的理由一">使用 <code>std::make_unique</code>
的理由一</span></h3>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">upw1</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::make_unique&lt;Widget&gt;())</span></span>;      <span class="hljs-comment">//使用make函数</span><br><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;Widget&gt; <span class="hljs-title">upw2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Widget)</span></span>;   <span class="hljs-comment">//不使用make函数</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">spw1</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::make_shared&lt;Widget&gt;())</span></span>;      <span class="hljs-comment">//使用make函数</span><br><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt; <span class="hljs-title">spw2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Widget)</span></span>;   <span class="hljs-comment">//不使用make函数</span><br></code></pre></div></td></tr></table></figure>
<p>我高亮了关键区别：使用<code>new</code>的版本重复了类型，但是<code>make</code>函数的版本没有。</p>
<p>重复写类型和软件工程里面一个关键原则相冲突：应该避免重复代码。源代码中的重复增加了编译的时间，会导致目标代码冗余，并且通常会让代码库使用更加困难。</p>
<p>它经常演变成不一致的代码，而代码库中的不一致常常导致bug。</p>
<h3><span id="使用-stdmake_unique的理由二">使用 <code>std::make_unique</code>
的理由二</span></h3>
<p>在调用<code>processWidget</code>时使用了<code>new</code>而不是<code>std::make_shared</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">processWidget(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt;(<span class="hljs-keyword">new</span> Widget),  <span class="hljs-comment">//潜在的资源泄漏！</span><br>              computePriority());<br></code></pre></div></td></tr></table></figure>
<p>内存泄漏的原因在于：</p>
<p>在运行时，一个函数的实参必须先被计算，这个函数再被调用，所以在调用<code>processWidget</code>之前，必须执行以下操作，<code>processWidget</code>才开始执行：</p>
<ul>
<li>表达式“<code>new Widget</code>”必须计算，例如，一个<code>Widget</code>对象必须在堆上被创建</li>
<li>负责管理<code>new</code>出来指针的<code>std::shared_ptr&lt;Widget&gt;</code>构造函数必须被执行</li>
<li><code>computePriority</code>必须运行</li>
</ul>
<p>而编译器不保证按照顺序生成代码。</p>
<p>虽然“<code>new Widget</code>”必须在<code>std::shared_ptr</code>的构造函数被调用前执行，因为<code>new</code>出来的结果作为构造函数的实参，但<code>computePriority</code>可能在这之前，之后，或者<strong>之间</strong>执行。也就是说，编译器可能按照这个执行顺序生成代码：</p>
<ol type="1">
<li>执行“<code>new Widget</code>”</li>
<li>执行<code>computePriority</code></li>
<li>运行<code>std::shared_ptr</code>构造函数</li>
</ol>
<p>在运行时<code>computePriority</code>产生了异常，那么第一步动态分配的<code>Widget</code>就会泄漏。因为它永远都不会被第三步的<code>std::shared_ptr</code>所管理了。</p>
<p>使用<code>std::make_shared</code>可以防止这种问题。调用代码看起来像是这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">processWidget(<span class="hljs-built_in">std</span>::make_shared&lt;Widget&gt;(),   <span class="hljs-comment">//没有潜在的资源泄漏</span><br>              computePriority());<br></code></pre></div></td></tr></table></figure>
<p>在运行时，<code>std::make_shared</code>和<code>computePriority</code>其中一个会先被调用。</p>
<h3><span id="使用-stdmake_unique的理由三">使用 <code>std::make_unique</code>
的理由三</span></h3>
<p>使用<code>std::make_shared</code>允许编译器生成更小，更快的代码，并使用更简洁的数据结构。考虑以下对new的直接使用：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt; <span class="hljs-title">spw</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Widget)</span></span>;<br></code></pre></div></td></tr></table></figure>
<p>显然，这段代码需要进行内存分配，但它实际上执行了两次。</p>
<p>每个<code>std::shared_ptr</code>指向一个控制块，其中包含被指向对象的引用计数，还有其他东西。这个控制块的内存在<code>std::shared_ptr</code>构造函数中分配。因此，直接使用<code>new</code>需要为<code>Widget</code>进行一次内存分配，为控制块再进行一次内存分配。</p>
<p>如果使用<code>std::make_shared</code>代替：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> spw = <span class="hljs-built_in">std</span>::make_shared&lt;Widget&gt;();<br></code></pre></div></td></tr></table></figure>
<p>一次分配足矣。这是因为<code>std::make_shared</code>分配一块内存，同时容纳了<code>Widget</code>对象和控制块。这种优化减少了程序的静态大小，因为代码只包含一个内存分配调用，并且它提高了可执行代码的速度，因为内存只分配一次。此外，使用<code>std::make_shared</code>避免了对控制块中的某些簿记信息的需要，潜在地减少了程序的总内存占用。</p>
<h3><span id="不使用stdmake_shared-的情况">不使用
<code>std::make_shared</code> 的情况</span></h3>
<h4><span id="需要自定义删除器时">需要自定义删除器时</span></h4>
<p><code>make</code>函数都不允许指定自定义删除器，但是<code>std::unique_ptr</code>和<code>std::shared_ptr</code>有构造函数这么做。有个<code>Widget</code>的自定义删除器：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> widgetDeleter = [](Widget* pw) &#123; … &#125;;<br></code></pre></div></td></tr></table></figure>
<p>创建一个使用它的智能指针只能直接使用<code>new</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;Widget, <span class="hljs-keyword">decltype</span>(widgetDeleter)&gt;<br>    upw(<span class="hljs-keyword">new</span> Widget, widgetDeleter);<br><br><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt; <span class="hljs-title">spw</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Widget, widgetDeleter)</span></span>;<br></code></pre></div></td></tr></table></figure>
<p>对于<code>make</code>函数，没有办法做同样的事情。</p>
<h4><span id="不支持花括号调用stdinitializer_list">不支持花括号调用
<code>std::initializer_list</code></span></h4>
<p>常规的用花括号创建的对象更倾向于使用<code>std::initializer_list</code>作为形参的重载形式，而用小括号创建对象将调用不用<code>std::initializer_list</code>作为参数的的重载形式。</p>
<p>但是，在这些调用中，</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> upv = <span class="hljs-built_in">std</span>::make_unique&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<br><span class="hljs-keyword">auto</span> spv = <span class="hljs-built_in">std</span>::make_shared&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<br></code></pre></div></td></tr></table></figure>
<p>生成的智能指针指向带有10个元素的<code>std::vector</code>，每个元素值为20。</p>
<p>如果你想用花括号初始化指向的对象，你必须直接使用<code>new</code>。</p>
<p>一个变通的方法：使用<code>auto</code>类型推导从花括号初始化创建<code>std::initializer_list</code>对象，然后将<code>auto</code>创建的对象传递给<code>make</code>函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//创建std::initializer_list</span><br><span class="hljs-keyword">auto</span> initList = &#123; <span class="hljs-number">10</span>, <span class="hljs-number">20</span> &#125;;<br><span class="hljs-comment">//使用std::initializer_list为形参的构造函数创建std::vector</span><br><span class="hljs-keyword">auto</span> spv = <span class="hljs-built_in">std</span>::make_shared&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;(initList);<br></code></pre></div></td></tr></table></figure>
<p>对于<code>std::unique_ptr</code>，只有这两种情景（自定义删除器和花括号初始化）使用<code>make</code>函数有点问题。对于<code>std::shared_ptr</code>和它的<code>make</code>函数，还有2个问题。都属于边缘情况，但是一些开发者常碰到。</p>
<h4><span id="类重载了operator-new和operator-delete">类重载了<code>operator new</code>和<code>operator delete</code></span></h4>
<p>例如，<code>Widget</code>类的<code>operator new</code>和<code>operator delete</code>只会处理<code>sizeof(Widget)</code>大小的内存块的分配和释放。因为<code>std::allocate_shared</code>需要的内存总大小不等于动态分配的对象大小，还需要<strong>再加上</strong>控制块大小。</p>
<p>与直接使用<code>new</code>相比，<code>std::make_shared</code>在大小和速度上的优势源于<code>std::shared_ptr</code>的控制块与指向的对象放在同一块内存中。当对象的引用计数降为0，对象被销毁（即析构函数被调用）。但是，因为控制块和对象被放在同一块分配的内存块中，直到控制块的内存也被销毁，对象占用的内存才被释放。</p>
<p>控制块除了引用计数，还包含簿记信息。引用计数追踪有多少<code>std::shared_ptr</code>s指向控制块，但控制块还有第二个计数，记录多少个<code>std::weak_ptr</code>s指向控制块。第二个引用计数就是<em>weak
count</em>。当一个<code>std::weak_ptr</code>检测它是否过期时，它会检测指向的控制块中的引用计数（而不是<em>weak
count</em>）。</p>
<p>如果引用计数是0（即对象没有<code>std::shared_ptr</code>再指向它，已经被销毁了），<code>std::weak_ptr</code>就已经过期。</p>
<p>但是只要<code>std::weak_ptr</code>s引用一个控制块（即<em>weak
count</em>大于零），该控制块必须继续存在。只要控制块存在，包含它的内存就必须保持分配。</p>
<p>所以，通过<code>std::shared_ptr</code>的<code>make</code>函数分配的内存，直到最后一个<code>std::shared_ptr</code>和最后一个指向它的<code>std::weak_ptr</code>已被销毁，才会释放。</p>
<p>所以，如果对象类型非常大，而且销毁最后一个<code>std::shared_ptr</code>和销毁最后一个<code>std::weak_ptr</code>之间的时间很长，那么在销毁对象和释放它所占用的内存之间可能会出现延迟。</p>
<p>例如，下面这种情况，明显，直接只用<code>new</code>，对象的释放会立即执行。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReallyBigType</span> &#123;</span> … &#125;;<br><br><span class="hljs-keyword">auto</span> pBigObj =                          <span class="hljs-comment">//通过std::make_shared</span><br>    <span class="hljs-built_in">std</span>::make_shared&lt;ReallyBigType&gt;();  <span class="hljs-comment">//创建一个大对象</span><br>                    <br>…           <span class="hljs-comment">//创建std::shared_ptrs和std::weak_ptrs</span><br>            <span class="hljs-comment">//指向这个对象，使用它们</span><br><br>…           <span class="hljs-comment">//最后一个std::shared_ptr在这销毁，</span><br>            <span class="hljs-comment">//但std::weak_ptrs还在</span><br><br>…           <span class="hljs-comment">//在这个阶段，原来分配给大对象的内存还分配着</span><br><br>…           <span class="hljs-comment">//最后一个std::weak_ptr在这里销毁；</span><br>            <span class="hljs-comment">//控制块和对象的内存被释放</span><br></code></pre></div></td></tr></table></figure>
<p>直接只用<code>new</code>，一旦最后一个<code>std::shared_ptr</code>被销毁，<code>ReallyBigType</code>对象的内存就会被释放：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReallyBigType</span> &#123;</span> … &#125;;              <span class="hljs-comment">//和之前一样</span><br><br><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;ReallyBigType&gt; <span class="hljs-title">pBigObj</span><span class="hljs-params">(<span class="hljs-keyword">new</span> ReallyBigType)</span></span>;<br>                                        <span class="hljs-comment">//通过new创建大对象</span><br><br>…           <span class="hljs-comment">//像之前一样，创建std::shared_ptrs和std::weak_ptrs</span><br>            <span class="hljs-comment">//指向这个对象，使用它们</span><br>            <br>…           <span class="hljs-comment">//最后一个std::shared_ptr在这销毁,</span><br>            <span class="hljs-comment">//但std::weak_ptrs还在；</span><br>            <span class="hljs-comment">//对象的内存被释放</span><br><br>…           <span class="hljs-comment">//在这阶段，只有控制块的内存仍然保持分配</span><br><br>…           <span class="hljs-comment">//最后一个std::weak_ptr在这里销毁；</span><br>            <span class="hljs-comment">//控制块内存被释放</span><br></code></pre></div></td></tr></table></figure>
<h3><span id="一个优化的例子">一个优化的例子</span></h3>
<p>考虑前面的 <code>processWidget</code>
函数，现在我们指定一个自定义删除器:</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">processWidget</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt; spw,     <span class="hljs-comment">//和之前一样</span></span></span><br><span class="hljs-function"><span class="hljs-params">                   <span class="hljs-keyword">int</span> priority)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cusDel</span><span class="hljs-params">(Widget *ptr)</span></span>;                           <span class="hljs-comment">//自定义删除器</span><br></code></pre></div></td></tr></table></figure>
<p>下面这个是非异常安全的调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">processWidget( 									    <span class="hljs-comment">//和之前一样，</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt;(<span class="hljs-keyword">new</span> Widget, cusDel),    <span class="hljs-comment">//潜在的内存泄漏！</span><br>    computePriority() <br>);<br></code></pre></div></td></tr></table></figure>
<p>还是实参调用的顺序问题。</p>
<p>一个优化方式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt; <span class="hljs-title">spw</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Widget, cusDel)</span></span>;<br>processWidget(spw, computePriority());  <span class="hljs-comment">// 正确，但是没优化，见下</span><br></code></pre></div></td></tr></table></figure>
<p>但是有一个性能问题，实参在前一个非异常安全调用中，<code>std::shared_ptr</code>形参是传值，从右值构造只需要移动。</p>
<p>而优化后，传递左值构造需要拷贝。对<code>std::shared_ptr</code>而言，这种区别是有意义的，因为拷贝<code>std::shared_ptr</code>需要对引用计数原子递增，移动则不需要对引用计数有操作。</p>
<p>所以，更高效安全的版本是：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">processWidget(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(spw), computePriority());   <span class="hljs-comment">//高效且异常安全</span><br></code></pre></div></td></tr></table></figure>
<h3><span id="结论">结论</span></h3>
<ul>
<li>和直接使用<code>new</code>相比，<code>make</code>函数消除了代码重复，提高了异常安全性。对于<code>std::make_shared</code>和<code>std::allocate_shared</code>，生成的代码更小更快。</li>
<li>不适合使用<code>make</code>函数的情况包括需要指定自定义删除器和希望用花括号初始化。</li>
<li>对于<code>std::shared_ptr</code>s，其他不建议使用<code>make</code>函数的情况包括：(1)
有自定义内存管理的类；(2)
特别关注内存的系统，非常大的对象，以及<code>std::weak_ptr</code>s比对应的<code>std::shared_ptr</code>s活得更久。</li>
</ul>
<h2><span id="22-当使用pimpl-idiom请在实现文件中定义特殊成员函数">22 当使用
Pimpl Idiom，请在实现文件中定义特殊成员函数</span></h2>
<p>Pimpl Idiom
将类数据成员替换成一个指向包含具体实现的类（implementation
class）（或结构体）的指针，并将原本放在主类（primary
class）的相关数据成员们移动到实现类（implementation
class）去，而这些数据成员的访问将通过指针间接访问。</p>
<p>举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">class <span class="hljs-title">Widget</span><span class="hljs-params">()</span> </span>&#123;                    <span class="hljs-comment">//定义在头文件“widget.h”</span><br><span class="hljs-keyword">public</span>:<br>    Widget();<br>    …<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> name;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt; data;<br>    Gadget g1, g2, g3;              <span class="hljs-comment">//Gadget是用户自定义的类型</span><br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>因为类<code>Widget</code>的数据成员包含有类型<code>std::string</code>，<code>std::vector</code>和<code>Gadget</code>，
定义有这些类型的头文件在类<code>Widget</code>编译的时候，必须被包含进来，这意味着类<code>Widget</code>的使用者必须要<code>#include &lt;string&gt;</code>，<code>&lt;vector&gt;</code>以及<code>gadget.h</code>。</p>
<p>这些头文件将会增加类<code>Widget</code>使用者的编译时间，并且让这些使用者依赖于这些头文件。
如果一个头文件的内容变了，类<code>Widget</code>使用者也必须要重新编译。
标准库文件<code>&lt;string&gt;</code>和<code>&lt;vector&gt;</code>不是很常变，但是<code>gadget.h</code>可能会经常修订。</p>
<p>在C++98中使用Pimpl惯用法，可以把<code>Widget</code>的数据成员替换成一个原始指针，指向一个已经被声明过却还未被定义的结构体:</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span>                        //仍然在“<span class="hljs-title">widget</span>.<span class="hljs-title">h</span>”中</span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    Widget();<br>    ~Widget();                      <br>    …<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Impl</span>;</span>                    <span class="hljs-comment">//声明一个 实现结构体</span><br>    Impl *pImpl;                    <span class="hljs-comment">//以及指向它的指针</span><br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>因为类<code>Widget</code>不再提到类型<code>std::string</code>，<code>std::vector</code>以及<code>Gadget</code>，<code>Widget</code>的使用者不再需要为了这些类型而引入头文件。
这可以加速编译，并且意味着，如果这些头文件中有所变动，<code>Widget</code>的使用者不会受到影响。</p>
<p>一个已经被声明，却还未被实现的类型，被称为<strong>未完成类型</strong>（<em>incomplete
type</em>）。 <code>Widget::Impl</code>就是这种类型。</p>
<p>下一步是对 实现类（implementation class） 的内存管理：</p>
<p>在<code>Widget.cpp</code>里:</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"widget.h"</span>             <span class="hljs-comment">//以下代码均在实现文件“widget.cpp”里</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"gadget.h"</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Widget</span>:</span>:Impl &#123;           <span class="hljs-comment">//含有之前在Widget中的数据成员的</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> name;           <span class="hljs-comment">//Widget::Impl类型的定义</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt; data;<br>    Gadget g1,g2,g3;<br>&#125;;<br><br>Widget::Widget()                <span class="hljs-comment">//为此Widget对象分配数据成员</span><br>: pImpl(<span class="hljs-keyword">new</span> Impl)<br>&#123;&#125;<br><br>Widget::~Widget()               <span class="hljs-comment">//销毁数据成员</span><br>&#123; <span class="hljs-keyword">delete</span> pImpl; &#125;<br></code></pre></div></td></tr></table></figure>
<p>它使用了原始指针，原始的<code>new</code>和原始的<code>delete</code>，一切都让它如此的...原始。</p>
<h3><span id="使用智能指针">使用智能指针</span></h3>
<p>如果我们想要的只是在类<code>Widget</code>的构造函数动态分配<code>Widget::impl</code>对象，在<code>Widget</code>对象销毁时一并销毁它，
<code>std::unique_ptr</code>是最合适的工具。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> &#123;</span>                      <span class="hljs-comment">//在“widget.h”中</span><br><span class="hljs-keyword">public</span>:<br>    Widget();<br>    …<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Impl</span>;</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;Impl&gt; pImpl;    <span class="hljs-comment">//使用智能指针而不是原始指针</span><br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>实现文件也可以改成如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"widget.h"</span>                 <span class="hljs-comment">//在“widget.cpp”中</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"gadget.h"</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Widget</span>:</span>:Impl &#123;               <span class="hljs-comment">//跟之前一样</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> name;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt; data;<br>    Gadget g1,g2,g3;<br>&#125;;<br><br>Widget::Widget()                    <br>: pImpl(<span class="hljs-built_in">std</span>::make_unique&lt;Impl&gt;()) <br>&#123;&#125;<br></code></pre></div></td></tr></table></figure>
<h3><span id="问题出现了">问题出现了</span></h3>
<p>以上的代码能编译，但是，最普通的<code>Widget</code>用法却会导致编译出错：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"widget.h"</span></span><br><br>Widget w;                           <span class="hljs-comment">//错误！</span><br></code></pre></div></td></tr></table></figure>
<p>在对象<code>w</code>被析构时（例如离开了作用域），问题出现了。</p>
<p>在这个时候，它的析构函数被调用。我们在类的定义里使用了<code>std::unique_ptr</code>，所以我们没有声明析构函数。编译器会自动为我们生成一个析构函数。
在这个析构函数里，编译器会插入一些代码来调用类<code>Widget</code>的数据成员<code>pImpl</code>的析构函数。</p>
<p>问题就在于，此时<code>pImpl</code>的析构函数调用默认的删除器。默认删除器是一个函数，它使用<code>delete</code>来销毁内置于<code>std::unique_ptr</code>的原始指针。然而，在使用<code>delete</code>之前，通常会使默认删除器使用C++11的特性<code>static_assert</code>来确保原始指针指向的类型不是一个未完成类型。</p>
<p>需要确保在编译器生成销毁<code>std::unique_ptr&lt;Widget::Impl&gt;</code>的代码之前，
<code>Widget::Impl</code>已经是一个完成类型（<em>complete type</em>）。
当编译器“看到”它的定义的时候，该类型就成为完成类型了。 但是
<code>Widget::Impl</code>的定义在<code>widget.cpp</code>里。</p>
<p>成功编译的关键，就是在<code>widget.cpp</code>文件内，让编译器在“看到”
<code>Widget</code>的析构函数实现之前（也即编译器插入的，用来销毁<code>std::unique_ptr</code>这个数据成员的代码段之前），先定义<code>Widget::Impl</code>。</p>
<p>修改方法就是，在<code>widget.h</code>里只声明类<code>Widget</code>的析构函数，但不要在这里定义它：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> &#123;</span>                  <span class="hljs-comment">//跟之前一样，在“widget.h”中</span><br><span class="hljs-keyword">public</span>:<br>    Widget();<br>    ~Widget();                  <span class="hljs-comment">//只有声明语句</span><br>    …<br><br><span class="hljs-keyword">private</span>:                        <span class="hljs-comment">//跟之前一样</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Impl</span>;</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;Impl&gt; pImpl;<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>在<code>widget.cpp</code>文件中，在结构体<code>Widget::Impl</code>被定义之后，再定义析构函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"widget.h"</span>                 <span class="hljs-comment">//跟之前一样，在“widget.cpp”中</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"gadget.h"</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><br><span class="hljs-comment">// 先于析构函数定义</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Widget</span>:</span>:Impl &#123;               <span class="hljs-comment">//跟之前一样，定义Widget::Impl</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> name;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt; data;<br>    Gadget g1,g2,g3;<br>&#125;<br><br>Widget::Widget()                    <span class="hljs-comment">//跟之前一样</span><br>: pImpl(<span class="hljs-built_in">std</span>::make_unique&lt;Impl&gt;())<br>&#123;&#125;<br><br>Widget::~Widget()                   <span class="hljs-comment">//析构函数的定义</span><br>&#123;&#125;<br></code></pre></div></td></tr></table></figure>
<p>如果你想强调编译器自动生成的析构函数会做和你一样正确的事情，你可以直接使用“<code>= default</code>”定义析构函数体</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">Widget::~Widget() = <span class="hljs-keyword">default</span>;        <span class="hljs-comment">//同上述代码效果一致</span><br></code></pre></div></td></tr></table></figure>
<h3><span id="移动">移动</span></h3>
<p>编译器自动生成的移动操作对其中的<code>std::unique_ptr</code>进行移动。但是，声明一个类<code>Widget</code>的析构函数会阻止编译器生成移动操作，所以你需要这样做：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> &#123;</span>                                  <span class="hljs-comment">//仍然在“widget.h”中</span><br><span class="hljs-keyword">public</span>:<br>    Widget();<br>    ~Widget();<br><br>    Widget(Widget&amp;&amp; rhs) = <span class="hljs-keyword">default</span>;             <span class="hljs-comment">//思路正确，</span><br>    Widget&amp; <span class="hljs-keyword">operator</span>=(Widget&amp;&amp; rhs) = <span class="hljs-keyword">default</span>;  <span class="hljs-comment">//但代码错误</span><br>    …<br><br><span class="hljs-keyword">private</span>:                                        <span class="hljs-comment">//跟之前一样</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Impl</span>;</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;Impl&gt; pImpl;<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>问题在于：</p>
<p>编译器生成的移动赋值操作符，在重新赋值之前，需要先销毁指针<code>pImpl</code>指向的对象。然而在<code>Widget</code>的头文件里，<code>pImpl</code>指针指向的是一个未完成类型。</p>
<p>移动构造函数的情况有所不同。
移动构造函数的问题是编译器自动生成的代码里，包含有抛出异常的事件，在这个事件里会生成销毁<code>pImpl</code>的代码。</p>
<p>这些都需要，<code>Impl</code>是一个完成类型。</p>
<p>解决方法：</p>
<p>把移动操作的定义移动到实现文件里</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> &#123;</span>                          <span class="hljs-comment">//仍然在“widget.h”中</span><br><span class="hljs-keyword">public</span>:<br>    Widget();<br>    ~Widget();<br><br>    Widget(Widget&amp;&amp; rhs);               <span class="hljs-comment">//只有声明</span><br>    Widget&amp; <span class="hljs-keyword">operator</span>=(Widget&amp;&amp; rhs);<br>    …<br><br><span class="hljs-keyword">private</span>:                                <span class="hljs-comment">//跟之前一样</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Impl</span>;</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;Impl&gt; pImpl;<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;                   //跟之前一样，仍然在“widget.cpp”中</span></span><br>…<br>    <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Widget</span>:</span>:Impl &#123; … &#125;;          <span class="hljs-comment">//跟之前一样</span><br><br>Widget::Widget()                    <span class="hljs-comment">//跟之前一样</span><br>: pImpl(<span class="hljs-built_in">std</span>::make_unique&lt;Impl&gt;())<br>&#123;&#125;<br><br>Widget::~Widget() = <span class="hljs-keyword">default</span>;        <span class="hljs-comment">//跟之前一样</span><br><br>Widget::Widget(Widget&amp;&amp; rhs) = <span class="hljs-keyword">default</span>;             <span class="hljs-comment">//这里定义</span><br>Widget&amp; Widget::<span class="hljs-keyword">operator</span>=(Widget&amp;&amp; rhs) = <span class="hljs-keyword">default</span>;<br></code></pre></div></td></tr></table></figure>
<h3><span id="拷贝">拷贝</span></h3>
<p>对于 <code>struct Impl</code>
中数据成员，可以使用默认拷贝函数，完成拷贝动作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> &#123;</span>                          <span class="hljs-comment">//仍然在“widget.h”中</span><br><span class="hljs-keyword">public</span>:<br>    …<br><br>    Widget(<span class="hljs-keyword">const</span> Widget&amp; rhs);          <span class="hljs-comment">//只有声明</span><br>    Widget&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Widget&amp; rhs);<br><br><span class="hljs-keyword">private</span>:                                <span class="hljs-comment">//跟之前一样</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Impl</span>;</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;Impl&gt; pImpl;<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;                   //跟之前一样，仍然在“widget.cpp”中</span></span><br>…<br>    <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Widget</span>:</span>:Impl &#123; … &#125;;          <span class="hljs-comment">//跟之前一样</span><br><br>Widget::~Widget() = <span class="hljs-keyword">default</span>;		<span class="hljs-comment">//其他函数，跟之前一样</span><br><br>Widget::Widget(<span class="hljs-keyword">const</span> Widget&amp; rhs)   <span class="hljs-comment">//拷贝构造函数</span><br>: pImpl(<span class="hljs-built_in">std</span>::make_unique&lt;Impl&gt;(*rhs.pImpl))<br>&#123;&#125;<br><br>Widget&amp; Widget::<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Widget&amp; rhs)    <span class="hljs-comment">//拷贝operator=</span><br>&#123;<br>    *pImpl = *rhs.pImpl;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>利用了编译器会为我们自动生成结构体<code>Impl</code>的复制操作函数的机制，而不是逐一复制结构体<code>Impl</code>的成员，自动生成的复制操作能自动复制每一个成员。</p>
<h3><span id="stdshared_ptr"><code>std::shared_ptr</code></span></h3>
<p>如果我们使用<code>std::shared_ptr</code>而不是<code>std::unique_ptr</code>来做<code>pImpl</code>指针，本条款的建议不再适用。</p>
<p>不需要在类<code>Widget</code>里声明析构函数，没有了用户定义析构函数，编译器将会成移动操作，并且将会如我们所期望般工作。<code>widget.h</code>里的代码如下，</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> &#123;</span>                      <span class="hljs-comment">//在“widget.h”中</span><br><span class="hljs-keyword">public</span>:<br>    Widget();<br>    …                               <span class="hljs-comment">//没有析构函数和移动操作的声明</span><br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Impl</span>;</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Impl&gt; pImpl;    <span class="hljs-comment">//用std::shared_ptr</span><br>&#125;;                                  <span class="hljs-comment">//而不是std::unique_ptr</span><br></code></pre></div></td></tr></table></figure>
<p>这是<code>#include</code>了<code>widget.h</code>的客户代码，</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">Widget w1;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">w2</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::move(w1))</span></span>;     <span class="hljs-comment">//移动构造w2</span><br>w1 = <span class="hljs-built_in">std</span>::move(w2);         <span class="hljs-comment">//移动赋值w1</span><br></code></pre></div></td></tr></table></figure>
<p>这些都能编译，并且工作地如我们所望：<code>w1</code>将会被默认构造，它的值会被移动进<code>w2</code>，随后值将会被移动回<code>w1</code>，然后两者都会被销毁（指向的<code>Widget::Impl</code>对象一并也被销毁）。</p>
<p><code>std::unique_ptr</code>和<code>std::shared_ptr</code>在<code>pImpl</code>指针上的表现上的区别的深层原因在于，他们支持自定义删除器的方式不同。</p>
<p>对<code>std::unique_ptr</code>而言，删除器的类型是这个智能指针的一部分，这让编译器有可能生成更小的运行时数据结构和更快的运行代码。
这种更高效率的后果之一就是<code>std::unique_ptr</code>指向的类型，在编译器的生成特殊成员函数（如析构函数，移动操作）被调用时，必须已经是一个完成类型。</p>
<p>而对<code>std::shared_ptr</code>而言，删除器的类型不是该智能指针的一部分，这让它会生成更大的运行时数据结构和稍微慢点的代码，但是当编译器生成的特殊成员函数被使用的时候，指向的对象不必是一个完成类型。</p>
<h3><span id="结论">结论</span></h3>
<ul>
<li>Pimpl
惯用法通过减少在类实现和类使用者之间的编译依赖来减少编译时间。</li>
<li>对于<code>std::unique_ptr</code>类型的<code>pImpl</code>指针，需要在头文件的类里声明特殊成员函数，并在实现文件中
<code>struct Impl</code>定义之后来实现他们。即使是编译器自动生成的代码可以工作，也要这么做。</li>
<li>以上的建议只适用于<code>std::unique_ptr</code>，不适用于<code>std::shared_ptr</code>。</li>
</ul>
<h2><span id="23理解stdmove和stdforward">23
理解<code>std::move</code>和<code>std::forward</code></span></h2>
<h3><span id="intro">Intro</span></h3>
<ul>
<li><p><strong>移动语义</strong>使编译器有可能用廉价的移动操作来代替昂贵的拷贝操作。正如拷贝构造函数和拷贝赋值操作符给了你控制拷贝语义的权力，移动构造函数和移动赋值操作符也给了你控制移动语义的权力。移动语义也允许创建只可移动（<em>move-only</em>）的类型，例如<code>std::unique_ptr</code>，<code>std::future</code>和<code>std::thread</code>。</p></li>
<li><p><strong>完美转发</strong>使接收任意数量实参的函数模板成为可能，它可以将实参转发到其他的函数，使目标函数接收到的实参与被传递给转发函数的实参保持一致。</p></li>
<li><p><strong>右值引用</strong>是连接这两个截然不同的概念的胶合剂。它是使移动语义和完美转发变得可能的基础语言机制。</p></li>
</ul>
<p>但是，<code>std::move</code>并不移动任何东西，完美转发也并不完美。移动操作并不永远比复制操作更廉价。构造“<code>type&amp;&amp;</code>”也并非总是代表一个右值引用。</p>
<p>非常重要的一点是要牢记形参永远是<strong>左值</strong>，即使它的类型是一个右值引用。比如，假设</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(Widget&amp;&amp; w)</span></span>;<br></code></pre></div></td></tr></table></figure>
<p>形参<code>w</code>是一个左值，即使它的类型是一个rvalue-reference-to-<code>Widget</code>。</p>
<h3><span id="stdmove和stdforward不会做什么"><code>std::move</code>和<code>std::forward</code>不会做什么</span></h3>
<p><code>std::move</code>不移动（move）任何东西，<code>std::forward</code>也不转发（forward）任何东西。在运行时，它们不做任何事情。它们不产生任何可执行代码，一字节也没有。</p>
<h3><span id="stdmove"><code>std::move</code></span></h3>
<p>C++11的<code>std::move</code>的示例实现。它并不完全满足标准细则，但是它已经非常接近了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;                            <br><span class="hljs-keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;<br>move(T&amp;&amp; param)<br>&#123;<br>    <span class="hljs-keyword">using</span> ReturnType =                          <br>        <span class="hljs-keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;ReturnType&gt;(param);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>该函数返回类型的<code>&amp;&amp;</code>部分表明<code>std::move</code>函数返回的是一个右值引用，但是，如果类型<code>T</code>恰好是一个左值引用，那么<code>T&amp;&amp;</code>将会成为一个左值引用。</p>
<p>所以，使用 <code>std::remove_reference</code>，得到
ReturnType。这保证了<code>std::move</code>返回的真的是右值引用。</p>
<p><code>std::move</code>在C++14中可以被更简单地实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">move</span><span class="hljs-params">(T&amp;&amp; param)</span>          <span class="hljs-comment">//在std命名空间</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">using</span> ReturnType = <span class="hljs-keyword">remove_referece_t</span>&lt;T&gt;&amp;&amp;;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;ReturnType&gt;(param);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>因此，<code>std::move</code>将它的实参转换为一个右值，这就是它的全部作用。</p>
<h3><span id="const-的限制"><code>const</code> 的限制</span></h3>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Annotation</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Annotation</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> text)</span></span><br>    ：value(std::move(text))    //“移动”text到value里；这段代码执行起来<br>    &#123; … &#125;                       <span class="hljs-comment">//并不是看起来那样</span><br>    <br>    …<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> value;<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>这段代码可以编译，可以链接，可以运行。</p>
<p><code>text</code>通过<code>std::move</code>被转换到右值，但是<code>text</code>被声明为<code>const std::string</code>，所以在转换之前，<code>text</code>是一个左值的<code>const std::string</code>，而转换的结果是一个右值的<code>const std::string</code></p>
<p>那么，string 对 <code>value</code> 赋值时，调用的是哪个构造函数？</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">string</span> &#123;</span>                  <span class="hljs-comment">//std::string事实上是</span><br><span class="hljs-keyword">public</span>:                         <span class="hljs-comment">//std::basic_string&lt;char&gt;的类型别名</span><br>    …<br>    <span class="hljs-built_in">string</span>(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; rhs);  <span class="hljs-comment">//拷贝构造函数</span><br>    <span class="hljs-built_in">string</span>(<span class="hljs-built_in">string</span>&amp;&amp; rhs);       <span class="hljs-comment">//移动构造函数</span><br>    …<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>右值不能被传递给<code>std::string</code>的移动构造函数，因为移动构造函数只接受一个指向<strong>non-<code>const</code></strong>的<code>std::string</code>的右值引用。</p>
<p>该右值却可以被传递给<code>std::string</code>的拷贝构造函数，因为<code>lvalue-reference-to-const</code>允许被绑定到一个<code>const</code>右值上。因此，<code>std::string</code>在成员初始化的过程中调用了<strong>拷贝</strong>构造函数。</p>
<p>可以总结出两点：</p>
<p>第一，不要在你希望能移动对象的时候，声明他们为<code>const</code>。</p>
<p>第二，<code>std::move</code>不仅不移动任何东西，而且它也不保证它执行转换的对象可以被移动。</p>
<h3><span id="stdforward"><code>std::forward</code></span></h3>
<p>与<code>std::move</code>总是<strong>无条件</strong>的将它的实参为右值不同，<code>std::forward</code>是<strong>有条件</strong>的转换。</p>
<p>最常见的情景是一个模板函数，接收一个通用引用形参（T&amp;&amp;），并将它传递给另外的函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Widget&amp; lvalArg)</span></span>;        <span class="hljs-comment">//处理左值</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(Widget&amp;&amp; rvalArg)</span></span>;             <span class="hljs-comment">//处理右值</span><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;                        <span class="hljs-comment">//用以转发param到process的模板</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">logAndProcess</span><span class="hljs-params">(T&amp;&amp; param)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> now =                              <span class="hljs-comment">//获取现在时间</span><br>        <span class="hljs-built_in">std</span>::chrono::system_clock::now();<br>    <br>    makeLogEntry(<span class="hljs-string">"Calling 'process'"</span>, now);<br>    process(<span class="hljs-built_in">std</span>::forward&lt;T&gt;(param));<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>考虑两次对<code>logAndProcess</code>的调用，一次左值为实参，一次右值为实参：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">Widget w;<br><br>logAndProcess(w);               <span class="hljs-comment">//用左值调用</span><br>logAndProcess(<span class="hljs-built_in">std</span>::move(w));    <span class="hljs-comment">//用右值调用</span><br></code></pre></div></td></tr></table></figure>
<p><code>std::forward</code> 将保留实参的值类型，传递到 process
函数，调用正确的函数重载。</p>
<h3><span id="对比">对比</span></h3>
<p>考虑一个类，我们希望统计有多少次移动构造函数被调用了。我们只需要一个<code>static</code>的计数器，它会在移动构造的时候自增。假设在这个类中，唯一一个非静态的数据成员是<code>std::string</code>，一种经典的移动构造函数（即，使用<code>std::move</code>）可以被实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    Widget(Widget&amp;&amp; rhs)<br>    : s(<span class="hljs-built_in">std</span>::move(rhs.s))<br>    &#123; ++moveCtorCalls; &#125;<br><br>    …<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> moveCtorCalls;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> s;<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>如果要用<code>std::forward</code>来达成同样的效果，代码可能会看起来像：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    Widget(Widget&amp;&amp; rhs)                    <span class="hljs-comment">//不自然，不合理的实现</span><br>    : s(<span class="hljs-built_in">std</span>::forward&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt;(rhs.s))<br>    &#123; ++moveCtorCalls; &#125;<br><br>    …<br><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><code>std::forward</code>不但需要一个函数实参（<code>rhs.s</code>），还需要一个模板类型实参<code>std::string</code>。</p>
<p><code>std::move</code>的使用代表着无条件向右值的转换，而使用<code>std::forward</code>只对绑定了右值的引用进行到右值转换。这是两种完全不同的动作。前者是典型地为了移动操作，而后者只是传递（亦为转发）一个对象到另外一个函数，保留它原有的左值属性或右值属性。</p>
<h3><span id="结论">结论</span></h3>
<ul>
<li><code>std::move</code>执行到右值的无条件的转换，但就自身而言，它不移动任何东西。</li>
<li><code>std::forward</code>只有当它的参数被绑定到一个右值时，才将参数转换为右值。</li>
<li><code>std::move</code>和<code>std::forward</code>在运行期什么也不做。</li>
</ul>
<h2><span id="24-区分通用引用与右值引用">24 区分通用引用与右值引用</span></h2>
<p>为了声明一个指向某个类型<code>T</code>的右值引用，你写下了<code>T&amp;&amp;</code>。但是，这不一定是一个右值引用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(Widget&amp;&amp; param)</span></span>;             <span class="hljs-comment">//右值引用</span><br>Widget&amp;&amp; var1 = Widget();           <span class="hljs-comment">//右值引用</span><br><span class="hljs-keyword">auto</span>&amp;&amp; var2 = var1;                 <span class="hljs-comment">//不是右值引用</span><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;T&gt;&amp;&amp; param)</span></span>;     <span class="hljs-comment">//右值引用</span><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T&amp;&amp; param)</span></span>;                  <span class="hljs-comment">//不是右值引用</span><br></code></pre></div></td></tr></table></figure>
<p>“<code>T&amp;&amp;</code>”有两种不同的意思。第一种，当然是右值引用。它们只绑定到右值上，并且它们主要的存在原因就是为了识别可以移动操作的对象。</p>
<p>“<code>T&amp;&amp;</code>”的另一种意思是，它既可以是右值引用，也可以是左值引用。它们的二重性使它们既可以绑定到右值上（就像右值引用），也可以绑定到左值上（就像左值引用）。
此外，它们还可以绑定到<code>const</code>或者non-<code>const</code>的对象上，也可以绑定到<code>volatile</code>或者non-<code>volatile</code>的对象上，甚至可以绑定到既<code>const</code>又<code>volatile</code>的对象上。它们可以绑定到几乎任何东西。它叫做<strong>通用引用</strong>（<em>universal
references</em>）。</p>
<blockquote>
<p>一些C++社区的成员已经开始将这种通用引用称之为<strong>转发引用</strong>（<em>forwarding
references</em>）</p>
<p>通用引用，其特性是<strong>引用折叠</strong>决定的。</p>
</blockquote>
<h3><span id="初始化">初始化</span></h3>
<p>通用引用是引用，所以它们必须被初始化。一个通用引用的初始值决定了它是代表了右值引用还是左值引用。如果初始值是一个右值，那么通用引用就会是对应的右值引用，如果初始值是一个左值，那么通用引用就会是一个左值引用。对那些是函数形参的通用引用来说，初始值在调用函数的时候被提供：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T&amp;&amp; param)</span></span>;              <span class="hljs-comment">//param是一个通用引用</span><br><br>Widget w;<br>f(w);                           <span class="hljs-comment">//传递给函数f一个左值；param的类型</span><br>                                <span class="hljs-comment">//将会是Widget&amp;，也即左值引用</span><br><br>f(<span class="hljs-built_in">std</span>::move(w));                <span class="hljs-comment">//传递给f一个右值；param的类型会是</span><br>                                <span class="hljs-comment">//Widget&amp;&amp;，即右值引用</span><br></code></pre></div></td></tr></table></figure>
<p>对一个通用引用而言，类型推导是必要的，但是其必须是
<code>T&amp;&amp;</code> 形式，如果是
<code>std::vector&lt;T&gt;&amp;&amp;</code> 的形式，那就变成了
右值引用。</p>
<p>而如果传入左值，那么是不能传入右值参数的。</p>
<h3><span id="一个例子">一个例子</span></h3>
<p>考虑如下<code>push_back</code>成员函数，来自<code>std::vector</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>, <span class="hljs-title">class</span> <span class="hljs-title">Allocator</span> = <span class="hljs-title">allocator</span>&lt;T&gt;&gt;   //来自<span class="hljs-title">C</span>++标准</span><br><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">vector</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(T&amp;&amp; x)</span></span>;<br>    …<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><code>push_back</code>函数的形参当然有一个通用引用的正确形式，然而，在这里并没有发生类型推导。类型推导发生在
vector 实例化时。</p>
<p>作为对比，<code>std::vector</code>内的概念上相似的成员函数<code>emplace_back</code>，却确实包含类型推导:</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>, <span class="hljs-title">class</span> <span class="hljs-title">Allocator</span> = <span class="hljs-title">allocator</span>&lt;T&gt;&gt;   //依旧来自<span class="hljs-title">C</span>++标准</span><br><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">vector</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span>... <span class="hljs-title">Args</span>&gt;</span><br><span class="hljs-class">    <span class="hljs-title">void</span> <span class="hljs-title">emplace_back</span>(<span class="hljs-title">Args</span>&amp;&amp;... <span class="hljs-title">args</span>);</span><br>    …<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>类型参数（<em>type
parameter</em>）<code>Args</code>是独立于<code>vector</code>的类型参数<code>T</code>的，所以<code>Args</code>会在每次<code>emplace_back</code>被调用的时候被推导。</p>
<p>所以，此时是一个通用引用。</p>
<h3><span id="autoampamp">auto&amp;&amp;</span></h3>
<p>类型声明为<code>auto&amp;&amp;</code>的变量是通用引用，因为会发生类型推导，并且它们具有正确形式(<code>T&amp;&amp;</code>)。<code>auto</code>类型的通用引用不如函数模板形参中的通用引用常见，但是它们在C++11中常常突然出现。而它们在C++14中出现得更多，因为C++14的<em>lambda</em>表达式可以声明<code>auto&amp;&amp;</code>类型的形参。</p>
<p>举个例子，如果你想写一个C++14标准的<em>lambda</em>表达式，来记录任意函数调用的时间开销，你可以这样写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> timeFuncInvocation =<br>    [](<span class="hljs-keyword">auto</span>&amp;&amp; func, <span class="hljs-keyword">auto</span>&amp;&amp;... params)           <span class="hljs-comment">//C++14</span><br>    &#123;<br>        start timer;<br>        <span class="hljs-built_in">std</span>::forward&lt;<span class="hljs-keyword">decltype</span>(func)&gt;(func)(     <span class="hljs-comment">//对params调用func</span><br>            <span class="hljs-built_in">std</span>::forward&lt;delctype(params)&gt;(params)...<br>        );<br>        stop timer <span class="hljs-keyword">and</span> record elapsed time;<br>    &#125;;<br></code></pre></div></td></tr></table></figure>
<h3><span id="结论">结论</span></h3>
<ul>
<li>如果一个函数模板形参的类型为<code>type&amp;&amp;</code>，并且<code>type</code>需要被推导得知，或者如果一个对象被声明为<code>auto&amp;&amp;</code>，这个形参或者对象就是一个通用引用。</li>
<li>如果类型声明的形式不是标准的<code>type&amp;&amp;</code>，或者如果类型推导没有发生，那么<code>type&amp;&amp;</code>代表一个右值引用。</li>
<li>通用引用，如果它被右值初始化，就会对应地成为右值引用；如果它被左值初始化，就会成为左值引用。</li>
</ul>
<h2><span id="25对右值引用使用stdmove对通用引用使用stdforward">25
对右值引用使用<code>std::move</code>，对通用引用使用<code>std::forward</code></span></h2>
<p>在参数传递时，<code>std::forward</code>是有条件的传递，会根据参数的类型，传递实际的参数形式，右值还是右值，左值还是左值。</p>
<p><code>std::move</code>是无条件的将其变为右值。</p>
<p>有的时候，并不一定需要对象的移动操作。区分移动和拷贝是有必要的。遇到下面这种情况：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; newName)</span>    <span class="hljs-comment">//用const左值设置</span></span><br><span class="hljs-function">    </span>&#123; name = newName; &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp;&amp; newName)</span>         <span class="hljs-comment">//用右值设置</span></span><br><span class="hljs-function">    </span>&#123; name = <span class="hljs-built_in">std</span>::move(newName); &#125;<br>    <br>    …<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>如果不用 通用引用，那么实现会变得冗长，尤其是参数数量较多的时候。</p>
<p>使用通用引用 + 完美转发 std::forward，那么实现会优雅得多。</p>
<p>并且对于变参函数模板：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>, <span class="hljs-title">class</span>... <span class="hljs-title">Args</span>&gt;                //来自<span class="hljs-title">C</span>++11标准</span><br><span class="hljs-class"><span class="hljs-title">shared_ptr</span>&lt;T&gt; <span class="hljs-title">make_shared</span>(<span class="hljs-title">Args</span>&amp;&amp;... <span class="hljs-title">args</span>);</span><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>, <span class="hljs-title">class</span>... <span class="hljs-title">Args</span>&gt;                //来自<span class="hljs-title">C</span>++14标准</span><br><span class="hljs-class"><span class="hljs-title">unique_ptr</span>&lt;T&gt; <span class="hljs-title">make_unique</span>(<span class="hljs-title">Args</span>&amp;&amp;... <span class="hljs-title">args</span>);</span><br></code></pre></div></td></tr></table></figure>
<p>对于这种函数，对于左值和右值分别重载就不能考虑了：通用引用是仅有的实现方案。对这种函数，我向你保证，肯定使用<code>std::forward</code>传递通用引用形参给其他函数。</p>
<h3><span id="返回值的情况">返回值的情况</span></h3>
<p>如果你在<strong>按值</strong>返回的函数中，返回值绑定到右值引用或者通用引用上，需要对返回的引用使用<code>std::move</code>或者<code>std::forward</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">Matrix                              <span class="hljs-comment">//按值返回</span><br><span class="hljs-keyword">operator</span>+(Matrix&amp;&amp; lhs, <span class="hljs-keyword">const</span> Matrix&amp; rhs)<br>&#123;<br>    lhs += rhs;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::move(lhs);	        <span class="hljs-comment">//移动lhs到返回值中</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>通过在<code>return</code>语句中将<code>lhs</code>转换为右值（通过<code>std::move</code>），<code>lhs</code>可以移动到返回值的内存位置。如果省略了<code>std::move</code>调用，</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">Matrix                              <span class="hljs-comment">//同之前一样</span><br><span class="hljs-keyword">operator</span>+(Matrix&amp;&amp; lhs, <span class="hljs-keyword">const</span> Matrix&amp; rhs)<br>&#123;<br>    lhs += rhs;<br>    <span class="hljs-keyword">return</span> lhs;                     <span class="hljs-comment">//拷贝lhs到返回值中</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><code>lhs</code>是个左值的事实，会强制编译器拷贝它到返回值的内存空间。</p>
<p>假定<code>Matrix</code>支持移动操作，并且比拷贝操作效率更高，在<code>return</code>语句中使用<code>std::move</code>的代码效率更高。</p>
<p>如果<code>Matrix</code>不支持移动操作，将其转换为右值不会变差，因为右值可以直接被<code>Matrix</code>的拷贝构造函数拷贝。</p>
<p>使用通用引用和<code>std::forward</code>的情况类似。考虑函数模板<code>reduceAndCopy</code>收到一个未reduce（unreduced）对象<code>Fraction</code>，将其规约，并返回一个reduce
(规约，好难听的名字) 后的副本。</p>
<p>如果原始对象是右值，可以将其移动到返回值中（避免拷贝开销），但是如果原始对象是左值，必须创建副本，因此如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>Fraction                            <span class="hljs-comment">//按值返回</span><br>reduceAndCopy(T&amp;&amp; frac)             <span class="hljs-comment">//通用引用的形参</span><br>&#123;<br>    frac.reduce();<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::forward&lt;T&gt;(frac);		<span class="hljs-comment">//移动右值，或拷贝左值到返回值中</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>如果<code>std::forward</code>被忽略，<code>frac</code>就被无条件复制到<code>reduceAndCopy</code>的返回值内存空间。</p>
<p>注意，对于函数内部的局部变量，这是不成立的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">Widget <span class="hljs-title">makeWidget</span><span class="hljs-params">()</span>                 <span class="hljs-comment">//makeWidget的“拷贝”版本</span></span><br><span class="hljs-function"></span>&#123;<br>    Widget w;                       <span class="hljs-comment">//局部对象</span><br>    …                               <span class="hljs-comment">//配置w</span><br>    <span class="hljs-keyword">return</span> w;                       <span class="hljs-comment">//“拷贝”w到返回值中</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>他们想要“优化”代码，把“拷贝”变为移动：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">Widget <span class="hljs-title">makeWidget</span><span class="hljs-params">()</span>                 <span class="hljs-comment">//makeWidget的移动版本</span></span><br><span class="hljs-function"></span>&#123;<br>    Widget w;<br>    …<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::move(w);            <span class="hljs-comment">//移动w到返回值中（不要这样做！）</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>因为有 RVO
的存在，<code>makeWidget</code>的“拷贝”版本实际上不拷贝任何东西。在返回的地址上，进行对象的构造。</p>
<p>但是 move 版本，不支持 RVO。</p>
<p>返回的已经不是局部对象<code>w</code>，而是<strong><code>w</code>的引用</strong>——<code>std::move(w)</code>的结果。</p>
<h3><span id="结论">结论</span></h3>
<ul>
<li>对于传入函数的形参，在函数内最后一次使用时，在右值引用上使用<code>std::move</code>，在通用引用上使用<code>std::forward</code>。</li>
<li>对按值返回的函数要返回的右值引用使用<code>std::move</code>，和通用引用使用<code>std::forward</code>。</li>
<li>如果局部对象可以被返回值优化消除，就绝不使用<code>std::move</code>或者<code>std::forward</code>。</li>
</ul>
<h2><span id="26-避免重载通用引用">26 避免重载通用引用</span></h2>
<h3><span id="弊端一">弊端一</span></h3>
<p>比如，下面的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">logAndAdd</span><span class="hljs-params">(T&amp;&amp; name)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> now = <span class="hljs-built_in">std</span>::chrono::system_clock::now();<br>    <span class="hljs-built_in">log</span>(now, <span class="hljs-string">"logAndAdd"</span>);<br>    names.emplace(<span class="hljs-built_in">std</span>::forward&lt;T&gt;(name));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">logAndAdd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> idx)</span>             <span class="hljs-comment">//新的重载</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> now = <span class="hljs-built_in">std</span>::chrono::system_clock::now();<br>    <span class="hljs-built_in">log</span>(now, <span class="hljs-string">"logAndAdd"</span>);<br>    names.emplace(nameFromIdx(idx));<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>如果有以下调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">short nameIdx;<br><br>logAndAdd(nameIdx);                     <span class="hljs-comment">//错误！</span><br></code></pre></div></td></tr></table></figure>
<p>由于没有 short
类型的重载，但是有通用引用存在，所以<code>name</code>形参绑定到要传入的<code>short</code>上，然后<code>name</code>被<code>std::forward</code>给<code>names</code>（一个<code>std::multiset&lt;std::string&gt;</code>）的<code>emplace</code>成员函数，然后又被转发给<code>std::string</code>构造函数。<code>std::string</code>没有接受<code>short</code>的构造函数，所以<code>logAndAdd</code>调用里的<code>multiset::emplace</code>调用里的<code>std::string</code>构造函数调用失败。</p>
<p>所有这一切的原因就是对于<code>short</code>类型通用引用重载优先于<code>int</code>类型的重载。这导致了代码执行出错。</p>
<p>使用通用引用的函数在C++中是最贪婪的函数。它们几乎可以精确匹配任何类型的实参。</p>
<p>通用引用的实现会匹配比开发者预期要多得多的实参类型。</p>
<h3><span id="弊端二">弊端二</span></h3>
<p>有以下<code>Person</code>类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Person</span><span class="hljs-params">(T&amp;&amp; n)</span>              <span class="hljs-comment">//完美转发的构造函数，初始化数据成员</span></span><br><span class="hljs-function">    : <span class="hljs-title">name</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::forward&lt;T&gt;(n))</span> </span>&#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Person</span><span class="hljs-params">(<span class="hljs-keyword">int</span> idx)</span>            <span class="hljs-comment">//int的构造函数</span></span><br><span class="hljs-function">    : <span class="hljs-title">name</span><span class="hljs-params">(nameFromIdx(idx))</span> </span>&#123;&#125;<br>    …<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> name;<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>函数模板能实例化产生与拷贝和移动构造函数一样的签名。如果拷贝和移动构造被生成，<code>Person</code>类看起来就像这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;            <span class="hljs-comment">//完美转发的构造函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Person</span><span class="hljs-params">(T&amp;&amp; n)</span></span><br><span class="hljs-function">    : <span class="hljs-title">name</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::forward&lt;T&gt;(n))</span> </span>&#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Person</span><span class="hljs-params">(<span class="hljs-keyword">int</span> idx)</span></span>;       <span class="hljs-comment">//int的构造函数</span><br><br>    Person(<span class="hljs-keyword">const</span> Person&amp; rhs);      <span class="hljs-comment">//拷贝构造函数</span><br>    Person(Person&amp;&amp; rhs);           <span class="hljs-comment">//移动构造函数</span><br>    …<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>如果通过 non-<code>const</code>左值类型的<code>Person</code>
来拷贝构造一个新的对象，完美转发的构造函数会优先匹配。</p>
<p>如果通过 <code>const</code>左值类型的<code>Person</code>
来拷贝构造一个新的对象，拷贝构造函数会优先匹配，因为这是精确匹配。</p>
<p>如果在继承关系中，会有以下行为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpecialPerson</span>:</span> <span class="hljs-keyword">public</span> Person &#123;<br><span class="hljs-keyword">public</span>:<br>    SpecialPerson(<span class="hljs-keyword">const</span> SpecialPerson&amp; rhs) <span class="hljs-comment">//拷贝构造函数，调用基类的</span><br>    : Person(rhs)                           <span class="hljs-comment">//基类的完美转发构造函数！</span><br>    &#123; … &#125;<br><br>    SpecialPerson(SpecialPerson&amp;&amp; rhs)      <span class="hljs-comment">//移动构造函数，调用基类的</span><br>    : Person(<span class="hljs-built_in">std</span>::move(rhs))                <span class="hljs-comment">//基类的完美转发构造函数！</span><br>    &#123; … &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>派生类的拷贝和移动构造函数没有调用基类的<strong>拷贝和移动构造函数</strong>，而是调用了基类的<strong>完美转发构造函数</strong>。</p>
<p>派生类将<code>SpecialPerson</code>类型的实参传递给其基类，然后通过模板实例化和重载解析规则作用于基类<code>Person</code>。最终，代码无法编译，因为<code>std::string</code>没有接受一个<code>SpecialPerson</code>的构造函数（只有完美转发构造函数初始化了
<code>name</code> ）。</p>
<h3><span id="结论">结论</span></h3>
<ul>
<li>对通用引用形参的函数进行重载时，通用引用函数可匹配的类型，几乎总会比你期望的多得多。</li>
<li>完美转发构造函数是糟糕的实现，因为对于non-<code>const</code>左值，它们会优先于拷贝构造函数匹配，而且会劫持派生类对于基类的拷贝和移动构造函数的调用。</li>
</ul>
<h2><span id="27-通用引用重载的替代方法">27 通用引用重载的替代方法</span></h2>
<p>一个直接的思路，放弃重载，另外声明一个函数签名。</p>
<p>另一种思路，放弃重载，但是使用 lvalue-refrence-to-<code>const</code>
的方式，参数类型变为 const T&amp;。</p>
<p>放弃重载的另一种思路是，直接传值 +
<code>std::mov</code>，的方式。</p>
<p>另外两种方案，保留了重载，但是都有局限，效率更高但是并不是万能的。这两种方案是：<code>tag dispatch</code>
和 <code>enable_if 约束模板</code>。</p>
<h3><span id="tag-dispath">tag dispath</span></h3>
<p>实现形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">logAndAdd</span><span class="hljs-params">(T&amp;&amp; name)</span></span><br><span class="hljs-function"></span>&#123;<br>    logAndAddImpl(<br>        <span class="hljs-built_in">std</span>::forward&lt;T&gt;(name),<br>        <span class="hljs-built_in">std</span>::is_integral&lt;<span class="hljs-keyword">typename</span> <span class="hljs-built_in">std</span>::remove_reference&lt;T&gt;::type&gt;()<br>        <span class="hljs-comment">// C++14 </span><br>        <span class="hljs-comment">// std::is_integral&lt;std::remove_reference&lt;T&gt;&gt;()</span><br>    );<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>原来函数模板不变，但是将实际的函数调用，进行了分发（dispatch）。</p>
<p>之所以 remove_reference，是因为 T 可能被推导为左值 T&amp;，这不是
<code>type trait</code> <code>std::is_integral</code>
识别为真的类型。</p>
<p>分发实现为：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;                            <span class="hljs-comment">//非整型实参：添加到全局数据结构中</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">logAndAddImpl</span><span class="hljs-params">(T&amp;&amp; name, <span class="hljs-built_in">std</span>::false_type)</span>	</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> now = <span class="hljs-built_in">std</span>::chrono::system_clock::now();<br>    <span class="hljs-built_in">log</span>(now, <span class="hljs-string">"logAndAdd"</span>);<br>    names.emplace(<span class="hljs-built_in">std</span>::forward&lt;T&gt;(name));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title">nameFromIdx</span><span class="hljs-params">(<span class="hljs-keyword">int</span> idx)</span></span>;           <span class="hljs-comment">// 整型实参：查找名字并用它调用logAndAdd</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">logAndAddImpl</span><span class="hljs-params">(<span class="hljs-keyword">int</span> idx, <span class="hljs-built_in">std</span>::true_type)</span> </span><br><span class="hljs-function"></span>&#123;<br>  logAndAdd(nameFromIdx(idx)); <br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>这里的 <code>std::false_type</code> 和 <code>std::true_type</code>
，是 T 分别在不满足 <code>std::is_integral</code>和满足
<code>std::is_integral</code> 的情况下的父类。</p>
<h3><span id="enable_if-约束模板">enable_if 约束模板</span></h3>
<p>tag dispath 并不能解决父类的通用引用重载函数的问题（见上一条款
26）。</p>
<p>enable_if 约束模板，基于以下机制：</p>
<p>默认情况下，所有模板是<strong>启用</strong>的（enabled），但是使用<code>std::enable_if</code>可以使得仅在<code>std::enable_if</code>指定的条件满足时模板才启用。不满足条件，模板就是被<strong>禁止</strong>（disabled）的。</p>
<p>首先解决传入 Person 类对象，导致通用引用重载中，string 用 Person
对象初始化报错的问题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// C++11</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">template</span>&lt;<br>        <span class="hljs-keyword">typename</span> T,<br>        <span class="hljs-keyword">typename</span> = <span class="hljs-keyword">typename</span> <span class="hljs-built_in">std</span>::enable_if&lt;<br>            		   <span class="hljs-comment">// !std::is_base_of&lt;Person, </span><br>                       !<span class="hljs-built_in">std</span>::is_base_of&lt;Person, <br>                                        <span class="hljs-keyword">typename</span> <span class="hljs-built_in">std</span>::decay&lt;T&gt;::type<br>                                       &gt;::value<br>                   &gt;::type<br>    &gt;<br>    <span class="hljs-keyword">explicit</span> Person(T&amp;&amp; n);<br>    …<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>使用 <code>type trait</code> <code>is_same</code> ，可以在传入 Person
对象时，禁用模板。但是，传入子类对象，同样时不允许的，所以使用了
<code>std::is_base_of</code>。</p>
<p><code>std::decay&lt;T&gt;</code>
去掉了对于<code>T</code>的引用，<code>const</code>，<code>volatile</code>修饰。</p>
<p>再结合对传入 int 类型参数的限制，可以的得到下面的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">template</span>&lt;<br>        <span class="hljs-keyword">typename</span> T,<br>        <span class="hljs-keyword">typename</span> = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">enable_if_t</span>&lt;<br>            !<span class="hljs-built_in">std</span>::is_base_of&lt;Person, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">decay_t</span>&lt;T&gt;&gt;::value<br>            &amp;&amp;<br>            !<span class="hljs-built_in">std</span>::is_integral&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">remove_reference_t</span>&lt;T&gt;&gt;::value<br>        &gt;<br>    &gt;<br>    <span class="hljs-keyword">explicit</span> Person(T&amp;&amp; n)          <br>    : name(<span class="hljs-built_in">std</span>::forward&lt;T&gt;(n))      <span class="hljs-comment">//std::strings的实参的构造函数</span><br>    &#123;<br>        <span class="hljs-comment">//断言可以用T对象创建std::string</span><br>        <span class="hljs-keyword">static_assert</span>(<br>        <span class="hljs-built_in">std</span>::is_constructible&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>, T&gt;::value,<br>        <span class="hljs-string">"Parameter n can't be used to construct a std::string"</span><br>        );<br>        ...<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Person</span><span class="hljs-params">(<span class="hljs-keyword">int</span> idx)</span>        <span class="hljs-comment">//整型实参的构造函数</span></span><br><span class="hljs-function">    : <span class="hljs-title">name</span><span class="hljs-params">(nameFromIdx(idx))</span></span><br><span class="hljs-function">    </span>&#123; … &#125;<br><br>    …                               <span class="hljs-comment">//拷贝、移动构造函数等</span><br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> name;<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>其中：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">bool</span> B, <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span> = <span class="hljs-title">void</span> &gt;</span><br><span class="hljs-class"><span class="hljs-title">using</span> <span class="hljs-title">enable_if_t</span> = <span class="hljs-title">typename</span> <span class="hljs-title">enable_if</span>&lt;B,T&gt;:</span>:type; <span class="hljs-comment">// (since C++14)</span><br></code></pre></div></td></tr></table></figure>
</blockquote>
<p>这里的 <code>static_assert</code> 断言虽然可以识别，T
类型是否可以构建 string，但是这发生在
<code>name(std::forward&lt;T&gt;(n))</code>
之后。所以，报错先于断言。</p>
<h3><span id="结论">结论</span></h3>
<ul>
<li>通用引用重载的替代方法：使用不同的函数名，通过lvalue-reference-to-<code>const</code>传递形参，按值传递形参，使用<em>tag
dispatch</em>，使用 <code>enable_if</code> 约束模板。</li>
<li>通用引用参数通常具有高效率的优势，但是其使用需要仔细分析。</li>
</ul>
<h2><span id="28-引用折叠">28 引用折叠</span></h2>
<p>目的就是禁止你生成引用的引用。</p>
<p>存在两种类型的引用（左值和右值），所以有四种可能的引用组合（左值的左值，左值的右值，右值的右值，右值的左值）。</p>
<p>这些组合的的结果：如果两个中任一引用为左值引用，则结果为左值引用。否则（即，如果引用都是右值引用），结果为右值引用。</p>
<table>
<thead>
<tr class="header">
<th>组合</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>左值的右值</td>
<td>左值</td>
</tr>
<tr class="even">
<td>左值的左值</td>
<td>左值</td>
</tr>
<tr class="odd">
<td>右值的左值</td>
<td>左值</td>
</tr>
<tr class="even">
<td>右值的右值</td>
<td>右值</td>
</tr>
</tbody>
</table>
<h3><span id="stdforword实现">std::forword实现</span></h3>
<p><code>std::forward</code>应用在通用引用参数上，所以经常能看到这样使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T&amp;&amp; fParam)</span></span><br><span class="hljs-function"></span>&#123;<br>    …                                   <span class="hljs-comment">//做些工作</span><br>    someFunc(<span class="hljs-built_in">std</span>::forward&lt;T&gt;(fParam));  <span class="hljs-comment">//转发fParam到someFunc</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>因为<code>fParam</code>是通用引用，类型参数<code>T</code>的类型根据<code>f</code>被传入实参（即用来实例化<code>fParam</code>的表达式）是左值还是右值来决定。</p>
<p><code>std::forward</code>的作用是当且仅当传给<code>f</code>的实参为右值时（此时<code>T</code>为非引用类型），才将<code>fParam</code>转化为一个右值。</p>
<p><code>std::forward</code>可以这样实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;                                <span class="hljs-comment">//在std命名空间</span><br><span class="hljs-function">T&amp;&amp; <span class="hljs-title">forward</span><span class="hljs-params">(<span class="hljs-keyword">typename</span> remove_reference&lt;T&gt;::type&amp; param)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;T&amp;&amp;&gt;(param);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>在C++14中，<code>std::remove_reference_t</code>的存在使得实现变得更简洁：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;                        <span class="hljs-comment">//C++14；仍然在std命名空间</span><br><span class="hljs-function">T&amp;&amp; <span class="hljs-title">forward</span><span class="hljs-params">(<span class="hljs-keyword">remove_reference_t</span>&lt;T&gt;&amp; param)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;T&amp;&amp;&gt;(param);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>假设传入到<code>f</code>的实参是<code>Widget</code>的左值类型。<code>T</code>被推导为<code>Widget&amp;</code>，然后调用<code>std::forward</code>将实例化为<code>std::forward&lt;Widget&amp;&gt;</code>。</p>
<p><code>Widget&amp;</code>带入到上面的<code>std::forward</code>的实现中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">Widget&amp; &amp;&amp; <span class="hljs-title">forward</span><span class="hljs-params">(<span class="hljs-keyword">typename</span> </span></span><br><span class="hljs-function"><span class="hljs-params">                       remove_reference&lt;Widget&amp;&gt;::type&amp; param)</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;Widget&amp; &amp;&amp;&gt;(param); &#125;<br></code></pre></div></td></tr></table></figure>
<p><code>std::remove_reference&lt;Widget&amp;&gt;::type</code>这个<em>type
trait</em>产生<code>Widget</code>
，所以<code>std::forward</code>成为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">Widget&amp; &amp;&amp; <span class="hljs-title">forward</span><span class="hljs-params">(Widget&amp; param)</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;Widget&amp; &amp;&amp;&gt;(param); &#125;<br></code></pre></div></td></tr></table></figure>
<p>根据引用折叠规则，返回值和强制转换可以化简，最终版本的<code>std::forward</code>调用就是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">Widget&amp; <span class="hljs-title">forward</span><span class="hljs-params">(Widget&amp; param)</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;Widget&amp;&gt;(param); &#125;<br></code></pre></div></td></tr></table></figure>
<p>当左值实参被传入到函数模板<code>f</code>时，<code>std::forward</code>被实例化为接受和返回左值引用。</p>
<p>如果传入右值，那么结果会是这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">Widget&amp;&amp; <span class="hljs-title">forward</span><span class="hljs-params">(Widget&amp; param)</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;Widget&amp;&amp;&gt;(param); &#125;<br></code></pre></div></td></tr></table></figure>
<h3><span id="auto">auto</span></h3>
<p>在auto的写法中，规则是类似的。声明</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span>&amp;&amp; w1 = w;<br></code></pre></div></td></tr></table></figure>
<p>用一个左值初始化<code>w1</code>，因此为<code>auto</code>推导出类型<code>Widget&amp;</code>。把<code>Widget&amp;</code>代回<code>w1</code>声明中的<code>auto</code>里，产生了引用的引用，</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">Widget&amp; &amp;&amp; w1 = w;<br></code></pre></div></td></tr></table></figure>
<p>应用引用折叠规则，就是</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">Widget&amp; w1 = w<br></code></pre></div></td></tr></table></figure>
<p>结果就是<code>w1</code>是一个左值引用。</p>
<p>下面这个声明，</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span>&amp;&amp; w2 = widgetFactory();<br></code></pre></div></td></tr></table></figure>
<p>使用右值初始化<code>w2</code>，为<code>auto</code>推导出非引用类型<code>Widget</code>。把<code>Widget</code>代入<code>auto</code>得到：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">Widget&amp;&amp; w2 = widgetFactory()<br></code></pre></div></td></tr></table></figure>
<p>没有引用的引用，这就是最终结果，<code>w2</code>是个右值引用。</p>
<h3><span id="通用引用">通用引用</span></h3>
<p>通用引用不是一种新的引用，它实际上是满足以下两个条件下的右值引用：</p>
<ul>
<li><strong>类型推导区分左值和右值</strong>。<code>T</code>类型的左值被推导为<code>T&amp;</code>类型，<code>T</code>类型的右值被推导为<code>T</code>。</li>
<li><strong>发生引用折叠</strong>。</li>
</ul>
<h3><span id="结论">结论</span></h3>
<ul>
<li>引用折叠发生在四种情况下：模板实例化，<code>auto</code>类型推导，<code>typedef</code>与别名声明的创建和使用，<code>decltype</code>。</li>
<li>当编译器在引用折叠环境中生成了引用的引用时，结果就是单个引用。带有左值引用的引用折叠，结果就是左值引用。否则就是右值引用。</li>
<li>通用引用就是引用折叠的结果。</li>
</ul>
<h2><span id="29-移动操作的缺点">29 移动操作的缺点</span></h2>
<h3><span id="升级c11之前的代码">升级C++11之前的代码</span></h3>
<p>C++11倾向于为缺少移动操作的类生成它们，但是只有在<strong>没有声明复制操作，移动操作，析构函数的类</strong>中才会生成移动操作。</p>
<p>另外数据成员或者某类型的基类禁止移动操作，编译器不生成移动操作的支持。</p>
<p>所以，对于没有明确支持移动操作的类型，并且不符合编译器默认生成的条件的类，没有理由期望C++11会比C++98进行任何性能上的提升。</p>
<h3><span id="移动大对象">移动大对象</span></h3>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;Widget&gt; vm1;<br><br><span class="hljs-comment">//把数据存进vw1</span><br>…<br><br><span class="hljs-comment">//把vw1移动到vw2。以常数时间运行。只有vw1和vw2中的指针被改变</span><br><span class="hljs-keyword">auto</span> vm2 = <span class="hljs-built_in">std</span>::move(vm1);<br></code></pre></div></td></tr></table></figure>
<p><code>std::array</code>没有这种指针实现，数据就保存在<code>std::array</code>对象中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">array</span>&lt;Widget, 10000&gt; aw1;<br><br><span class="hljs-comment">//把数据存进aw1</span><br>…<br><br><span class="hljs-comment">//把aw1移动到aw2。以线性时间运行。aw1中所有元素被移动到aw2</span><br><span class="hljs-keyword">auto</span> aw2 = <span class="hljs-built_in">std</span>::move(aw1);<br></code></pre></div></td></tr></table></figure>
<p>移动还是遍历了所有元素。</p>
<h3><span id="移动小字符串">移动小字符串</span></h3>
<p><code>std::string</code>提供了常数时间的移动操作和线性时间的复制操作。</p>
<p>许多字符串的实现采用了小字符串优化（<em>small string
optimization</em>，SSO）。“小”字符串（比如长度小于15个字符的）存储在了<code>std::string</code>的缓冲区中，并没有存储在堆内存，移动这种存储的字符串并不比复制操作更快（并不会执行指针的复制，而是将字符串完全从一个位置拷贝到另一个位置，再清空原来的内存）。</p>
<h3><span id="结论">结论</span></h3>
<p>C++11的移动语义并无优势：</p>
<ul>
<li><p><strong>没有移动操作</strong>：要移动的对象没有提供移动操作，所以移动的写法也会变成复制操作。</p></li>
<li><p><strong>移动不会更快</strong>：要移动的对象提供的移动操作并不比复制速度更快。</p></li>
<li><p><strong>移动不可用</strong>：进行移动的上下文要求移动操作不会抛出异常，但是该操作没有被声明为<code>noexcept</code>。</p></li>
<li><p><strong>源对象是左值</strong>：除了极少数的情况外，只有右值可以作为移动操作的来源。</p></li>
</ul>
<h2><span id="30-完美转发失败的情况">30 完美转发失败的情况</span></h2>
<p><strong>完美转发</strong>（<em>perfect
forwarding</em>）意味着我们不仅转发对象，我们还转发显著的特征：它们的类型，是左值还是右值，是<code>const</code>还是<code>volatile</code>。</p>
<p>有以下函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Ts&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fwd</span><span class="hljs-params">(Ts&amp;&amp;... params)</span>            <span class="hljs-comment">//接受任何实参</span></span><br><span class="hljs-function"></span>&#123;<br>    f(<span class="hljs-built_in">std</span>::forward&lt;Ts&gt;(params)...); <span class="hljs-comment">//转发给f</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>讨论下面函数调用失败的情况：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">f( expression );        <span class="hljs-comment">//调用f执行某个操作</span><br>fwd( expression );		<span class="hljs-comment">//但调用fwd执行另一个操作，则fwd不能完美转发expression给f</span><br></code></pre></div></td></tr></table></figure>
<h3><span id="花括号初始化器">花括号初始化器</span></h3>
<p>假定<code>f</code>这样声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; v)</span></span>;<br></code></pre></div></td></tr></table></figure>
<p>在这个例子中，用花括号初始化调用<code>f</code>通过编译，</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">f(&#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;);         <span class="hljs-comment">//可以，“&#123;1, 2, 3&#125;”隐式转换为std::vector&lt;int&gt;</span><br></code></pre></div></td></tr></table></figure>
<p>但是传递相同的列表初始化给fwd不能编译</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">fwd(&#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;);       <span class="hljs-comment">//错误！不能编译</span><br></code></pre></div></td></tr></table></figure>
<p>当通过调用函数模板<code>fwd</code>间接调用<code>f</code>时，编译器不再把调用地传入给<code>fwd</code>的实参和<code>f</code>的声明中形参类型进行比较。</p>
<p>而是<strong>推导</strong>传入给<code>fwd</code>的实参类型，然后比较推导后的实参类型和<code>f</code>的形参声明类型。</p>
<p>编译器不允许在对<code>fwd</code>的调用中推导表达式<code>{ 1, 2, 3 }</code>的类型，因为<code>fwd</code>的形参没有声明为<code>std::initializer_list</code>。对于<code>fwd</code>形参的推导类型被阻止，编译器只能拒绝该调用。</p>
<p>但是，使用花括号初始化的<code>auto</code>的变量的类型推导是成功的。这种变量被视为<code>std::initializer_list</code>对象，在转发函数应推导出类型为<code>std::initializer_list</code>的情况，这提供了一种简单的解决方法——使用<code>auto</code>声明一个局部变量，然后将局部变量传进转发函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> il = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;;  <span class="hljs-comment">//il的类型被推导为std::initializer_list&lt;int&gt;</span><br>fwd(il);                <span class="hljs-comment">//可以，完美转发il给f</span><br></code></pre></div></td></tr></table></figure>
<h3><span id="0或者null"><code>0</code>或者<code>NULL</code></span></h3>
<p>当你试图传递<code>0</code>或者<code>NULL</code>作为空指针给模板时，类型推导会出错，会把传来的实参推导为一个整型类型（典型情况为<code>int</code>）而不是指针类型。结果就是不管是<code>0</code>还是<code>NULL</code>都不能作为空指针被完美转发。解决方法非常简单，传一个<code>nullptr</code>而不是<code>0</code>或者<code>NULL</code>。</p>
<h3><span id="只有声明的-static-const数据成员">只有声明的 static const
数据成员</span></h3>
<p>下面的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> MinVals = <span class="hljs-number">28</span>;  <span class="hljs-comment">//MinVal的声明</span><br>    …<br>&#125;;<br>…                                           <span class="hljs-comment">//没有MinVals定义</span><br><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; widgetData;<br>widgetData.reserve(Widget::MinVals);        <span class="hljs-comment">//使用MinVals</span><br></code></pre></div></td></tr></table></figure>
<p>使用<code>MinVals</code>调用<code>f</code>是可以的，因为编译器直接将值28代替<code>MinVals</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">f(Widget::MinVals);         <span class="hljs-comment">//可以，视为“f(28)”</span><br></code></pre></div></td></tr></table></figure>
<p>不过如果我们尝试通过<code>fwd</code>调用<code>f</code>，事情不会进展那么顺利：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">fwd(Widget::MinVals);       <span class="hljs-comment">//错误！</span><br></code></pre></div></td></tr></table></figure>
<p>代码可以编译，但是不应该链接。</p>
<p>尽管代码中没有使用<code>MinVals</code>的地址，但是<code>fwd</code>的形参是通用引用。</p>
<p>而引用，在编译器生成的代码中，通常被视作指针。</p>
<p>在程序的二进制底层代码中（以及硬件中）指针和引用是一样的。在这个水平上，引用只是可以自动解引用的指针。在这种情况下，通过引用传递<code>MinVals</code>实际上与通过指针传递<code>MinVals</code>是一样的，因此，必须有内存使得指针可以指向。</p>
<p>链接时，链接不到内存，就会报错。</p>
<p>只要给整型<code>static const</code>提供一个定义，就可以解决问题了，比如这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> Widget::MinVals;  <span class="hljs-comment">//在Widget的.cpp文件</span><br></code></pre></div></td></tr></table></figure>
<p>注意定义中不要重复初始化。如果在两个地方都提供了初始化，编译器就会报错，提醒你只能初始化一次。</p>
<h3><span id="重载函数的名称和模板名称">重载函数的名称和模板名称</span></h3>
<p>假设有了一个重载函数，<code>processVal</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> (*pf)(<span class="hljs-keyword">int</span>))</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">processVal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">processVal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value, <span class="hljs-keyword">int</span> priority)</span></span>;<br></code></pre></div></td></tr></table></figure>
<p>传递给 <code>f</code>
是没问题的，因为编译器是可以基于现有信息判断调用哪一个重载函数的。</p>
<p>但是，<code>fwd(processVal);</code> 不行。
单用<code>processVal</code>是没有类型信息的，所以就不能类型推导，完美转发失败。</p>
<p>需要这样使用：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> ProcessFuncType = <span class="hljs-keyword">int</span> (*)(<span class="hljs-keyword">int</span>);<br><br>ProcessFuncType processValPtr = processVal;     <span class="hljs-comment">//指定所需的processVal签名</span><br><br>fwd(processValPtr);                             <span class="hljs-comment">//可以</span><br>fwd(<span class="hljs-keyword">static_cast</span>&lt;ProcessFuncType&gt;(workOnVal));   <span class="hljs-comment">//也可以</span><br></code></pre></div></td></tr></table></figure>
<p>对于模板，有相似的问题。一个函数模板不代表单独一个函数，它表示一个函数族：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function">T <span class="hljs-title">workOnVal</span><span class="hljs-params">(T param)</span>                <span class="hljs-comment">//处理值的模板</span></span><br><span class="hljs-function"></span>&#123; … &#125;<br><br>fwd(workOnVal);                     <span class="hljs-comment">//错误！哪个workOnVal实例？</span><br></code></pre></div></td></tr></table></figure>
<p>要让像<code>fwd</code>的完美转发函数接受一个重载函数名或者模板名，方法是指定要转发的那个重载或者实例。</p>
<h3><span id="位域">位域</span></h3>
<p>IPv4的头部有如下模型：（假定位域是按从最低有效位（<em>least
significant bit</em>，lsb）到最高有效位（<em>most significant
bit</em>，msb）</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IPv4Header</span> &#123;</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span> version:<span class="hljs-number">4</span>,<br>                  IHL:<span class="hljs-number">4</span>,<br>                  DSCP:<span class="hljs-number">6</span>,<br>                  ECN:<span class="hljs-number">2</span>,<br>                  totalLength:<span class="hljs-number">16</span>;<br>    …<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>如果声明我们的函数<code>f</code>（转发函数<code>fwd</code>的目标）为接收一个<code>std::size_t</code>的形参，则使用<code>IPv4Header</code>对象的<code>totalLength</code>字段进行调用没有问题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> sz)</span></span>;         <span class="hljs-comment">//要调用的函数</span><br><br>IPv4Header h;<br>…<br>f(h.totalLength);               <span class="hljs-comment">//可以</span><br></code></pre></div></td></tr></table></figure>
<p>如果通过<code>fwd</code>转发<code>h.totalLength</code>给<code>f</code>呢，那就是一个不同的情况了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">fwd(h.totalLength);             <span class="hljs-comment">//错误！</span><br></code></pre></div></td></tr></table></figure>
<p>问题在于<code>fwd</code>的形参是引用，而<code>h.totalLength</code>是non-<code>const</code>位域，这是C++不允许的行为。</p>
<p>位域可能包含了一个字的任意部分（比如32位<code>int</code>的3-5位），但是这些东西无法直接寻址。在硬件层面引用和指针是一样的，所以没有办法创建一个指向任意<em>bit</em>的指针。</p>
<p>传递位域给完美转发的方法就是，创建副本然后利用副本调用完美转发。在<code>IPv4Header</code>的例子中，可以如下写法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//拷贝位域值</span><br><span class="hljs-keyword">auto</span> length = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint16_t</span>&gt;(h.totalLength);<br><br>fwd(length);                    <span class="hljs-comment">//转发这个副本</span><br></code></pre></div></td></tr></table></figure>
<h3><span id="结论">结论</span></h3>
<ul>
<li>导致完美转发失败的实参种类有：花括号初始化，作为空指针的<code>0</code>或者<code>NULL</code>，仅有声明的<code>static const</code>数据成员，模板和重载函数的名字，位域。</li>
</ul>
<h2><span id="30-lambda-表达式">30 Lambda 表达式</span></h2>
<p><strong>闭包</strong>（<em>enclosure</em>）是<em>lambda</em>创建的运行时对象。依赖捕获模式，闭包持有被捕获数据的副本或者引用。</p>
<p><strong>闭包类</strong>（<em>closure
class</em>）是从中实例化闭包的类。每个<em>lambda</em>都会使编译器生成唯一的闭包类。<em>lambda</em>中的语句成为其闭包类的成员函数中的可执行指令。</p>
<p><em>lambda</em>通常被用来创建闭包，该闭包仅用作函数的实参。闭包通常可以拷贝，所以可能有多个闭包对应于一个<em>lambda</em>。</p>
<p>但是对于闭包，需要明白的一点是：区分什么存在于编译期（<em>lambdas</em>
和闭包类），什么存在于运行时（闭包）以及它们之间的相互关系。</p>
<h3><span id="避免使用默认的捕获模式">避免使用默认的捕获模式</span></h3>
<p>按默认引用捕获会导致闭包中包含了对某个局部变量或者形参的引用。如果该<em>lambda</em>创建的闭包生命周期超过了局部变量，那么闭包中的引用将会变成悬空引用。</p>
<p>另外，成员函数中，使用捕获需要明白 <code>this</code>
指针的存在，直接捕获成员变量是会出错的。</p>
<p>一个解决方案是：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Widget::addFilter</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> divisorCopy = divisor;                 <span class="hljs-comment">//拷贝数据成员</span><br><br>    filters.emplace_back(<br>        [divisorCopy](<span class="hljs-keyword">int</span> value)                <span class="hljs-comment">//捕获副本</span><br>        &#123; <span class="hljs-keyword">return</span> value % divisorCopy == <span class="hljs-number">0</span>; &#125;	<span class="hljs-comment">//使用副本</span><br>    );<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>在C++14中，一个更好的捕获成员变量的方式时使用通用的<em>lambda</em>捕获：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Widget::addFilter</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span><br><span class="hljs-function"></span>&#123;<br>    filters.emplace_back(                   <span class="hljs-comment">//C++14：</span><br>        [divisor = divisor](<span class="hljs-keyword">int</span> value)      <span class="hljs-comment">//拷贝divisor到闭包</span><br>        &#123; <span class="hljs-keyword">return</span> value % divisor == <span class="hljs-number">0</span>; &#125;	<span class="hljs-comment">//使用这个副本</span><br>    );<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>如果是 static 成员，那么默认捕获行为将什么也不会捕获。</p>
<h3><span id="结论">结论</span></h3>
<ul>
<li>默认的按引用捕获可能会导致悬空引用。</li>
<li>默认的按值捕获对于悬空指针很敏感（尤其是<code>this</code>指针），并且它会误导人产生<em>lambda</em>是独立的想法。</li>
</ul>
<h2><span id="31-使用-init-capture来移动对象到闭包">31 使用 init capture
来移动对象到闭包</span></h2>
<p>在某些场景下，按值捕获和按引用捕获都不是你所想要的。如果你有一个只能被移动的对象（例如<code>std::unique_ptr</code>或<code>std::future</code>）要进入到闭包里，使用C++11是无法实现的。到了C++14就另一回事了，它能支持将对象移动到闭包中。</p>
<h3><span id="init-capture">init capture</span></h3>
<p>C++14中，这是使用初始化捕获将<code>std::unique_ptr</code>移动到闭包中的方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> &#123;</span>                          <span class="hljs-comment">//一些有用的类型</span><br><span class="hljs-keyword">public</span>:<br>    …<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isValidated</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isProcessed</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isArchived</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br><span class="hljs-keyword">private</span>:<br>    …<br>&#125;;<br><br><span class="hljs-keyword">auto</span> pw = <span class="hljs-built_in">std</span>::make_unique&lt;Widget&gt;();   <span class="hljs-comment">//创建Widget；使用std::make_unique</span><br>                                        <span class="hljs-comment">//的有关信息参见条款21</span><br><br>…                                       <span class="hljs-comment">//设置*pw</span><br><br><span class="hljs-keyword">auto</span> func = [pw = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(pw)]        <span class="hljs-comment">//使用std::move(pw)初始化闭包数据成员</span><br>            &#123; <span class="hljs-keyword">return</span> pw-&gt;isValidated()<br>                     &amp;&amp; pw-&gt;isArchived(); &#125;;<br></code></pre></div></td></tr></table></figure>
<p>“<code>pw = std::move(pw)</code>”的意思是“在闭包中创建一个数据成员<code>pw</code>，并使用将<code>std::move</code>应用于局部变量<code>pw</code>的结果来初始化该数据成员”。</p>
<p>在C++11中，无法捕获表达式的结果。
因此，初始化捕获的另一个名称是<strong>通用<em>lambda</em>捕获</strong>（<em>generalized
lambda capture</em>）。</p>
<p><em>lambda</em>表达式只是生成一个类和创建该类型对象的一种简单方式而已。没什么是你用<em>lambda</em>可以做而不能自己手动实现的。</p>
<p>C++14的示例代码可以用C++11重新编写，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IsValAndArch</span> &#123;</span>                            <span class="hljs-comment">//“is validated and archived”</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> DataType = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;Widget&gt;;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">IsValAndArch</span><span class="hljs-params">(DataType&amp;&amp; ptr)</span>       <span class="hljs-comment">//条款25解释了std::move的使用</span></span><br><span class="hljs-function">    : <span class="hljs-title">pw</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(ptr))</span> </span>&#123;&#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span><br><span class="hljs-function">    </span>&#123; <span class="hljs-keyword">return</span> pw-&gt;isValidated() &amp;&amp; pw-&gt;isArchived(); &#125;<br>    <br><span class="hljs-keyword">private</span>:<br>    DataType pw;<br>&#125;;<br><br><span class="hljs-keyword">auto</span> func = IsValAndArch(<span class="hljs-built_in">std</span>::make_unique&lt;Widget&gt;());<br></code></pre></div></td></tr></table></figure>
<p>使用 <code>bind</code> 的解决方法：</p>
<p>C++11的等效代码如下，其中我强调了相同的关键事项：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt; data;           <br><br>…                                      <br><br><span class="hljs-keyword">auto</span> func =<br>    <span class="hljs-built_in">std</span>::bind(                              <span class="hljs-comment">//C++11模拟初始化捕获</span><br>        [](<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt;&amp; data) <span class="hljs-comment">//译者注：本行高亮</span><br>        &#123; <span class="hljs-comment">/*使用data*/</span> &#125;,<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(data)                     <span class="hljs-comment">//译者注：本行高亮</span><br>    );<br></code></pre></div></td></tr></table></figure>
<p>默认情况下，从<em>lambda</em>生成的闭包类中的<code>operator()</code>成员函数为<code>const</code>的。在<em>lambda</em>主体内把闭包中的所有数据成员渲染为<code>const</code>。</p>
<p>但是，bind对象内部的移动构造的<code>data</code>副本不是<code>const</code>的，因此，为了防止在<em>lambda</em>内修改该<code>data</code>副本，<em>lambda</em>的形参应声明为reference-to-<code>const</code>。
如果将<em>lambda</em>声明为<code>mutable</code>，则闭包类中的<code>operator()</code>将不会声明为<code>const</code>，并且在<em>lambda</em>的形参声明中省略<code>const</code>也是合适的：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> func =<br>    <span class="hljs-built_in">std</span>::bind(                                  <span class="hljs-comment">//C++11对mutable lambda</span><br>        [](<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt;&amp; data) <span class="hljs-keyword">mutable</span>	<span class="hljs-comment">//初始化捕获的模拟</span><br>        &#123; <span class="hljs-comment">/*使用data*/</span> &#125;,<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(data)<br>    );<br></code></pre></div></td></tr></table></figure>
<h3><span id="结论">结论</span></h3>
<ul>
<li>使用C++14的初始化捕获将对象移动到闭包中。</li>
<li>在C++11中，可以通过手写类或<code>std::bind</code>的方式来模拟初始化捕获。</li>
</ul>
<h2><span id="33对autoampamp形参使用decltype">33
对<code>auto&amp;&amp;</code>形参使用<code>decltype</code></span></h2>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> f = [](<span class="hljs-keyword">auto</span>&amp;&amp; x)<br>         &#123; <span class="hljs-keyword">return</span> func(normalize(<span class="hljs-built_in">std</span>::forward&lt;???&gt;(x))); &#125;;<br></code></pre></div></td></tr></table></figure>
<p>这里的<code>???</code>该是什么？</p>
<p>在泛型<em>lambda</em>中，没有可用的类型参数<code>T</code>。在<em>lambda</em>生成的闭包里，模版化的<code>operator()</code>函数中的确有一个<code>T</code>，但在<em>lambda</em>里却无法直接使用它。</p>
<p>如果一个左值实参被传给通用引用的形参，那么形参类型会变成左值引用。传递的是右值，形参就会变成右值引用。这意味着在这个<em>lambda</em>中，可以通过检查形参<code>x</code>的类型来确定传递进来的实参是一个左值还是右值，<code>decltype</code>就可以实现这样的效果。</p>
<p>传递给<em>lambda</em>的是一个左值，<code>decltype(x)</code>就能产生一个左值引用；如果传递的是一个右值，<code>decltype(x)</code>就会产生右值引用。</p>
<p>在调用<code>std::forward</code>时，惯例决定了类型实参是左值引用时来表明要传进左值，类型实参是非引用就表明要传进右值。</p>
<p>在前面的<em>lambda</em>中，如果<code>x</code>绑定的是一个左值，<code>decltype(x)</code>就能产生一个左值引用。</p>
<p>然而如果<code>x</code>绑定的是一个右值，<code>decltype(x)</code>就会产生右值引用，而不是常规的非引用。</p>
<p>但是<code>decltype(x)</code>就会产生右值引用传入
<code>std::forward</code>
后，引用折叠后的结果和传入非引用的结果是相同的。</p>
<p>所以<code>decltype(x)</code> 完美解决了问题。</p>
<p>C++14中的<em>lambda</em>也可以是可变形参的，最后的实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> f =<br>    [](<span class="hljs-keyword">auto</span>&amp;&amp;... params)<br>    &#123;<br>        <span class="hljs-keyword">return</span><br>            func(normalize(<span class="hljs-built_in">std</span>::forward&lt;<span class="hljs-keyword">decltype</span>(params)&gt;(params)...));<br>    &#125;;<br></code></pre></div></td></tr></table></figure>
<h2><span id="34优先考虑lambda而非stdbind">34
优先考虑<em>lambda</em>而非<code>std::bind</code></span></h2>
<p>优先<em>lambda</em>而不是<code>std::bind</code>的最重要原因是<em>lambda</em>更易读。</p>
<p>但是，在C++11中，可以在两种情况下使用<code>std::bind</code>是合理的：</p>
<ul>
<li><strong>移动捕获</strong>。C++11的<em>lambda</em>不提供移动捕获，但是可以通过结合<em>lambda</em>和<code>std::bind</code>来模拟。</li>
<li><strong>多态函数对象</strong>。因为bind对象上的函数调用运算符使用完美转发，所以它可以接受任何类型的实参</li>
</ul>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PolyWidget</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T&amp; param)</span></span>;<br>    …<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p><code>std::bind</code>可以如下绑定一个<code>PolyWidget</code>对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">PolyWidget pw;<br><span class="hljs-keyword">auto</span> boundPW = <span class="hljs-built_in">std</span>::bind(pw, _1);<br></code></pre></div></td></tr></table></figure>
<p><code>boundPW</code>可以接受任意类型的对象了：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">boundPW(<span class="hljs-number">1930</span>);              <span class="hljs-comment">//传int给PolyWidget::operator()</span><br>boundPW(<span class="hljs-literal">nullptr</span>);           <span class="hljs-comment">//传nullptr给PolyWidget::operator()</span><br>boundPW(<span class="hljs-string">"Rosebud"</span>); 		<span class="hljs-comment">//传字面值给PolyWidget::operator()</span><br></code></pre></div></td></tr></table></figure>
<p>这一点无法使用C++11的<em>lambda</em>做到。
但是，在C++14中，可以通过带有<code>auto</code>形参的<em>lambda</em>轻松实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> boundPW = [pw](<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; param)  <span class="hljs-comment">//C++14 </span><br>               &#123; pw(param); &#125;;<br></code></pre></div></td></tr></table></figure>
<h3><span id="结论">结论</span></h3>
<ul>
<li>与使用<code>std::bind</code>相比，<em>lambda</em>更易读，更具表达力并且可能更高效。</li>
<li>只有在C++11中，<code>std::bind</code>
对实现移动捕获，或者绑定函数模板，会很有用。</li>
</ul>
<h2><span id="并发api">并发API</span></h2>
<p>C++11的伟大成功之一是将并发整合到语言和库中。</p>
<h2><span id="35优先考虑基于任务的编程而非基于线程的编程">35
优先考虑基于任务的编程而非基于线程的编程</span></h2>
<p>如果开发者想要异步执行<code>doAsyncWork</code>函数，通常有两种方式。其一是通过创建<code>std::thread</code>执行<code>doAsyncWork</code>，这是应用了<strong>基于线程</strong>（<em>thread-based</em>）的方式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">doAsyncWork</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-built_in">std</span>::thread <span class="hljs-title">t</span><span class="hljs-params">(doAsyncWork)</span></span>;<br></code></pre></div></td></tr></table></figure>
<p>其二是将<code>doAsyncWork</code>传递给<code>std::async</code>，一种<strong>基于任务</strong>（<em>task-based</em>）的策略：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> fut = <span class="hljs-built_in">std</span>::async(doAsyncWork); <span class="hljs-comment">//“fut”表示“future”</span><br></code></pre></div></td></tr></table></figure>
<p>这种方式中，传递给<code>std::async</code>的函数对象被称为一个<strong>任务</strong>（<em>task</em>）。</p>
<p>基于任务的方法通常比基于线程的方法更优：</p>
<ul>
<li>代码量更少</li>
<li>如果 task 的返回值是必需的，那么 <em>thread-based</em>
的方式将无能为力。而基于任务的方法就简单了，因为<code>std::async</code>返回的<em>future</em>提供了<code>get</code>函数（从而可以获取返回值）。</li>
<li>如果<code>doAsycnWork</code>发生了异常，<code>get</code>函数就显得更为重要，因为<code>get</code>函数可以提供抛出异常的访问，而基于线程的方法，如果<code>doAsyncWork</code>抛出了异常，程序会直接终止（通过调用<code>std::terminate</code>）。</li>
</ul>
<h3><span id="区别">区别</span></h3>
<p>基于线程与基于任务最根本的区别在于，基于任务的抽象层次更高。基于任务的方式使得开发者从线程管理的细节中解放出来，对此在C++并发软件中总结了“<em>thread</em>”的三种含义：</p>
<ul>
<li><strong>硬件线程</strong>（hardware
threads）是真实执行计算的线程。现代计算机体系结构为每个CPU核心提供一个或者多个硬件线程。</li>
<li><strong>软件线程</strong>（software threads）（也被称为系统线程（OS
threads、system
threads））是操作系统管理的在硬件线程上执行的线程。通常可以存在比硬件线程更多数量的软件线程。当软件线程被阻塞的时候（比如
I/O、同步锁或者条件变量），操作系统可以调度其他未阻塞的软件线程执行提供吞吐量。</li>
<li><strong><code>std::thread</code></strong>
是C++执行过程的对象，并作为软件线程的句柄（<em>handle</em>）。</li>
</ul>
<p>软件线程是有限的资源。如果开发者试图创建大于系统支持的线程数量，会抛出<code>std::system_error</code>异常。</p>
<p>即使没有超出软件线程的限额，仍然可能会遇到<strong>资源超额</strong>（<em>oversubscription</em>）的麻烦。当前准备运行的（即未阻塞的）软件线程大于硬件线程的数量时，线程调度器会将软件线程时间切片，分配到硬件上。</p>
<p>当一个软件线程的时间片执行结束，会让给另一个软件线程，此时发生上下文切换。软件线程的上下文切换会增加系统的软件线程管理开销。当软件线程安排到与上次时间片运行时不同的硬件线程上，这个开销会更高。</p>
<p>使用<code>std::async</code>
将线程管理的职责转交给C++标准库的开发者。举个例子，这种调用方式会减少抛出资源超额异常的可能性，因为这个调用可能不会开启一个新的线程。合理的调度器在系统资源超额或者线程耗尽时就会利用这个自由度。</p>
<p>通过向<code>std::async</code>传递<code>std::launch::async</code>启动策略来保证想运行函数在不同的线程上执行，处理不同线程响应优先级的问题。</p>
<blockquote>
<p>线程调度器使用系统级线程池（<em>thread
pool</em>）来避免资源超额的问题，并且通过工作窃取算法（<em>work-stealing
algorithm</em>）来提升了跨硬件核心的负载均衡。实现更为繁琐。</p>
<p>直接使用<code>std::thread</code>编程，处理线程耗尽、资源超额、负责均衡问题的责任就压在了你身上，更不用说你对这些问题的解决方法与同机器上其他程序采用的解决方案配合得好不好了。</p>
</blockquote>
<p>基于任务的设计为开发者避免了手动线程管理的痛苦，并且自然提供了一种获取异步执行程序的结果（即返回值或者异常）的方式。当然，仍然存在一些场景直接使用<code>std::thread</code>会更有优势：</p>
<ul>
<li><strong>你需要访问非常基础的线程API</strong>。C++并发API通常是通过操作系统提供的系统级API（pthreads或者Windows
threads）来实现的，系统级API通常会提供更加灵活的操作方式（举个例子，C++没有线程优先级和亲和性的概念）。为了提供对底层系统级线程API的访问，<code>std::thread</code>对象提供了<code>native_handle</code>的成员函数，而<code>std::future</code>（即<code>std::async</code>返回的东西）没有这种能力。</li>
<li><strong>你需要且能够优化应用的线程使用</strong>。</li>
<li><strong>你需要实现C++并发API之外的线程技术</strong>，比如，实现未支持的平台的线程池。</li>
</ul>
<h3><span id="结论">结论</span></h3>
<ul>
<li><code>std::thread</code>
API不能直接访问异步执行的结果，如果执行函数有异常抛出，代码会终止执行。</li>
<li>基于线程的编程方式需要手动的线程耗尽、资源超额、负责均衡、平台适配性管理。</li>
<li>通过带有默认启动策略的<code>std::async</code>进行基于任务的编程方式会解决大部分问题。</li>
</ul>
<h2><span id="36如有必要指定stdlaunchasync">36
如有必要指定<code>std::launch::async</code></span></h2>
<ul>
<li><strong><code>std::launch::async</code>启动策略</strong>意味着<code>f</code>必须异步执行，即在不同的线程。</li>
<li><strong><code>std::launch::deferred</code>启动策略</strong>意味着<code>f</code>仅当在<code>std::async</code>返回的<em>future</em>上调用<code>get</code>或者<code>wait</code>时才执行。这表示<code>f</code><strong>推迟</strong>到存在这样的调用时才执行。当<code>get</code>或<code>wait</code>被调用，<code>f</code>会同步执行，即调用方被阻塞，直到<code>f</code>运行结束。如果<code>get</code>和<code>wait</code>都没有被调用，<code>f</code>将不会被执行。</li>
</ul>
<p><code>std::async</code>的默认启动策略，如果你不显式指定一个策略，不是上面中任意一个。相反，是求或在一起的。下面的两种调用含义相同：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> fut1 = <span class="hljs-built_in">std</span>::async(f);                      <span class="hljs-comment">//使用默认启动策略运行f</span><br><span class="hljs-keyword">auto</span> fut2 = <span class="hljs-built_in">std</span>::async(<span class="hljs-built_in">std</span>::launch::async |     <span class="hljs-comment">//使用async或者deferred运行f</span><br>                       <span class="hljs-built_in">std</span>::launch::deferred,<br>                       f);<br></code></pre></div></td></tr></table></figure>
<p>因此默认策略允许<code>f</code>异步或者同步执行。</p>
<p>这导致了三种结果：</p>
<ul>
<li><strong>无法预测<code>f</code>是否会与<code>t</code>并发运行</strong>，因为<code>f</code>可能被安排延迟运行。</li>
<li><strong>无法预测<code>f</code>是否会在与某线程相异的另一线程上执行，这个某线程在<code>fut</code>上调用<code>get</code>或<code>wait</code></strong>。如果对<code>fut</code>调用函数的线程是<code>t</code>，无法预测<code>f</code>是否在异于<code>t</code>的另一线程上执行。</li>
<li><strong>无法预测<code>f</code>是否执行</strong>。</li>
</ul>
<p>所以，以下循环看似应该最终会终止，但可能实际上永远运行：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>::literals;      <span class="hljs-comment">//为了使用C++14中的时间段后缀</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span>                            <span class="hljs-comment">//f休眠1秒，然后返回</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">std</span>::this_thread::sleep_for(<span class="hljs-number">1</span>s);<br>&#125;<br><br><span class="hljs-keyword">auto</span> fut = <span class="hljs-built_in">std</span>::async(f);           <span class="hljs-comment">//异步运行f（理论上）</span><br><br><span class="hljs-keyword">while</span> (fut.wait_for(<span class="hljs-number">100</span>ms) !=       <span class="hljs-comment">//循环，直到f完成运行时停止...</span><br>       <span class="hljs-built_in">std</span>::future_status::ready)   <span class="hljs-comment">//但是有可能永远不会发生！</span><br>&#123;<br>    …<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>如果<code>f</code>与调用<code>std::async</code>的线程并发运行（即，如果为<code>f</code>选择的启动策略是<code>std::launch::async</code>），这里没有问题（假定<code>f</code>最终会执行完毕），但是如果<code>f</code>是延迟执行，<code>fut.wait_for</code>将总是返回<code>std::future_status::deferred</code>。这永远不等于<code>std::future_status::ready</code>，循环会永远执行下去。</p>
<p>改进的方式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> fut = <span class="hljs-built_in">std</span>::async(f);               <span class="hljs-comment">//同上</span><br><br><span class="hljs-keyword">if</span> (fut.wait_for(<span class="hljs-number">0</span>s) ==                 <span class="hljs-comment">//如果task是deferred（被延迟）状态</span><br>    <span class="hljs-built_in">std</span>::future_status::deferred)<br>&#123;<br>    …                                   <span class="hljs-comment">//在fut上调用wait或get来异步调用f</span><br>&#125; <span class="hljs-keyword">else</span> &#123;                                <span class="hljs-comment">//task没有deferred（被延迟）</span><br>    <span class="hljs-keyword">while</span> (fut.wait_for(<span class="hljs-number">100</span>ms) !=       <span class="hljs-comment">//不可能无限循环（假设f完成）</span><br>           <span class="hljs-built_in">std</span>::future_status::ready) &#123;<br>        …                               <span class="hljs-comment">//task没deferred（被延迟），也没ready（已准备）</span><br>                                        <span class="hljs-comment">//做并行工作直到已准备</span><br>    &#125;<br>    …                                   <span class="hljs-comment">//fut是ready（已准备）状态</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>一个总是使用 <code>std::launch::async</code> 的函数实现如下：</p>
<p>C++11版本如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> F, <span class="hljs-keyword">typename</span>... Ts&gt;<br><span class="hljs-keyword">inline</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">future</span>&lt;<span class="hljs-keyword">typename</span> <span class="hljs-built_in">std</span>::result_of&lt;F(Ts...)&gt;::type&gt;<br>reallyAsync(F&amp;&amp; f, Ts&amp;&amp;... params)          <span class="hljs-comment">//返回异步调用f(params...)得来的future</span><br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::async(<span class="hljs-built_in">std</span>::launch::async,<br>                      <span class="hljs-built_in">std</span>::forward&lt;F&gt;(f),<br>                      <span class="hljs-built_in">std</span>::forward&lt;Ts&gt;(params)...);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>在C++14中，<code>reallyAsync</code>返回类型的推导能力可以简化函数的声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> F, <span class="hljs-keyword">typename</span>... Ts&gt;<br><span class="hljs-keyword">inline</span><br><span class="hljs-keyword">auto</span>                                        <span class="hljs-comment">// C++14</span><br>reallyAsync(F&amp;&amp; f, Ts&amp;&amp;... params)<br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::async(<span class="hljs-built_in">std</span>::launch::async,<br>                      <span class="hljs-built_in">std</span>::forward&lt;F&gt;(f),<br>                      <span class="hljs-built_in">std</span>::forward&lt;Ts&gt;(params)...);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3><span id="结论">结论</span></h3>
<ul>
<li><code>std::async</code>的默认启动策略是异步和同步执行兼有的。</li>
<li><code>std::async</code>的默认启动策略，隐含了任务可能不会被执行的意思，会影响调用基于超时的<code>wait</code>的程序逻辑。</li>
<li>如果异步执行任务非常关键，则指定<code>std::launch::async</code>。</li>
</ul>
<h2><span id="37-使stdthread-是unjoinable-的">37 使<code>std::thread</code> 是
unjoinable 的</span></h2>
<p>每个<code>std::thread</code>对象处于两个状态之一：<strong>可结合的</strong>（<em>joinable</em>）或者<strong>不可结合的</strong>（<em>unjoinable</em>）。</p>
<p>可结合状态的<code>std::thread</code>对应于正在运行或者可能要运行的异步执行线程。比如，对应于一个阻塞的（<em>blocked</em>）或者等待调度的线程的<code>std::thread</code>是可结合的；对应于运行结束的线程的<code>std::thread</code>也可以认为是可结合的。</p>
<p>不可结合的 <code>std::thread</code> 包括：</p>
<ul>
<li><strong>默认构造的<code>std::thread</code>s</strong>。这种<code>std::thread</code>没有函数执行，因此没有对应到底层执行线程上。</li>
<li><strong>已经被移动走的<code>std::thread</code>对象</strong>。移动的结果就是一个<code>std::thread</code>原来对应的执行线程现在对应于另一个<code>std::thread</code>。</li>
<li><strong>已经被<code>join</code>的<code>std::thread</code></strong>
。在<code>join</code>之后，<code>std::thread</code>不再对应于已经运行完了的执行线程。</li>
<li><strong>已经被<code>detach</code>的<code>std::thread</code></strong>
。<code>detach</code>断开了<code>std::thread</code>对象与执行线程之间的连接。</li>
</ul>
<p>如果发生 <code>std::thread</code> 析构，而 <code>std::thread</code>
是 joinable，那么会造成程序终止。析构时发生的
<strong>隐式<code>join</code></strong>
可能还会访问已经被回收的值。<strong>隐式<code>detach</code></strong>
，可能出现访问或者修改没有所有权的内存的行为。</p>
<p>解决方法，使用 RAII
对象类管理，保证每当在执行跳至块之外时，调用局部对象的析构函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadRAII</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">enum</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DtorAction</span> &#123;</span> join, detach &#125;;         <br><br>    ThreadRAII(<span class="hljs-built_in">std</span>::thread&amp;&amp; t, DtorAction a)       <span class="hljs-comment">// 在析构函数中对t实行a动作</span><br>    : action(a), t(<span class="hljs-built_in">std</span>::move(t)) &#123;&#125;                 <span class="hljs-comment">// `std::thread`不可以复制</span><br><br>    ~ThreadRAII()<br>    &#123;              <br>        <span class="hljs-keyword">if</span> (t.joinable()) &#123;                         <span class="hljs-comment">//可结合性测试见下</span><br>            <span class="hljs-keyword">if</span> (action == DtorAction::join) &#123;<br>                t.join();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                t.detach();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    ThreadRAII(ThreadRAII&amp;&amp;) = <span class="hljs-keyword">default</span>;             <span class="hljs-comment">//支持移动</span><br>    ThreadRAII&amp; <span class="hljs-keyword">operator</span>=(ThreadRAII&amp;&amp;) = <span class="hljs-keyword">default</span>;<br><br>    <span class="hljs-function"><span class="hljs-built_in">std</span>::thread&amp; <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> t; &#125;                <br><br><span class="hljs-keyword">private</span>: <span class="hljs-comment">// as before</span><br>    DtorAction action;<br>    <span class="hljs-built_in">std</span>::thread t;        <span class="hljs-comment">// 最后声明，实例化时，前面的成员都是可用状态</span><br>&#125;;<br></code></pre></div></td></tr></table></figure>
<h3><span id="结论">结论</span></h3>
<ul>
<li>析构时<code>join</code>会导致难以调试的表现异常问题。</li>
<li>析构时<code>detach</code>会导致难以调试的未定义行为。</li>
<li>声明类数据成员时，最后声明<code>std::thread</code>对象。</li>
</ul>
<h2><span id="38-future析构行为">38 future析构行为</span></h2>
<h3><span id="结论">结论</span></h3>
<ul>
<li><em>future</em>的正常析构行为就是销毁<em>future</em>本身的数据成员。</li>
<li>使用<code>std::async</code>启动的
<em>future</em>，引用了共享状态（<code>std::shared_future</code>）的最后一个<em>future</em>的析构函数会阻塞住，直到任务完成。</li>
</ul>
<h2><span id="39-简单事件通信">39 简单事件通信</span></h2>
<p>一个任务通知另一个异步执行的任务发生了特定的事件很有用，因为第二个任务要等到这个事件发生之后才能继续执行。事件也许是一个数据结构已经初始化，也许是计算阶段已经完成，或者检测到重要的传感器值。</p>
<h3><span id="使用条件变量">使用条件变量</span></h3>
<p>如果我们将检测条件的任务称为<strong>检测任务</strong>（<em>detecting
task</em>），对条件作出反应的任务称为<strong>反应任务</strong>（<em>reacting
task</em>），策略很简单：反应任务等待一个条件变量，检测任务在事件发生时改变条件变量。代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-built_in">std</span>::condition_variable cv;         <span class="hljs-comment">//事件的条件变量</span><br><span class="hljs-built_in">std</span>::mutex m;                       <span class="hljs-comment">//配合cv使用的mutex</span><br></code></pre></div></td></tr></table></figure>
<p>检测任务中的代码不能再简单了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">…                                   <span class="hljs-comment">//检测事件</span><br>cv.notify_one();                    <span class="hljs-comment">//通知反应任务</span><br></code></pre></div></td></tr></table></figure>
<p>如果有多个反应任务需要被通知，使用<code>notify_all</code>代替<code>notify_one</code>。</p>
<p>线程API的存在一个事实（不只是C++），等待一个条件变量的代码即使在条件变量没有被通知时，也可能被唤醒，这种唤醒被称为<strong>虚假唤醒</strong>（<em>spurious
wakeups</em>）。</p>
<p>正确的代码通过确认要等待的条件确实已经发生来处理这种情况，并将这个操作作为唤醒后的第一个操作。C++条件变量的API使得这种问题很容易解决，因为允许把一个测试要等待的条件的<em>lambda</em>（或者其他函数对象）传给<code>wait</code>。因此，可以将反应任务<code>wait</code>调用这样写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">cv.wait(lk, <br>        []&#123; <span class="hljs-keyword">return</span> whether the evet has occurred; &#125;);<br></code></pre></div></td></tr></table></figure>
<p>使用 <em>condition variable</em> 的示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-built_in">std</span>::condition_variable cv;             <br><span class="hljs-built_in">std</span>::mutex m;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">flag</span><span class="hljs-params">(<span class="hljs-literal">false</span>)</span></span>;                       <span class="hljs-comment">//不是std::atomic</span><br>…                                       <span class="hljs-comment">//检测某个事件</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-built_in">std</span>::lock_guard&lt;<span class="hljs-built_in">std</span>::mutex&gt; <span class="hljs-title">g</span><span class="hljs-params">(m)</span></span>;   <span class="hljs-comment">//通过g的构造函数锁住m</span><br>    flag = <span class="hljs-literal">true</span>;                        <span class="hljs-comment">//通知反应任务（第1部分）</span><br>&#125;                                       <span class="hljs-comment">//通过g的析构函数解锁m</span><br>cv.notify_one();                        <span class="hljs-comment">//通知反应任务（第2部分）</span><br></code></pre></div></td></tr></table></figure>
<p>反应任务代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">…                                       <span class="hljs-comment">//准备作出反应</span><br>&#123;                                       <br>    <span class="hljs-function"><span class="hljs-built_in">std</span>::unique_lock&lt;<span class="hljs-built_in">std</span>::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(m)</span></span>; <br>    cv.wait(lk, [] &#123; <span class="hljs-keyword">return</span> flag; &#125;);   <span class="hljs-comment">//使用lambda来避免虚假唤醒</span><br>    …                                   <span class="hljs-comment">//对事件作出反应（m被锁定）</span><br>&#125;<br>…                                       <span class="hljs-comment">//继续反应动作（m现在解锁）</span><br></code></pre></div></td></tr></table></figure>
<h3><span id="原子变量轮询">原子变量轮询</span></h3>
<p>使用原子变量的示例：</p>
<p>当检测线程识别到发生的事件，将flag置位：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">std</span>::atomic&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">flag</span><span class="hljs-params">(<span class="hljs-literal">false</span>)</span></span>;          <span class="hljs-comment">//共享的flag</span><br>…                                       <span class="hljs-comment">//检测某个事件</span><br>flag = <span class="hljs-literal">true</span>;                            <span class="hljs-comment">//告诉反应线程</span><br></code></pre></div></td></tr></table></figure>
<p>就其本身而言，反应线程轮询该flag。当发现flag被置位，它就知道等待的事件已经发生了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">…                                       <span class="hljs-comment">//准备作出反应</span><br><span class="hljs-keyword">while</span> (!flag);                          <span class="hljs-comment">//等待事件</span><br>…                                       <span class="hljs-comment">//对事件作出反应</span><br></code></pre></div></td></tr></table></figure>
<p>这里多出了轮询的开销。</p>
<h3><span id="promise-future">promise + future</span></h3>
<p>检测任务使用<code>std::promise&lt;void&gt;</code>，反应任务使用<code>std::future&lt;void&gt;</code>或者<code>std::shared_future&lt;void&gt;</code>。当感兴趣的事件发生时，检测任务设置<code>std::promise&lt;void&gt;</code>，反应任务在<em>future</em>上<code>wait</code>。</p>
<p>尽管反应任务不从检测任务那里接收任何数据，通信信道也可以让反应任务知道，检测任务什么时候已经通过对<code>std::promise&lt;void&gt;</code>调用<code>set_value</code>“写入”了<code>void</code>数据。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-built_in">std</span>::promise&lt;<span class="hljs-keyword">void</span>&gt; p;                   <span class="hljs-comment">//通信信道的promise</span><br></code></pre></div></td></tr></table></figure>
<p>检测任务代码很简洁：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">…                                       <span class="hljs-comment">//检测某个事件</span><br>p.set_value();                          <span class="hljs-comment">//通知反应任务</span><br></code></pre></div></td></tr></table></figure>
<p>反应任务代码也同样简单：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">…                                       <span class="hljs-comment">//准备作出反应</span><br>p.get_future().wait();                  <span class="hljs-comment">//等待对应于p的那个future</span><br>…                                       <span class="hljs-comment">//对事件作出反应</span><br></code></pre></div></td></tr></table></figure>
<p>像使用flag的方法一样，此设计不需要互斥锁，无论在反应线程调用<code>wait</code>之前检测线程是否设置了<code>std::promise</code>都可以工作，并且不受虚假唤醒的影响（只有条件变量才容易受到此影响）。</p>
<p>与基于条件变量的方法一样，反应任务在调用<code>wait</code>之后是真被阻塞住的，不会一直占用系统资源。</p>
<p>但是以上代码中，<code>std::promise</code>和<em>future</em>之间有个共享状态，并且共享状态是动态分配的。因此你应该假定此设计会产生基于堆的分配和释放开销。</p>
<p><code>std::promise</code>只能设置一次。<code>std::promise</code>和<em>future</em>之间的通信是<strong>一次性</strong>的：不能重复使用。这是与基于条件变量或者基于flag的设计的明显差异，条件变量和flag都可以通信多次。</p>
<p>假设你仅仅想要对某线程挂起一次（在创建后，运行线程函数前），使用<code>void</code>的<em>future</em>就是一个可行方案。</p>
<p>通过<code>share</code>获得的<code>shared_future</code>要被在反应线程中运行的<em>lambda</em>按值捕获：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-built_in">std</span>::promise&lt;<span class="hljs-keyword">void</span>&gt; p;                   <span class="hljs-comment">//跟之前一样</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">detect</span><span class="hljs-params">()</span>                           <span class="hljs-comment">//现在针对多个反映线程</span></span><br><span class="hljs-function"></span>&#123;	<br>    <span class="hljs-comment">// 写在前面，防止异常发生，p.set_value() 不执行</span><br>    <span class="hljs-keyword">auto</span> sf = p.get_future().share();   <span class="hljs-comment">//sf的类型是std::shared_future&lt;void&gt;</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::thread&gt; vt;        <span class="hljs-comment">//反应线程容器</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; threadsToRun; ++i) &#123;<br>        vt.emplace_back([sf]&#123; sf.wait();    <span class="hljs-comment">//在sf的局部副本上wait；</span><br>                              react(); &#125;);  <br>    &#125;<br>    …                                   <span class="hljs-comment">//如果这个“…”抛出异常，detect挂起！</span><br>    p.set_value();                      <span class="hljs-comment">//所有线程解除挂起</span><br>    …<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; t : vt) &#123;                <span class="hljs-comment">//使所有线程不可结合；</span><br>        t.join();                       <span class="hljs-comment">//“auto&amp;”见条款2</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3><span id="结论">结论</span></h3>
<ul>
<li>三种简单事件通信：使用条件变量、使用原子变量、使用
<code>promise + future</code></li>
<li><code>promise + future</code>
的方式，在单次事件通信时，更有优势</li>
</ul>
<h2><span id="40并发使用stdatomic特殊内存使用volatile">40
并发使用<code>std::atomic</code>，特殊内存使用<code>volatile</code></span></h2>
<p>如下使用<code>std::atmoic</code>的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">std</span>::atomic&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ai</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;         <span class="hljs-comment">//初始化ai为0</span><br>ai = <span class="hljs-number">10</span>;                        <span class="hljs-comment">//原子性地设置ai为10</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; ai;                <span class="hljs-comment">//原子性地读取ai的值</span><br>++ai;                           <span class="hljs-comment">//原子性地递增ai到11</span><br>--ai;                           <span class="hljs-comment">//原子性地递减ai到10</span><br></code></pre></div></td></tr></table></figure>
<p>在这些语句执行过程中，其他线程读取<code>ai</code>，只能读取到0，10，11三个值其中一个。假设只有这个线程会修改<code>ai</code>，没有其他可能的值。</p>
<p>使用<code>volatile</code>在多线程中实际上不保证任何事情：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> <span class="hljs-title">vi</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;             <span class="hljs-comment">//初始化vi为0</span><br>vi = <span class="hljs-number">10</span>;                        <span class="hljs-comment">//设置vi为10 </span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; vi;                <span class="hljs-comment">//读vi的值</span><br>++vi;                           <span class="hljs-comment">//递增vi到11</span><br>--vi;                           <span class="hljs-comment">//递减vi到10</span><br></code></pre></div></td></tr></table></figure>
<p>代码的执行过程中，如果其他线程读取<code>vi</code>，可能读到任何值，比如-12，68，4090727——任何值！这份代码有未定义行为，因为这里的语句修改<code>vi</code>，所以如果同时其他线程读取<code>vi</code>，同时存在多个readers和writers读取没有<code>std::atomic</code>或者互斥锁保护的内存，这就是数据竞争的定义。</p>
<h3><span id="指令排序">指令排序</span></h3>
<blockquote>
<p>代码执行本身，即使编译器没有重排顺序，底层硬件也可能重排（或者可能使它看起来运行在其他核心上），因为有时这样代码执行更快。</p>
<p>然而，<code>std::atomic</code>会限制这种重排序，保持了指令执行的有序性。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">std</span>::atomic&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">valVailable</span><span class="hljs-params">(<span class="hljs-literal">false</span>)</span></span>; <br><span class="hljs-keyword">auto</span> imptValue = computeImportantValue();   <span class="hljs-comment">//计算值</span><br>valAvailable = <span class="hljs-literal">true</span>;                        <span class="hljs-comment">//告诉另一个任务，值可用了</span><br></code></pre></div></td></tr></table></figure>
<p>编译器不仅要保证<code>imptValue</code>和<code>valAvailable</code>的赋值顺序，还要保证生成的硬件代码不会改变这个顺序。结果就是，将<code>valAvailable</code>声明为<code>std::atomic</code>确保了必要的顺序——其他线程看到的是<code>imptValue</code>值的改变不会晚于<code>valAvailable</code>。</p>
<p>将<code>valAvailable</code>声明为<code>volatile</code>不能保证上述顺序：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">volatile</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">valVailable</span><span class="hljs-params">(<span class="hljs-literal">false</span>)</span></span>; <br><span class="hljs-keyword">auto</span> imptValue = computeImportantValue();<br>valAvailable = <span class="hljs-literal">true</span>;                        <span class="hljs-comment">//其他线程可能看到这个赋值操作早于imptValue的赋值操作</span><br></code></pre></div></td></tr></table></figure>
<p>这份代码编译器可能将<code>imptValue</code>和<code>valAvailable</code>赋值顺序对调。</p>
<h3><span id="结论">结论</span></h3>
<ul>
<li><code>std::atomic</code>用于在不使用互斥锁情况下，来使变量被多个线程访问的情况。是用来编写并发程序的一个工具。</li>
<li><code>volatile</code>用在读取和写入不应被优化掉的内存上。是用来处理特殊内存的一个工具。</li>
</ul>
<h2><span id="其他优化">其他优化</span></h2>
<h2><span id="41对于移动成本低且总是被拷贝的可拷贝形参考虑按值传递">41
对于移动成本低且总是被拷贝的可拷贝形参，考虑按值传递</span></h2>
<p>三个版本的<code>addName</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> &#123;</span>                                  <span class="hljs-comment">//方法1：对左值和右值重载</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addName</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; newName)</span></span><br><span class="hljs-function">    </span>&#123; names.push_back(newName); &#125; <span class="hljs-comment">// rvalues</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addName</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp;&amp; newName)</span></span><br><span class="hljs-function">    </span>&#123; names.push_back(<span class="hljs-built_in">std</span>::move(newName)); &#125;<br>    …<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; names;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> &#123;</span>                                  <span class="hljs-comment">//方法2：使用通用引用</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addName</span><span class="hljs-params">(T&amp;&amp; newName)</span></span><br><span class="hljs-function">    </span>&#123; names.push_back(<span class="hljs-built_in">std</span>::forward&lt;T&gt;(newName)); &#125;<br>    …<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> &#123;</span>                                  <span class="hljs-comment">//方法3：传值</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addName</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> newName)</span></span><br><span class="hljs-function">    </span>&#123; names.push_back(<span class="hljs-built_in">std</span>::move(newName)); &#125;<br>    …<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>我将前两个版本称为“按引用方法”，因为都是通过引用传递形参。</p>
<p>仍然考虑这两种调用方式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">Widget w;<br>…<br><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title">name</span><span class="hljs-params">(<span class="hljs-string">"Bart"</span>)</span></span>;<br>w.addName(name);                                <span class="hljs-comment">//传左值</span><br>…<br>w.addName(name + <span class="hljs-string">"Jenne"</span>);                      <span class="hljs-comment">//传右值</span><br></code></pre></div></td></tr></table></figure>
<p>现在分别考虑三种实现中，给<code>Widget</code>添加一个名字的两种调用方式，拷贝和移动操作的开销。</p>
<ul>
<li><p><strong>重载</strong>：无论传递左值还是传递右值，调用都会绑定到一个叫<code>newName</code>的引用上。从拷贝和移动操作方面看，这个过程零开销。左值重载中，<code>newName</code>拷贝到<code>Widget::names</code>中，右值重载中，移动进去。</p>
<p>​ 开销总结：左值一次拷贝，右值一次移动。</p></li>
<li><p><strong>使用通用引用</strong>：同重载一样，调用也绑定到<code>addName</code>这个引用上，没有开销。由于使用了<code>std::forward</code>，左值<code>std::string</code>实参会拷贝到<code>Widget::names</code>，右值<code>std::string</code>实参移动进去。</p>
<p>​
对<code>std::string</code>实参来说，开销同重载方式一样：左值一次拷贝，右值一次移动。</p></li>
<li><p><strong>按值传递</strong>：无论传递左值还是右值，都必须构造<code>newName</code>形参。如果传递的是左值，需要拷贝的开销，如果传递的是右值，需要移动的开销。在函数的实现中，<code>newName</code>总是采用移动的方式到<code>Widget::names</code>。</p>
<p>​ 开销总结：左值实参，一次拷贝一次移动，右值实参两次移动。</p></li>
</ul>
<p>对于特殊的场景，可拷贝且移动开销小的类型，传递给总是会拷贝他们的一个函数，切片也不需要考虑，。这时，按值传递就提供了一种简单的实现方式，效率接近传递引用的函数，但是避免了传引用方案的缺点。</p>
<blockquote>
<p>当移动的开销较低，额外的一次移动才能被开发者接受，但是当移动的开销很大，执行不必要的移动就类似执行一个不必要的拷贝，也就是避免不必要的拷贝。</p>
<p>对于<strong>可拷贝形参</strong>使用按值传递。不符合此条件的的形参必须有只可移动的类型（<em>move-only
types</em>）。</p>
<p>只会在目标代码中生成一个函数。避免了通用引用的种种问题。</p>
<p>只对<strong>总是被拷贝</strong>的形参考虑按值传递。因为传引用可以避免这个不必要的开销。</p>
</blockquote>
<h3><span id="结论">结论</span></h3>
<ul>
<li><p>对于可拷贝，移动开销低，而且无条件被拷贝的形参，按值传递效率基本与按引用传递效率一致，而且易于实现，还生成更少的目标代码。</p></li>
<li><p>某些情况下，通过构造拷贝形参可能比通过赋值拷贝形参开销大的多。</p></li>
<li><p>按值传递会引起切片问题，所说不适合基类形参类型。</p></li>
</ul>
<h2><span id="42-emplacement-而不是insertion">42 emplacement 而不是
insertion</span></h2>
<p>编译器处理的下面的调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">vs.push_back(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>(<span class="hljs-string">"xyzzy"</span>)); <span class="hljs-comment">//创建临时std::string，把它传给push_back</span><br></code></pre></div></td></tr></table></figure>
<p>为了在<code>std::string</code>容器中创建新元素，调用了<code>std::string</code>的构造函数，但是这份代码并不仅调用了一次构造函数，而是调用了两次，而且还调用了<code>std::string</code>析构函数。下面是在<code>push_back</code>运行时发生了什么：</p>
<ol type="1">
<li>一个<code>std::string</code>的临时对象从字面量“<code>xyzzy</code>”被创建。这个对象没有名字，我们可以称为<code>temp</code>。<code>temp</code>的构造是第一次<code>std::string</code>构造。因为是临时变量，所以<code>temp</code>是右值。</li>
<li><code>temp</code>被传递给<code>push_back</code>的右值重载函数，绑定到右值引用形参<code>x</code>。在<code>std::vector</code>的内存中一个<code>x</code>的副本被创建。这次构造——也是第二次构造——在<code>std::vector</code>内部真正创建一个对象。</li>
<li>在<code>push_back</code>返回之后，<code>temp</code>立刻被销毁，调用了一次<code>std::string</code>的析构函数。</li>
</ol>
<p>使用传递给它的任何实参直接在<code>std::vector</code>内部构造一个<code>std::string</code>。没有临时变量会生成：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">vs.emplace_back(<span class="hljs-string">"xyzzy"</span>);           <span class="hljs-comment">//直接用“xyzzy”在vs内构造std::string</span><br></code></pre></div></td></tr></table></figure>
<p><code>emplace_back</code>使用完美转发，因此只要你没有遇到使用完美转发的限制，就可以传递任何实参以及组合到<code>emplace_back</code>。</p>
<p><code>emplace_back</code>：</p>
<ul>
<li><strong>值是通过构造函数添加到容器，而不是直接赋值。</strong></li>
<li><strong>传递的实参类型与容器的初始化类型不同。</strong></li>
<li><strong>容器不拒绝重复项作为新值。</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">vs.emplace_back(<span class="hljs-string">"xyzzy"</span>);              <span class="hljs-comment">//在容器末尾构造新值；不是传递的容器中元</span><br>                                       <span class="hljs-comment">//素的类型；没有使用拒绝重复项的容器</span><br></code></pre></div></td></tr></table></figure>
<h3><span id="资源管理">资源管理</span></h3>
<p>假定你有一个盛放<code>std::shared_ptr&lt;Widget&gt;</code>s的容器，</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">list</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt;&gt; ptrs;<br></code></pre></div></td></tr></table></figure>
<p>使用<code>push_back</code>的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">ptrs.push_back(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt;(<span class="hljs-keyword">new</span> Widget, killWidget));<br></code></pre></div></td></tr></table></figure>
<p>也可以像这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">ptrs.push_back(&#123;<span class="hljs-keyword">new</span> Widget, killWidget&#125;);<br></code></pre></div></td></tr></table></figure>
<p>不管哪种写法，在调用<code>push_back</code>前会生成一个临时<code>std::shared_ptr</code>对象。<code>push_back</code>的形参是<code>std::shared_ptr</code>的引用，因此必须有一个<code>std::shared_ptr</code>。</p>
<p>用<code>emplace_back</code>应该可以避免<code>std::shared_ptr</code>临时对象的创建，但是在这个场景下，临时对象值得被创建。考虑如下可能的时间序列：</p>
<ol type="1">
<li>在上述的调用中，一个<code>std::shared_ptr&lt;Widget&gt;</code>的临时对象被创建来持有“<code>new Widget</code>”返回的原始指针。称这个对象为<code>temp</code>。</li>
<li><code>push_back</code>通过引用接受<code>temp</code>。在存储<code>temp</code>的副本的<em>list</em>节点的内存分配过程中，内存溢出异常被抛出。</li>
<li>随着异常从<code>push_back</code>的传播，<code>temp</code>被销毁。作为唯一管理这个<code>Widget</code>的<code>std::shared_ptr</code>，它自动销毁<code>Widget</code>，在这里就是调用<code>killWidget</code>。</li>
</ol>
<p>这样的话，即使发生了异常，没有资源泄漏。</p>
<p>考虑使用<code>emplace_back</code>代替<code>push_back</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">ptrs.emplace_back(<span class="hljs-keyword">new</span> Widget, killWidget);<br></code></pre></div></td></tr></table></figure>
<ol type="1">
<li>通过<code>new Widget</code>创建的原始指针完美转发给<code>emplace_back</code>中，<em>list</em>节点被分配的位置。如果分配失败，还是抛出内存溢出异常。</li>
<li>当异常从<code>emplace_back</code>传播，原始指针是仅有的访问堆上<code>Widget</code>的途径，但是因为异常而丢失了，那个<code>Widget</code>的资源（以及任何它所拥有的资源）发生了泄漏。</li>
</ol>
<p>在这个场景中，生命周期不良好，这个失误不能赖<code>std::shared_ptr</code>。使用带自定义删除器的<code>std::unique_ptr</code>也会有同样的问题。</p>
<p>解决方法是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt; <span class="hljs-title">spw</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Widget,      <span class="hljs-comment">//创建Widget，让spw管理它</span></span></span><br><span class="hljs-function"><span class="hljs-params">                            killWidget)</span></span>;<br>ptrs.push_back(<span class="hljs-built_in">std</span>::move(spw));              <span class="hljs-comment">//添加spw右值</span><br></code></pre></div></td></tr></table></figure>
<p><code>emplace_back</code>的版本如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt; <span class="hljs-title">spw</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Widget, killWidget)</span></span>;<br>ptrs.emplace_back(<span class="hljs-built_in">std</span>::move(spw));<br></code></pre></div></td></tr></table></figure>
<p>无论哪种方式，都会产生<code>spw</code>的创建和销毁成本。</p>
<h3><span id="与explicit的构造函数的交互">与<code>explicit</code>的构造函数的交互</span></h3>
<p>相似的初始化语句导致了多么不一样的结果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-built_in">std</span>::regex r1 = <span class="hljs-literal">nullptr</span>;                 <span class="hljs-comment">//错误！不能编译</span><br><span class="hljs-function"><span class="hljs-built_in">std</span>::regex <span class="hljs-title">r2</span><span class="hljs-params">(<span class="hljs-literal">nullptr</span>)</span></span>;                  <span class="hljs-comment">//可以编译</span><br></code></pre></div></td></tr></table></figure>
<p>在标准的官方术语中，用于初始化<code>r1</code>的语法（使用等号）是所谓的<strong>拷贝初始化</strong>。相反，用于初始化<code>r2</code>的语法是（使用小括号，有时也用花括号）被称为<strong>直接初始化</strong>。</p>
<p>emplace_back
使用直接初始化，这意味着可能使用<code>explicit</code>的构造函数。</p>
<p>push_back
使用拷贝初始化，所以不能用<code>explicit</code>的构造函数。因此：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">regexes.emplace_back(<span class="hljs-literal">nullptr</span>);           <span class="hljs-comment">//可编译。直接初始化允许使用接受指针的</span><br>                                         <span class="hljs-comment">//std::regex的explicit构造函数</span><br>regexes.push_back(<span class="hljs-literal">nullptr</span>);              <span class="hljs-comment">//错误！拷贝初始化不允许用那个构造函数</span><br></code></pre></div></td></tr></table></figure>
<p>获得的经验是，当你使用<code>emplace_back</code>时，请特别小心确保传递了正确的实参，因为即使是<code>explicit</code>的构造函数也会被编译器考虑，编译器会试图以有效方式解释你的代码。</p>
<h3><span id="结论">结论</span></h3>
<ul>
<li>原则上，<code>emplace_back</code>有时会比<code>push_back</code>高效，并且不会更差。</li>
<li>实际上，当以下条件满足时，<code>emplace_back</code>更快：（1）值被构造到容器中，而不是直接赋值；（2）传入的类型与容器的元素类型不一致；（3）容器不拒绝已经存在的重复值。</li>
<li><code>emplace_back</code>可能执行<code>push_back</code>拒绝的类型转换。</li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Notes/">Notes</a>
                    
                      <a class="hover-with-bg" href="/categories/Notes/C/">C++</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/C/">C++</a>
                    
                      <a class="hover-with-bg" href="/tags/Book/">Book</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/posts/89ba64e7.html">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">再看Lookahead</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/posts/fd5f561d.html">
                        <span class="hidden-mobile">MySQL笔记</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      var light = 'github-light';
      var dark = 'github-dark';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'RacleRay/comments');
      s.setAttribute('issue-term', 'title');
      
      s.setAttribute('label', 'utterances');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://github.com/RacleRay" class="hint--bottom hint--rounded" aria-label="GitHub" target="_blank"> <i class="iconfont icon-github-fill" aria-hidden="true"></i> </a>
<a href="mailto:969232057@qq.com" class="hint--bottom hint--rounded" aria-label="Email" target="_blank"> <i class="iconfont icon-mail" aria-hidden="true"></i> </a>
<a href="tencent://AddContact/?fromId=50&amp;fromSubId=1&amp;subcmd=all&amp;uin=969232057" class="hint--bottom hint--rounded" aria-label="QQ" target="_blank"> <i class="iconfont icon-qq-fill" aria-hidden="true"></i> </a>
<a class="qr-trigger" target="_self"> <i class="iconfont icon-wechat-fill" aria-hidden="true"></i> <img class="qr-img" src="/img/wexin.jpg" srcset="/img/loading.gif" lazyload alt="qrcode"> </a>
<a href="/atom.xml" class="hint--bottom hint--rounded" aria-label="Email" target="_blank"> <i class="iconfont icon-rss" aria-hidden="true"></i> </a>
<div></div> <a> POWERED BY </a> <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.staticfile.org/jquery/3.5.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.staticfile.org/tocbot/4.12.0/tocbot.min.js" ></script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>



  <script  src="/js/local-search.js" ></script>






  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>
