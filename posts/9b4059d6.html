

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.ico">
  <link rel="icon" href="/img/favicon.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#1aa3ff">
  <meta name="description" content="Rust Notes">
  <meta name="author" content="HeRui">
  <meta name="keywords" content="Rust">
  <meta name="description" content="Rust Notes">
<meta property="og:type" content="article">
<meta property="og:title" content="RUST Part1">
<meta property="og:url" content="https://racleray.github.io/posts/9b4059d6.html">
<meta property="og:site_name" content="Racle&#96;s Story">
<meta property="og:description" content="Rust Notes">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-06-27T14:54:55.000Z">
<meta property="article:modified_time" content="2024-06-27T14:59:34.346Z">
<meta property="article:author" content="江左时雨">
<meta property="article:tag" content="Rust">
<meta name="twitter:card" content="summary_large_image">
  
     <meta name="baidu-site-verification" content="code-tH44R5Z2fc" /> <meta name="msvalidate.01" content="4E3B92EC6A38584E946DBE40929107D9" /> <meta name="google-site-verification" content="c-8NXvOa-KKHK4OB0TyzjFeRUuIPFXEXM9h5hYePPpw" /> 
  
  <title>RUST Part1 - Racle`s Story</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.4.0/styles/night-owl.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  
<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC&display=swap.css">
<link rel="stylesheet" href="/css/custom.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"racleray.github.io","root":"/","version":"1.8.11","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Racle`s Story" type="application/atom+xml"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>


<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="link link--kukuri" href="/", data-letters="Racle`s Story">
      Racle`s Story
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/talking/">
                <i class="iconfont icon-comment"></i>
                说说
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/46.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="RUST Part1">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2024-06-27 22:54" pubdate>
        2024年6月27日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      38k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      118 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">RUST Part1</h1>
            
            <div class="markdown-body">
              <h2><span id="rust-概览">RUST 概览</span></h2>
<p>Rust 变量和函数</p>
<ul>
<li>const , static 变量需要声明类型。const
是右值，保存在可执行文件的数据段。static 可以声明为可变，lazy_static
结合使用。</li>
<li>默认变量不可变</li>
<li>函数可以作为参数或者返回值。函数没返回值时，默认返回 unit ()。</li>
</ul>
<p>Rust 数据结构</p>
<ul>
<li>struct 定义结构体，struct ()
元组结构体，有匿名域。空结构体不占任何空间。</li>
<li>enum 定义 tagged union</li>
<li>tuple ()</li>
<li>数据行为通过 trait 定义</li>
<li>派生宏支持，#[derive(Debug)] ，支持 {:?} 进行打印</li>
<li>Copy 参数传递时，按字节拷贝</li>
<li>Clone 支持结构复制</li>
</ul>
<p>Rust 控制流程</p>
<ul>
<li>顺序执行，函数跳转上下文执行</li>
<li>循环执行，loop 死循环，while 条件循环，迭代循环 for。for
循环可用于任何实现了 IntoIterator trait 的数据结构，实际上是 loop
访问迭代器，直到返回 None</li>
<li>分支执行，if/else</li>
<li>模式匹配分支执行。match expr {} ，if let pat = expr {}
只关心某一种匹配情况</li>
<li>错误跳转，终止当前函数执行，向上一层返回错误</li>
<li>异步跳转，async 函数执行 await
，程序可能阻塞当前上下文，跳转到另一个异步任务，直到 await
不再阻塞（poll()）</li>
</ul>
<p>Rust 错误处理</p>
<ul>
<li>借鉴 Haskell 的错误处理，错误封装在 Result&lt;T, E&gt; 类型中。?
用于传播错误。</li>
</ul>
<p>Rust 项目组织</p>
<ul>
<li>mod 组织。在 lib.rs 或者 main.rs 中，用 mod
来声明要加载的模块。子文件下下，新建 mod.rs 类似 python 中的 __init__.py
，写入目录下的子模块文件名称 xx.rs</li>
<li>一个项目也被称为 crate，也可以是一个库。</li>
<li>单元测试一般放在被测试代码相同的文件中，使用条件编译 #[cfg(test)]
来确保测试代码旨在测试环境中编译。</li>
<li>集成测试一般放在 tests
目录下，集成测试只测试公开接口，编译时编译成单独的可执行文件。</li>
<li>cargo test 运行测试用例</li>
<li>所有代码放在一个 crate 中，会导致修改后，频繁编译整个
crate。workspace 是管理多个 crate 的工具。修改只影响所在的 crate。</li>
</ul>
<p>Rust 可以用过程宏、trait、泛型函数、trait object 等组织代码。</p>
<blockquote>
<p>Rust 服务器参考：<a href="https://github.com/actix/actix-web" target="_blank" rel="noopener">actix-web</a> 、<a href="https://github.com/SergioBenitez/Rocket" target="_blank" rel="noopener">rocket</a> 、<a href="https://github.com/seanmonstar/warp" target="_blank" rel="noopener">warp</a>、 <a href="https://github.com/tokio-rs/axum" target="_blank" rel="noopener">axum</a></p>
</blockquote>
<h2><span id="所有权和生命周期">所有权和生命周期</span></h2>
<ul>
<li><p>一个值同一时刻只有一个所有者，作用域外释放资源</p></li>
<li><p>赋值或者传参 Move 语义转移所有权</p></li>
<li><p>Copy trait
保留原所有权，按位拷贝数据，浅拷贝。可变引用、动态大小数据结构、包含动态大小成员的结构没有默认实现
Copy trait</p></li>
<li><p>Borrow 默认是只读的，不影响所有权</p></li>
<li><p>Rust 传参都是传值</p></li>
<li><p>一个值可以有多个只读引用，但是，只读引用不可以和可变引用共存，动态内存再分配导致地址失效的问题</p></li>
<li><p>一个值只能有一个可变引用</p></li>
<li><p>在所有权模型下，堆内存的生命周期，和创建它的栈内存的生命周期保持一致</p></li>
<li><p><code>引用</code>的生命周期不能超过<code>值</code>的生命周期</p></li>
<li><p>运行时动态检查，提供所有权的灵活控制</p></li>
<li><p>Rc 和 Arc ，创建多个所有者的数据结构，clone()
不会复制内存中数据，只会增加引用计数，Rc 和 Arc 是可变的，需要结合
RefCell 和 Mutex 实现数据的可变修改</p></li>
<li><p>Weak 是 Rc 的弱引用版本</p></li>
<li><p>RefCell 绕过 Rust
编译器静态检查，允许在运行时对只读数据进行可变借用。Rc
本身是一个只读的引用计数器</p></li>
<li><p>Arc 跨线程访问，原子引用计数，RefCell 变为 Mutex(v.lock()) 或者
RwLock (v.read()/v.write())</p></li>
<li><p>Box::leak()
创建了不受栈内存控制的堆内存，从而绕过了编译时所有权规则检查</p></li>
<li><p>外部可变性，let mut , let &amp;mut，编译时检查</p></li>
<li><p>运行时，修改内部数据，RefCell borrow_mut()，出错会引发
panic</p></li>
</ul>
<h2><span id="生命周期">生命周期</span></h2>
<ul>
<li><p>除了显示地做 Box::leak() / Box::into_raw() / ManualDrop
，一般情况下，堆内存的生命周期会和其栈内存的生命周期绑定在一起</p></li>
<li><p>静态生命周期的值，其引用也有静态生命周期</p></li>
<li><p>全局变量，静态变量，字符串字面量等，都有静态生命周期，Box::leak
后也具有静态生命周期，函数指针变量也是静态生命周期（因为它在 text
段）</p></li>
<li><p>某个作用域中，创建在堆和栈上的值，其生命周期是动态的</p></li>
<li><p>动态生命周期的表达，约定使用 'a 'b 这样表述</p></li>
<li><p>生命周期描述的是参数与参数之间，参数与返回值之间的关系，并不改变原有的生命周期</p></li>
<li><p>所有引用类型的参数都需要生命周期标注</p></li>
<li><p>编译器可以依照一些准则，自动添加标注：</p>
<ul>
<li>所有引用类型的参数都有独立的生命周期</li>
<li>如果只有一个引用类型输入，它的生命周期会赋给所有的输出</li>
<li>如果有多个引用类型的参数，其中一个是
self，那么它的生命周期会赋给所有输出</li>
</ul></li>
<li><p>使用数据结构时，数据结构自身的生命周期，需要小于等于其内部字段的所有引用的生命周期</p></li>
</ul>
<h2><span id="内存管理">内存管理</span></h2>
<ul>
<li>struct 在栈空间中，rust 会自动重排结构体</li>
<li>enum 按照最大类型长度对齐，长度乘以成员数量</li>
<li>Option<t> 会被有值和无值分别占用两块内存位置</t></li>
<li>Result&lt;T, E&gt; 会占用两块位置 T 和 E</li>
<li>rust 会对 Option<ptr> 这种引用类型数据进行优化，只占用一块空间，因为
ptr 引用为 0 是不可能的（一定错误的），那么就将 0 表示 None</ptr></li>
<li>String 内部是 Vec<u8>，Vec<t> 是 3 个 word
大小的胖指针：pointer，capacity，length</t></u8></li>
</ul>
<blockquote>
<p>Ref : <a href="https://cheats.rs/#data-layout" target="_blank" rel="noopener">Rust Language Cheat
Sheet</a></p>
</blockquote>
<ul>
<li>Copy Move
都只是浅层的按位内存复制，只要不涉及栈上的大数组拷贝或者堆内存的深拷贝，效率还是很高的</li>
<li>动态数据结构，需要注意频繁的动态扩容缩容，导致的数据拷贝，造成的效率下降。同时考虑使用
shrink_to_fit 节省内存使用</li>
<li>Drop trait ，相当于析构函数，递归调用成员的 drop()</li>
<li>rust 会自动对 socket，file，lock
进行关闭，这是其他语言中很罕见的</li>
</ul>
<blockquote>
<p>多个变量和多种异常或者错误叠加，忘记释放资源的风险敞口会成倍增加，导致死锁或者资源泄露。</p>
</blockquote>
<h2><span id="类型系统">类型系统</span></h2>
<p>对类型进行定义，检查，处理的系统。</p>
<ul>
<li>按照定义后，类型是否可以隐式转化，分为强类型和弱类型</li>
<li>按照类型检查的时机是编译时检查还是运行时检查，分为静态类型系统和动态类型系统</li>
</ul>
<p>Rust
是强类型加静态类型系统。<strong>只能按照被允许的方法，访问它被授权访问的内存</strong>。</p>
<p>Rust 中除了 let / fn / static / const
这些定义性语句外，都是表达式，而一切表达式都有类型，所以可以说在 Rust
中，类型无处不在。</p>
<p>多态的实现：</p>
<ul>
<li>动态类型系统，通过鸭子类型实现</li>
<li>静态类型系统，通过参数多态，特设多态，子类型多态实现
<ul>
<li>参数多态：代码操作的类型是，一个满足一些约束条件的参数，而非具体的类型</li>
<li>特设多态：一种行为可以有多个不同实现的多态，比如函数重载</li>
<li>子类型多态：在运行时，子类型可以被当成父类型使用</li>
</ul></li>
</ul>
<p>Rust 支持：</p>
<ul>
<li>参数多态 -- 通过泛型实现</li>
<li>特设多态 -- 通过 trait 来支持</li>
<li>子类型多态 -- 通过 trait object 来支持</li>
</ul>
<p>Rust
支持一个作用域内的局部类型推导。但是，在不能推断出类型的上下文中，需要手动指明类型。比如，全局变量
const / static。</p>
<p><a href="https://thume.ca/2019/07/14/a-tour-of-metaprogramming-models-for-generics/" target="_blank" rel="noopener">Models
of Generics and Metaprogramming: Go, Rust, Swift, D and More - Tristan
Hume (thume.ca)</a></p>
<h3><span id="trait">Trait</span></h3>
<p>Rust
中的接口，定义了某个类型使用这个接口的行为。将数据结构的行为单独抽取出来，可以在多个类型中共享，或者作为参数约束，在泛型编程中使用。</p>
<h4><span id="带约束的-trait">带约束的 Trait</span></h4>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::<span class="hljs-built_in">str</span>::FromStr;<br><span class="hljs-keyword">use</span> regex::Regex;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Parse</span></span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">parse</span></span>(s: &amp;<span class="hljs-built_in">str</span>) -&gt; <span class="hljs-keyword">Self</span>;<br>&#125;<br><br><span class="hljs-comment">// 约束 T 必须同时实现了 FromStr 和 Default</span><br><span class="hljs-keyword">impl</span>&lt;T&gt; Parse <span class="hljs-keyword">for</span> T<br><span class="hljs-keyword">where</span><br>    T: FromStr + <span class="hljs-built_in">Default</span>,<br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">parse</span></span>(s: &amp;<span class="hljs-built_in">str</span>) -&gt; <span class="hljs-keyword">Self</span> &#123;<br>        <span class="hljs-keyword">let</span> re: Regex = Regex::new(<span class="hljs-string">r"^[0-9]+(\.[0-9]+)?"</span>).unwrap();<br>        <span class="hljs-comment">// Default::default() 返回的类型根据上下文能推导出来</span><br>        <span class="hljs-keyword">let</span> d = || <span class="hljs-built_in">Default</span>::default();<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(captures) = re.captures(s) &#123;<br>            captures<br>                .get(<span class="hljs-number">0</span>)<br>                .map_or(d(), |s| s.as_str().parse().unwrap_or(d()))<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            d()<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4><span id="带关联类型的-trait">带关联类型的 Trait</span></h4>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::<span class="hljs-built_in">str</span>::FromStr;<br><span class="hljs-keyword">use</span> regex::Regex;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Parse</span></span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Error</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">parse</span></span>(s: &amp;<span class="hljs-built_in">str</span>) -&gt; <span class="hljs-built_in">Result</span>&lt;<span class="hljs-keyword">Self</span>, Self::Error&gt;<br>    <span class="hljs-keyword">where</span><br>        <span class="hljs-keyword">Self</span>: <span class="hljs-built_in">Sized</span>;<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;T&gt; Parse <span class="hljs-keyword">for</span> T<br><span class="hljs-keyword">where</span><br>    T: FromStr + <span class="hljs-built_in">Default</span>,<br>&#123;<br>    <span class="hljs-comment">// 定义关联类型 Error 为 String</span><br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Error</span></span> = <span class="hljs-built_in">String</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">parse</span></span>(s: &amp;<span class="hljs-built_in">str</span>) -&gt; <span class="hljs-built_in">Result</span>&lt;<span class="hljs-keyword">Self</span>, Self::Error&gt; &#123;<br>        <span class="hljs-keyword">let</span> re: Regex = Regex::new(<span class="hljs-string">r"^[0-9]+(\.[0-9]+)?"</span>).unwrap();<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(captures) = re.captures(s) &#123;<br>            captures<br>                .get(<span class="hljs-number">0</span>)<br>                .map_or(<span class="hljs-literal">Err</span>(<span class="hljs-string">"failed to capture"</span>.to_string()), |s| &#123;<br>                    s.as_str()<br>                        .parse()<br>                        .map_err(|_err| <span class="hljs-string">"failed to parse captured string"</span>.to_string())<br>                &#125;)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-literal">Err</span>(<span class="hljs-string">"failed to parse string"</span>.to_string())<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>trait
方法里的参数或者返回值，都可以用关联类型来表述，而在实现有关联类型的
trait 时，只需要额外提供关联类型的具体类型即可。</p>
<h4><span id="支持泛型的-trait">支持泛型的 Trait</span></h4>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Add</span></span>&lt;Rhs = <span class="hljs-keyword">Self</span>&gt; &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Output</span></span>;<br>    <span class="hljs-meta">#[must_use]</span><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">add</span></span>(<span class="hljs-keyword">self</span>, rhs: Rhs) -&gt; Self::Output;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-comment">// 对 Complex 类型的实现</span><br><span class="hljs-keyword">impl</span> Add <span class="hljs-keyword">for</span> Complex &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Output</span></span> = <span class="hljs-keyword">Self</span>;<br><br>    <span class="hljs-comment">// 注意 add 第一个参数是 self，会移动所有权</span><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">add</span></span>(<span class="hljs-keyword">self</span>, rhs: <span class="hljs-keyword">Self</span>) -&gt; Self::Output &#123;<br>        <span class="hljs-keyword">let</span> real = <span class="hljs-keyword">self</span>.real + rhs.real;<br>        <span class="hljs-keyword">let</span> imagine = <span class="hljs-keyword">self</span>.imagine + rhs.imagine;<br>        Self::new(real, imagine)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 为 &amp;Complex 实现 add</span><br><span class="hljs-keyword">impl</span> Add <span class="hljs-keyword">for</span> &amp;Complex &#123;<br>    <span class="hljs-comment">// 返回 Complex</span><br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Output</span></span> = Complex;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">add</span></span>(<span class="hljs-keyword">self</span>, rhs: <span class="hljs-keyword">Self</span>) -&gt; Self::Output &#123;<br>        <span class="hljs-keyword">let</span> real = <span class="hljs-keyword">self</span>.real + rhs.real;<br>        <span class="hljs-keyword">let</span> imagine = <span class="hljs-keyword">self</span>.imagine + rhs.imagine;<br>        Complex::new(real, imagine)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 因为 Add&lt;Rhs = Self&gt; 是个泛型 trait，可以为 Complex 实现 Add&lt;f64&gt;</span><br><span class="hljs-keyword">impl</span> Add&lt;<span class="hljs-built_in">f64</span>&gt; <span class="hljs-keyword">for</span> &amp;Complex &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Output</span></span> = Complex;<br><br>    <span class="hljs-comment">// rhs 现在是 f64</span><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">add</span></span>(<span class="hljs-keyword">self</span>, rhs: <span class="hljs-built_in">f64</span>) -&gt; Self::Output &#123;<br>        <span class="hljs-keyword">let</span> real = <span class="hljs-keyword">self</span>.real + rhs;<br>        Complex::new(real, <span class="hljs-keyword">self</span>.imagine)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> c1 = Complex::new(<span class="hljs-number">1.0</span>, <span class="hljs-number">1f64</span>);<br>    <span class="hljs-keyword">let</span> c2 = Complex::new(<span class="hljs-number">2</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">f64</span>, <span class="hljs-number">3.0</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"&#123;:?&#125;"</span>, &amp;c1 + &amp;c2);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"&#123;:?&#125;"</span>, &amp;c1 + <span class="hljs-number">5.0</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"&#123;:?&#125;"</span>, c1 + c2);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>泛型 trait 可以在需要的时候，对同一种类型的同一个
trait，有多个实现。</p>
<h4><span id="trait-的继承">Trait 的继承</span></h4>
<p><code>trait B: A</code>，表示 trait B 在定义时可以使用 trait A
中的关联类型和方法。</p>
<p>很多常见的 trait 都会使用 trait 继承来提供更多的能力，比如 tokio
库中的 <a href="https://docs.rs/tokio/1.10.0/tokio/io/trait.AsyncWriteExt.html" target="_blank" rel="noopener">AsyncWriteExt</a>、futures
库中的 <a href="https://docs.rs/futures/0.3.16/futures/stream/trait.StreamExt.html" target="_blank" rel="noopener">StreamExt</a>。</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span>&lt;T: ?<span class="hljs-built_in">Sized</span>&gt; StreamExt <span class="hljs-keyword">for</span> T <span class="hljs-keyword">where</span> T: Stream &#123;&#125;<br></code></pre></div></td></tr></table></figure>
<h4><span id="基于子类型多态">基于子类型多态</span></h4>
<p>Rust 虽然没有父类和子类，但 trait 和实现 trait
的类型之间也是类似的关系。</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Cat</span></span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Dog</span></span>;<br><br><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Animal</span></span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">name</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; &amp;<span class="hljs-symbol">'static</span> <span class="hljs-built_in">str</span>;<br>&#125;<br><br><span class="hljs-keyword">impl</span> Animal <span class="hljs-keyword">for</span> Cat &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">name</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; &amp;<span class="hljs-symbol">'static</span> <span class="hljs-built_in">str</span> &#123;<br>        <span class="hljs-string">"Cat"</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> Animal <span class="hljs-keyword">for</span> Dog &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">name</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; &amp;<span class="hljs-symbol">'static</span> <span class="hljs-built_in">str</span> &#123;<br>        <span class="hljs-string">"Dog"</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 等价于 fn name&lt;T: Animal&gt;(animal: T) -&gt; &amp;'static str;</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">name</span></span>(animal: <span class="hljs-keyword">impl</span> Animal) -&gt; &amp;<span class="hljs-symbol">'static</span> <span class="hljs-built_in">str</span> &#123;<br>    animal.name()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> cat = Cat;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"cat: &#123;&#125;"</span>, name(cat));<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>这种泛型函数会根据具体使用的类型被单态化，编译成多个实例，是静态分派。</p>
<p>但是有的时候，类型可能很难在编译时决定。使用 Trait Object
可以应对这种情况。</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-comment">// Vec&lt;&gt; 容器里的类型需要是一致的，但此处无法给定一个一致的类型。</span><br><span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">format</span></span>(input: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">String</span>, formatters: <span class="hljs-built_in">Vec</span>&lt;???&gt;) &#123;<br>    <span class="hljs-keyword">for</span> formatter <span class="hljs-keyword">in</span> formatters &#123;<br>        formatter.format(input);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 动态分派（dynamic dispatching）</span><br><span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">format</span></span>(input: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">String</span>, formatters: <span class="hljs-built_in">Vec</span>&lt;&amp;<span class="hljs-keyword">dyn</span> Formatter&gt;) &#123;<br>    <span class="hljs-keyword">for</span> formatter <span class="hljs-keyword">in</span> formatters &#123;<br>        formatter.format(input);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> html: &amp;<span class="hljs-keyword">dyn</span> Formatter = &amp;HtmlFormatter;<br>    <span class="hljs-keyword">let</span> rust: &amp;<span class="hljs-keyword">dyn</span> Formatter = &amp;RustFormatter;<br>    <span class="hljs-keyword">let</span> formatters = <span class="hljs-built_in">vec!</span>[html, rust];<br>	...<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>HtmlFormatter 的引用赋值给 Formatter 后，会生成一个 Trait
Object。</p>
<p><strong>Trait Object
的底层逻辑就是胖指针</strong>。其中，一个指针指向数据本身，另一个则指向<strong>虚函数表（vtable）</strong>。</p>
<p>vtable 是一张静态的表，Rust 在编译时会为使用了 trait object 的类型的
trait 实现生成一张表，放在可执行文件中（一般在 TEXT 或 RODATA 段）。</p>
<blockquote>
<p>Rust 也并不区分原生类型和组合类型，对 Rust
来说，所有类型的地位都是一致的。</p>
</blockquote>
<p>使用 trait object 的时候，要注意对象安全（object
safety）。只有满足对象安全的 trait 才能使用 trait object。如果 trait
所有的方法，返回值是 Self 或者携带泛型参数，那么这个 trait 就不能产生
trait object。如果一个 trait 只有部分方法返回 Self
或者使用了泛型参数，那么这部分方法在 trait object 中不能调用。</p>
<p>不允许返回 Self，是因为 trait object
在产生时，原来的类型会被抹去，所以 Self 究竟是谁不知道。比如 Clone trait
只有一个方法 clone()，返回 Self，所以它就不能产生 trait object。</p>
<p>不允许携带泛型参数，是因为 Rust 里带泛型的类型在编译时会做单态化，而
trait object 是运行时的产物，两者不能兼容。</p>
<h5><span id="vtable-测试">vtable 测试</span></h5>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fmt::&#123;<span class="hljs-built_in">Debug</span>, Display&#125;;<br><span class="hljs-keyword">use</span> std::mem::transmute;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> s1 = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">"hello world!"</span>);<br>    <span class="hljs-keyword">let</span> s2 = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">"goodbye world!"</span>);<br>    <span class="hljs-comment">// Display / Debug trait object for s</span><br>    <span class="hljs-keyword">let</span> w1: &amp;<span class="hljs-keyword">dyn</span> Display = &amp;s1;<br>    <span class="hljs-keyword">let</span> w2: &amp;<span class="hljs-keyword">dyn</span> <span class="hljs-built_in">Debug</span> = &amp;s1;<br><br>    <span class="hljs-comment">// Display / Debug trait object for s1</span><br>    <span class="hljs-keyword">let</span> w3: &amp;<span class="hljs-keyword">dyn</span> Display = &amp;s2;<br>    <span class="hljs-keyword">let</span> w4: &amp;<span class="hljs-keyword">dyn</span> <span class="hljs-built_in">Debug</span> = &amp;s2;<br><br>    <span class="hljs-comment">// 强行把 triat object 转换成两个地址 (usize, usize)</span><br>    <span class="hljs-comment">// 这是不安全的，所以是 unsafe</span><br>    <span class="hljs-keyword">let</span> (addr1, vtable1): (<span class="hljs-built_in">usize</span>, <span class="hljs-built_in">usize</span>) = <span class="hljs-keyword">unsafe</span> &#123; transmute(w1) &#125;;<br>    <span class="hljs-keyword">let</span> (addr2, vtable2): (<span class="hljs-built_in">usize</span>, <span class="hljs-built_in">usize</span>) = <span class="hljs-keyword">unsafe</span> &#123; transmute(w2) &#125;;<br>    <span class="hljs-keyword">let</span> (addr3, vtable3): (<span class="hljs-built_in">usize</span>, <span class="hljs-built_in">usize</span>) = <span class="hljs-keyword">unsafe</span> &#123; transmute(w3) &#125;;<br>    <span class="hljs-keyword">let</span> (addr4, vtable4): (<span class="hljs-built_in">usize</span>, <span class="hljs-built_in">usize</span>) = <span class="hljs-keyword">unsafe</span> &#123; transmute(w4) &#125;;<br><br>    <span class="hljs-comment">// s 和 s1 在栈上的地址，以及 main 在 TEXT 段的地址</span><br>    <span class="hljs-built_in">println!</span>(<br>        <span class="hljs-string">"s1: &#123;:p&#125;, s2: &#123;:p&#125;, main(): &#123;:p&#125;"</span>,<br>        &amp;s1, &amp;s2, main <span class="hljs-keyword">as</span> *<span class="hljs-keyword">const</span> ()<br>    );<br>    <span class="hljs-comment">// trait object(s / Display) 的 ptr 地址和 vtable 地址</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"addr1: 0x&#123;:x&#125;, vtable1: 0x&#123;:x&#125;"</span>, addr1, vtable1);<br>    <span class="hljs-comment">// trait object(s / Debug) 的 ptr 地址和 vtable 地址</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"addr2: 0x&#123;:x&#125;, vtable2: 0x&#123;:x&#125;"</span>, addr2, vtable2);<br><br>    <span class="hljs-comment">// trait object(s1 / Display) 的 ptr 地址和 vtable 地址</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"addr3: 0x&#123;:x&#125;, vtable3: 0x&#123;:x&#125;"</span>, addr3, vtable3);<br>    <span class="hljs-comment">// trait object(s1 / Display) 的 ptr 地址和 vtable 地址</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"addr4: 0x&#123;:x&#125;, vtable4: 0x&#123;:x&#125;"</span>, addr4, vtable4);<br><br>    <span class="hljs-comment">// 指向同一个数据的 trait object 其 ptr 地址相同</span><br>    <span class="hljs-built_in">assert_eq!</span>(addr1, addr2);<br>    <span class="hljs-built_in">assert_eq!</span>(addr3, addr4);<br><br>    <span class="hljs-comment">// 指向同一种类型的同一个 trait 的 vtable 地址相同</span><br>    <span class="hljs-comment">// 这里都是 String + Display</span><br>    <span class="hljs-built_in">assert_eq!</span>(vtable1, vtable3);<br>    <span class="hljs-comment">// 这里都是 String + Debug</span><br>    <span class="hljs-built_in">assert_eq!</span>(vtable2, vtable4);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4><span id="使用-trait-注意事项">使用 trait 注意事项</span></h4>
<ol type="1">
<li>在定义和使用 trait 时，需要遵循孤儿规则（Orphan Rule）。trait 和实现
trait 的数据类型，至少有一个是在当前 crate
中定义的，也就是说，你不能为第三方的类型实现第三方的 trait。</li>
<li>Rust 对含有 async fn 的 trait
，还没有一个很好的被标准库接受的实现(2019)</li>
</ol>
<h3><span id="常见-trait">常见 Trait</span></h3>
<ul>
<li>Clone / Copy trait，约定了数据被深拷贝和浅拷贝的行为；</li>
<li>Read / Write trait，约定了对 I/O 读写的行为；</li>
<li>Iterator，约定了迭代器的行为；</li>
<li>Debug，约定了数据如何被以 debug 的方式显示出来的行为；</li>
<li>Default，约定数据类型的缺省值如何产生的行为；</li>
<li>From<t> / TryFrom<t>，约定了数据间如何转换的行为.</t></t></li>
</ul>
<h4><span id="内存相关clone">内存相关：Clone</span></h4>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Clone</span></span> &#123;<br>  <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">clone</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-keyword">Self</span>;<br><br>  <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">clone_from</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, source: &amp;<span class="hljs-keyword">Self</span>) &#123;<br>    *<span class="hljs-keyword">self</span> = source.clone()<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>在 clone 过程中会分配内存，那么<strong>用
<code>a.clone_from(&amp;b)</code>
可以避免内存分配，提高效率</strong>。</p>
<p>Clone trait
可以通过派生宏直接实现，这样能简化不少代码。如果在你的数据结构里，每一个字段都已经实现了Clone
trait，你可以用 <code>#[derive(Clone)]</code>。</p>
<p>Clone 是深度拷贝，栈内存和堆内存一起拷贝。</p>
<p>clone 方法的接口是 &amp;self，这在绝大多数场合下都是适用的。在 clone
一个数据时只需要有已有数据的只读引用。但对 Rc<t> 这样在 clone()
时维护引用计数的数据结构，clone() 过程中会改变自己，所以要用 Cell<t>
这样提供内部可变性的结构来进行改变。</t></t></p>
<h4><span id="内存相关copy">内存相关：Copy</span></h4>
<p>Copy trait 没有任何额外的方法，它只是一个标记 trait（marker
trait）.</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Copy</span></span>: <span class="hljs-built_in">Clone</span> &#123;&#125;<br></code></pre></div></td></tr></table></figure>
<p><strong>虽然没有任何行为，但它可以用作 trait bound
来进行类型安全检查</strong>，所以叫<strong>标记 trait</strong>。</p>
<p>如果类型实现了
Copy，那么在赋值、函数调用的时候，值会被拷贝，否则所有权会被移动
Move。</p>
<p>可变引用 &amp;mut T 没有实现
Copy。因为，不符合<code>同一个作用域下只能有一个可变引用</code>
的所有权规则。</p>
<h4><span id="内存相关drop">内存相关：Drop</span></h4>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Drop</span></span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">drop</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>大部分场景无需为数据结构提供 Drop
trait，系统默认会依次对数据结构的每个域做 drop。</p>
<p>除了以下两种情况：</p>
<ol type="1">
<li>希望在数据结束生命周期的时候做一些事情，比如记日志。</li>
<li>需要对资源回收的场景。比如说锁资源的释放，在 MutexGuard<t> 中实现了
Drop 来释放锁资源：</t></li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span>&lt;T: ?<span class="hljs-built_in">Sized</span>&gt; <span class="hljs-built_in">Drop</span> <span class="hljs-keyword">for</span> MutexGuard&lt;<span class="hljs-symbol">'_</span>, T&gt; &#123;<br>    <span class="hljs-meta">#[inline]</span><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">drop</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">unsafe</span> &#123;<br>            <span class="hljs-keyword">self</span>.lock.poison.done(&amp;<span class="hljs-keyword">self</span>.poison);<br>            <span class="hljs-keyword">self</span>.lock.inner.raw_unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>Copy trait 和 Drop trait 是互斥的，两者不能共存。</p>
<p>Copy是按位做浅拷贝，那么它会默认拷贝的数据没有需要释放的资源；而Drop恰恰是为了释放额外的资源而生的。</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::&#123;fmt, slice&#125;;<br><br><span class="hljs-comment">// 注意这里，实现了 Copy，这是因为 *mut u8/usize 都支持 Copy</span><br><span class="hljs-meta">#[derive(Clone, Copy)]</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">RawBuffer</span></span> &#123;<br>    <span class="hljs-comment">// 裸指针用 *const / *mut 来表述，这和引用的 &amp; 不同</span><br>    ptr: *<span class="hljs-keyword">mut</span> <span class="hljs-built_in">u8</span>,<br>    len: <span class="hljs-built_in">usize</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-built_in">From</span>&lt;<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;&gt; <span class="hljs-keyword">for</span> RawBuffer &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">from</span></span>(vec: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;) -&gt; <span class="hljs-keyword">Self</span> &#123;<br>        <span class="hljs-keyword">let</span> slice = vec.into_boxed_slice();<br>        <span class="hljs-keyword">Self</span> &#123;<br>            len: slice.len(),<br>            <span class="hljs-comment">// into_raw 之后，Box 就不管这块内存的释放了，RawBuffer 需要处理释放</span><br>            ptr: <span class="hljs-built_in">Box</span>::into_raw(slice) <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> <span class="hljs-built_in">u8</span>,<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 如果 RawBuffer 实现了 Drop trait，就可以在所有者退出时释放堆内存</span><br><span class="hljs-comment">// 然后，Drop trait 会跟 Copy trait 冲突，要么不实现 Copy，要么不实现 Drop</span><br><span class="hljs-comment">// 如果不实现 Drop，那么就会导致内存泄漏，但它不会对正确性有任何破坏</span><br><span class="hljs-comment">// 比如不会出现 use after free 这样的问题。</span><br><span class="hljs-comment">// 你可以试着把下面注释去掉，看看会出什么问题</span><br><span class="hljs-comment">// impl Drop for RawBuffer &#123;</span><br><span class="hljs-comment">//     #[inline]</span><br><span class="hljs-comment">//     fn drop(&amp;mut self) &#123;</span><br><span class="hljs-comment">//         let data = unsafe &#123; Box::from_raw(slice::from_raw_parts_mut(self.ptr, self.len)) &#125;;</span><br><span class="hljs-comment">//         drop(data)</span><br><span class="hljs-comment">//     &#125;</span><br><span class="hljs-comment">// &#125;</span><br><br><span class="hljs-keyword">impl</span> fmt::<span class="hljs-built_in">Debug</span> <span class="hljs-keyword">for</span> RawBuffer &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">fmt</span></span>(&amp;<span class="hljs-keyword">self</span>, f: &amp;<span class="hljs-keyword">mut</span> fmt::Formatter&lt;<span class="hljs-symbol">'_</span>&gt;) -&gt; fmt::<span class="hljs-built_in">Result</span> &#123;<br>        <span class="hljs-keyword">let</span> data = <span class="hljs-keyword">self</span>.as_ref();<br>        <span class="hljs-built_in">write!</span>(f, <span class="hljs-string">"&#123;:p&#125;: &#123;:?&#125;"</span>, <span class="hljs-keyword">self</span>.ptr, data)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-built_in">AsRef</span>&lt;[<span class="hljs-built_in">u8</span>]&gt; <span class="hljs-keyword">for</span> RawBuffer &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">as_ref</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; &amp;[<span class="hljs-built_in">u8</span>] &#123;<br>        <span class="hljs-keyword">unsafe</span> &#123; slice::from_raw_parts(<span class="hljs-keyword">self</span>.ptr, <span class="hljs-keyword">self</span>.len) &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> data = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><br>    <span class="hljs-keyword">let</span> buf: RawBuffer = data.into();<br><br>    <span class="hljs-comment">// 因为 buf 允许 Copy，所以这里 Copy 了一份</span><br>    use_buffer(buf);<br><br>    <span class="hljs-comment">// buf 还能用</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"buf: &#123;:?&#125;"</span>, buf);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">use_buffer</span></span>(buf: RawBuffer) &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"buf to die: &#123;:?&#125;"</span>, buf);<br><br>    <span class="hljs-comment">// 这里不用特意 drop，写出来只是为了说明 Copy 出来的 buf 被 Drop 了</span><br>    <span class="hljs-built_in">drop</span>(buf)<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>对于代码安全来说，内存泄漏危害大？还是 use after free
危害大呢？肯定是后者。Rust 的底线是内存安全，所以两害相权取其轻。</p>
<p>无法保证不发生人为的内存泄漏，比如程序在运行时，对哈希表只添加不删除，就会造成内存泄漏。</p>
<h4><span id="标记相关sized">标记相关：Sized</span></h4>
<p>Sized trait 用于标记有具体大小的类型。在使用泛型参数时，Rust
编译器会自动为泛型参数加上 Sized 约束，比如下面的 Data<t> 和处理 Data<t>
的函数 process_data：</t></t></p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Data</span></span>&lt;T&gt; &#123;<br>    inner: T,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">process_data</span></span>&lt;T&gt;(data: Data&lt;T&gt;) &#123;<br>    todo!();<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>它等价于：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Data</span></span>&lt;T: <span class="hljs-built_in">Sized</span>&gt; &#123;<br>    inner: T,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">process_data</span></span>&lt;T: <span class="hljs-built_in">Sized</span>&gt;(data: Data&lt;T&gt;) &#123;<br>    todo!();<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>在少数情况下，需要 T 是可变类型的，Rust 提供了 ?Sized
来摆脱这个约束。</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Cow</span></span>&lt;<span class="hljs-symbol">'a</span>, B: ?<span class="hljs-built_in">Sized</span> + <span class="hljs-symbol">'a</span>&gt; <span class="hljs-keyword">where</span> B: <span class="hljs-built_in">ToOwned</span>,<br>&#123;<br>    <span class="hljs-comment">// 借用的数据</span><br>    Borrowed(&amp;<span class="hljs-symbol">'a</span> B),<br>    <span class="hljs-comment">// 拥有的数据</span><br>    Owned(&lt;B <span class="hljs-keyword">as</span> <span class="hljs-built_in">ToOwned</span>&gt;::Owned),<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>这样 B 就可以是 [T] 或者 str 类型，大小都是不固定的。要注意
Borrowed(&amp;'a B) 大小是固定的，因为它内部是对 B
的一个引用，而引用的大小是固定的。</p>
<h4><span id="标记相关sendsync">标记相关：Send/Sync</span></h4>
<p>说完了 Sized，再来看 Send / Sync，定义是：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">unsafe</span> auto <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Send</span></span> &#123;&#125;<br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">unsafe</span> auto <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Sync</span></span> &#123;&#125;<br></code></pre></div></td></tr></table></figure>
<p>这两个 trait 都是 unsafe auto trait，auto
意味着编译器会在合适的场合，自动为数据结构添加它们的实现，而 unsafe
代表实现的这个 trait 可能会违背 Rust
的内存安全准则，如果开发者手工实现这两个 trait
，要自己为它们的安全性负责。</p>
<p>Send/Sync 是 Rust 并发安全的基础：</p>
<ul>
<li>如果一个类型 T 实现了 Send trait，意味着 T
可以安全地从一个线程移动到另一个线程，也就是说所有权可以在线程间移动。</li>
<li>如果一个类型 T 实现了 Sync trait，则意味着 &amp;T
可以安全地在多个线程中共享。一个类型 T 满足 Sync trait，当且仅当 &amp;T
满足 Send trait。</li>
</ul>
<p>如果一个类型T: Send，那么 T
在某个线程中的独占访问是线程安全的；如果一个类型 T: Sync，那么 T
在线程间的只读共享是安全的。</p>
<p>定义的数据结构，如果其内部的所有域都实现了 Send /
Sync，那么这个数据结构会被自动添加 Send / Sync
。基本上原生数据结构都支持 Send /
Sync，也就是说，绝大多数自定义的数据结构都是满足 Send / Sync
的。标准库中，不支持 Send / Sync 的数据结构主要有：</p>
<ul>
<li>裸指针 <em>const T / </em>mut T。它们是不安全的，所以既不是 Send
也不是 Sync。</li>
<li>UnsafeCell<t> 不支持 Sync。也就是说，任何使用了 Cell 或者 RefCell
的数据结构不支持 Sync。</t></li>
<li>引用计数 Rc 不支持 Send 也不支持 Sync。所以 Rc 无法跨线程。</li>
</ul>
<p>如果尝试跨线程使用 Rc / RefCell，会发生什么？</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">spawn</span></span>&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt; <br><span class="hljs-keyword">where</span><br>    F: <span class="hljs-built_in">FnOnce</span>() -&gt; T,<br>    F: <span class="hljs-built_in">Send</span> + <span class="hljs-symbol">'static</span>,<br>    T: <span class="hljs-built_in">Send</span> + <span class="hljs-symbol">'static</span>,<br></code></pre></div></td></tr></table></figure>
<ul>
<li>'static
意思是闭包捕获的自由变量必须是一个拥有所有权的类型，或者是一个拥有静态生命周期的引用；</li>
<li>Send
意思是，这些被捕获自由变量的所有权可以从一个线程移动到另一个线程。</li>
</ul>
<p>如果在线程间传递 Rc，是无法编译通过的，因为 <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html#impl-Send" target="_blank" rel="noopener">Rc
的实现不支持 Send 和 Sync</a>。</p>
<p>Arc 内部的数据是共享的，需要支持 Sync 的数据结构，但是RefCell 不是
Sync。</p>
<h4><span id="标记相关unpin">标记相关：Unpin</span></h4>
<h4><span id="类型转换from">类型转换：From<t></t></span></h4>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-comment">// 第一种方法，为每一种转换提供一个方法</span><br><span class="hljs-comment">// 把字符串 s 转换成 Path</span><br><span class="hljs-keyword">let</span> v = s.to_path();<br><span class="hljs-comment">// 把字符串 s 转换成 u64</span><br><span class="hljs-keyword">let</span> v = s.to_u64();<br><br><span class="hljs-comment">// 第二种方法，为 s 和要转换的类型之间实现一个 Into&lt;T&gt; trait</span><br><span class="hljs-comment">// v 的类型根据上下文得出</span><br><span class="hljs-keyword">let</span> v = s.into();<br><span class="hljs-comment">// 或者也可以显式地标注 v 的类型</span><br><span class="hljs-keyword">let</span> v: <span class="hljs-built_in">u64</span> = s.into();<br></code></pre></div></td></tr></table></figure>
<p>第一种方式，在类型 T
的实现里，要为每一种可能的转换提供一个方法；第二种，为类型 T 和类型 U
之间的转换实现一个数据转换
trait，这样可以用同一个方法来实现不同的转换。</p>
<p>显然，第二种方法要更好，因为它符合软件开发的开闭原则（Open-Close
Principle），“<strong>软件中的对象（类、模块、函数等等）对扩展是开放的，但是对修改是封闭的</strong>”。</p>
<p>Rust 提供了两套不同的 trait：</p>
<ul>
<li>值类型到值类型的转换：From<t> / Into<t> / TryFrom<t> /
TryInto<t></t></t></t></t></li>
<li>引用类型到引用类型的转换：AsRef<t> / AsMut<t></t></t></li>
</ul>
<p>先看 <a href="https://doc.rust-lang.org/std/convert/trait.From.html" target="_blank" rel="noopener">From</a> 和
<a href="https://doc.rust-lang.org/std/convert/trait.Into.html" target="_blank" rel="noopener">Into</a>。这两个
trait 的定义如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">From</span></span>&lt;T&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">from</span></span>(T) -&gt; <span class="hljs-keyword">Self</span>;<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Into</span></span>&lt;T&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">into</span></span>(<span class="hljs-keyword">self</span>) -&gt; T;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>在实现 From<t> 的时候会自动实现 Into<t>。这是因为：</t></t></p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-comment">// 实现 From 会自动实现 Into</span><br><span class="hljs-keyword">impl</span>&lt;T, U&gt; <span class="hljs-built_in">Into</span>&lt;U&gt; <span class="hljs-keyword">for</span> T <span class="hljs-keyword">where</span> U: <span class="hljs-built_in">From</span>&lt;T&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">into</span></span>(<span class="hljs-keyword">self</span>) -&gt; U &#123;<br>        U::from(<span class="hljs-keyword">self</span>)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>所以大部分情况下，只用实现
From<t>，然后这两种方式都能做数据转换，比如：</t></p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> s = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">"Hello world!"</span>);<br><span class="hljs-keyword">let</span> s: <span class="hljs-built_in">String</span> = <span class="hljs-string">"Hello world!"</span>.into();<br></code></pre></div></td></tr></table></figure>
<p>这两种方式是等价的，怎么选呢？From<t>
可以根据上下文做类型推导，使用场景更多；而且因为实现了 From<t>
会自动实现 Into<t>，反之不会。<strong>所以需要的时候，不要去实现
Into<t>，只要实现 From<t> 就好了</t></t></strong>。</t></t></t></p>
<p>此外，From<t> 和 Into<t> 还是自反的：把类型 T 的值转换成类型
T，会直接返回。这是因为标准库有如下的实现：</t></t></p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-comment">// From（以及 Into）是自反的</span><br><span class="hljs-keyword">impl</span>&lt;T&gt; <span class="hljs-built_in">From</span>&lt;T&gt; <span class="hljs-keyword">for</span> T &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">from</span></span>(t: T) -&gt; T &#123;<br>        t<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>有了 From<t> 和
Into<t>，很多函数的接口就可以变得灵活，比如函数如果接受一个 IpAddr
为参数，可以使用 Into<ipaddr> 让更多的类型可以被这个函数使用，看下面的<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=f8be081138a8bb2c736e30badcc5ae41" target="_blank" rel="noopener">代码</a>：</ipaddr></t></t></p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::net::&#123;IpAddr, Ipv4Addr, Ipv6Addr&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">print</span></span>(v: <span class="hljs-keyword">impl</span> <span class="hljs-built_in">Into</span>&lt;IpAddr&gt;) &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"&#123;:?&#125;"</span>, v.into());<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> v4: Ipv4Addr = <span class="hljs-string">"2.2.2.2"</span>.parse().unwrap();<br>    <span class="hljs-keyword">let</span> v6: Ipv6Addr = <span class="hljs-string">"::1"</span>.parse().unwrap();<br>    <br>    <span class="hljs-comment">// IPAddr 实现了 From&lt;[u8; 4]，转换 IPv4 地址</span><br>    print([<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]);<br>    <span class="hljs-comment">// IPAddr 实现了 From&lt;[u16; 8]，转换 IPv6 地址</span><br>    print([<span class="hljs-number">0xfe80</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0xaede</span>, <span class="hljs-number">0x48ff</span>, <span class="hljs-number">0xfe00</span>, <span class="hljs-number">0x1122</span>]);<br>    <span class="hljs-comment">// IPAddr 实现了 From&lt;Ipv4Addr&gt;</span><br>    print(v4);<br>    <span class="hljs-comment">// IPAddr 实现了 From&lt;Ipv6Addr&gt;</span><br>    print(v6);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>所以，合理地使用 From<t> / Into<t>，可以让代码变得简洁，符合 Rust
可读性强的风格，更符合开闭原则。</t></t></p>
<p>如果你的数据类型在转换过程中有可能出现错误，可以使用 <a href="https://doc.rust-lang.org/std/convert/trait.TryFrom.html" target="_blank" rel="noopener">TryFrom</a>
和 <a href="https://doc.rust-lang.org/std/convert/trait.TryInto.html" target="_blank" rel="noopener">TryInto</a>，它们的用法和
From<t> / Into<t> 一样，只是 trait 内多了一个关联类型
Error，且返回的结果是 Result&lt;T, Self::Error&gt;。</t></t></p>
<h4><span id="类型转换asref-asmut">类型转换：AsRef<t> / AsMut<t></t></t></span></h4>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">AsRef</span></span>&lt;T&gt; <span class="hljs-keyword">where</span> T: ?<span class="hljs-built_in">Sized</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">as_ref</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; &amp;T;<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">AsMut</span></span>&lt;T&gt; <span class="hljs-keyword">where</span> T: ?<span class="hljs-built_in">Sized</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">as_mut</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; &amp;<span class="hljs-keyword">mut</span> T;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>在 trait 的定义上，都允许 T 使用大小可变的类型，如 str、[u8]
等。AsMut<t> 除了使用可变引用生成可变引用外，其它都和 AsRef<t>
一样。</t></t></p>
<p>看标准库中打开文件的接口 <a href="https://doc.rust-lang.org/std/fs/struct.File.html#method.open" target="_blank" rel="noopener">std::fs::File::open</a>：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">open</span></span>&lt;P: <span class="hljs-built_in">AsRef</span>&lt;Path&gt;&gt;(path: P) -&gt; <span class="hljs-built_in">Result</span>&lt;File&gt;<br></code></pre></div></td></tr></table></figure>
<p>它的参数 path 是符合 AsRef<path></path> 的类型，所以，你可以为这个参数传入
String、&amp;str、PathBuf、Path 等类型。而且，当你使用 path.as_ref()
时，会得到一个 &amp;Path。</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-meta">#[allow(dead_code)]</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Language</span></span> &#123;<br>    Rust,<br>    TypeScript,<br>    Elixir,<br>    Haskell,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-built_in">AsRef</span>&lt;<span class="hljs-built_in">str</span>&gt; <span class="hljs-keyword">for</span> Language &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">as_ref</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; &amp;<span class="hljs-built_in">str</span> &#123;<br>        <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span> &#123;<br>            Language::Rust =&gt; <span class="hljs-string">"Rust"</span>,<br>            Language::TypeScript =&gt; <span class="hljs-string">"TypeScript"</span>,<br>            Language::Elixir =&gt; <span class="hljs-string">"Elixir"</span>,<br>            Language::Haskell =&gt; <span class="hljs-string">"Haskell"</span>,<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">print_ref</span></span>(v: <span class="hljs-keyword">impl</span> <span class="hljs-built_in">AsRef</span>&lt;<span class="hljs-built_in">str</span>&gt;) &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"&#123;&#125;"</span>, v.as_ref());<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> lang = Language::Rust;<br>    <span class="hljs-comment">// &amp;str 实现了 AsRef&lt;str&gt;</span><br>    print_ref(<span class="hljs-string">"Hello world!"</span>);<br>    <span class="hljs-comment">// String 实现了 AsRef&lt;str&gt;</span><br>    print_ref(<span class="hljs-string">"Hello world!"</span>.to_string());<br>    <span class="hljs-comment">// 自己定义的 enum 也实现了 AsRef&lt;str&gt;</span><br>    print_ref(lang);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>如果你的代码出现 v.as_ref().clone() 这样的语句，也就是说你要对 v
进行引用转换，然后又得到了拥有所有权的值，那么你应该实现 From<t>，然后做
v.into()。</t></p>
<h4><span id="操作符相关derefderefmut">操作符相关：Deref/DerefMut</span></h4>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Deref</span></span> &#123;<br>    <span class="hljs-comment">// 解引用出来的结果类型</span><br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Target</span></span>: ?<span class="hljs-built_in">Sized</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">deref</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; &amp;Self::Target;<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">DerefMut</span></span>: Deref &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">deref_mut</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; &amp;<span class="hljs-keyword">mut</span> Self::Target;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>可以看到，DerefMut “继承”了 Deref，只是它额外提供了一个 deref_mut
方法，用来获取可变的解引用。</p>
<p>Deref 和 DerefMut 是自动调用的，<em>b 会被展开为 </em>(b.deref())</p>
<p>在 Rust 里，绝大多数智能指针都实现了
Deref，也可以为自己的数据结构实现 Deref。</p>
<p>对于普通的引用，解引用很直观，因为它只有一个指向值的地址，从这个地址可以获取到所需要的值，比如下面的例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> x = <span class="hljs-number">42</span>;<br><span class="hljs-keyword">let</span> y = &amp;<span class="hljs-keyword">mut</span> x;<br><span class="hljs-comment">// 解引用，内部调用 DerefMut（其实现就是 *self）</span><br>*y += <span class="hljs-number">1</span>;<br></code></pre></div></td></tr></table></figure>
<p>但对智能指针来说，拿什么域来解引用就不那么直观了，来看之前学过的 Rc
是怎么实现 Deref 的：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span>&lt;T: ?<span class="hljs-built_in">Sized</span>&gt; Deref <span class="hljs-keyword">for</span> Rc&lt;T&gt; &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Target</span></span> = T;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">deref</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; &amp;T &#123;<br>        &amp;<span class="hljs-keyword">self</span>.inner().value<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>可以看到，它最终指向了堆上的 RcBox 内部的 value
的地址，然后如果对其解引用的话，得到了 value 对应的值。</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::ops::&#123;Deref, DerefMut&#125;;<br><br><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Buffer</span></span>&lt;T&gt;(<span class="hljs-built_in">Vec</span>&lt;T&gt;);<br><br><span class="hljs-keyword">impl</span>&lt;T&gt; Buffer&lt;T&gt; &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">new</span></span>(v: <span class="hljs-keyword">impl</span> <span class="hljs-built_in">Into</span>&lt;<span class="hljs-built_in">Vec</span>&lt;T&gt;&gt;) -&gt; <span class="hljs-keyword">Self</span> &#123;<br>        <span class="hljs-keyword">Self</span>(v.into())<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;T&gt; Deref <span class="hljs-keyword">for</span> Buffer&lt;T&gt; &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Target</span></span> = [T];<br><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">deref</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; &amp;Self::Target &#123;<br>        &amp;<span class="hljs-keyword">self</span>.<span class="hljs-number">0</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;T&gt; DerefMut <span class="hljs-keyword">for</span> Buffer&lt;T&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">deref_mut</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; &amp;<span class="hljs-keyword">mut</span> Self::Target &#123;<br>        &amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>.<span class="hljs-number">0</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> buf = Buffer::new([<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>]);<br>    <span class="hljs-comment">// 因为实现了 Deref 和 DerefMut，这里 buf 可以直接访问 Vec&lt;T&gt; 的方法</span><br>    <span class="hljs-comment">// 下面这句相当于：(&amp;mut buf).deref_mut().sort()，也就是 (&amp;mut buf.0).sort()</span><br>    buf.sort();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"buf: &#123;:?&#125;"</span>, buf);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><strong>实现 Deref 和 DerefMut，这样在解引用的时候，直接访问到
buf.0</strong>，省去了代码的啰嗦和数据结构内部字段的隐藏。</p>
<h4><span id="其它-debug">其它: Debug</span></h4>
<p>先看 Debug / Display，它们的定义如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Debug</span></span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">fmt</span></span>(&amp;<span class="hljs-keyword">self</span>, f: &amp;<span class="hljs-keyword">mut</span> Formatter&lt;<span class="hljs-symbol">'_</span>&gt;) -&gt; <span class="hljs-built_in">Result</span>&lt;(), Error&gt;;<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Display</span></span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">fmt</span></span>(&amp;<span class="hljs-keyword">self</span>, f: &amp;<span class="hljs-keyword">mut</span> Formatter&lt;<span class="hljs-symbol">'_</span>&gt;) -&gt; <span class="hljs-built_in">Result</span>&lt;(), Error&gt;;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>可以看到，Debug 和 Display 两个 trait 的签名一样，都接受一个
&amp;self 和一个 &amp;mut Formatter。</p>
<p><strong>Debug 是为开发者调试打印数据结构所设计的，而 Display
是给用户显示数据结构所设计的</strong>。这也是为什么 Debug trait
的实现可以通过派生宏直接生成，而 Display
必须手工实现。在使用的时候，Debug 用 {:?} 来打印，Display 用 {}
打印。</p>
<p>最后看 Default trait。它的定义如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Default</span></span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">default</span></span>() -&gt; <span class="hljs-keyword">Self</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>Default trait 用于为类型提供缺省值。它也可以通过 derive 宏
#[derive(Default)] 来生成实现，前提是类型中的每个字段都实现了 Default
trait。在初始化一个数据结构时，可以部分初始化，然后剩余的部分使用
Default::default()。</p>
<p>Debug/Display/Default 如何使用，统一看个例子（<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=77bdb7c373ad7762bf0e3c2081c96719" target="_blank" rel="noopener">代码</a>）：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fmt;<br><span class="hljs-comment">// struct 可以 derive Default，但需要所有字段都实现了 Default</span><br><span class="hljs-meta">#[derive(Clone, Debug, Default)]</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Developer</span></span> &#123;<br>    name: <span class="hljs-built_in">String</span>,<br>    age: <span class="hljs-built_in">u8</span>,<br>    lang: Language,<br>&#125;<br><br><span class="hljs-comment">// enum 不能 derive Default</span><br><span class="hljs-meta">#[allow(dead_code)]</span><br><span class="hljs-meta">#[derive(Clone, Debug)]</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Language</span></span> &#123;<br>    Rust,<br>    TypeScript,<br>    Elixir,<br>    Haskell,<br>&#125;<br><br><span class="hljs-comment">// 手工实现 Default</span><br><span class="hljs-keyword">impl</span> <span class="hljs-built_in">Default</span> <span class="hljs-keyword">for</span> Language &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">default</span></span>() -&gt; <span class="hljs-keyword">Self</span> &#123;<br>        Language::Rust<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> Developer &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">new</span></span>(name: &amp;<span class="hljs-built_in">str</span>) -&gt; <span class="hljs-keyword">Self</span> &#123;<br>        <span class="hljs-comment">// 用 ..Default::default() 为剩余字段使用缺省值</span><br>        <span class="hljs-keyword">Self</span> &#123;<br>            name: name.to_owned(),<br>            ..<span class="hljs-built_in">Default</span>::default()<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> fmt::Display <span class="hljs-keyword">for</span> Developer &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">fmt</span></span>(&amp;<span class="hljs-keyword">self</span>, f: &amp;<span class="hljs-keyword">mut</span> fmt::Formatter&lt;<span class="hljs-symbol">'_</span>&gt;) -&gt; fmt::<span class="hljs-built_in">Result</span> &#123;<br>        <span class="hljs-built_in">write!</span>(<br>            f,<br>            <span class="hljs-string">"&#123;&#125;(&#123;&#125; years old): &#123;:?&#125; developer"</span>,<br>            <span class="hljs-keyword">self</span>.name, <span class="hljs-keyword">self</span>.age, <span class="hljs-keyword">self</span>.lang<br>        )<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-comment">// 使用 T::default()</span><br>    <span class="hljs-keyword">let</span> dev1 = Developer::default();<br>    <span class="hljs-comment">// 使用 Default::default()，但此时类型无法通过上下文推断，需要提供类型</span><br>    <span class="hljs-keyword">let</span> dev2: Developer = <span class="hljs-built_in">Default</span>::default();<br>    <span class="hljs-comment">// 使用 T::new</span><br>    <span class="hljs-keyword">let</span> dev3 = Developer::new(<span class="hljs-string">"Tyr"</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"dev1: &#123;&#125;\\ndev2: &#123;&#125;\\ndev3: &#123;:?&#125;"</span>, dev1, dev2, dev3);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>在软件开发中，延迟绑定会带来极大的灵活性。</p>
<p>从数据的角度看，数据结构是具体数据的延迟绑定，泛型结构是具体数据结构的延迟绑定；从代码的角度看，函数是一组实现某个功能的表达式的延迟绑定，泛型函数是函数的延迟绑定。那么
trait 是什么的延迟绑定呢？</p>
<p><strong>trait
是行为的延迟绑定</strong>。可以在不知道具体要处理什么数据结构的前提下，先通过
trait
把系统的很多行为约定好。这也是为什么开头解释标准trait时，频繁用到了“约定……行为”。</p>
<h2><span id="智能指针">智能指针</span></h2>
<p>指针是一个持有内存地址的值，可以通过解引用来访问它指向的内存地址，理论上可以解引用到任意数据类型；引用是一个特殊的指针，它的解引用访问是受限的，只能解引用到它引用数据的类型。</p>
<p>智能指针是一个表现行为很像指针的数据结构，但除了指向数据的指针外，它还有元数据以提供额外的处理能力。</p>
<p><strong>在 Rust 中，凡是需要做资源回收的数据结构，且实现了
Deref/DerefMut/Drop，都是智能指针</strong>。</p>
<p>用于在堆上分配内存的 Box<t> 和 Vec<t>、用于引用计数的 Rc<t> 和 Arc<t>
。很多其他数据结构，如 PathBuf、Cow&lt;'a,
B&gt;、MutexGuard<t>、RwLockReadGuard<t> 和 RwLockWriteGuard
等也是智能指针。</t></t></t></t></t></t></p>
<p>String 是用结构体定义的：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">String</span></span> &#123;<br>    vec: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;,<br>&#125;<br><br><span class="hljs-keyword">impl</span> ops::Deref <span class="hljs-keyword">for</span> <span class="hljs-built_in">String</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Target</span></span> = <span class="hljs-built_in">str</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">deref</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; &amp;<span class="hljs-built_in">str</span> &#123;<br>        <span class="hljs-keyword">unsafe</span> &#123; <span class="hljs-built_in">str</span>::from_utf8_unchecked(&amp;<span class="hljs-keyword">self</span>.vec) &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> ops::DerefMut <span class="hljs-keyword">for</span> <span class="hljs-built_in">String</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">deref_mut</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">str</span> &#123;<br>        <span class="hljs-keyword">unsafe</span> &#123; <span class="hljs-built_in">str</span>::from_utf8_unchecked_mut(&amp;<span class="hljs-keyword">mut</span> *<span class="hljs-keyword">self</span>.vec) &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">impl</span>&lt;<span class="hljs-meta">#[may_dangle]</span> T, A: Allocator&gt; <span class="hljs-built_in">Drop</span> <span class="hljs-keyword">for</span> <span class="hljs-built_in">Vec</span>&lt;T, A&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">drop</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">unsafe</span> &#123;<br>            <span class="hljs-comment">// use drop for [T]</span><br>            <span class="hljs-comment">// use a raw slice to refer to the elements of the vector as weakest necessary type;</span><br>            <span class="hljs-comment">// could avoid questions of validity in certain cases</span><br>            ptr::drop_in_place(ptr::slice_from_raw_parts_mut(<span class="hljs-keyword">self</span>.as_mut_ptr(), <span class="hljs-keyword">self</span>.len))<br>        &#125;<br>        <span class="hljs-comment">// RawVec handles deallocation</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3><span id="box">Box<t></t></span></h3>
<p>Rust 中最基本的在堆上分配内存的方式。</p>
<p>Box<t> 的定义里，内部是一个 <a href="https://doc.rust-lang.org/src/core/ptr/unique.rs.html#36-44" target="_blank" rel="noopener">Unique</a>
用于致敬 C++，Unique<t> 是一个私有的数据结构，不能直接使用，它包裹了一个
*const T 指针，并唯一拥有这个指针。</t></t></p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Unique</span></span>&lt;T: ?<span class="hljs-built_in">Sized</span>&gt; &#123;<br>    pointer: *<span class="hljs-keyword">const</span> T,<br>    <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> this marker has no consequences for variance, but is necessary</span><br>    <span class="hljs-comment">// for dropck to understand that we logically own a `T`.</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// For details, see:</span><br>    <span class="hljs-comment">// https://github.com/rust-lang/rfcs/blob/master/text/0769-sound-generic-drop.md#phantom-data</span><br>    _marker: PhantomData&lt;T&gt;,<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>在堆上分配内存，需要使用内存分配器（Allocator）。设计内存分配器的目的除了保证正确性之外，就是为了有效地利用剩余内存，并控制内存在分配和释放过程中产生的碎片的数量。</p>
<p>堆上分配内存的 Box<t> 其实有一个缺省的泛型参数 A，就需要满足 <a href="https://doc.rust-lang.org/std/alloc/trait.Allocator.html" target="_blank" rel="noopener">Allocator
trait</a>，并且默认是 Global：</t></p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Box</span></span>&lt;T: ?<span class="hljs-built_in">Sized</span>,A: Allocator = Global&gt;(Unique&lt;T&gt;, A)<br></code></pre></div></td></tr></table></figure>
<p>Allocator trait 提供很多方法：</p>
<ul>
<li>allocate是主要方法，用于分配内存，对应 C 的 malloc/calloc；</li>
<li>deallocate，用于释放内存，对应 C 的 free；</li>
<li>还有 grow / shrink，用来扩大或缩小堆上已分配的内存，对应 C 的
realloc。</li>
</ul>
<p>替换默认的内存分配器，可以使用 #[global_allocator]
标记宏，定义你自己的全局分配器。下面的代码展示了如何在 Rust 下使用 <a href="https://crates.io/crates/jemallocator" target="_blank" rel="noopener">jemalloc</a>：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> jemallocator::Jemalloc;<br><br><span class="hljs-meta">#[global_allocator]</span><br><span class="hljs-keyword">static</span> GLOBAL: Jemalloc = Jemalloc;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;&#125;<br></code></pre></div></td></tr></table></figure>
<p>这样设置之后，使用 Box::new() 分配的内存就是 jemalloc
分配出来的了。另外，撰写自己的全局分配器，可以实现 <a href="https://doc.rust-lang.org/std/alloc/trait.GlobalAlloc.html" target="_blank" rel="noopener">GlobalAlloc
trait</a>，它和 Allocator trait
的区别，主要在于是否允许分配长度为零的内存。</p>
<blockquote>
<p>常见的通用内存分配器有 glibc 的 <a href="http://www.malloc.de/en/" target="_blank" rel="noopener">pthread malloc</a>、Google 开发的 <a href="https://github.com/google/tcmalloc" target="_blank" rel="noopener">tcmalloc</a>、FreeBSD
上默认使用的 <a href="https://github.com/jemalloc/jemalloc" target="_blank" rel="noopener">jemalloc</a>
等。除了通用内存分配器，对于特定类型内存的分配，还可以用 <a href="https://en.wikipedia.org/wiki/Slab_allocation" target="_blank" rel="noopener">slab</a>，slab
相当于一个预分配好的对象池，可以扩展和收缩。</p>
</blockquote>
<h4><span id="示例">示例</span></h4>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::alloc::&#123;GlobalAlloc, Layout, System&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MyAllocator</span></span>;<br><br><span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">impl</span> GlobalAlloc <span class="hljs-keyword">for</span> MyAllocator &#123;<br>    <span class="hljs-keyword">unsafe</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">alloc</span></span>(&amp;<span class="hljs-keyword">self</span>, layout: Layout) -&gt; *<span class="hljs-keyword">mut</span> <span class="hljs-built_in">u8</span> &#123;<br>        <span class="hljs-keyword">let</span> data = System.alloc(layout);<br>        eprintln!(<span class="hljs-string">"ALLOC: &#123;:p&#125;, size &#123;&#125;"</span>, data, layout.size());<br>        data<br>    &#125;<br><br>    <span class="hljs-keyword">unsafe</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">dealloc</span></span>(&amp;<span class="hljs-keyword">self</span>, ptr: *<span class="hljs-keyword">mut</span> <span class="hljs-built_in">u8</span>, layout: Layout) &#123;<br>        System.dealloc(ptr, layout);<br>        eprintln!(<span class="hljs-string">"FREE: &#123;:p&#125;, size &#123;&#125;"</span>, ptr, layout.size());<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">#[global_allocator]</span><br><span class="hljs-keyword">static</span> GLOBAL: MyAllocator = MyAllocator;<br><br><span class="hljs-meta">#[allow(dead_code)]</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Matrix</span></span> &#123;<br>    <span class="hljs-comment">// 使用不规则的数字如 505 可以让 dbg! 的打印很容易分辨出来</span><br>    data: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">505</span>],<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-built_in">Default</span> <span class="hljs-keyword">for</span> Matrix &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">default</span></span>() -&gt; <span class="hljs-keyword">Self</span> &#123;<br>        <span class="hljs-keyword">Self</span> &#123; data: [<span class="hljs-number">0</span>; <span class="hljs-number">505</span>] &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-comment">// 在这句执行之前已经有好多内存分配</span><br>    <span class="hljs-keyword">let</span> data = <span class="hljs-built_in">Box</span>::new(Matrix::default());<br><br>    <span class="hljs-comment">// 输出中有一个 1024 大小的内存分配，是 println! 导致的</span><br>    <span class="hljs-built_in">println!</span>(<br>        <span class="hljs-string">"!!! allocated memory: &#123;:p&#125;, len: &#123;&#125;"</span>,<br>        &amp;*data,<br>        std::mem::size_of::&lt;Matrix&gt;()<br>    );<br><br>    <span class="hljs-comment">// data 在这里 drop，可以在打印中看到 FREE</span><br>    <span class="hljs-comment">// 之后还有很多其它内存被释放</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>注意这里不能使用 println!() 。因为 stdout 会打印到一个由 Mutex
互斥锁保护的共享全局 buffer 中，这个过程中会涉及内存的分配，再运行
println!()，最终造成程序崩溃。而 eprintln! 直接打印到 stderr，不会
buffer。</p>
</blockquote>
<p>Box::new()
是一个函数，所以传入它的数据会出现在栈上，再移动到堆上。所以，如果的
Matrix 结构不是 505 个字节，是一个非常大的结构，就有可能出现 stack
overflow 问题。</p>
<p>如果是 debug build，它不会做任何 inline 的优化，而 Box::new()
注明了要 inline，在 release 模式下，这个函数调用会被优化掉：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-meta">#[cfg(not(no_global_oom_handling))]</span><br><span class="hljs-meta">#[inline(always)]</span><br><span class="hljs-meta">#[doc(alias = <span class="hljs-meta-string">"alloc"</span>)]</span><br><span class="hljs-meta">#[doc(alias = <span class="hljs-meta-string">"malloc"</span>)]</span><br><span class="hljs-meta">#[stable(feature = <span class="hljs-meta-string">"rust1"</span>, since = <span class="hljs-meta-string">"1.0.0"</span>)]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">new</span></span>(x: T) -&gt; <span class="hljs-keyword">Self</span> &#123;<br>    <span class="hljs-keyword">box</span> x<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>如果不 inline，整个 16M 的大数组会通过栈内存传递给
Box::new，导致栈溢出。</p>
<p>Box<t> 的内存释放实现：</t></p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-meta">#[stable(feature = <span class="hljs-meta-string">"rust1"</span>, since = <span class="hljs-meta-string">"1.0.0"</span>)]</span><br><span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">impl</span>&lt;<span class="hljs-meta">#[may_dangle]</span> T: ?<span class="hljs-built_in">Sized</span>, A: Allocator&gt; <span class="hljs-built_in">Drop</span> <span class="hljs-keyword">for</span> <span class="hljs-built_in">Box</span>&lt;T, A&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">drop</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-comment">// <span class="hljs-doctag">FIXME:</span> Do nothing, drop is currently performed by compiler.</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>drop trait 什么都没有做，编译器会自动插入 deallocate 的代码。这是
Rust
语言的一种策略：<strong>在具体实现还没有稳定下来之前，先把接口稳定，实现随着之后的迭代慢慢稳定</strong>。</p>
<h3><span id="cowlta-bgt">Cow&lt;'a, B&gt;</span></h3>
<p>Cow 是 Rust
下用于提供写时克隆（Clone-on-Write）的一个智能指针，<strong>有一个只读借用，但如果调用者需要所有权或者需要修改内容，那么它会
clone 借用的数据</strong>。</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Cow</span></span>&lt;<span class="hljs-symbol">'a</span>, B&gt; <span class="hljs-keyword">where</span> B: <span class="hljs-symbol">'a</span> + <span class="hljs-built_in">ToOwned</span> + ?<span class="hljs-built_in">Sized</span> &#123;<br>  Borrowed(&amp;<span class="hljs-symbol">'a</span> B),<br>  Owned(&lt;B <span class="hljs-keyword">as</span> <span class="hljs-built_in">ToOwned</span>&gt;::Owned),<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>它是一个 enum，可以包含一个对类型 B 的只读引用，或者包含对类型 B
的拥有所有权的数据。</p>
<p>这里又引入了两个 trait，首先是 ToOwned，在 ToOwned trait
定义的时候，又引入了 Borrow trait，它们都是 <a href="https://doc.rust-lang.org/std/borrow/index.html" target="_blank" rel="noopener">std::borrow</a>
下的 trait：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">ToOwned</span></span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Owned</span></span>: Borrow&lt;<span class="hljs-keyword">Self</span>&gt;;<br>    <span class="hljs-meta">#[must_use = <span class="hljs-meta-string">"cloning is often expensive and is not expected to have side effects"</span>]</span><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">to_owned</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; Self::Owned;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">clone_into</span></span>(&amp;<span class="hljs-keyword">self</span>, target: &amp;<span class="hljs-keyword">mut</span> Self::Owned) &#123; ... &#125;<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Borrow</span></span>&lt;Borrowed&gt; <span class="hljs-keyword">where</span> Borrowed: ?<span class="hljs-built_in">Sized</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">borrow</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; &amp;Borrowed;<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;B: ?<span class="hljs-built_in">Sized</span> + <span class="hljs-built_in">ToOwned</span>&gt; Deref <span class="hljs-keyword">for</span> Cow&lt;<span class="hljs-symbol">'_</span>, B&gt; &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Target</span></span> = B;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">deref</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; &amp;B &#123;<br>        <span class="hljs-keyword">match</span> *<span class="hljs-keyword">self</span> &#123;<br>            Borrowed(borrowed) =&gt; borrowed,<br>            Owned(<span class="hljs-keyword">ref</span> owned) =&gt; owned.borrow(),<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>根据 self 是 Borrowed 还是 Owned，分别取其内容，生成引用：</p>
<ul>
<li>对于 Borrowed，直接就是引用；</li>
<li>对于 Owned，调用其 borrow() 方法，获得引用。</li>
</ul>
<p><strong>根据 enum
的不同状态来进行统一分发的方法是第三种分发手段</strong>，对应的有使用泛型参数做静态分发和使用
trait object 做动态分发。</p>
<p>相对于栈内存的分配释放来说，堆内存的分配和释放效率要低很多，其内部还涉及系统调用和锁，<strong>减少不必要的堆内存分配是提升系统效率的关键手段</strong>。而
Rust 的 Cow&lt;'a,
B&gt;，在帮助你达成这个效果的同时，使用体验还非常简单舒服。</p>
<h4><span id="使用示例">使用示例</span></h4>
<p>在解析 URL 的时候，需要将 querystring 中的参数，提取成 KV pair
来进一步使用。绝大多数语言中，提取出来的 KV
都是新的字符串，在每秒钟处理几十 k 甚至上百 k
请求的系统中，堆内存的分配会很频繁。</p>
<p>但在 Rust 中，可以用 Cow 类型轻松高效处理它，在读取 URL
的过程中：</p>
<ul>
<li>每解析出一个 key 或者 value，可以用一个 &amp;str 指向 URL
中相应的位置，然后用 Cow 封装它；</li>
<li>而当解析出来的内容不能直接使用，需要 decode 时，比如
“hello%20world”，可以生成一个解析后的 String，同样用 Cow 封装它。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::borrow::Cow;<br><br><span class="hljs-keyword">use</span> url::Url;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> url = Url::parse(<span class="hljs-string">"https://tyr.com/rust?page=1024&amp;sort=desc&amp;extra=hello%20world"</span>).unwrap();<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> pairs = url.query_pairs();<br><br>    <span class="hljs-built_in">assert_eq!</span>(pairs.count(), <span class="hljs-number">3</span>);<br><br>    <span class="hljs-keyword">let</span> (<span class="hljs-keyword">mut</span> k, v) = pairs.next().unwrap();<br>    <span class="hljs-comment">// 因为 k, v 都是 Cow&lt;str&gt; 他们用起来感觉和 &amp;str 或者 String 一样</span><br>    <span class="hljs-comment">// 此刻，他们都是 Borrowed</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"key: &#123;&#125;, v: &#123;&#125;"</span>, k, v);<br>    <span class="hljs-comment">// 当修改发生时，k 变成 Owned</span><br>    k.to_mut().push_str(<span class="hljs-string">"_lala"</span>);<br><br>    print_pairs((k, v));<br><br>    print_pairs(pairs.next().unwrap());<br>    <span class="hljs-comment">// 在处理 extra=hello%20world 时，value 被处理成 "hello world"</span><br>    <span class="hljs-comment">// 所以这里 value 是 Owned</span><br>    print_pairs(pairs.next().unwrap());<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">print_pairs</span></span>(pair: (Cow&lt;<span class="hljs-built_in">str</span>&gt;, Cow&lt;<span class="hljs-built_in">str</span>&gt;)) &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"key: &#123;&#125;, value: &#123;&#125;"</span>, show_cow(pair.<span class="hljs-number">0</span>), show_cow(pair.<span class="hljs-number">1</span>));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">show_cow</span></span>(cow: Cow&lt;<span class="hljs-built_in">str</span>&gt;) -&gt; <span class="hljs-built_in">String</span> &#123;<br>    <span class="hljs-keyword">match</span> cow &#123;<br>        Cow::Borrowed(v) =&gt; <span class="hljs-built_in">format!</span>(<span class="hljs-string">"Borrowed &#123;&#125;"</span>, v),<br>        Cow::Owned(v) =&gt; <span class="hljs-built_in">format!</span>(<span class="hljs-string">"Owned &#123;&#125;"</span>, v),<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>在 Rust 标准库和第三方库中非常常见。比如 Rust 下著名的 <a href="https://serde.rs/" target="_blank" rel="noopener">serde 库</a>，可以非常高效地对 Rust
数据结构，进行序列化/反序列化操作，它对 Cow 就有很好的支持。</p>
<p>我们可以通过如下代码将一个 JSON 数据反序列化成 User 类型，同时让 User
中的 name 使用 Cow 来引用 JSON 文本中的内容：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::borrow::Cow;<br><span class="hljs-keyword">use</span> serde::Deserialize;<br><br><span class="hljs-meta">#[derive(Debug, Deserialize)]</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">User</span></span>&lt;<span class="hljs-symbol">'input</span>&gt; &#123;<br>    <span class="hljs-meta">#[serde(borrow)]</span><br>    name: Cow&lt;<span class="hljs-symbol">'input</span>, <span class="hljs-built_in">str</span>&gt;,<br>    age: <span class="hljs-built_in">u8</span>,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> input = <span class="hljs-string">r#"&#123; "name": "Tyr", "age": 18 &#125;"#</span>;<br>    <span class="hljs-keyword">let</span> user: User = serde_json::from_str(input).unwrap();<br><br>    <span class="hljs-keyword">match</span> user.name &#123;<br>        Cow::Borrowed(x) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"borrowed &#123;&#125;"</span>, x),<br>        Cow::Owned(x) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"owned &#123;&#125;"</span>, x),<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3><span id="mutexguard">MutexGuard<t></t></span></h3>
<p>MutexGuard 不但通过 Deref 提供良好的用户体验，还通过 Drop trait
来确保，使用到的内存以外的资源在退出时进行释放。</p>
<p>MutexGuard 这个结构是在调用 <a href="https://doc.rust-lang.org/src/std/sync/mutex.rs.html#279-284" target="_blank" rel="noopener">Mutex::lock</a>
时生成的：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">lock</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; LockResult&lt;MutexGuard&lt;<span class="hljs-symbol">'_</span>, T&gt;&gt; &#123;<br>    <span class="hljs-keyword">unsafe</span> &#123;<br>        <span class="hljs-keyword">self</span>.inner.raw_lock();<br>        MutexGuard::new(<span class="hljs-keyword">self</span>)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>首先，它会取得锁资源，如果拿不到，会在这里等待；如果拿到了，会把
Mutex 结构的引用传递给 MutexGuard。</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-comment">// 这里用 must_use，当你得到了却不使用 MutexGuard 时会报警</span><br><span class="hljs-meta">#[must_use = <span class="hljs-meta-string">"if unused the Mutex will immediately unlock"</span>]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MutexGuard</span></span>&lt;<span class="hljs-symbol">'a</span>, T: ?<span class="hljs-built_in">Sized</span> + <span class="hljs-symbol">'a</span>&gt; &#123;<br>    lock: &amp;<span class="hljs-symbol">'a</span> Mutex&lt;T&gt;,<br>    poison: poison::Guard,<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;T: ?<span class="hljs-built_in">Sized</span>&gt; Deref <span class="hljs-keyword">for</span> MutexGuard&lt;<span class="hljs-symbol">'_</span>, T&gt; &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Target</span></span> = T;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">deref</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; &amp;T &#123;<br>        <span class="hljs-keyword">unsafe</span> &#123; &amp;*<span class="hljs-keyword">self</span>.lock.data.get() &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;T: ?<span class="hljs-built_in">Sized</span>&gt; DerefMut <span class="hljs-keyword">for</span> MutexGuard&lt;<span class="hljs-symbol">'_</span>, T&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">deref_mut</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; &amp;<span class="hljs-keyword">mut</span> T &#123;<br>        <span class="hljs-keyword">unsafe</span> &#123; &amp;<span class="hljs-keyword">mut</span> *<span class="hljs-keyword">self</span>.lock.data.get() &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;T: ?<span class="hljs-built_in">Sized</span>&gt; <span class="hljs-built_in">Drop</span> <span class="hljs-keyword">for</span> MutexGuard&lt;<span class="hljs-symbol">'_</span>, T&gt; &#123;<br>    <span class="hljs-meta">#[inline]</span><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">drop</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">unsafe</span> &#123;<br>            <span class="hljs-keyword">self</span>.lock.poison.done(&amp;<span class="hljs-keyword">self</span>.poison);<br>            <span class="hljs-keyword">self</span>.lock.inner.raw_unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4><span id="使用示例">使用示例</span></h4>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> lazy_static::lazy_static;<br><span class="hljs-keyword">use</span> std::borrow::Cow;<br><span class="hljs-keyword">use</span> std::collections::HashMap;<br><span class="hljs-keyword">use</span> std::sync::&#123;Arc, Mutex&#125;;<br><span class="hljs-keyword">use</span> std::thread;<br><span class="hljs-keyword">use</span> std::time::Duration;<br><br><span class="hljs-comment">// lazy_static 宏可以生成复杂的 static 对象</span><br>lazy_static! &#123;<br>    <span class="hljs-comment">// 一般情况下 Mutex 和 Arc 一起在多线程环境下提供对共享内存的使用</span><br>    <span class="hljs-comment">// 如果你把 Mutex 声明成 static，其生命周期是静态的，不需要 Arc</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">ref</span> METRICS: Mutex&lt;HashMap&lt;Cow&lt;<span class="hljs-symbol">'static</span>, <span class="hljs-built_in">str</span>&gt;, <span class="hljs-built_in">usize</span>&gt;&gt; =<br>        Mutex::new(HashMap::new());<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-comment">// 用 Arc 来提供并发环境下的共享所有权（使用引用计数）</span><br>    <span class="hljs-keyword">let</span> metrics: Arc&lt;Mutex&lt;HashMap&lt;Cow&lt;<span class="hljs-symbol">'static</span>, <span class="hljs-built_in">str</span>&gt;, <span class="hljs-built_in">usize</span>&gt;&gt;&gt; =<br>        Arc::new(Mutex::new(HashMap::new()));<br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">32</span> &#123;<br>        <span class="hljs-keyword">let</span> m = metrics.clone();<br>        thread::spawn(<span class="hljs-keyword">move</span> || &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> g = m.lock().unwrap();<br>            <span class="hljs-comment">// 此时只有拿到 MutexGuard 的线程可以访问 HashMap</span><br>            <span class="hljs-keyword">let</span> data = &amp;<span class="hljs-keyword">mut</span> *g;<br>            <span class="hljs-comment">// Cow 实现了很多数据结构的 From trait，</span><br>            <span class="hljs-comment">// 所以我们可以用 "hello".into() 生成 Cow</span><br>            <span class="hljs-keyword">let</span> entry = data.entry(<span class="hljs-string">"hello"</span>.into()).or_insert(<span class="hljs-number">0</span>);<br>            *entry += <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// MutexGuard 被 Drop，锁被释放</span><br>        &#125;);<br>    &#125;<br><br>    thread::sleep(Duration::from_millis(<span class="hljs-number">100</span>));<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"metrics: &#123;:?&#125;"</span>, metrics.lock().unwrap());<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>MutexGuard 不允许 Send，只允许 Sync，也就是说，你可以把 MutexGuard
的引用传给另一个线程使用，但你无法把 MutexGuard
整个移动到另一个线程：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span>&lt;T: ?<span class="hljs-built_in">Sized</span>&gt; !<span class="hljs-built_in">Send</span> <span class="hljs-keyword">for</span> MutexGuard&lt;<span class="hljs-symbol">'_</span>, T&gt; &#123;&#125;<br><span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">impl</span>&lt;T: ?<span class="hljs-built_in">Sized</span> + <span class="hljs-built_in">Sync</span>&gt; <span class="hljs-built_in">Sync</span> <span class="hljs-keyword">for</span> MutexGuard&lt;<span class="hljs-symbol">'_</span>, T&gt; &#123;&#125;<br></code></pre></div></td></tr></table></figure>
<p>类似 MutexGuard 的智能指针有很多用途。比如要创建一个连接池，可以在
Drop trait 中，回收 checkout 出来的连接，将其再放回连接池。</p>
<blockquote>
<p>数据库连接池实现：<a href="https://github.com/sfackler/r2d2/blob/master/src/lib.rs#L611" target="_blank" rel="noopener">r2d2</a></p>
</blockquote>
<h3><span id="优化-string">优化 String</span></h3>
<p>Rust 下 String 在栈上占了 24
个字节，然后在堆上存放字符串实际的内容，对于一些比较短的字符串，这很浪费内存。</p>
<p>用一个 enum 来处理：当字符串小于 N
字节时，我们直接用栈上的数组，否则，使用 String。但是这个 N
不宜太大，否则当使用 String 时，会比目前的版本浪费内存。</p>
<p>当使用 enum 时，额外的 tag + 为了对齐而使用的 padding
会占用一些内存。因为 String 结构是 8 字节对齐的，我们的 enum 最小 8 + 24
= 32 个字节。</p>
<p>设计一个数据结构，<strong>内部用一个字节表示字符串的长度，用 30
个字节表示字符串内容，再加上 1 个字节的 tag，正好也是 32 字节，可以和
String 放在一个 enum 里使用</strong>。</p>
<p>通过实现 Deref trait 让 MyString 可以被解引用成
&amp;str。除此之外，还可以实现 Debug/Display 和 From<t> trait，让
MyString 使用起来更方便。</t></p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::&#123;fmt, ops::Deref, <span class="hljs-built_in">str</span>&#125;;<br><br><span class="hljs-keyword">const</span> MINI_STRING_MAX_LEN: <span class="hljs-built_in">usize</span> = <span class="hljs-number">30</span>;<br><br><span class="hljs-comment">// MyString 里，String 有 3 个 word，供 24 字节，所以它以 8 字节对齐</span><br><span class="hljs-comment">// 所以 enum 的 tag + padding 最少 8 字节，整个结构占 32 字节。</span><br><span class="hljs-comment">// MiniString 可以最多有 30 字节（再加上 1 字节长度和 1字节 tag），就是 32 字节.</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MiniString</span></span> &#123;<br>    len: <span class="hljs-built_in">u8</span>,<br>    data: [<span class="hljs-built_in">u8</span>; MINI_STRING_MAX_LEN],<br>&#125;<br><br><span class="hljs-keyword">impl</span> MiniString &#123;<br>    <span class="hljs-comment">// 这里 new 接口不暴露出去，保证传入的 v 的字节长度小于等于 30</span><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">new</span></span>(v: <span class="hljs-keyword">impl</span> <span class="hljs-built_in">AsRef</span>&lt;<span class="hljs-built_in">str</span>&gt;) -&gt; <span class="hljs-keyword">Self</span> &#123;<br>        <span class="hljs-keyword">let</span> bytes = v.as_ref().as_bytes();<br>        <span class="hljs-comment">// 我们在拷贝内容时一定要使用字符串的字节长度</span><br>        <span class="hljs-keyword">let</span> len = bytes.len();<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> data = [<span class="hljs-number">0u8</span>; MINI_STRING_MAX_LEN];<br>        data[..len].copy_from_slice(bytes);<br>        <span class="hljs-keyword">Self</span> &#123;<br>            len: len <span class="hljs-keyword">as</span> <span class="hljs-built_in">u8</span>,<br>            data,<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> Deref <span class="hljs-keyword">for</span> MiniString &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Target</span></span> = <span class="hljs-built_in">str</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">deref</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; &amp;Self::Target &#123;<br>        <span class="hljs-comment">// 由于生成 MiniString 的接口是隐藏的，它只能来自字符串，所以下面这行是安全的</span><br>        <span class="hljs-built_in">str</span>::from_utf8(&amp;<span class="hljs-keyword">self</span>.data[..<span class="hljs-keyword">self</span>.len <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>]).unwrap()<br>        <span class="hljs-comment">// 也可以直接用 unsafe 版本</span><br>        <span class="hljs-comment">// unsafe &#123; str::from_utf8_unchecked(&amp;self.data[..self.len as usize]) &#125;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> fmt::<span class="hljs-built_in">Debug</span> <span class="hljs-keyword">for</span> MiniString &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">fmt</span></span>(&amp;<span class="hljs-keyword">self</span>, f: &amp;<span class="hljs-keyword">mut</span> fmt::Formatter&lt;<span class="hljs-symbol">'_</span>&gt;) -&gt; fmt::<span class="hljs-built_in">Result</span> &#123;<br>        <span class="hljs-comment">// 这里由于实现了 Deref trait，可以直接得到一个 &amp;str 输出</span><br>        <span class="hljs-built_in">write!</span>(f, <span class="hljs-string">"&#123;&#125;"</span>, <span class="hljs-keyword">self</span>.deref())<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">MyString</span></span> &#123;<br>    Inline(MiniString),<br>    Standard(<span class="hljs-built_in">String</span>),<br>&#125;<br><br><span class="hljs-comment">// 实现 Deref 接口对两种不同的场景统一得到 &amp;str</span><br><span class="hljs-keyword">impl</span> Deref <span class="hljs-keyword">for</span> MyString &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Target</span></span> = <span class="hljs-built_in">str</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">deref</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; &amp;Self::Target &#123;<br>        <span class="hljs-keyword">match</span> *<span class="hljs-keyword">self</span> &#123;<br>            MyString::Inline(<span class="hljs-keyword">ref</span> v) =&gt; v.deref(),<br>            MyString::Standard(<span class="hljs-keyword">ref</span> v) =&gt; v.deref(),<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-built_in">From</span>&lt;&amp;<span class="hljs-built_in">str</span>&gt; <span class="hljs-keyword">for</span> MyString &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">from</span></span>(s: &amp;<span class="hljs-built_in">str</span>) -&gt; <span class="hljs-keyword">Self</span> &#123;<br>        <span class="hljs-keyword">match</span> s.len() &gt; MINI_STRING_MAX_LEN &#123;<br>            <span class="hljs-literal">true</span> =&gt; Self::Standard(s.to_owned()),<br>            _ =&gt; Self::Inline(MiniString::new(s)),<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> fmt::Display <span class="hljs-keyword">for</span> MyString &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">fmt</span></span>(&amp;<span class="hljs-keyword">self</span>, f: &amp;<span class="hljs-keyword">mut</span> fmt::Formatter&lt;<span class="hljs-symbol">'_</span>&gt;) -&gt; fmt::<span class="hljs-built_in">Result</span> &#123;<br>        <span class="hljs-built_in">write!</span>(f, <span class="hljs-string">"&#123;&#125;"</span>, <span class="hljs-keyword">self</span>.deref())<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> len1 = std::mem::size_of::&lt;MyString&gt;();<br>    <span class="hljs-keyword">let</span> len2 = std::mem::size_of::&lt;MiniString&gt;();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Len: MyString &#123;&#125;, MiniString &#123;&#125;"</span>, len1, len2);<br><br>    <span class="hljs-keyword">let</span> s1: MyString = <span class="hljs-string">"hello world"</span>.into();<br>    <span class="hljs-keyword">let</span> s2: MyString = <span class="hljs-string">"这是一个超过了三十个字节的很长很长的字符串"</span>.into();<br><br>    <span class="hljs-comment">// debug 输出</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"s1: &#123;:?&#125;, s2: &#123;:?&#125;"</span>, s1, s2);<br>    <span class="hljs-comment">// display 输出</span><br>    <span class="hljs-built_in">println!</span>(<br>        <span class="hljs-string">"s1: &#123;&#125;(&#123;&#125; bytes, &#123;&#125; chars), s2: &#123;&#125;(&#123;&#125; bytes, &#123;&#125; chars)"</span>,<br>        s1,<br>        s1.len(),<br>        s1.chars().count(),<br>        s2,<br>        s2.len(),<br>        s2.chars().count()<br>    );<br><br>    <span class="hljs-comment">// MyString 可以使用一切 &amp;str 接口，感谢 Rust 的自动 Deref</span><br>    <span class="hljs-built_in">assert!</span>(s1.ends_with(<span class="hljs-string">"world"</span>));<br>    <span class="hljs-built_in">assert!</span>(s2.starts_with(<span class="hljs-string">"这"</span>));<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>这个简单实现的 MyString，不管它内部的数据是纯栈上的 MiniString
版本，还是包含堆上内存的 String 版本，使用的体验和 &amp;str
都一致，仅仅牺牲了一点点效率和内存，就可以让小容量的字符串，可以高效地存储在栈上并且自如地使用。</p>
<p>Rust 有个叫 <a href="https://github.com/bodil/smartstring" target="_blank" rel="noopener">smartstring</a>
的第三方库就实现并优化了这个功能。</p>
<h2><span id="集合容器">集合容器</span></h2>
<h3><span id="切片">切片</span></h3>
<p>在 Rust
里，切片是描述一组属于同一类型、长度不确定的、在内存中连续存放的数据结构，用
[T] 来表述。因为长度不确定，所以切片是个 DST（Dynamically Sized
Type）。</p>
<p>切片一般只出现在数据结构的定义中，不能直接访问，在使用中主要用以下形式：</p>
<ul>
<li>&amp;[T]：表示一个只读的切片引用。</li>
<li>&amp;mut [T]：表示一个可写的切片引用。</li>
<li>Box&lt;[T]&gt;：一个在堆上分配的切片。</li>
</ul>
<p>通过解引用，数据结构可以获得切片的所有能力，包括：binary_search、chunks、concat、contains、start_with、end_with、group_by、iter、join、sort、split、swap
等。</p>
<p>当构建自己的数据结构时，如果它内部也有连续排列的等长的数据结构，可以考虑
AsRef 或者 Deref 到切片。</p>
<p>切片的对象可以在堆上，也可以在栈上，并且其内容可以相互比较。</p>
<p>切片是集合数据的视图，而迭代器定义了对集合数据的各种各样的访问操作。</p>
<p>大多数情况下，我们只需要定义它的关联类型 Item 和 next() 方法。</p>
<ul>
<li>Item 定义了每次我们从迭代器中取出的数据类型；</li>
<li>next() 是从迭代器里取下一个值的方法。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-meta">#[must_use = <span class="hljs-meta-string">"iterators are lazy and do nothing unless consumed"</span>]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Iterator</span></span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Item</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">next</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;Self::Item&gt;;<br>    <span class="hljs-comment">// 大量缺省的方法，包括 size_hint, count, chain, zip, map, </span><br>    <span class="hljs-comment">// filter, for_each, skip, take_while, flat_map, flatten</span><br>    <span class="hljs-comment">// collect, partition 等</span><br>		... <br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>对 Vec<t> 使用 iter() 方法，并进行各种 map / filter / take 操作。</t></p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-comment">// 这里 Vec&lt;T&gt; 在调用 iter() 时被解引用成 &amp;[T]，所以可以访问 iter()</span><br>    <span class="hljs-keyword">let</span> result = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br>        .iter()<br>        .map(|v| v * v)<br>        .filter(|v| *v &lt; <span class="hljs-number">16</span>)<br>        .take(<span class="hljs-number">1</span>)<br>        .collect::&lt;<span class="hljs-built_in">Vec</span>&lt;_&gt;&gt;();<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"&#123;:?&#125;"</span>, result);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>需要注意的是 Rust 下的迭代器是个懒接口（lazy
interface），也就是说<strong>这段代码直到运行到 collect
时才真正开始执行，之前的部分不过是在不断地生成新的结构</strong>，来累积处理逻辑而已。</p>
<p>Rust 大量使用了 inline 等优化技巧，函数式编程优化后，性能和 C 语言的
for 循环差别不大。</p>
<p><a href="https://docs.rs/itertools/0.10.1/itertools/trait.Itertools.html" target="_blank" rel="noopener">itertools</a>，是和
Python 下 itertools 同名且功能类似的工具，提供了大量额外的 adapter。</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> itertools::Itertools;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> err_str = <span class="hljs-string">"bad happened"</span>;<br>    <span class="hljs-keyword">let</span> input = <span class="hljs-built_in">vec!</span>[<span class="hljs-literal">Ok</span>(<span class="hljs-number">21</span>), <span class="hljs-literal">Err</span>(err_str), <span class="hljs-literal">Ok</span>(<span class="hljs-number">7</span>)];<br>    <span class="hljs-keyword">let</span> it = input<br>        .into_iter()<br>        .filter_map_ok(|i| <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">10</span> &#123; <span class="hljs-literal">Some</span>(i * <span class="hljs-number">2</span>) &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-literal">None</span> &#125;);<br>    <span class="hljs-comment">// 结果应该是：vec![Ok(42), Err(err_str)]</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"&#123;:?&#125;"</span>, it.collect::&lt;<span class="hljs-built_in">Vec</span>&lt;_&gt;&gt;());<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>在实际开发中，我们可能从一组 Future
中汇聚出一组结果，里面有成功执行的结果，也有失败的错误信息。用 itertools
里的 filter_map_ok()，进一步做 filter/map。</p>
<p>String 是一个特殊的 Vec<u8>，所以在 String
上做切片，也是一个特殊的结构 &amp;str。<strong>String
在解引用时，会转换成 &amp;str</strong>。</u8></p>
<h4><span id="boxlttgt">Box&lt;[T]&gt;</span></h4>
<p>Box&lt;[T]&gt; 和 Vec<t> 有一点点差别：Vec<t> 有额外的
capacity，可以增长；<strong>而 Box&lt;[T]&gt; 一旦生成就固定下来，没有
capacity，也无法增长</strong>。</t></t></p>
<p>Box&lt;[T]&gt;和切片的引用&amp;[T]
也很类似：它们都是在栈上有一个包含长度的胖指针，指向存储数据的内存位置。区别是：Box&lt;[T]&gt;
只会指向堆，&amp;[T] 指向的位置可以是栈也可以是堆；此外，Box&lt;[T]&gt;
对数据具有所有权，而 &amp;[T] 只是一个借用。</p>
<p>那么如何产生 Box&lt;[T]&gt; 呢？目前可用的接口就只有一个：从已有的
Vec<t> 中转换。</t></p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-comment">// 从 Vec&lt;T&gt; 转换成 Box&lt;[T]&gt;，此时会丢弃多余的 capacity</span><br><span class="hljs-keyword">let</span> b1 = v1.into_boxed_slice();<br><span class="hljs-comment">// Box&lt;[T]&gt; 也可以通过 into_vec() 转换回 Vec&lt;T&gt;</span><br><br><span class="hljs-comment">// Box&lt;[T]&gt; 可以更改其内部数据，但无法 push</span><br>b2[<span class="hljs-number">0</span>] = <span class="hljs-number">2</span>;<br><span class="hljs-comment">// b2.push(6);</span><br><br><span class="hljs-comment">// 注意 Box&lt;[T]&gt; 和 Box&lt;[T; n]&gt; 并不相同</span><br><span class="hljs-keyword">let</span> b3 = <span class="hljs-built_in">Box</span>::new([<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]);<br><br><span class="hljs-comment">// b2 和 b3 相等，但 b3.deref() 和 v2 无法比较</span><br><span class="hljs-built_in">assert!</span>(b2 == b3);<br><span class="hljs-comment">// assert!(b3.deref() == v2);</span><br></code></pre></div></td></tr></table></figure>
<p>into_boxed_slice 和 into_vec
两个转换都是很轻量的转换，只是变换一下结构，不涉及数据的拷贝。区别是，当
Vec<t> 转换成 Box&lt;[T]&gt;
时，没有使用到的容量就会被丢弃，所以整体占用的内存可能会降低。</t></p>
<p>Box&lt;[T]&gt; 有一个很好的特性是，不像 Box&lt;[T;n]&gt;
那样在编译时就要确定大小，它可以在运行期生成，以后大小不会再改变。</p>
<p>所以，<strong>需要在堆上创建固定大小的集合数据，且不希望自动增长，那么，可以先创建
Vec<t>，再转换成 Box&lt;[T]&gt;</t></strong>。tokio 在提供 <a href="https://github.com/tokio-rs/tokio/blob/master/tokio/src/sync/broadcast.rs#L447" target="_blank" rel="noopener">broadcast
channel</a> 时，就使用了 Box&lt;[T]&gt; 这个特性。</p>
<h3><span id="哈希表">哈希表</span></h3>
<p>哈希冲突解决：链地址法（chaining）和开放寻址法（open
addressing）。Rust 使用 开放寻址法 +
<strong>二次探查</strong>（开放寻址法把整个哈希表看做一个大数组，不引入额外的内存，在冲突发生时，不断探寻哈希位置加减
n 的二次方，找到空闲的位置插入）。</p>
<blockquote>
<p>链地址法缺点是哈希表和冲突链使用了不同的内存，对缓存不友好。</p>
</blockquote>
<p>标准库的 <a href="https://doc.rust-lang.org/src/std/collections/hash/map.rs.html#206-208" target="_blank" rel="noopener">源代码</a>：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> hashbrown::hash_map <span class="hljs-keyword">as</span> base;<br><br><span class="hljs-meta">#[derive(Clone)]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">RandomState</span></span> &#123;<br>    k0: <span class="hljs-built_in">u64</span>,<br>    k1: <span class="hljs-built_in">u64</span>,<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HashMap</span></span>&lt;K, V, S = RandomState&gt; &#123;<br>    base: base::HashMap&lt;K, V, S&gt;,<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>HashMap 有三个泛型参数，K 和 V 代表 key / value 的类型，S
是哈希算法的状态，它默认是 RandomState，占两个 u64。RandomState 使用
SipHash 作为缺省的哈希算法，一个加密安全的哈希函数（cryptographically
secure hashing）。</p>
<p>Rust 的 HashMap 复用了 hashbrown 的 HashMap。hashbrown 是 Rust 下对
<a href="https://abseil.io/blog/20180927-swisstables" target="_blank" rel="noopener">Google Swiss
Table</a> 的一个改进版<a href="https://docs.rs/hashbrown/0.11.2/src/hashbrown/map.rs.html#192-195" target="_blank" rel="noopener">实现</a>：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HashMap</span></span>&lt;K, V, S = DefaultHashBuilder, A: Allocator + <span class="hljs-built_in">Clone</span> = Global&gt; &#123;<br>    <span class="hljs-keyword">pub</span>(<span class="hljs-keyword">crate</span>) hash_builder: S,<br>    <span class="hljs-keyword">pub</span>(<span class="hljs-keyword">crate</span>) table: RawTable&lt;(K, V), A&gt;,<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>可以看到，HashMap 里有两个域，一个是 hash_builder，类型是标准库使用的
RandomState，还有一个是具体的 RawTable：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">RawTable</span></span>&lt;T, A: Allocator + <span class="hljs-built_in">Clone</span> = Global&gt; &#123;<br>    table: RawTableInner&lt;A&gt;,<br>    <span class="hljs-comment">// Tell dropck that we own instances of T.</span><br>    marker: PhantomData&lt;T&gt;,<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">RawTableInner</span></span>&lt;A&gt; &#123;<br>    <span class="hljs-comment">// Mask to get an index from a hash value. The value is one less than the</span><br>    <span class="hljs-comment">// number of buckets in the table.</span><br>    bucket_mask: <span class="hljs-built_in">usize</span>,<br><br>    <span class="hljs-comment">// [Padding], T1, T2, ..., Tlast, C1, C2, ...</span><br>    <span class="hljs-comment">//                                ^ points here</span><br>    <span class="hljs-comment">// 指向哈希表堆内存末端的 ctrl 区</span><br>    ctrl: NonNull&lt;<span class="hljs-built_in">u8</span>&gt;,<br><br>    <span class="hljs-comment">// Number of elements that can be inserted before we need to grow the table</span><br>    growth_left: <span class="hljs-built_in">usize</span>,<br><br>    <span class="hljs-comment">// Number of elements in the table, only really used by len()</span><br>    items: <span class="hljs-built_in">usize</span>,<br>	<br>    <span class="hljs-comment">// 和 RawTable 的 marker 一样，只是一个用来占位的类型</span><br>    alloc: A,<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4><span id="hashmap-内存布局">HashMap 内存布局</span></h4>
<p>ctrl 是一个指向哈希表堆地址末端 ctrl 区的地址。每个 bucket 大小是
key（char） + value（i32） 的大小，也就是 8
个字节。以此可以计算出哈希表的起始地址。</p>
<blockquote>
<p>可用的调试工具：rust-gdb，rust-lldb</p>
</blockquote>
<p>内存布局分为栈和堆两部分：</p>
<p>栈：RandomState(2*u64) | mask | ctrl ptr | growth_left | items</p>
<p>堆：(ctrl ptr) 指向 ctrl 表 | (key, value) | (key, value)</p>
<p>ctrl 表用于快速查找，由 16 字节大小的 control byte 组成，每个 byte
对应一个 bucket，每个 bucket 对应一个 (key, value) 对。</p>
<p>16 字节大小的 control byte 可以用 SIMD 指令快速读取到缓存中。</p>
<p>当 HashMap 插入和删除数据，导致重新分配的时候，主要工作就是在维护
ctrl 表和数据的对应。</p>
<p>当要在哈希表中删除一个值时，先要找到要被删除的 key
所在的位置。在找到具体位置后，并不需要实际清除内存，只需要将它的 ctrl
byte 设回 0xff。</p>
<p>当 key/value 有额外的内存时，比如
String，它的内存不会立即回收，只有在下一次对应的 bucket 被使用时，让
HashMap 不再拥有这个 String 的所有权之后，这个 String
的内存才被回收。</p>
<p>所以，如果在 HashMap 中，添加大量内容，又删除大量内容，这时，最好使用
<code>shrink_to_fit / shrink_to</code> 释放不需要的内存占用。</p>
<p>如果需要自定义 Hash Key，只需要定义三个 Trait：<a href="https://doc.rust-lang.org/std/hash/trait.Hash.html" target="_blank" rel="noopener">Hash</a>、<a href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html" target="_blank" rel="noopener">PartialEq</a>、<a href="https://doc.rust-lang.org/std/cmp/trait.Eq.html" target="_blank" rel="noopener">Eq</a>。</p>
<h4><span id="hashset-btreemap-btreeset">HashSet / BTreeMap / BTreeSet</span></h4>
<p>HashSet 用于简单确认元素是否在集合中。</p>
<p>BTreeMap 和 BTreeSet 是内部使用 B-tree
来组织哈希表的数据结构，用来存放有序集合。 BTreeMap 的 key，需要实现 <a href="https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html" target="_blank" rel="noopener">PartialOrd</a>
和 <a href="https://doc.rust-lang.org/std/cmp/trait.Ord.html" target="_blank" rel="noopener">Ord</a>
Trait。</p>
<h4><span id="siphash">SipHash</span></h4>
<p><a href="https://en.wikipedia.org/wiki/SipHash" target="_blank" rel="noopener">SipHash</a>
就是为了回应 DoS 攻击而创建的哈希算法，虽然和 sha2
这样的加密哈希不同（不要将 SipHash
用于加密！），但它可以提供更好的安全性。把 SipHash 作为 HashMap
的缺省的哈希算法，Rust 可以避免开发者在不知情的情况下被 DoS。</p>
<p>这一切的代价是性能损耗，虽然 SipHash 非常快，但比 hashbrown 使用的 <a href="https://github.com/tkaitchuck/aHash" target="_blank" rel="noopener">Ahash</a>
慢了不少。如果不需要 DoS 防护（比如一个完全内部使用的
HashMap），那么可以用 Ahash 来替换。使用 Ahash 提供的 RandomState
即可：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> ahash::&#123;AHasher, RandomState&#125;;<br><span class="hljs-keyword">use</span> std::collections::HashMap;<br><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> map: HashMap&lt;<span class="hljs-built_in">char</span>, <span class="hljs-built_in">i32</span>, RandomState&gt; = HashMap::default();<br>map.insert(<span class="hljs-string">'a'</span>, <span class="hljs-number">1</span>);<br></code></pre></div></td></tr></table></figure>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Notes/">Notes</a>
                    
                      <a class="hover-with-bg" href="/categories/Notes/Rust/">Rust</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Rust/">Rust</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/posts/7f1634b6.html">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">RUST Part2</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/posts/a61fc9c9.html">
                        <span class="hidden-mobile">Windows终端配置</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      var light = 'github-light';
      var dark = 'github-dark';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'RacleRay/comments');
      s.setAttribute('issue-term', 'title');
      
      s.setAttribute('label', 'utterances');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://github.com/RacleRay" class="hint--bottom hint--rounded" aria-label="GitHub" target="_blank"> <i class="iconfont icon-github-fill" aria-hidden="true"></i> </a>
<a href="mailto:969232057@qq.com" class="hint--bottom hint--rounded" aria-label="Email" target="_blank"> <i class="iconfont icon-mail" aria-hidden="true"></i> </a>
<a href="tencent://AddContact/?fromId=50&amp;fromSubId=1&amp;subcmd=all&amp;uin=969232057" class="hint--bottom hint--rounded" aria-label="QQ" target="_blank"> <i class="iconfont icon-qq-fill" aria-hidden="true"></i> </a>
<a class="qr-trigger" target="_self"> <i class="iconfont icon-wechat-fill" aria-hidden="true"></i> <img class="qr-img" src="/img/wexin.jpg" srcset="/img/loading.gif" lazyload alt="qrcode"> </a>
<a href="/atom.xml" class="hint--bottom hint--rounded" aria-label="Email" target="_blank"> <i class="iconfont icon-rss" aria-hidden="true"></i> </a>
<div></div> <a> POWERED BY </a> <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.staticfile.org/jquery/3.5.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.staticfile.org/tocbot/4.12.0/tocbot.min.js" ></script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>



  <script  src="/js/local-search.js" ></script>






  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->


</body>
</html>
